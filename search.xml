<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>书籍笔记 - 程序是怎样跑起来的（硬件软件交互理解）</title>
      <link href="/Tech/BookNote/bookNote_howProgramRun/"/>
      <url>/Tech/BookNote/bookNote_howProgramRun/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="CPU可直接执行的“机器码”，到底能处理什么？"><a href="#CPU可直接执行的“机器码”，到底能处理什么？" class="headerlink" title="CPU可直接执行的“机器码”，到底能处理什么？"></a>CPU可直接执行的“机器码”，到底能处理什么？</h2><p>简单来说分为4种，</p><p>数据传送指令：用于寄存器、内存、外围设备之间进行数据读写的操作。也就是<strong>读写操作</strong>。</p><p>运算指令：用累加寄存器执行<strong>算术运算、逻辑运算、比较运算和位移运算</strong>。</p><p>跳转指令：实现条件分支、循环、强制跳转等。其实就是个<strong>goto</strong>。</p><p>call/return指令：函数的调用 / 返回调用前的地址。和c#的函数<strong>栈桢</strong>展开是类似的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221026103246.png"></p><h1 id="二进制数"><a href="#二进制数" class="headerlink" title="二进制数"></a>二进制数</h1><h2 id="如何在硬件层面理解二进制、bit、byte？"><a href="#如何在硬件层面理解二进制、bit、byte？" class="headerlink" title="如何在硬件层面理解二进制、bit、byte？"></a>如何在硬件层面理解二进制、bit、byte？</h2><p>像计算机的CPU和内存都是IC的一种，IC就是有很多引脚的集成电路，而每一个引脚的状态只有直流电压0V和5V，这两种。因此计算机的信息只能转化成二进制。</p><p>而**位(bit)**这个数据结构，就刚好对应了这个规律。</p><p>**字节(byte)**则是8个bit，因为内存和磁盘都是用字节为最小单位来存储、读写数据的，所以用位bit不能直接读写数据，所以都会在高位补0实现bit转byte。</p><p>而一个CPU有32位，就意味着它有32个引脚来处理信息的输入和输出，也就是说一次可以处理32位的二进制数信息。</p><h2 id="为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）"><a href="#为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）" class="headerlink" title="为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）"></a>为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）</h2><p>为了实现通过相加来实现减法。</p><p>补码是取反+1的结果，同样的这个结果和无符号位的原码相加结果为0。</p><h1 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h1><h2 id="什么是浮点数？它是怎么表示小数的？"><a href="#什么是浮点数？它是怎么表示小数的？" class="headerlink" title="什么是浮点数？它是怎么表示小数的？"></a>什么是浮点数？它是怎么表示小数的？</h2><p><strong>什么是浮点数？</strong>是使用<strong>符号、尾数、基数、指数</strong>这四个部分来表示小数的，形式为<font color= "red"><code>± m * n的e次方</code></font >。符号就是±，基数n因为计算机二进制所以是2。而至于尾数m和指数n，就是根据具体数字来的，但也并不是毫无参照。</p><p><strong>它是怎么表示小数的？</strong></p><p>首先，分为单、双精度浮点数，它们表示范围不同，根据最为普遍的IEEE标准，单精浮点（32位）有1位符号部分、8位指数部分、23位尾数部分；双精浮点（64位）有1位符号部分、11位指数部分、52位尾数部分。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221018103720.png"></p><p>其次，对于尾数m，就像科学计数法一样，浮点数也有一种表示规则来限制诸如<code>0.75 * 10^0</code>、<code>7.5 * 10^-1</code>这种同一个数字，表示方式却不同的情况。在二进制数中，用的是<strong>“将小数点前面的值固定为1的正则表达式”</strong>。</p><p>比如<code>1011.0011</code> =&gt; <code>0001.0110011</code> =&gt;第一位固定1所以可以去掉，多表示1位 <code>0110011000...(省略0，补齐23/52位)</code></p><p>最后，对于指数e，用的是<strong>EXCESS系统</strong>来表示它的正负。比如单精指数部分只有8位的情况下，最大值<code>11111111</code>=255，用它的一半<code>01111111</code>=127来记作0，比它大的是正数，比它小的是负数。指数e的表示范围从0<del>255变为-127</del>128。</p><h2 id="浮点数会不准确"><a href="#浮点数会不准确" class="headerlink" title="浮点数会不准确"></a>浮点数会不准确</h2><p><strong>为什么浮点数会不准确？</strong>计算机用浮点数无法处理0.1这种转换为二进制会无尽的小数。所以会导致0.1打印输出会变成0.10000002之类的。</p><p><strong>如何解决？</strong>一般可以不解决，因为科学近似精度已经足够高了。但如果是一些严格要求准确的领域，</p><p>方法1.可以把小数倍乘成整数来计算，计算完后再除回去。</p><p>方法2.可以使用BCD(Binary Coded Decimal)表示法，就是用4位来表示0~9的1位数字。</p><h2 id="浮点数c-实践"><a href="#浮点数c-实践" class="headerlink" title="浮点数c#实践"></a>浮点数c#实践</h2><p>在c#中尝试把一个float用二进制输出出来，比如<code>0.75f</code>，输出的值确实是按照1-8-23划分的：<code>0-01111110-10000000000000000000000</code>。但是结果是反过来的，不清楚为什么，书中用的c++是正序的。另外就是，用<code>BitConverter.GetBytes</code>接口转的是byte，也就是8位2进制转成10进制读得的数值，所以还需要再转回8位2进制数。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="如何理解内存硬件"><a href="#如何理解内存硬件" class="headerlink" title="如何理解内存硬件"></a>如何理解内存硬件</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221020085834.png"></p><p>比如一个内存，其实就是一堆引脚。VCC、GND引脚是接电源的，DR、WR是控制信号用来操控读、写。</p><p>A0-A9的引脚用来表示地址，所以可以表示1024个地址；D0-D7表示数据，8位2进制，也就是1个字节B。所以这个内存的容量为1KB。</p><p>一个内存内部有大量空间去存储这些8位数据，通过地址引脚指定的地址来读写这些数据。</p><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>1个地址指向1个字节（内存的最小单位）；</p><p>32位系统一次可以读4个字节，等于其最高可表示2^32个地址数。</p><p>所以32位系统，内存上限为4GB。</p><h1 id="内存与磁盘"><a href="#内存与磁盘" class="headerlink" title="内存与磁盘"></a>内存与磁盘</h1><h2 id="CPU、内存、磁盘"><a href="#CPU、内存、磁盘" class="headerlink" title="CPU、内存、磁盘"></a>CPU、内存、磁盘</h2><p>1.程序保存在存储设备中，通过有序地被读出来实现运行。</p><p>2.CPU只能执行已经加载到内存中的程序。</p><h2 id="如何理解磁盘硬件"><a href="#如何理解磁盘硬件" class="headerlink" title="如何理解磁盘硬件"></a>如何理解磁盘硬件</h2><p>磁盘是用扇区作为读写最小物理单位的，一个扇区为512字节。但是Windows在逻辑方面对磁盘进行读写的单位是<strong>簇</strong>，1簇可以设置为扇区整数倍，比如可以1簇=1扇区（512字节）、也可以1簇=2扇区（1KB）等等。</p><p>无论是多么小的文件，都会占用至少1簇。</p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>磁盘访问速度 &lt; 内存访问速度，所以会用内存映射一段磁盘数据作为缓存，如果下一次还用到的磁盘数据刚好被内存加载过，那就直接去速度更快的内存里拿数据。这叫<strong>缓存</strong>。到win98时代，由于磁盘访问速度越来越快，这种技术的提升就不是很显著了，但是这个思想也用于Web把远端服务器加载下来的数据存入磁盘中。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>正好与磁盘缓存相对的概念，就是说划分一块磁盘区域作为假想的内存来使用。但CPU只能执行已经加载到内存中的程序，所以实际上是在把内存和磁盘中的内容不停进行置换，保持当前正在运行的程序部分有在物理内存中。而置换就涉及一个最小单位，Windows是用<strong>页</strong>为单位（一般4KB）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221020142308.png"></p><h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><p>就只列举一些常见的压缩算法。</p><p>文本文件：RLE压缩（文本 x 次数 的形式）、哈夫曼（权重画树、编码）压缩</p><p>图像文件：可逆压缩、不可逆压缩。</p><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><h2 id="虚拟机是什么"><a href="#虚拟机是什么" class="headerlink" title="虚拟机是什么"></a>虚拟机是什么</h2><p>因为应用是针对操作系统OS的，所以Windows应用只能在Windows系统上运行。而虚拟机就是在其他OS上，模拟Windows运行环境，来实现跨平台。</p><h2 id="其他跨平台方式"><a href="#其他跨平台方式" class="headerlink" title="其他跨平台方式"></a>其他跨平台方式</h2><p>除了虚拟机之外，还有两个方式。一个是<strong>Ports机制</strong>，是移植的意思。该机制能够结合当前运行的硬件环境来编译应用的源代码。</p><p>另一个是Java虚拟机，它其实是一种运行环境。Java在编译之后生成的不是机器码而是<strong>字节代码</strong>，然后字节代码在不同平台实现的Java虚拟机上运行，转换成本机代码。和c#一样。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="从程序到机器码-编译器"><a href="#从程序到机器码-编译器" class="headerlink" title="从程序到机器码 - 编译器"></a>从程序到机器码 - 编译器</h2><p><strong>编译器</strong>把源代码转换成本地代码（本机代码），它内部仿佛有一个 源代码-本机码 的对应表，但实际上读入的源代码还需要经过<strong>语法解析、句法解析、语义解析</strong>等，才能生成本地代码。</p><p>编译器本身也是一个程序，所以也需要<strong>运行环境</strong>（比如Windows）。根据<strong>输出的目标CPU类型、输入的高级语言</strong>的不同，编译器也不同（比如Windows可用的x86系CPU的C编译器）。</p><h2 id="生成EXE-链接器"><a href="#生成EXE-链接器" class="headerlink" title="生成EXE - 链接器"></a>生成EXE - 链接器</h2><p>编译后的机器代码是一个obj文件（里面都是2进制数），并不能直接运行。还需要把代码中的引用其他文件的部分、和obj文件结合，生成出一个EXE文件。这就是<strong>链接</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221025144538.png"></p><h2 id="EXE启动-分配内存"><a href="#EXE启动-分配内存" class="headerlink" title="EXE启动 - 分配内存"></a>EXE启动 - 分配内存</h2><p>一个程序经过编译+链接后，生成了可执行文件EXE，但是程序源码里对函数、变量的调用都是指向内存地址的，但一个EXE文件并没有给它分配内存地址，怎么办呢？</p><p>其实，EXE文件中给变量、函数分配了虚拟的内存地址，当EXE运行时会把虚拟的内存地址转换成实际的内存地址。链接器在EXE文件的开头，追加转换内存地址所需的必要信息，这个叫做<strong>再配置信息</strong>。</p><p>当EXE运行时，还会分配额外的2块连续内存，一个是栈、一个是堆。栈用来存储函数内部临时变量，堆用来存储运行时数据以及对象。栈的内存管理代码是编译器自动生成的，而堆的内存管理是需要人为编写的，c++中用new申请、delete来释放。这就是GC。</p><h2 id="常见编译问题"><a href="#常见编译问题" class="headerlink" title="常见编译问题"></a>常见编译问题</h2><h3 id="什么是编译器、什么是解释器？"><a href="#什么是编译器、什么是解释器？" class="headerlink" title="什么是编译器、什么是解释器？"></a>什么是编译器、什么是解释器？</h3><p>两者都是把高级语言转化为机器语言的程序。编译器再运行前把源码转换成二进制可执行文件，而解释器逐条读取源码转换成机器码。</p><h3 id="Build是什么意思？"><a href="#Build是什么意思？" class="headerlink" title="Build是什么意思？"></a>Build是什么意思？</h3><p>编译+链接</p><h3 id="DLL可以不用链接就调用到吗？"><a href="#DLL可以不用链接就调用到吗？" class="headerlink" title="DLL可以不用链接就调用到吗？"></a>DLL可以不用链接就调用到吗？</h3><p>可以，通过<code>LoadLibrary()</code>、<code>GetProcAddress()</code>这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。</p><h1 id="通过汇编理解程序"><a href="#通过汇编理解程序" class="headerlink" title="通过汇编理解程序"></a>通过汇编理解程序</h1><h2 id="什么是汇编语言？"><a href="#什么是汇编语言？" class="headerlink" title="什么是汇编语言？"></a>什么是汇编语言？</h2><p>汇编语言和本地代码是一一对应的。汇编语言是本地代码（二进制）的助记符。</p><h2 id="汇编语言怎么看？"><a href="#汇编语言怎么看？" class="headerlink" title="汇编语言怎么看？"></a>汇编语言怎么看？</h2><p><strong>伪指令</strong>：负责把程序的构造以及汇编的方法指示给汇编器。伪指令<code>proc</code>和<code>endp</code>围起来的部分，表示的是函数的范围，里面的是函数执行过程。</p><p><strong>语法结构</strong>：操作码+操作数，比如<code>mov</code>+内存地址</p><p>以下是x86的部分操作码、主要寄存器：</p><table><thead><tr><th>操作码</th><th>操作数</th><th>功能</th></tr></thead><tbody><tr><td>mov</td><td>A、B</td><td>把B的值赋给A</td></tr><tr><td>and</td><td>A、B</td><td>把A同B的值相加，并将结果赋给A</td></tr><tr><td>push</td><td>A</td><td>把A的值存储在栈中</td></tr><tr><td>pop</td><td>A</td><td>从栈中读取出值，并将其赋给A</td></tr><tr><td>call</td><td>A</td><td>调用函数A，<font color="red">调用时自动获取栈上对应数量的入参</font></td></tr><tr><td>ret</td><td>无</td><td>将处理返回到函数的调用源</td></tr></tbody></table><p><strong>调用函数流程</strong>：</p><p>1.先把ebp寄存器（数据领域基址寄存器）的值入栈，再把函数的入参push入栈。</p><p>//注意，栈的高位地址在下面，低位地址在上面。</p><p>2.使用<code>call</code>指令 + 函数名（函数指针），调用时自动获取栈上对应数量的入参。</p><p>3.清理栈，把入参销毁掉。具体是把esp的寄存器值（栈顶指针寄存器）add上 4 * 入参数。</p><p>//至于为什么是4字节，因为堆栈进行数值的输入输出时，数值的单位是4字节。</p><p>4.<code>pop</code>读出此时栈顶的数值，也就是1中存储的ebp寄存器值，存入ebp寄存器。执行<code>ret</code>返回。</p><p>//为什么把edp寄存器的值原地倒腾了一遍？因为这是c语言的规定，确保函数调用前后edp不变。</p><p><strong>此外.函数的参数是通过栈来传递，返回值是通过寄存器返回的。</strong></p><h2 id="汇编实现功能"><a href="#汇编实现功能" class="headerlink" title="汇编实现功能"></a>汇编实现功能</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>使用标记 + goto标记 的 思路去做，具体助记符就不记了（先cmp再jmp）。</p><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><p>一样是标记 + go标记去实现的。</p><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>写2个把全局变量x2的相同的函数，再多线程分别调用1次，可能遇到结果为2倍而不是2x2倍的情况。原因如图。解决方案是用c语言中的锁定方法。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027090224.png"></p><h1 id="硬件控制"><a href="#硬件控制" class="headerlink" title="硬件控制"></a>硬件控制</h1><h2 id="外围设备硬件和软件是如何实现通信的？"><a href="#外围设备硬件和软件是如何实现通信的？" class="headerlink" title="外围设备硬件和软件是如何实现通信的？"></a>外围设备硬件和软件是如何实现通信的？</h2><p><strong>首先，应用与硬件无关：</strong>Windows系统下的硬件是由系统全权负责的，应用层只能通过API来通过系统调用。</p><p><strong>其次，硬件们是通过I/O控制器来实现和操作系统通信的：</strong>计算机有着USB等和外围设备交互的连接器，因为外围设备的电压不同、用的也是模拟信号，所以无法和硬件直接连接，需要用I/O控制器。</p><p><strong>什么是端口：</strong>I/O控制器中由用于临时保存输入输出数据的内存，这个内存叫端口。端口是内存，也有自己的地址，叫<strong>端口号</strong>或者<strong>I/O地址</strong>。</p><p><strong>汇编语言的IN/OUT指令，是通过端口和寄存器之间数据互换实现的：</strong>汇编中的IN/OUT助记符是实现和硬件交互的，IN指令把端口数据存储在CPU寄存器中，OUT把CPU寄存器数据存储在端口中。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027100225.png"></p><h2 id="外围设备硬件的中断操作IRQ"><a href="#外围设备硬件的中断操作IRQ" class="headerlink" title="外围设备硬件的中断操作IRQ"></a>外围设备硬件的中断操作IRQ</h2><p>IRQ（Interrupt Request）是<strong>中断请求</strong>的意思，对应的值是0x06。</p><p>它负责把当前正在运行的主程序中断（同时把CPU所有寄存器的数值保存到栈中），然后跳转到外围设备的输入输出运行，等运行完后返回中断程序（同时恢复所有寄存器的值），继续执行。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027103320.png"></p><p>遇到诸如打印机这种操作比CPU慢很多的设备，就可以等中断请求发生时再输出数据即可；而对于实时性比较高的比如鼠标等，就可以不停轮询。</p><h2 id="外围设备直接和内存通信DMA"><a href="#外围设备直接和内存通信DMA" class="headerlink" title="外围设备直接和内存通信DMA"></a>外围设备直接和内存通信DMA</h2><p>像IRQ的中断，本质上还是要和CPU交互的。但是DMA（Direct Memory Access）可以不通过CPU，外围设备直接和主内存进行数据传送。这样更快。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027104221.png"></p><h2 id="计算机图形的内存VRAM"><a href="#计算机图形的内存VRAM" class="headerlink" title="计算机图形的内存VRAM"></a>计算机图形的内存VRAM</h2><p>显示器中显示的数据，一直存储在内存总，这个内存叫<strong>VRAM</strong>（Video RAM）。在程序中，只要往VRAM中写入数据，该数据就会在显示其中显示出来，此功能由操作系统或BIOS提供。</p><p>在DOS系统时代，VRAM是主内存的一部分，图形颜色只能用16种是因为这块内存太小了。而如今，显卡配有独立的VRAM内存。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027104612.png"></p><h1 id="计算机的随机数"><a href="#计算机的随机数" class="headerlink" title="计算机的随机数"></a>计算机的随机数</h1><h2 id="线性同余法实现伪随机"><a href="#线性同余法实现伪随机" class="headerlink" title="线性同余法实现伪随机"></a>线性同余法实现伪随机</h2><p>很多伪随机其实就是用线性同余法的递推公式<img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027110424.png"></p><p>实现的。</p><p>指定了a、b、c之后，就会生成0 ~ c（不包括c）的随机数。其中Ri、a、b、c就是随机数的种子。</p><p>那这样为什么叫伪随机呢？因为指定好a、b、c之后的数，不停递推生成的结果是有<strong>周期性</strong>的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027110819.png"></p><h1 id="C入门"><a href="#C入门" class="headerlink" title="C入门"></a>C入门</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>名称</th><th>长度（位长）</th><th>精度</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>-128，+127</td></tr><tr><td>short</td><td>16</td><td>-32768，32767</td></tr><tr><td>int（或者long）</td><td>32</td><td>-2147483648，2147483647</td></tr><tr><td>float</td><td>32</td><td>略</td></tr><tr><td>double</td><td>64</td><td>略</td></tr></tbody></table><h2 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221028110814.png"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AB包基础</title>
      <link href="/Tech/Game/tools/assetbundleInit/"/>
      <url>/Tech/Game/tools/assetbundleInit/</url>
      
        <content type="html"><![CDATA[<p>2023年6月更新：已完成学习并实现huatuo+yooasset+uniTask的demo，下一步是接入自己的ui框架并迭代，地址：<a href="https://github.com/CodingCodingK/CodingK_SutureFramework">https://github.com/CodingCodingK/CodingK_SutureFramework</a></p><p>=================================================================================</p><p>学习计划：（我感觉用脑图好像比md更适合这种架构的学习和复习）</p><p>什么是热更 <a href="https://www.bilibili.com/video/BV1Np4y1e7DX/">https://www.bilibili.com/video/BV1Np4y1e7DX/</a></p><p>AB入门 <a href="https://www.bilibili.com/video/BV1LD4y1m7kF">https://www.bilibili.com/video/BV1LD4y1m7kF</a></p><p>AB实战 <a href="https://www.bilibili.com/video/BV1VP411G7w2/">https://www.bilibili.com/video/BV1VP411G7w2/</a></p><p>AA包 <a href="https://blog.csdn.net/u011366226/article/details/104506802">https://blog.csdn.net/u011366226/article/details/104506802</a></p><p>UniTask <a href="https://www.lfzxb.top/unitask_reademe_cn/">https://www.lfzxb.top/unitask_reademe_cn/</a></p><p>做出自己的学习版demo，服务器上跑一下，测试后上传github。</p><p>后面开始学习yooasset+huatuo方案，学习整合成自己能用的插件。如果资源管理不完整或者太难理解可以再参考gf。</p><p>等做完对资源有划分理解后，我们再开始做战斗，学习结点吧。</p><p>如果实现完还有时间，就用xLua重写c#热更项目。</p><h1 id="AB包入门"><a href="#AB包入门" class="headerlink" title="AB包入门"></a>AB包入门</h1><p>什么是AB包：资产压缩包，资产包括：模型、贴图、预设体、音效、材质球等。</p><p>AB包和Resources区别：Resources打包时定死，只读，无法修改。所以AB包的优势就是可压缩资源、可热更新。</p><p>热更基本规则：双端都带有一个资源对比文件，客户端检查热更就是检查资源对比文件。</p><p>可生成AB包资源文件的资源管理系统：</p><p>1.可以自定义打包工具，AB包的话gf和yooasset都是不错的开源插件。</p><p>2.官方在过去提供的AB包管理系统插件，叫Asset Bundle Browser，但在如今已经弃用了。</p><p>3.官方现在推崇的是Addressables了，它可以打AA包也可以打AB包。</p><p>AB包和AA包的区别：</p><ul><li>Addressable Asset Bundle可以自动加载相关依赖包，而AssetBundle是需要编程实现的；</li><li>Addressable Asset Bundle加载到内存中的bundle有引用计数，而AssetBundle加载到内存中的bundle需要自己进行管理</li></ul><h1 id="yooAsset"><a href="#yooAsset" class="headerlink" title="yooAsset"></a>yooAsset</h1><p>手册：<a href="https://www.yooasset.com/docs">https://www.yooasset.com/docs</a></p><p>教程：<a href="https://www.bilibili.com/video/BV1do4y1v7Pb/">https://www.bilibili.com/video/BV1do4y1v7Pb/</a></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 网络库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI学习 - 合批规则</title>
      <link href="/Tech/Game/UI/ugui_batch/"/>
      <url>/Tech/Game/UI/ugui_batch/</url>
      
        <content type="html"><![CDATA[<p><strong>1.抛开UGUI的概念，什么是drawcall？什么是批处理？他俩有啥关系？</strong></p><p>CPU告诉GPU“可以渲染这个模型”的过程或者说这个命令叫做Draw Call（我们在Stats面板上看到的Batches其实就是Draw Call的调用次数）。在NGUI里甚至有UIDrawCall这个具体的类去抽象一次drawcall。</p><p>批处理（UGUI里类似的行为叫合批）就是把渲染时使用相同材质(Shader)、相同贴图的3D模型的网格合并在一起，成为一个大网格，然后再调用一次Draw Call，直接渲染这一个大网格。</p><p>关系就是，批处理是降低CPU发起drawcall次数的手段。</p><p><strong>2.Unity中我怎么直观的去检查它？</strong></p><p>frame debugger可以查看一帧整体的绘制流程，从而观察到UGUI层调了多少次Draw Mesh、每次是怎么样的。</p><p>profiler可以更直接的看到一个Canvas下的batch 0、batch 1…</p><p><strong>3.基础的UGUI合批规则</strong></p><p>无论是UGUI还是NGUI，都以一个基础的合批规则：当前渲染的UI组件与上一个UI组件的material+shader（也就是材质球）、texture（贴图）都需要一致。满足了这个最基本要求才能合批。</p><p><strong>4.进阶的UGUI合批规则</strong></p><p>首先我们要明确UGUI中Canvas下可以嵌套子Canvas，但是合批是以Canvas(不包含子Canvas)为单位的(子Canvas会是另外一个批次了)。除此之外，合批的操作是在子线程完成的。这段的理解要结合图，<a href="https://blog.csdn.net/sinat_25415095/article/details/112388638">详见</a>。<br>① 既然合批是以Canvas为单位，第一步自然就是把所有Canvas给找出来，然后剔除掉不必渲染的Canvas(透明度为0，长宽为0，在RectMask2D控件下，且在RectMask2D的区域外)<br>② 然后计算Canvas下各UI控件的深度值Depth(需要注意的是Image的属性里面也有个depth，两者不是同一个东西)</p><p>③Depth的计算规则如下：</p><p>按照Hierarchy中从上往下的顺序依次遍历Canvas下所有UI元素<br>对于当前的UI元素CurrentUI<br>i.如果CurrentUI不渲染，则Depth = -1<br>ii.如果CurrentUI要渲染，但CurrentUI下面没有其他UI元素与其相交，则Depth = 0<br>iii.如果CurrentUI要渲染，下面只有一个UI元素(LowerUI)与其相交，且CurrentUI与LowerUI可以合批(材质和贴图完全相同)，则CurrentUI.Depth = LowerUI.Depth；如果两者不能合批，CurrentUI.Depth= LowerUI.Depth + 1<br>iv.如果CurrentUI要渲染，下面有n个元素与其相交，则按照步骤iii，分别计算出n个Depth(Depth_1、Depth_2、Depth_3…)，然后CurrentUI.Depth取其最大值，即CurrentUI.Depth = max(Depth_1, Depth_2, Depth_3，…)<br>上面步骤中的“下面”和“相交”要明确下意思，这两个概念很重要。<br>CurrentUI下面的UI，指Hierarchy面板中，在CurrentUI之上的元素。</p><p>在计算相交时，由于要遍历所有UI元素和已计算的底层UI元素（平方复杂度），源码中使用<strong>分组计算包围盒矩形的方法加快计算，即16个UI元素为一组计算Group 网格Rect</strong>，检查是否与底层UI元素相交时，先计算是否与底层Group相交，如果相交再与Group中的元素做判定。<br>④各个UI的Depth计算完毕后，依次按照Depth、material ID、texture ID、RendererOrder（即UI层级队列顺序，即Hierarchy面板上的顺序）排序（条件的优先级依次递减，且均为从小到大排序）。然后剔除Depth = -1的UI元素，得到Batch前的UI 元素队列，这个队列被称之为VisiableList。<br>⑤得到VisiableList之后，判断VisiableList中相邻的元素是否能够合批(相同的材质和贴图)。需要注意这里不再考虑Depth是否相同，只要两个元素相邻然后材质和贴图相同，即使两个元素的Depth不相同，这两个元素也能合批。然后一个批次一个批次的合并网格，提交GPU进行渲染。</p><p>除此之外，需要注意的是，合批是将同一Canvas下多个UI的网格合并在一起，如果其中任何一个元素的材质、网格顶点、位置(Transform)甚至颜色或者在该Canvas下动态创建或删除UI元素都将导致该Canvas重新计算合批(需要注意的是仅仅会影响这一个Canvas，子Canvas或父Canvas以及其他Canvas不会重新计算)，重新生成新的网格，这个重新计算生成网格的过程被称为rebuild。所以，这也是为什么做UI提倡动静分离(动态部分和静态部分分别用不同的Canvas)，层级尽量减少(层级多了，重新计算更耗时)的原因。</p><p><strong>5.总结合批规则</strong></p><p>合批是自己Canvas内部的规则，排序规则：计算得到的Depth &gt; material ID &gt; texture ID &gt; RendererOrder。计算Depth时会16个UI元素为一组最为包围盒检测，计算Depth和Mesh（UGUI本质）是否相交也有关。会剔除透明度为0、长宽为0、在RectMask2D下在Mask外的UI组件。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spine安装和简单了解、导入unity</title>
      <link href="/Project/Unity/RPG/himegami/spineInit/"/>
      <url>/Project/Unity/RPG/himegami/spineInit/</url>
      
        <content type="html"><![CDATA[<p>1.首先简单了解下spine导出的东西是什么。spine导出的文件会有3个：png图集、atlas图集切分文件、记录骨骼、动画的一个二进制skel文件 或者 一个json文件。</p><p>2.要把spine导出的文件导入进unity，只要事先在<a href="https://zh.esotericsoftware.com/spine-unity-download">spine-unity页面</a>下载好对应的 spine-runtime unitypackage就可以。注意这个版本卡的特别死，unity版本和spine导出版本是必须严格遵照要求的，具体看页面。<strong>安装好对应的package之后，需要先把atlas后缀加上.txt，再给二进制文件skel加上.bytes，json就不用改了，然后直接复制粘贴文件到unity里就会自动转换。</strong></p><p>3.<strong>在这里记录一个大坑</strong>，众所周知 Spine3.8.75 这个版本是网上能找到的破解版本。所以Spine直接在自己的 3.8版本unity runtime里，特别在2个地方写了一行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;3.8.75&quot;</span> == skeletonData.version)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unsupported skeleton data, please export with a newer version of Spine.&quot;</span>);</span><br></pre></td></tr></table></figure><p>这会直接导致你的转换文件生成失败。我一开始以为是自己资源的版本导出有问题，研究了很久，最后感觉哪都跑通了就这个离奇，就直接查代码了，结果才发现这行特殊的代码。</p><p>实在是666。</p><p>解决方法是直接全局搜索到<code>&quot;3.8.75&quot;</code>，然后注释掉就完事了。</p><p>4.一个简单的优化，就是spine的文件选择skel二进制而不是json文件。json文件的读取，那可真的是慢到爆炸了…其他的话应该还可以在战斗开始前就把所有可能用到的人物bytes全部加载好一起进，这个具体怎么操作还没看估计得小改一下spine的加载部分。</p><p>5.途径的有用链接</p><p>Spine-Unity 官网页面：<a href="http://zh.esotericsoftware.com/spine-unity-download/">http://zh.esotericsoftware.com/spine-unity-download/</a></p><p>一个日本老哥做的 skel转json：<a href="https://naganeko.pages.dev/chibi-gif/">https://naganeko.pages.dev/chibi-gif/</a></p><p>6.总得来说还是第3点最离谱，网上看到很多有同样问题的却只有人回答说要把json文件里的版本号改成3.8这种方法去解决。说回来如果Spine真的想玩一手盗版用户，为什么还要抛出而不是直接在这里return掉呢，那样我估计可以自我怀疑到天荒地老了。总之不会做商用仅作学习，搞了一晚上总算可以开始用spine了。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> ひめがみ絵巻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>战斗同步思考（未完）</title>
      <link href="/Project/Unity/RPG/himegami/battle/"/>
      <url>/Project/Unity/RPG/himegami/battle/</url>
      
        <content type="html"><![CDATA[<h1 id="需求拆解"><a href="#需求拆解" class="headerlink" title="需求拆解"></a>需求拆解</h1><h2 id="战斗同步"><a href="#战斗同步" class="headerlink" title="战斗同步"></a>战斗同步</h2><p>1.战斗同步有2种模式，一种是离线验证模式，在本地记录操作帧和随机种子，发送到服务端，再重新演算战斗逻辑；另一种是同步模式，客户端只转发操作帧，由服务端下发真实操作帧。<strong>服务器成本原因，优先实现第一种。</strong></p><p>2.结果验证</p><p>3.掉落验证</p><h2 id="战斗流程"><a href="#战斗流程" class="headerlink" title="战斗流程"></a>战斗流程</h2><p>1.实现战前匹配（可以是玩家也可以是Boss）、匹配成功后在服务端对所有玩家建立房间，下发开始。房间用状态机管理。进入房间后，启动倒计时，超过设定的最长战斗时长（10分钟）就判定失败，战斗视为失败，服务器回收资源。</p><p>2.从第一回合到最终回合，每一个回合的内部，进行回合触发时机的执行、行动优先级的判定、技能逻辑的执行、存活死亡的结算、战斗胜负的判定这几个程序步骤。</p><h1 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h1><h2 id="伪随机"><a href="#伪随机" class="headerlink" title="伪随机"></a>伪随机</h2><p>1.PRD算法</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20230413152135.png"></p><p>这是伪随机在游戏中最常见的用法，因此直接就被玩家用Pseudo Random Distribution的缩写PRD来指代了。</p><p>在WAR3中，一个暴击率20%的英雄，并不是每一刀都20%暴击率的。而是以5.57%作为初始暴率，如果第一刀不暴，则第二刀的暴率增加到初始值的2倍：11.14%；如果还是不暴，就继续增加到初始值的3倍：16.71%，以此类推。</p><p>而如果在这个过程中任何一次攻击打出了暴击，就会把暴击率重置到5.57%。</p><p>因此可以把所有游戏中可能出现的暴击概率（比如0-100的整数%） 和 公式计算出的初始值 做成一张映射表，就不需要随机了。</p><p>2.洗牌算法</p><p>类似于音乐播放器，在一开始就把所有可能的结果列出并洗成乱序，然后从第一个开始取。那么具体怎么洗的话，就是比如30个按顺序排列的不重复数字，先从下标0-29里random一个，放到29，再从0-28里random一个，放到28…每次放到数组最后的就是洗好的，这样可以避免每次random的时候随到重复下标。</p><p>3.组合随机</p><p>其实就是保底机制，用于抽卡。品质值不随机（固定SR、SSR），只随机具体物品值。</p><h1 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h1><h2 id="掉落"><a href="#掉落" class="headerlink" title="掉落"></a>掉落</h2><p><a href="https://www.jianshu.com/p/f9c37c46c03c">https://www.jianshu.com/p/f9c37c46c03c</a></p><h2 id="战斗序列"><a href="#战斗序列" class="headerlink" title="战斗序列"></a>战斗序列</h2><p>使用行动队列的方式，通过将每一个行动定义为一个行动节点（操作帧），按照队列中节点的顺序依次执行。不管是回合初就确定了行动顺序，还是回合中每完成一个行动都需要重新计算行动优先级的方案，都适用上述的方式，区别只在于对技能逻辑中衍生的行动节点，是添加到队列的末端还是插入到队列的头部。</p><p>另外为了打破技能循环（比如暴击后再攻击一次），还需要定义出行动节点的类型，由战斗回合产生的行动节点称为原始行动节点，由技能触发的行动节点则称为衍生行动节点，所有的反制行动、追加行动都应该归属于衍生行动节点。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> ひめがみ絵巻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我用向日葵打开unity编辑器怎么白屏了？</title>
      <link href="/Project/Unity/RPG/himegami/remoteUnityBug/"/>
      <url>/Project/Unity/RPG/himegami/remoteUnityBug/</url>
      
        <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>根据网上搜索的结果，大致有两个原因：</p><p>台式机没有外接显示器，或显示器处于关闭状态。<br>笔记本合上了盖子。</p><p>根据以上原因，个人猜测主要是因为没有检测到显示器，电脑显卡自动切换到某种低负载模式，这将导致一些使用显卡硬件加速的软件出现无法显示的问题。</p><p>没错，所以unity编辑器肯定是用了硬件加速或者根据硬件情况切换负载模式这种策略。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决思路：既然软件无法正常显示，是由于显卡模式的切换，导致依赖显卡硬件加速的应用无法显示，那么解决方法主要有两种：</p><p>方法一： 让显卡能检测到显示器。可以通过外接显示器并通电、让笔记本打开盖子、外接虚拟HDMI之类的负载（让显卡误以为我们外接了显示器）。<br>方法二： 若某个软件时因为依赖显卡硬件加速而导致无法显示，那么禁用该软件的显卡硬件加速功能即可。禁用显卡硬件加速方法又有两种思路：<br>禁用手段一：百度，不同软件有不同的禁用方法。（可能有的软件没提供禁用选项）<br>禁用手段二：在NVIDIA控制面板里指定禁用某个软件（个人猜测，没试过）</p><h1 id="其他解决方法"><a href="#其他解决方法" class="headerlink" title="其他解决方法"></a>其他解决方法</h1><p>搜索的时候还遇到过别人有其他情况，一一列举，</p><p>1.清除cache</p><p>2.重装对应版本unity（前提是就个别版本unity白屏）</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> ひめがみ絵巻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2D游戏中，角色预制体Image和Sprite怎么选择？</title>
      <link href="/Project/Unity/RPG/himegami/spriteOrImgFor2D/"/>
      <url>/Project/Unity/RPG/himegami/spriteOrImgFor2D/</url>
      
        <content type="html"><![CDATA[<p>选型的时候搜了一下，Sprite更优，本来决定用Image的这样方便UI血条什么跟随不需要自己单独写代码了，但是发现Image对于帧动画支持并不好，需要手动SetNativeSize，感觉不如Sprite。以下是抄来的：</p><p>1.首先分析下两者的异同。</p><p>使用上，两者区别不大，都是使用一个Sprite源进行渲染，而Image需要位于某个Canvas下才能显示出来。场景中的Sprite可以像普通的3D游戏物体一样对待，通过Transform组件进行移动等操作，而Image则使用RectTransform进行布局，以便通过Canvas统一管理。由于RectTransform可以设置大小、对齐方式等，Image可以说更加方便一点，这也是很多人选择使用Image的原因。</p><p>渲染上，Sprite使用SpriteRenderer组件渲染，而Image则由CanvasRenderer组件渲染。两者在视觉上没有任何区别（都使用默认材质时）。它们默认的渲染也都是在Transparent Geometry队列中。</p><p>而在引擎的处理上，两者则有很大的不同。将Wireframe选项打开然后在场景中观察，就可以清楚地发现，Image会老老实实地为一个矩形的Sprite生成两个三角形拼成的矩形几何体，而Sprite则会根据显示内容，裁剪掉元素中的大部分透明区域，最终生成的几何体可能会有比较复杂的顶点结构。</p><p>image</p><p>那么这种不同会造成什么结果呢？在继续之前，我们先回顾一下游戏中每帧的渲染过程。对任何物体的渲染，我们需要先准备好相关数据（顶点、UV、贴图数据和shader参数等等），然后调用GPU的渲染接口进行绘制，这个过程称作Draw Call。GPU接收到DrawCall指令后，通过一系列流程生成最终要显示的内容并进行渲染，其中大致的步骤包括：</p><p>CPU发送Draw Call指令给GPU；</p><p>GPU读取必要的数据到自己的显存；</p><p>GPU通过顶点着色器（vertex shader）等步骤将输入的几何体信息转化为像素点数据；</p><p>每个像素都通过片段着色器（fragment shader）处理后写入帧缓存；</p><p>当全部计算完成后，GPU将帧缓存内容显示在屏幕上。</p><p>通过上面的认知，我们可以推断：</p><p>Sprite由于顶点数据更加复杂，在第1/2步时会比Image效率更低；</p><p>Sprite会比Image执行较多的顶点着色器运算；</p><p>Image会比Sprite执行更多的片段着色器运算；</p><p>看起来似乎Image比Sprite有更大的好处，然而事实上，由于片段着色器是针对每个像素运算，Sprite通过增加顶点而裁剪掉的部分减少了相当多的运算次数，在绝大多数情况下，反而比Image拥有更好的效率 —— 尤其是场景中有大量的2D精灵时。</p><p><strong>总结一下，SpriteRenderer会创建额外的几何体来裁剪掉多余的透明像素区域，从而减少了大量的片段着色器运算，并降低了overdraw；而Image则会创建简单的矩形几何体。随着2D元素数量的增加，这种差别会慢慢明显起来。</strong></p><p>可以看出，SpriteRenderer确实是经过优化以显示更多的元素的。所以在2D游戏开发中，游戏场景中的元素，应该尽量使用它去渲染。而Image应该仅用于UI显示（实际上即使不考虑性能原因，由于屏幕分辨率的变化，Image可能会被Canvas改变显示位置和实际大小，如果用于游戏内元素的显示，可能会造成跟预期设计不一致的显示结果，也应该避免使用）。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> ひめがみ絵巻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中如何把RGB图和Alpha图分离的图片还原</title>
      <link href="/Project/Unity/RPG/himegami/himegami_before/"/>
      <url>/Project/Unity/RPG/himegami/himegami_before/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity中如何把RGB图和Alpha图分离的图片还原"><a href="#Unity中如何把RGB图和Alpha图分离的图片还原" class="headerlink" title="Unity中如何把RGB图和Alpha图分离的图片还原"></a>Unity中如何把RGB图和Alpha图分离的图片还原</h1><h2 id="一-RGB图、Alpha图简述"><a href="#一-RGB图、Alpha图简述" class="headerlink" title="一.RGB图、Alpha图简述"></a>一.RGB图、Alpha图简述</h2><h3 id="RGB图"><a href="#RGB图" class="headerlink" title="RGB图"></a>RGB图</h3><p>RGB图是指由红、绿、蓝三个基本色光按不同比例合成的图像，是最常见的彩色图像。RGB图像的每个像素点由三个通道的颜色值组成，通常用三元组（R,G,B）表示，其中R表示红色通道，G表示绿色通道，B表示蓝色通道，三个通道的值均为0-255之间的整数。</p><h3 id="Alpha图"><a href="#Alpha图" class="headerlink" title="Alpha图"></a>Alpha图</h3><p>Alpha图是指一种用于描述图像透明度的图像格式，通常用于PNG格式的图像中。Alpha图像的每个像素点也由一个通道的值表示，通常用A表示，取值范围为0-255，0表示完全透明，255表示完全不透明。</p><h2 id="二-为什么需要拆成2种图打包？"><a href="#二-为什么需要拆成2种图打包？" class="headerlink" title="二.为什么需要拆成2种图打包？"></a>二.为什么需要拆成2种图打包？</h2><h3 id="1-ETC不支持透明通道"><a href="#1-ETC不支持透明通道" class="headerlink" title="1.ETC不支持透明通道"></a>1.ETC不支持透明通道</h3><p>ETC是一种Unity支持的贴图压缩格式，用于安卓设备，不过目前不支持ETC2的已经少到可以忽略了。</p><ul><li>ETC：不支持透明通道，被所有 android 设备支持</li><li>ETC2：支持透明通道，Android 设备的 GPU 必须支持 OpenGL es 3.0 才可以使用，对于不支持的设备，会以未压缩的形式存在内存中，占用更多内存</li><li>PVRTC：所有苹果设备都可以使用，要求压缩纹理长宽相等，且是 2 的幂次（POT，Power of 2）</li><li>ASTC：高质量低内存占用，未来可能普遍使用的压缩格式，现在有一部分机型不支持</li></ul><h3 id="2-对ios机上内存占用与素材清晰度之间的平衡问题的一种优解"><a href="#2-对ios机上内存占用与素材清晰度之间的平衡问题的一种优解" class="headerlink" title="2.对ios机上内存占用与素材清晰度之间的平衡问题的一种优解"></a>2.对ios机上内存占用与素材清晰度之间的平衡问题的一种优解</h3><p>一般来说，目前 Unity 的手机游戏 android 上非透明贴图会使用 RGB Compressed ETC 4bits，透明贴图可以使用 RGBA Compressed ETC2 8bit，iOS 非透明贴图使用 RGB Compressed PVRTC 4bits，透明贴图使用 RGBA Compressed PVRTC 4bits。</p><p>这里的 bits 概念的意思为：每个像素占用的比特数，举个例子，RGB Compressed PVRTC 4bits 格式的 1024x1024 的贴图，其在内存中占用的大小 = 1024x1024x4 (比特) = 4M (比特) = 0.5M (字节)。</p><p>我们可以看到，在 iOS 上，非透明贴图和透明贴图都是 4bpp（4bits per pixel）的，多了透明通道还是一样的大小，自然 4bpp 的透明贴图压缩出来效果就会变差，而实机上看确实也是惨不忍睹。这是第一个问题的答案。</p><p>要解决上面图片模糊的问题，可以有这些做法：</p><ul><li>透明贴图不压缩，内存占用 32bpp</li><li>分离 alpha 通道，内存占用 4bpp+4bpp（或 4bpp+8bpp）</li></ul><p>显然第一种是不靠谱的， 32bpp 的内存消耗对于手机来说过大了。所以就需要拆分。</p><h2 id="三-如何还原"><a href="#三-如何还原" class="headerlink" title="三.如何还原"></a>三.如何还原</h2><p>我现在通过解包拿到的就是2张图，一张rpg图，一张alpha通道的图，带梯度（并不是01非黑即白图）。还原有2种方式，1是可以<a href="https://blog.csdn.net/qq_39738178/article/details/120023891">ps之类的将图片遮罩还原</a>，2是可以通过写shader，采样rgb图的rgb数值和aplha图的a数值，作为最终输出。这里只介绍第二种，我用的shader graph。</p><p>1.导入2张png，转成sprite，alpha图的 Alpha Source 设置为 From Gray Scale 。</p><p>2.写shader，并将shader绑到material上，注意 Surface Type 要选择 Transparent 模式，不然会被当做01图用。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20230409145504.png"></p><p>3.新建一个sprite2D，给配上材质就ok了，效果还是不错的</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20230409151528.png"></p><h2 id="四-如何拆分打包"><a href="#四-如何拆分打包" class="headerlink" title="四.如何拆分打包"></a>四.如何拆分打包</h2><p>如何拆分打包：<a href="https://www.gameres.com/872788.html">https://www.gameres.com/872788.html</a></p><h2 id="五-如何通过PS还原"><a href="#五-如何通过PS还原" class="headerlink" title="五.如何通过PS还原"></a>五.如何通过PS还原</h2><p>又回来补PS版本的了…因为解包下来游戏内容上千张图集，很多都甚至需要手动拆分成散图，实在是不想自己干，还是用PS还原png透明图交给别人吧。</p><p>1.把RGB图扔到ps里，点击“添加蒙版”。</p><p>2.在图层中选中“蒙版”，保持选中的状态下，点击“通道”，可以看到有“图层 蒙版”这个图层，把前面的眼睛点开。</p><p>3.去复制alpha图，粘贴到这个蒙版图层里。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> ひめがみ絵巻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP、UDP的区别</title>
      <link href="/Tech/Net/tcp_udp/"/>
      <url>/Tech/Net/tcp_udp/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是TCP、UDP"><a href="#什么是TCP、UDP" class="headerlink" title="什么是TCP、UDP"></a>什么是TCP、UDP</h1><p>协议，他们都只工作在传输层。</p><h1 id="什么是TCP的挥手、握手"><a href="#什么是TCP的挥手、握手" class="headerlink" title="什么是TCP的挥手、握手"></a>什么是TCP的挥手、握手</h1><p>三次握手、传输确认、四次挥手。</p><p><strong>三次握手：</strong>建立连接用的。客户端发起请求给服务端，服务端返回消息给客户端发番号，客户端再发送请求给服务端，完成连接的建立。</p><p>为什么需要第三步？为了<strong>解决网络信道不可靠问题</strong>。第一个请求包阻塞了，所以客户端重新再做了第一步成功建立了连接，此时之前的那个阻塞包又恢复了，此时如果没有第三步服务端就会成功建立第二个连接。</p><p><strong>传输确认：</strong>一包数据可能拆成多包发送，如何处理丢包问题？这些包的到达顺序不一定，如何处理乱序问题？答案是通过回复确认包。</p><p>这个根据下图模型理解。首先TCP会在建立连接之后，会创建如下的发送缓冲区。每次发送报文时，除了数据内容，还会在TCP协议头中附带本次数据内容的序列号（起始下标）+长度。接收端收到这个包后，会进行回复确认，内容为序列号+长度，也就是下一包的其实序列号。这样做是为了能够<strong>把整个包根据序列号和长度重组</strong>，中间遇到丢包的情况申请重发即可。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220811083837.png"></p><p><strong>四次挥手：</strong>结束连接用的。</p><p>一、二挥手：客户端发送结束包给服务端；服务端返回一个包表示自己进入终止等待状态。这前两次挥手完之后，服务端还可以给客户端发送之前未发完的数据，此时客户端还可以接收。也就是说这前两次是为了发送之前未发完数据。</p><p>三、四挥手：服务端发送完未完数据后，给客户端发送结束包，服务端进入最后确认状态；客户端收到后回复服务端一个确认包，客户端进入超时等待状态，超时后自动关闭连接。这最后一段等待是为了第四次挥手的确认包万一服务端没收到，服务端要求重发时客户端这还能响应。</p><h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><p>基于连接 与 基于非连接。</p><p>UDP不像TCP握手、确认、挥手，它是直接把数据包发过去的，所以占用资源少、速度快。</p><p>因此TCP稳定可靠，UDP速度快实时性强。</p><p>隧道网络：VPN等。// TODO</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：代码热更新</title>
      <link href="/Tech/Game/tools/wolong_study/"/>
      <url>/Tech/Game/tools/wolong_study/</url>
      
        <content type="html"><![CDATA[<p>非常感谢 HybridCLR(代号wolong) 的作者walon大佬。</p><h1 id="初识HybridCLR"><a href="#初识HybridCLR" class="headerlink" title="初识HybridCLR"></a>初识HybridCLR</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>能够不写lua，简直就是神。</p><p>HybridCLR ： <a href="https://github.com/focus-creative-games/hybridclr">github</a></p><p>HybridCLR li2cpp plus ： <a href="https://github.com/focus-creative-games/il2cpp_plus">github</a></p><p>HybridCLR示例项目 ： <a href="https://github.com/focus-creative-games/hybridclr_trial">github</a></p><p>手册：<a href="https://focus-creative-games.github.io/hybridclr">github.io</a></p><blockquote><p>HybridCLR 由两部分构成 <a href="https://github.com/focus-creative-games/il2cpp_plus">il2cpp_plus 仓库 (opens new window)</a>和 <a href="https://github.com/focus-creative-games/hybridclr">HybridCLR 仓库 (opens new window)</a>。il2cpp_plus 仓库基于 unity 原始 il2cpp 作了少量修改（几百行），使得它可以支持动态注册元数据，进行可以动态加载 dll。HybridCLR 仓库是 HybridCLR 的核心源代码。</p><p>HybridCLR的安装基于这两部分，安装有一定的<strong>版本规则</strong>。具体见<a href="https://focus-creative-games.github.io/hybridclr/support_versions/">支持的 Unity 版本</a>文档。</p></blockquote><h1 id="配置第一个Unity项目"><a href="#配置第一个Unity项目" class="headerlink" title="配置第一个Unity项目"></a>配置第一个Unity项目</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>Unity版本2020.3.7</p><ol><li>  拷贝<a href="https://github.com/focus-creative-games/il2cpp_plus">HybridCLR li2cpp plus</a>项目中的libil2cpp文件夹 到对应版本Editor的<code>Editor\Data\il2cpp</code>文件夹下，替换原先的libil2cpp文件夹。</li><li>  拷贝<a href="https://github.com/focus-creative-games/hybridclr">HybridCLR</a>中的huatuo文件夹 到对应版本Editor的<code>Editor\Data\il2cpp\libil2cpp</code>文件夹下。</li></ol><p>上面是老版本的安装方法，现在上面2步在示例中已经可以通过修改li2cpp的path来实现了，按照说明<strong>修改.bat、运行.bat</strong>即可自动从远端仓库拉取huatuo。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 热更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：查找与搜索</title>
      <link href="/Tech/Algorithm/search/"/>
      <url>/Tech/Algorithm/search/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p><strong>1.顺序查找</strong><br>        顺序遍历。</p><p><strong>2.二分查找</strong><br>        折半查找、二分查找，一个东西。对数据有要求，必须是按照关键字进行排序的。</p><p><strong>3.插值查找</strong><br>        在二分查找上做的优化。其实就是计算mid值不再是除以2，而是根据线性插值求出一个接近的数。对数据更高要求，不但得是顺序，还必须满足数值分布均匀。</p><p><strong>4.斐波那契查找</strong><br>        想在非均匀分布的数据中优化二分查找，就需要用到了。原理与黄金分割有关，从没见过暂时不看。</p><p><strong>5.分块查找</strong><br>        这个就是类似桶排序的行为，把数据分成多个区间块来查找。</p><p><strong>6.哈希查找</strong><br>        其实就是散列表。选一种哈希函数f，把数据的存储位置x和关键字y形成一种映射，然后查找关键字y时求出下标x即可（当然会有哈希碰撞问题要解决）。</p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深度优先-DFS"><a href="#深度优先-DFS" class="headerlink" title="深度优先 DFS"></a>深度优先 DFS</h2><p>属于图算法一种，是一个针对图和树的遍历算法。是盲目搜索算法。一般用堆+栈数据结构来辅助进行遍历，堆是要遍历的对象、栈内是路径结果。</p><p>搜索前先定义是先找左下子结点还是右下子结点。探索时会不停往下找，直到下方结点没有了，就开始往上一级。遍历期间，将遇到的结点入栈，如果遇到往上一级的情况，就把栈顶结点进行出栈。最后栈内会得到一条路径。</p><p>但注意，DFS终究是一种盲目搜索算法，并不是真正用来寻路的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220629121222.png"></p><h2 id="广度优先-BFS"><a href="#广度优先-BFS" class="headerlink" title="广度优先 BFS"></a>广度优先 BFS</h2><p>连通图的一种遍历算法。是盲目搜索算法。</p><p>一般用队列来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220629144906.png"></p><h2 id="爬山法-Hill-Climbing"><a href="#爬山法-Hill-Climbing" class="headerlink" title="爬山法 Hill Climbing"></a>爬山法 Hill Climbing</h2><p><a href="https://blog.csdn.net/qq_43285351/article/details/90926784">https://blog.csdn.net/qq_43285351/article/details/90926784</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：常见排序</title>
      <link href="/Tech/Algorithm/sort/"/>
      <url>/Tech/Algorithm/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>精简归纳：<a href="https://www.drflower.top/posts/6a923688/">https://www.drflower.top/posts/6a923688/</a></p><p>入门图解：</p><p><a href="https://blog.csdn.net/weixin_50651363/article/details/120070517">https://blog.csdn.net/weixin_50651363/article/details/120070517</a></p><p><a href="https://blog.csdn.net/kexuanxiu1163/article/details/103051357">https://blog.csdn.net/kexuanxiu1163/article/details/103051357</a></p><h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>我们先固定队尾。进行多次遍历，每一次遍历途中两两比较、两两交换，直到确定到最后1位。下一次还是从头开始遍历，但是之确定到倒数第2位…直到第1位为止。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bbsort.gif"></p><p>可以优化，如果某次遍历产生了0次交换，那么可以提前结束遍历。比如排序有序数组时，一次遍历就结束了。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>我们先固定队头。将队列分为2个部分，前面是排序完的部分、后面是待排序部分，每一次遍历都是去找待排序部分的最小值，放到排序完部分的队尾。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/xuanze_sort.gif"></p><p>Q:冒泡排序与选择排序哪个效率高？<br>A:两者时间复杂度都时候O(n)，但冒泡排序在内存循环交换，选择排序在外循环交换，一般而言选择排序效率更高。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>我们先固定队头。将队列分为2个部分，前面是即刻排序完的部分、后面是待排序部分，每一次遍历都是去待排序部分取第一个数字，保持插入后仍然有序地插入到前面的部分中。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/insertsort.gif"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的改进。选定一个整数增量序列：{a1,a2,…,1}，其中最大的a1&lt;=list.Count()，最小为1。</p><p>这里为了理解选取好1/2序列，也就是{count/2,count/4,…,1}。然后每隔count/2的数为一组进行排序，会分割成很多个内部不相邻的队列，分别对他们进行插入排序。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/shellsort.gif"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分治思想。简单来说就是，两两分组+指针。</p><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4.重复步骤 3 直到某一指针达到序列尾。</p><p>按上面的操作，进行递归，两两分组直至每一组都是1个数，不能再分为止。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/gbsort.gif"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>也是分治思想。简单来说就是，基准值+2个指针，让L指针左侧的数永远小于基准值、让R指针右侧的数永远大于基准值。</p><p>1.先选定一个基准值povit，然后放2个指针Left和Right到最左和最右。</p><p>2.对比L指针的值和povit，如果L小就是合理的，L指针右移，直至大于povit再停止；</p><p>3.当L指针停止后，开始移动R指针，如果R指向的值大就是合理的，R指针左移，直至小于povit再停止。</p><p>4.如果L和R都停止了，那么就将L、R指向的值互换，之后重启第2步继续右移L。</p><p>5.在2、3步中，如果发现L指针已经和R指针重合了，那么就证明本次分治下的排序结束。之后把L指针的值和povit的值进行交换就可以。</p><p>在上述完成后，最终结果会变成povit放在某个确定位置，而这个位置左侧的元素都小于povit，右边的元素都大于povit。所以这其实是在确定povit的最终位置。之后继续同样操作来排序povit左侧和右侧的2个队列，直至无可划分。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/quicksort.gif"></p><p>优化：1.想办法让povit取到中值（三数中值法）</p><p><a href="https://zhuanlan.zhihu.com/p/57436476">更细的步骤拆分和优化点</a></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>这个排序本身很简单，难点在于将堆用数组表现出来。所以分2部分说。</p><h3 id="用数组表示堆"><a href="#用数组表示堆" class="headerlink" title="用数组表示堆"></a>用数组表示堆</h3><ol><li>  堆：一个完全二叉树。完全二叉树就是从上到下、从左到右，直到最后一个结点为止，没有一个结点是空着的二叉树。</li><li>  大顶堆：一个堆，每个节点都能保证 父&gt;子。      小顶堆：一个堆，每个节点都能保证 父&lt;子。</li><li>  shift_down(结点k)：一个用来确定结点位置的方法。将结点k和它的2个孩子中的最大值做位置交换，然后让它继续和孩子比较，直至它比2个孩子都大。</li></ol><p>从堆的概念可以直到，你可以对堆从上到下、从左到右进行编号，编成0,1,2,…,n。这刚好对应着下标。而<strong>某个结点k的2个孩子，刚好对应结点2k+1、2k+2</strong>。</p><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>对数组化后的堆<code>H[0……n-1]</code>进行操作。</p><p>1.排出一个大顶堆；</p><p>2.把堆顶和堆尾交换，然后调用<code>shift_down(0)</code>来确保这还是一个大顶堆；</p><p>3.再把换到堆尾（也就是最大数）的那个数移除出堆，放到一个临时队列的尾部。堆结点数量-1。</p><p>重复1-3直至最后一个结点被移除。这个临时队列就是最终的排序结果。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/heapsort.gif"></p><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>外部排序是指内存中无法直接完成的大数据排序。是一种分治思想，当分到能在内存中排序的大小之后，再对其用内部排序。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>把数组遍历一遍，取出min和max值，将其范围划分为n个桶。桶内用内部排序排完之后，再把每个桶按顺序串起来。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bucketsort.gif"></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出序列中最大值和最小值，开辟Max-Min+1的辅助空间。<br>2.最小的数对应下标为0的位置，遇到一个数就给对应下标处的值+1。<br>3.遍历一遍辅助空间，就可以得到有序的一组序列。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/countsort.gif"></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>排序先把所有数字位数统一，不够的在前面用0补齐。</p><p>然后从后往前，一位一位的排，直至第一位。注意，放的时候先放，拿的时候也先拿，这样才能保持顺序，具体看动画吧。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/basesort.gif"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/O_1.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/O_2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础：图论</title>
      <link href="/Tech/Algorithm/graph-1/"/>
      <url>/Tech/Algorithm/graph-1/</url>
      
        <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 - 渲染管线、Shader、Texture</title>
      <link href="/Tech/Graphics/games101-7/"/>
      <url>/Tech/Graphics/games101-7/</url>
      
        <content type="html"><![CDATA[<h1 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h1><p>图形渲染管线 Graphics (Real-time Rendering) Pipeline</p><h2 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h2><p>前面学的流程串起来，就是下图。里面还涉及到了 <strong>Shader 和 Texture Mapping</strong> 的时机。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623160112.png"></p><h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><p>一般指 Shader Programs ，是一个程序，会<strong>对一个像素点/片段进行处理、着色</strong>。可以用OpenGL的语言写，也就是<strong>GLSL</strong>。</p><p>在线shader测试：<a href="http://shadertoy.com/view/ld3Gz2">http://shadertoy.com/view/ld3Gz2</a></p><p>shader展示：<a href="https://youtu.be/XuSnLbB1j6E">https://youtu.be/XuSnLbB1j6E</a></p><h1 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射 Texture Mapping"></a>纹理映射 Texture Mapping</h1><p>前面已经知道，每个像素点的漫反射系数kd乘以光照强度，会得到该像素点最终的颜色。显然，每个像素点的漫反射系数是由物体本身的<strong>颜色属性</strong>来决定的，而这个像素点的颜色属性我们会通过一张<strong>材质图</strong>来确定。这就是贴图。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623175805.png"></p><h2 id="uv"><a href="#uv" class="headerlink" title="uv"></a>uv</h2><p>uv坐标是指纹理展开后，纹理上的坐标。u和v的范围，都定义在0-1之内。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623182239.png"></p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>前面已经学了，三角面内进行插值着色，是用重心坐标来计算出任一个点对应的uv贴图坐标的（也就是决定漫反射系数k）。那么会出现什么问题？</p><h2 id="纹理拉伸-纹理图过小"><a href="#纹理拉伸-纹理图过小" class="headerlink" title="纹理拉伸(纹理图过小)"></a>纹理拉伸(纹理图过小)</h2><p>当纹理贴图太小了，多个像素点会映射到一个纹理点上去，看上去就像是拉伸了。纹理拉伸现象，可以通过**双线性插值 ** 来优化处理。</p><p><strong>双线性插值 Bilinear Interpolation</strong>：当一个像素点映射到uv贴图上后，取出相邻的3个uv贴图点，进行2次水平、1次竖直方向上的插值，求出这个点在4个uv贴图点中的插值平滑结果（漫反射系数）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220626224605.png"></p><h2 id="纹理拉伸-纹理图过大"><a href="#纹理拉伸-纹理图过大" class="headerlink" title="纹理拉伸(纹理图过大)"></a>纹理拉伸(纹理图过大)</h2><p>纹理图过大时，一个像素点的映射区域会覆盖很大的范围，但是一个像素点只能映射一个颜色。最终会走样，产生大量摩尔纹和锯齿。</p><p>如果不考虑性能，可以考虑超采样来获取平均值。但是考虑到性能，我们可以用<strong>MipMap</strong>。</p><p><strong>MipMaps</strong>：只能做近似的、正方形的 范围查询。</p><p>先将原图进行一半分辨率的裁剪（比如32x32=&gt;16x16），直到1x1。所有Mipmap大小之和为的原图1/3。</p><p><strong>1.如何计算需要的数量</strong>：映射出像素点对应uv的范围是几x几。</p><p><strong>2.如何查询某个中间值</strong>（比如1.8x1.8）：三线性插值。比如1.8x1.8，就是把2x2和1x1的2张mipmap结果值，再进行一次线性插值，求出1.8的值作为最终结果。</p><p>通过上面2步完成一个正确的Mipmap处理，最终可以得到一个像素点映射连续变化的uv贴图（也就是色彩会平滑、渐变过度）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220627113118.png"></p><p>上面说了只能做正方形的范围查询，那如果面对不同长宽比的情况（矩形）该怎么做来避免Overblur？</p><p><strong>各向异性过滤 Ripmaps</strong>：水平和竖直方向上的表现各不相同，不是1：1时，生成长宽拉伸后的图以提供矩形查询，处理长宽比不同的情况。最终额外的贴图大小是原图的3倍。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220627120903.png"></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Graphics </tag>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 - 着色</title>
      <link href="/Tech/Graphics/games101-6/"/>
      <url>/Tech/Graphics/games101-6/</url>
      
        <content type="html"><![CDATA[<p><strong>目前为止我们学会了什么？</strong></p><p>相机和物体 -&gt; 变换坐标到原点 -&gt; 拉伸后映射成2D图像 -&gt; 对2D图像进行光栅化：滤波、采样、后处理，最终变成屏幕上的像素点</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622162501.png"></p><p>现在我们引入<strong>着色</strong>。</p><h1 id="着色-Shading"><a href="#着色-Shading" class="headerlink" title="着色 Shading"></a>着色 Shading</h1><h2 id="什么是着色？"><a href="#什么是着色？" class="headerlink" title="什么是着色？"></a>什么是着色？</h2><p>着色在普世意义上，是对明暗、颜色进行绘制。</p><p>而在图形学中，<strong>着色是一个对物体应用材质的过程</strong>，正是材质的不同才导致颜色不同。</p><h2 id="理解一个简单的着色模型"><a href="#理解一个简单的着色模型" class="headerlink" title="理解一个简单的着色模型"></a>理解一个简单的着色模型</h2><p><strong>Blinn-Phong Reflectance Model</strong> 是一个常用参考的光照反射模型，它分为以下：</p><p><strong>高光 Specular highlights</strong>：一根光线打到光滑平面（比如镜面）上，会往镜面反射附近去反射。</p><p><strong>漫反射 Diffuse reflections</strong>：一根光线打到粗糙平面（比如墙面）上，被反射到各个地方的情况。图中茶杯从浅黄到深黄的变化。</p><p><strong>环境光照 Ambient lighting</strong>：是由间接光源组成的光源统称。图中光线并没有直接打到箭头处，而是打到桌面上被反射，反射光再打到了箭头处。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622163914.png"></p><h2 id="开始前先定义一个“着色点”-shading-point"><a href="#开始前先定义一个“着色点”-shading-point" class="headerlink" title="开始前先定义一个“着色点” shading point"></a>开始前先定义一个“着色点” shading point</h2><p>虽然反射到的面有曲面、有直面，但我们只观察一个最小的反射点，那么曲面的极小也可以当作<strong>直面</strong>。这个被观察的点我们叫做 <strong>shading point</strong> ，同时再定义几个其他的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622170625.png"></p><p>单位向量 v：和相机的连线。</p><p>单位向量 n：反射面的法线。</p><p>单位向量 l：光照方向。</p><p>表面参数：颜色 color、反射强度 shininess、…</p><p><strong>着色的局部性 shading is local：我们着色只关注光线照过来这个点该怎么着色。</strong>比如因为遮挡产生的阴影，着色器是不考虑的。</p><p>接下来我们根据定义好的观测点 shading point，来分析上面提到的3种反射情况。</p><h2 id="漫反射-Diffuse-reflections"><a href="#漫反射-Diffuse-reflections" class="headerlink" title="漫反射 Diffuse reflections"></a>漫反射 Diffuse reflections</h2><p>一根光线打到一个点上时，会被均匀反射到四周。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622173813.png"></p><p>通过观察就可以知道，着色点的法线n和光照打来的方向l的夹角θ，会和这个着色点接收到的光照能量成反比。而这个反比有一个推导，叫 <strong>朗伯余弦定理 Lambert’s cosine law</strong>。</p><p>朗伯余弦定理的推导中，将点光源发出的光的轨迹视作一个个圆球体，而根据能量守恒，只要在真空中传播没有发生损耗，这些圆球体上某点的能量和圆球体表面积（也就是半径平方r）成正比。</p><p>最终公式如下：<img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622182248.png"></p><p>从上面也能得知一件事，就是<strong>漫反射与观测方向v无关</strong> =&gt; 通俗点说就是某点被漫反射了，即使你在不同的位置看它，它的着色情况也是不变的。</p><p>公式里还有个系数kd，这是颜色系数，乘以漫反射光的强度（右边的值），得到最终显示的颜色。</p><h2 id="高光-Specular-Term"><a href="#高光-Specular-Term" class="headerlink" title="高光 Specular Term"></a>高光 Specular Term</h2><p><strong>高光与v有关。</strong>当你的观测角度v，和反射光的方向R一致或者接近的时候，你才能看到高光。</p><p>而观测角度v和反射光R的夹角有多大，又可以转化为更简单的计算：求l和v的中间向量，然后和法线n求夹角。 这一个计算转化算是优化了，计算R和v夹角的方式叫做Phong模型，而我们这种优化的方式叫做<strong>Blinn-Phong模型</strong>，推导过程和最终公式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623001727.png"></p><p>公式里还有一个问题，就是为什么要有一个<strong>P次方</strong>去处理cosα？原因是cos函数的容忍度太大了，导致非常大的夹角仍然能保持高光，这是不合理的，所以需要人为控制一下，一般P会采用256甚至以上，让夹角控制在3°以内。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623003907.png"></p><h2 id="环境光照-Ambient-Term"><a href="#环境光照-Ambient-Term" class="headerlink" title="环境光照 Ambient Term"></a>环境光照 Ambient Term</h2><p>环境光来自四面八方，与光照方向l和观测方向v都没有关系，是一个常数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623101513.png"></p><h2 id="最终3种光照"><a href="#最终3种光照" class="headerlink" title="最终3种光照"></a>最终3种光照</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623102155.png"></p><h1 id="着色频率-Shading-Frequencies"><a href="#着色频率-Shading-Frequencies" class="headerlink" title="着色频率 Shading Frequencies"></a>着色频率 Shading Frequencies</h1><p>下面介绍3种着色方式，对应着不同的着色频率。</p><h2 id="逐三角面着色-flat-shading"><a href="#逐三角面着色-flat-shading" class="headerlink" title="逐三角面着色 flat shading"></a>逐三角面着色 flat shading</h2><p>每个三角面着一次色。</p><h2 id="逐顶点着色-Gouraud-shading"><a href="#逐顶点着色-Gouraud-shading" class="headerlink" title="逐顶点着色 Gouraud shading"></a>逐顶点着色 Gouraud shading</h2><p>每个三角面的3个顶点进行着色，着色完后三角面进行内部<strong>插值</strong>着色。顶点的法线方向，是通过这个顶点周围所有的面的法线平均或者加权平均算出来的。</p><p>插值可以用<strong>重心坐标插值</strong>，但是需要用投影前的重心坐标，而不是投影拉伸到屏幕后的，因为深度不同。取到重心坐标之后可以转换为uv坐标，这样就能取到对应的着色系数了。之后再把系数带入漫反射公式，算出光照下该像素的最终颜色。</p><h2 id="逐像素着色-Phong-shading"><a href="#逐像素着色-Phong-shading" class="headerlink" title="逐像素着色 Phong shading"></a>逐像素着色 Phong shading</h2><p>在顶点插值完之后，对每个像素都进行单独计算着色。</p><h2 id="并不是频率越高越好"><a href="#并不是频率越高越好" class="headerlink" title="并不是频率越高越好"></a>并不是频率越高越好</h2><p>当面数比较多的时候，哪怕是逐三角面着色也会有很好的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623121534.png"></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Graphics </tag>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 - 遮挡与深度</title>
      <link href="/Tech/Graphics/games101-5/"/>
      <url>/Tech/Graphics/games101-5/</url>
      
        <content type="html"><![CDATA[<p>之前几节课学了怎么映射一个三角面到画面上，这节学多个三角面之间的遮挡关系处理，谁在前谁在后，也就是<strong>可见性</strong>怎么处理。</p><h1 id="实现遮挡关系"><a href="#实现遮挡关系" class="headerlink" title="实现遮挡关系"></a>实现遮挡关系</h1><h2 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h2><p>由远及近依次画（光栅化）。近的物体覆盖远的物体，就可以实现遮挡关系。</p><p>但是画家算法也存在一些问题，比如存在一些不可依赖深度排序解决的问题。所以不会直接用画家算法。</p><h2 id="深度缓存-Z-Buffer"><a href="#深度缓存-Z-Buffer" class="headerlink" title="深度缓存 Z-Buffer"></a>深度缓存 Z-Buffer</h2><p>这是工业界采用的算法。这里的z不是z轴，而是深度 depth，是摄像机位置到所求点的距离。</p><p>最后，只渲染每个像素上depth最浅的那个颜色。当物体发生运动后，会同步更新深度，有更小值出现就重新赋色。</p><p>深度缓存的复杂度是O(n)，而不是排序的O(nlogn)，因为深度缓存并不排序只求最小值。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Graphics </tag>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 - 光栅化</title>
      <link href="/Tech/Graphics/games101-4/"/>
      <url>/Tech/Graphics/games101-4/</url>
      
        <content type="html"><![CDATA[<h1 id="学之前你必须知道"><a href="#学之前你必须知道" class="headerlink" title="学之前你必须知道"></a>学之前你必须知道</h1><h2 id="视锥"><a href="#视锥" class="headerlink" title="视锥"></a>视锥</h2><p>这是透视相机的概念，用来衡量视距的大小。一般用2种属性来描述一个视锥：</p><ol><li>  near面的宽高比</li><li>  垂直视角 Vertical Field of View</li></ol><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621104507.png"></p><p>有了上面2个确定值，然后再自己定义一个near的值（近平面与相机的距离），就能确定成像了，视锥完成。</p><h2 id="屏幕上的概念"><a href="#屏幕上的概念" class="headerlink" title="屏幕上的概念"></a>屏幕上的概念</h2><p><strong>分辨率</strong>，也就是1080p、2k等，就是像素的多少。</p><p><strong>屏幕 Raster</strong>，德语中的屏幕的意思，而屏幕是一个光栅成像设备。</p><p><strong>光栅化 Rasterize</strong>，把东西画在屏幕上的过程。</p><p><strong>像素 Pixel</strong>，全名picture element，是最小单位的小正方形，它的颜色由Red、Green、Blue三个色(0~255)来混和成。</p><h2 id="屏幕发展过程"><a href="#屏幕发展过程" class="headerlink" title="屏幕发展过程"></a>屏幕发展过程</h2><p><strong>过去方式</strong></p><ol><li>  示波器</li><li>  阴极射线管 Cathode Ray Tube：和示波器原理相同，用很多电子打在屏幕上。通过扫描一样的方式，一条一条画横线，组成图像。</li></ol><p>隔行扫描 Raster Scan：上面的画横线，优化的话还会在一帧只画1、3、5…奇数行，下一帧再只画偶数行。这样省去了一半的工作量，也能一定程度欺骗到肉眼。</p><p><strong>现代方式</strong></p><ol><li>  液晶显示器 LCD（Liquid Crystal Display）：通过液晶扭曲光的方向，让其可以通过对应的光栅。</li><li>  控制发光二极管的显示器 LED（Light Emitting diode array）</li><li>  电墨水：通过电子控制只有黑、白像素的电墨水，实现电纸书的页面刷新。</li></ol><p>帧缓存技术 Frame Buffer（Memory for a Raster Display）：将显卡中的一块内存区域中，存储的内容反映到屏幕上。</p><h1 id="光栅化一个Cube"><a href="#光栅化一个Cube" class="headerlink" title="光栅化一个Cube"></a>光栅化一个Cube</h1><h2 id="视口变换-Viewport"><a href="#视口变换-Viewport" class="headerlink" title="视口变换 Viewport"></a>视口变换 Viewport</h2><p>光栅化之前要做的事。将一个 <code>[-1,1] x [-1,1]</code> 的2维平面，转换成<code>[width,0] x [0,height]</code>的笛卡尔坐标系内来表示。这叫做视口变换，看下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621115856.png"></p><p>最后算出，变换矩阵如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621121741.png"></p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>我们将原图形分解成很多个三角面，投影到屏幕的像素点上。</p><h3 id="首先，怎么判断一个像素点与三角形的位置关系？"><a href="#首先，怎么判断一个像素点与三角形的位置关系？" class="headerlink" title="首先，怎么判断一个像素点与三角形的位置关系？"></a>首先，怎么判断一个像素点与三角形的位置关系？</h3><p>靠前面的知识，已经可以做到任何一个点都确定性地投影到屏幕上了。</p><p>那么如果想判断一个像素点是否在一个三角面内呢？也就是问，<strong>如何确定这个像素的着色？</strong></p><p>可以通过判断这个像素点的中心点与三角形的位置关系来确定，为了方便，就定义一个判断函数<code>Inside()</code>。而这个函数就是进行3次叉积。</p><h3 id="然后，哪些像素点需要判断呢？"><a href="#然后，哪些像素点需要判断呢？" class="headerlink" title="然后，哪些像素点需要判断呢？"></a>然后，哪些像素点需要判断呢？</h3><p>如果需要把整个屏幕的点都进行一次<code>Inside()</code>判断，实在是没有必要，那么哪些需要、哪些不需要，这就涉及到<strong>包围盒</strong>了。</p><p>简单介绍一个AABB包围盒，它就是取三角面3个顶点的<code>Min(x), Min(y), Max(x), Max(y),</code>作为他的盒子。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621151747.png"></p><h3 id="最后，成像完有锯齿-Jaggies-怎么解决？"><a href="#最后，成像完有锯齿-Jaggies-怎么解决？" class="headerlink" title="最后，成像完有锯齿 (Jaggies) 怎么解决？"></a>最后，成像完有锯齿 (Jaggies) 怎么解决？</h3><p>又叫做反走样（Aliasing ）、抗锯齿。</p><p>在解决之前先理解为什么会有这类问题？取哪些像素点来表示这个三角面，叫做<strong>采样（Sample）</strong>。而采样会有3种<strong>瑕疵（Artifacts）</strong></p><ol><li>  锯齿 Jaggies</li><li>  摩尔纹 Moire</li><li>  运动速度过快 Wagon wheel effect</li></ol><p>产生原因是信号变化的速度太快，而采样速度跟不上了。</p><p><strong>那么怎么抗锯齿？</strong></p><p>可以对三角面做预处理，比如滤波、模糊，之后再进行采样。</p><h1 id="抗锯齿-Anti-Aliasing"><a href="#抗锯齿-Anti-Aliasing" class="headerlink" title="抗锯齿 Anti-Aliasing"></a>抗锯齿 Anti-Aliasing</h1><p>前面了解了为什么会产生锯齿，以及大致的抗锯齿技术（滤波、模糊）。这里细说。</p><p><strong>频域 Frequency Domain</strong>：描述信号在频率方面特性时用到的一种坐标系。想象一下cos2Π的图。</p><p><strong>滤波 Filtering</strong>：把某个时段内，特殊的频率给过滤掉。</p><p><strong>傅里叶变换</strong>：变幻的具体内容不要深究，只要知道，可以通过傅里叶变换把一张图变换为频域图，这样就能知道哪些地方的信号量多、少。中心定义为低频、周围定义为高频。最后，得到的频域图，是可逆的！</p><p>// TODO 下面的都只简单理解，更为深入要去学习 数字图像处理</p><h2 id="先傅里叶变换，再过滤一张图-FFP"><a href="#先傅里叶变换，再过滤一张图-FFP" class="headerlink" title="先傅里叶变换，再过滤一张图 FFP"></a>先傅里叶变换，再过滤一张图 FFP</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621180700.png"></p><p>中心定义为低频、周围定义为高频。当颜色变化差异巨大的时候（比如人物边缘），会产生高频信息。</p><p>为什么会有十字线？没有学过信号学不能看懂这张频谱图，只能理解为傅里叶变换前会把这一张图复制很多份拼起来，来取样。拼起来之后每张图的4个边的边界之间的信息差异巨大，就有巨大的高频信息，而这十字线的高亮就是边界的映射。</p><h3 id="高通率波"><a href="#高通率波" class="headerlink" title="高通率波"></a>高通率波</h3><p>High-pass，就是只有高频能通过，低频直接忽略的滤波方式。可以看到，逆变换回来的图几乎只保留了边界信息（人物描边），这是因为<strong>边界处的信号量差异很大，这就是高频的信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182236.png"></p><h3 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h3><p>滤掉高频，也就是滤掉边界信息，那么就会像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182524.png"></p><h3 id="高低滤波"><a href="#高低滤波" class="headerlink" title="高低滤波"></a>高低滤波</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622105657.png"></p><h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><p>只简单概述结论：</p><p>在空间域中，对一张图进行卷积滤波 = 对一张图进行傅里叶变换、再对其乘以卷积核的傅里叶变换、最后逆傅里叶变换回去</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622111008.png"></p><h1 id="采样-Sample"><a href="#采样-Sample" class="headerlink" title="采样 Sample"></a>采样 Sample</h1><p>稀疏采样会产生更多混叠，导致走样；密集采样更少混叠，所以映射结果更好一些。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622114336.png"></p><h2 id="怎么较少走样，也就是如何反走样？"><a href="#怎么较少走样，也就是如何反走样？" class="headerlink" title="怎么较少走样，也就是如何反走样？"></a>怎么较少走样，也就是如何反走样？</h2><p>本质上，就是想办法增大傅里叶副本之间的距离来减少混叠。</p><p><strong>1.增加采样率</strong>（更高分辨率的屏幕）</p><p><strong>2.抗锯齿</strong>，通过对图像模糊预处理（使用傅里叶来低通滤波）再采样</p><h2 id="常规采样流程"><a href="#常规采样流程" class="headerlink" title="常规采样流程"></a>常规采样流程</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622115530.png"></p><p>先用低通滤波器模糊原图，然后再采样。</p><h3 id="抗锯齿：模糊操作"><a href="#抗锯齿：模糊操作" class="headerlink" title="抗锯齿：模糊操作"></a>抗锯齿：模糊操作</h3><p>取像素颜色时，根据三角面的在该像素块中覆盖的面积，来设置灰度。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622120331.png"></p><p>这个理论很简单，但是实现比较困难，于是采用一种类似的方法，对一个像素块再进行划分、进行更多的采样，也就是**多重采样抗锯齿 MSAA (MultiSampling Anti-Aliasing) **来实现。</p><p>下图就是一个MSAA的例子：把一个像素格分成了2x2，来确定0%、25%、50%、75%、100%。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622121659.png"></p><p>工业界会优化，想要2x2的效果不会这么单纯的分割成4个正方形，而是一些其他不规则图形，甚至可能多个像素块复用一个点，这么做都是为了减少需要检测的点数量。</p><h3 id="其他抗锯齿方法"><a href="#其他抗锯齿方法" class="headerlink" title="其他抗锯齿方法"></a>其他抗锯齿方法</h3><p>FXAA（Fast Approximate AA）：快速近似抗锯齿，是一种后处理，会对有锯齿的地方进行修正。</p><p>TAA（Temporal AA）：利用时间而不是空间采样，对于静止的连续帧，上一帧有效的采样点才继续采样。</p><p>DLSS（DeepLearning SuperSimple）：当低分辨率拉伸成高分辨率时，会有很多锯齿，此时用深度学习来猜测描绘。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Graphics </tag>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 - MVP变换</title>
      <link href="/Tech/Graphics/games101-3/"/>
      <url>/Tech/Graphics/games101-3/</url>
      
        <content type="html"><![CDATA[<h1 id="从三维旋转到欧拉角"><a href="#从三维旋转到欧拉角" class="headerlink" title="从三维旋转到欧拉角"></a>从三维旋转到欧拉角</h1><p>首先三维旋转绕某个轴旋转，已经知道是这样的了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p><p>那么就可以通过对3个轴的旋转分别描述，来实现复杂的旋转角。这3个旋转角就叫做欧拉角。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620123437.png"></p><h1 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h1><p>一个公式，来实现绕轴n旋转α角度。轴n的定义为起点为原点，方向为n。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620141702.png"></p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>// TODO</p><h1 id="四元数的引入"><a href="#四元数的引入" class="headerlink" title="四元数的引入"></a>四元数的引入</h1><p>由于用旋转矩阵来做<strong>平滑插值</strong>并不合理（旋转20°矩阵 和 旋转50°矩阵 的平均值并不是旋转35°），并且存在<strong>万向锁</strong>问题，所以引入四元数。games101不展开。</p><h1 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h1><p>Model-View-Projection 模型-视图-投影变换：将3D的模型（Model）投影到2D的屏幕（View）上。</p><p>先定义相机的 <strong>位置 Position、朝向 Look-at、向上方向 Up direction</strong>（与朝向垂直，用于确定相机本身的旋转角）。</p><p>视图结果是相对不变的，当物体和相机的移动方式完全一致、没有相对运动时，成像不变。</p><h2 id="标准相机"><a href="#标准相机" class="headerlink" title="标准相机"></a>标准相机</h2><p>我们定义一个Position在 原点，Look-at在 -Z，Up direction在 Y的相机作为默认相机。</p><p>以后就可以将其他相机移成标准相机、然后再做变换、最后移回就实现了相机旋转。</p><h2 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影 Projection"></a>投影 Projection</h2><p>投影是说3D转到2D屏幕的过程。首先分2种，<strong>正交投影</strong>和<strong>透视投影 Perspective</strong>。</p><p>正交不会有近大远小、每个平行边也不会有交点，但透视都会有。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620161157.png"></p><h2 id="正交投影-Orthographic"><a href="#正交投影-Orthographic" class="headerlink" title="正交投影 Orthographic"></a>正交投影 Orthographic</h2><p>定义6个点，就可以描述一个3维的长方体：</p><p>x轴：left =&gt; right ；y轴：buttom =&gt; top ；<font color="red">z轴：fear =&gt; near</font> 。</p><p>注意z轴，因为上面所有的<code>=&gt;</code>指的都是右手坐标系的负=&gt;正，near离我们更近、被定义为正值。</p><p>OpenGL用的是左手坐标系，全部相反。</p><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620182401.png"></p><p>上图的过程就是标准化，也就是将一个长方体变成一个中心点为原点，6个点为-1、1的正方体。标准化的好处是能够更好做正交相机的投影。</p><p>标准化的变换矩阵如下，将长度定为2是为了满足(-1,1)。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620184611.png"></p><h2 id="透视投影-Perspective"><a href="#透视投影-Perspective" class="headerlink" title="透视投影 Perspective"></a>透视投影 Perspective</h2><p>近大远小、平行线会相交。这是因为不同平面内的线投影到一个平面，会有交点。</p><h3 id="齐次坐标性质"><a href="#齐次坐标性质" class="headerlink" title="齐次坐标性质"></a>齐次坐标性质</h3><p>(x,y,z,1) 和 (kx,ky,kz,k) 表示的是同一个点。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620190109.png"></p><h3 id="透视投影拆分⭐"><a href="#透视投影拆分⭐" class="headerlink" title="透视投影拆分⭐"></a>透视投影拆分⭐</h3><p>要实现一个透视投影变换，拆成2步：1.将透视投影相机视锥，挤成一个长方体（正交相机视锥）；2.将得到的长方体进行正交投影。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620225451.png"></p><p>第二步的做法已经在正交投影里写了，那么关键就是第一步怎么做，其实就是乘以一个 <strong>透视=&gt;正交 的拉伸矩阵M</strong>。</p><p>这个矩阵M（4x4）的推导如下：</p><p>1.近似三角形可推导出除了第三行以外的所有矩阵</p><p>2.性质：近平面点挤压后，点坐标的x,y,z都不变（相机的近平面，就是最终2d屏幕的大小）</p><p>3.性质：远平面点挤压后，点坐标的z不变（z轴是深度，想象一下拉伸后，远平面的深度不会变）</p><p>4.根据性质2、3可以推导出矩阵的第三行</p><p>具体推导看第四章的PPT p29-36吧，这里把主要的近似三角形概念图放下来，结合上面的拉伸概念图可以自己推导了：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620235549.png"></p><p>最后4x4的透视=&gt;正交 的拉伸矩阵M：</p><p>n    0    0    0<br>0    n    0    0<br>0    0    n+f    -nf<br>0    0    1    0</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Graphics </tag>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 - 矩阵变换入门</title>
      <link href="/Tech/Graphics/games101-2/"/>
      <url>/Tech/Graphics/games101-2/</url>
      
        <content type="html"><![CDATA[<h1 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量 Vector"></a>向量 Vector</h1><h2 id="小概念"><a href="#小概念" class="headerlink" title="小概念"></a>小概念</h2><p>数学上叫做向量，物理上喜欢称作矢量。</p><p>向量的模 Magnitude。</p><p>向量的归一化，意味着求单位向量 unit Vector。</p><h2 id="向量矩阵"><a href="#向量矩阵" class="headerlink" title="向量矩阵"></a>向量矩阵</h2><p>下面是在表示笛卡尔坐标系x-y下的某个向量，可以用矩阵来表示向量。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220615180557.png"></p><h2 id="点乘-Dot"><a href="#点乘-Dot" class="headerlink" title="点乘 Dot"></a>点乘 Dot</h2><p>满足交换律、结合律、分配律。</p><p>结果是一个数值，可以用来检测2个向量的夹角，&lt;90度为正，90度为0，90~180度为负。</p><h2 id="叉乘-Cross"><a href="#叉乘-Cross" class="headerlink" title="叉乘 Cross"></a>叉乘 Cross</h2><p>不满足交换律！向量A x 向量B = -向量B x 向量A</p><p>结果是一个向量，这个向量是与A、B向量所组成平面的垂直向量，也就是说A、B、C向量构成一个右手直角坐标系。<strong>而法线的方向，满足右手螺旋。注意a在前所以a是食指</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620122459.png"></p><p><strong>图形学上，</strong>用来检测某个点是否在一个多边形（比如三角形）内。</p><p>//因为 向量AB x 向量AP 的结果大于0则说明P在AB左侧，小于0则说明P在AB右侧。</p><p>更新=&gt; 首先确定是左手还是右手坐标系。在【右手坐标系】下，如果两个向量的叉乘结果为正值，表示向量AB经过不大于180°的【逆时针】旋转可以与向量AP的方向一致；如果为负，那么就需要转180°到360°（右手法则）。</p><p>至于为什么，思考一下<code>a X b = |a|*|b|*sinθ</code>，其中sin的值范围是0°-180°为正，180°-360°为负，就可以知道了。点乘几何意义也是同理，靠cos的值判断的。</p><p>所以一个三角面ABC和一个点P，只要通过3次叉乘的结果（都大于0或者都小于0），就能判断出点P在三角面ABC中。这是光栅化的基础，用于着色判断。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616105243.png"></p><h1 id="矩阵变换：线性变换"><a href="#矩阵变换：线性变换" class="headerlink" title="矩阵变换：线性变换"></a>矩阵变换：线性变换</h1><p>关键是，要找出变换前后每一个点之间的变化关系式。矩阵的乘法是不满足交换律的。</p><h2 id="缩放-Sacle"><a href="#缩放-Sacle" class="headerlink" title="缩放 Sacle"></a>缩放 Sacle</h2><p>可以使用对角阵*向量来进行缩放，这个对角阵叫缩放矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616114924.png"></p><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h2><p>用于翻折的单位矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616115506.png"></p><h2 id="切变-Shear"><a href="#切变-Shear" class="headerlink" title="切变 Shear"></a>切变 Shear</h2><p>要找出每一个点之间的变化关系式。</p><p>比如下图情况，只是水平方向的点发生了变化，竖直方向的不变。水平方向上的每个点发生了a / 1 * y的平移。那么久可以很容易写出切变矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616120005.png"></p><h2 id="旋转-Rotate"><a href="#旋转-Rotate" class="headerlink" title="旋转 Rotate"></a>旋转 Rotate</h2><p>二维情况下，逆时针旋转θ角：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151759.png"></p><p>推导过程（只展示A、C。B、D的话由点0,1可以推出）如下，其实只是展开了点(1,0)的偏移等式。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151646.png"></p><p>再进一步探究可知，<strong>逆旋转矩阵 = 将原旋转矩阵转置</strong>。这意味着想要旋转一个负角度，只要求出正角度的旋转矩阵再转置就可以得到旋转矩阵了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620113534.png"></p><h2 id="统称：线性变换"><a href="#统称：线性变换" class="headerlink" title="统称：线性变换"></a>统称：线性变换</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616165650.png"></p><h1 id="矩阵变换：非线性变换"><a href="#矩阵变换：非线性变换" class="headerlink" title="矩阵变换：非线性变换"></a>矩阵变换：非线性变换</h1><h2 id="平移-Translation"><a href="#平移-Translation" class="headerlink" title="平移 Translation"></a>平移 Translation</h2><p>平移比较特殊，它不能通过2阶矩阵<strong>线性变换</strong>（矩阵乘法）得出。因为矩阵乘法你只能得到ax+by的结果，没法出现常数c，所以只能靠加法。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616170433.png"></p><h2 id="平移解决方案：更高1阶的矩阵"><a href="#平移解决方案：更高1阶的矩阵" class="headerlink" title="平移解决方案：更高1阶的矩阵"></a>平移解决方案：更高1阶的矩阵</h2><p>平移必须涉及到同阶矩阵的加法，没法直接用线性变换了。为了在这种情况下也能只使用矩阵乘法就达到变换的目的，可以使用2+1阶的矩阵。多出来的矩阵值，点是1、向量是0。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616175212.png"></p><p><strong>将二维的点，最后一个矩阵值写为1。</strong>如果不是1，那么就看作x =&gt; x/w、y =&gt; y/w。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616184017.png"></p><p>那么最后，给出2维 向量、点 的变化矩阵：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616185009.png"></p><h2 id="逆变换-Inverse"><a href="#逆变换-Inverse" class="headerlink" title="逆变换 Inverse"></a>逆变换 Inverse</h2><p>通过使用逆矩阵，可以撤回变换。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616190117.png"></p><h1 id="组合的矩阵变换"><a href="#组合的矩阵变换" class="headerlink" title="组合的矩阵变换"></a>组合的矩阵变换</h1><p>先旋转，后平移。否则会出错，因为矩阵乘法没有交换律！</p><p>那么通过矩阵乘法表示线性变换、矩阵平移的时候，就是从右到左一个个乘。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620101520.png"></p><p><strong>虽然没有交换律，但是有结合律</strong>，可以让前面的变换矩阵合成为一个：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102212.png"></p><h1 id="分解复杂的矩阵变换"><a href="#分解复杂的矩阵变换" class="headerlink" title="分解复杂的矩阵变换"></a>分解复杂的矩阵变换</h1><p>对于一个复杂的矩阵变换（线性变换+平移变换），需要分解为几步，才能通过矩阵乘法来实现。</p><h2 id="绕某点旋转"><a href="#绕某点旋转" class="headerlink" title="绕某点旋转"></a>绕某点旋转</h2><p>将c移到原点 =&gt; 绕原点旋转 =&gt; 移回原来</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102642.png"></p><h1 id="由二维引申到三维"><a href="#由二维引申到三维" class="headerlink" title="由二维引申到三维"></a>由二维引申到三维</h1><p>上面讨论的都是二维，转到三维空间，其实也是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620103459.png"></p><h2 id="三维缩放、平移"><a href="#三维缩放、平移" class="headerlink" title="三维缩放、平移"></a>三维缩放、平移</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115450.png"></p><h2 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h2><p>绕某个轴旋转，该轴上的点位置不变。</p><p>至于为什么y和x、z轴旋转不一样，详细参考叉乘的<strong>右手螺旋定则</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Graphics </tag>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 - 导学</title>
      <link href="/Tech/Graphics/games101-1/"/>
      <url>/Tech/Graphics/games101-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h1><p>看一个游戏的图形方面做得如何，一般可以参考画面亮不亮，原因是这关系到了全局光照。</p><h2 id="光栅化-Rasterization"><a href="#光栅化-Rasterization" class="headerlink" title="光栅化 Rasterization"></a>光栅化 Rasterization</h2><p>把三维的几何形体画在屏幕上，这个画的过程，就叫光栅化。</p><h2 id="几何学-Curves-and-Meshes"><a href="#几何学-Curves-and-Meshes" class="headerlink" title="几何学 Curves and Meshes"></a>几何学 Curves and Meshes</h2><h2 id="光线追踪-Ray-Tracing"><a href="#光线追踪-Ray-Tracing" class="headerlink" title="光线追踪 Ray Tracing"></a>光线追踪 Ray Tracing</h2><p>从相机发射光线穿过每个像素，计算交集和阴影，并继续反射光线直到它们击中光源。</p><h2 id="动画、仿真-Animation-Simulation"><a href="#动画、仿真-Animation-Simulation" class="headerlink" title="动画、仿真 Animation/Simulation"></a>动画、仿真 Animation/Simulation</h2><p>其他行业应用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="描述整个渲染管线"><a href="#描述整个渲染管线" class="headerlink" title="描述整个渲染管线"></a>描述整个渲染管线</h2><p>现代GPU常规流程。具体的可以看<a href="https://codingcodingk.top/Tech/Graphics/games101-7/">渲染管线篇</a>。</p><p>0.一堆三维空间的顶点。</p><p>1.将顶点做<strong>MVP变换</strong>，拉伸转换成2维平面。这步涉及2种相机、根据相似三角形确定的<strong>拉伸矩阵</strong>、<strong>纹理映射</strong>。（如果是顶点着色模式，这在一步，还会进行<strong>Shading</strong>。</p><ul><li>  纹理映射：这一步就要做，因为需要在3维空间内和uv贴图进行一一映射。关系是 二维像素 - 三维平面 - uv贴图。</li></ul><p>2.将二维平面的点进行连线，做出大量三角面（顺时针为正面）。</p><p>3.将三角面进行采样，投射到屏幕的像素点上，这一步叫<strong>光栅化</strong>。这步涉及：光栅化的预处理<strong>视口变换</strong>、采样阶段的优化<strong>包围盒、</strong>为了<strong>抗锯齿</strong>做的预处理（滤波、模糊）。</p><ul><li><p>  视口变换：光栅化的预处理，将一个 <code>[-1,1] x [-1,1]</code> 的2维平面，转换成<code>[width,0] x [0,height]</code>的笛卡尔坐标系内来表示。</p></li><li><p>  抗锯齿：通过对图像模糊预处理（使用傅里叶来低通滤波），再用 <strong>多重采样抗锯齿 MSAA</strong>（超采）或其他 技术来采样。</p></li></ul><p>4.确定了像素点，像素点之间还需要实现遮挡，用<strong>Z-Buffer</strong>。（如果是全像素着色模式，这在一步，还会进行<strong>Shading</strong>。</p><ul><li>  Z-Buffer：只渲染每个像素上depth最浅的那个颜色。当物体发生运动后，会同步更新深度，有更小值出现就重新赋色。</li></ul><p>5.通过 <strong>帧缓存技术 Framebuffer</strong>，将前面确定的像素点渲染到屏幕上。</p><ul><li>  帧缓存技术 Frame Buffer（Memory for a Raster Display）：将显卡中的一块内存区域中，存储的内容反映到屏幕上。</li></ul><p>6.Shading单独拉出来说。着色目的是为了确定一个像素点的颜色系数，它受到<strong>uv贴图上对应的像素点+光反射</strong>，得到最终值。光反射在<strong>Blinn-Phong模型</strong>下，有3种光源：高光、漫反射、环境光照。<strong>着色频率</strong>分为3种：逐三角面、逐顶点、逐像素。</p><p>此外，纹理处理也有2种处理：<strong>Mipmaps</strong> (1/3)、<strong>Ripmaps 各异向性过滤</strong>（3倍）。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>前向渲染 (Forward Rendering)：把空间的点进行各种剪裁后，进行处理。先渲染一遍物体，把法线和高光存在ARGB32的渲染纹理中（法线用rgb通道，高光用a通道），存在了z buffer里；然后通过深度信息，法线和高光信息计算光照（屏幕空间），光照信息缓存在Render Texture中；最后混合。</p><p>延后渲染 (Deferred Rendering)：将摄像机空间的点光栅化转化成屏幕坐标后再进行处理。先不进行光照运算，对每个像素生成一组数据(G-buffer)，包括位置，法线，高光等，然后用这些数据将每个光源以2D后处理的方式施加在最后图像上（屏幕空间），然后只进行了一次光照计算就实现了最终效果。缺点：不适用于半透明。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> Graphics </tag>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI学习 - Button</title>
      <link href="/Tech/Game/UI/ugui_6/"/>
      <url>/Tech/Game/UI/ugui_6/</url>
      
        <content type="html"><![CDATA[<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><code>Button</code>继承自<code>Selectable</code>、<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>。</p><h2 id="外部注册"><a href="#外部注册" class="headerlink" title="外部注册"></a>外部注册</h2><h3 id="IPointerClickHandler"><a href="#IPointerClickHandler" class="headerlink" title="IPointerClickHandler"></a>IPointerClickHandler</h3><p><code>IPointerClickHandler</code>接口仅包含一个<code>OnPointerClick()</code>方法，当鼠标点击时会调用该接口的方法。而<code>Button</code>能触发点击事件是因为继承自<code>IPointerClickHandler</code>接口，并且重写了<code>OnPointerClick</code>方法。那<code>IPointerClickHandler</code>接口的方法又是被谁调用的呢？查找引用，发现是<code>ExecuteEvents</code>类的<code>Execute</code>方法，并且<code>Execute</code>方法赋值给<code>s_PointerClickHandler</code>字段。</p><p>没错，ExecuteEvents，和之前我在<a href="https://codingcodingk.top/Tech/Game/UI/ugui_2/">UGUI学习 - 事件系统、射线检测</a>的分析一致。</p><h3 id="AddListener"><a href="#AddListener" class="headerlink" title="AddListener"></a>AddListener</h3><p>那么<code>onClick.AddListener()</code>的本质也可以挖一下，其实就是监听了<code> public ButtonClickedEvent onClick</code>。而这个追溯到最底层，就是对一个回调方法队列进行<code>List.Add()</code>。</p><h2 id="Unity调用"><a href="#Unity调用" class="headerlink" title="Unity调用"></a>Unity调用</h2><p>也是和之前分析的一样，在Process方法体内进行循环检测、触发OnClick等。</p><p><code>EventSystem</code>会在<code>Update()</code>中调用当前可用<code>BaseInputModule</code>的<code>Process()</code>方法，该方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用<code>ReleaseMouse()</code>方法，并最终调用<code>Execute()</code>方法并触发<code>IPointerClick</code>事件。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOI视野管理</title>
      <link href="/Tech/Game/tools/aoi/"/>
      <url>/Tech/Game/tools/aoi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是AOI"><a href="#什么是AOI" class="headerlink" title="什么是AOI"></a>什么是AOI</h1><h2 id="AOI"><a href="#AOI" class="headerlink" title="AOI"></a>AOI</h2><p>AOI（Area of Interest），一般指一个游戏对象在所处游戏场景（MMO居多）中的视野范围。</p><p>因为玩家和较远距离的角色不会产生互动，所以不需要他们的状态，只要关注、同步视野范围内的其他单位即可。</p><h2 id="AOI主要方式"><a href="#AOI主要方式" class="headerlink" title="AOI主要方式"></a>AOI主要方式</h2><ul><li>暴力计算：每隔一定帧数，就执行一次位置计算</li><li>十字链表：只关注上下左右四个方位。</li><li>九宫格：</li></ul>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> mmo </category>
          
          <category> AOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI学习 - LayoutSystem布局系统</title>
      <link href="/Tech/Game/UI/ugui_4/"/>
      <url>/Tech/Game/UI/ugui_4/</url>
      
        <content type="html"><![CDATA[<p>学习博客：<br><a href="https://blog.csdn.net/qq_28820675/article/details/106245195">https://blog.csdn.net/qq_28820675/article/details/106245195</a></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328144810.png"></p><blockquote><p> CanvasUpdateSystem中更新布局的具体实现系统。</p></blockquote><h1 id="布局-LayoutSystem"><a href="#布局-LayoutSystem" class="headerlink" title="布局 LayoutSystem"></a>布局 LayoutSystem</h1><p>也就是上一篇中说的 Canvas刷新系统 中，重建得2个数组之一<strong>Layout数组</strong>是怎么来的、又是怎么重建得。</p><h2 id="什么时候标记"><a href="#什么时候标记" class="headerlink" title="什么时候标记"></a>什么时候标记</h2><p>也是用脏标记。时机一般为尺寸改变时（RectTransform Dimensions）。</p><h2 id="标记后干什么"><a href="#标记后干什么" class="headerlink" title="标记后干什么"></a>标记后干什么</h2><p>UGUI组件（如Graphic、ScrollRect…）在需要布局处理时（也就是被标记或OnDisable时），会把自身的RectTransform组件用LayoutRebuilder对象包装，之后加入<strong>Layout数组</strong>。</p><h2 id="重建布局"><a href="#重建布局" class="headerlink" title="重建布局"></a>重建布局</h2><p>这个的执行时机，在画布刷新系统那篇里有细写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CanvasUpdateSystem触发重建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (executing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.Layout:</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputHorizontal());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutHorizontal());</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputVertical());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutVertical());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="布局组件-LayoutGroup"><a href="#布局组件-LayoutGroup" class="headerlink" title="布局组件 LayoutGroup"></a>布局组件 LayoutGroup</h1><p>经过对LayoutSystem、LayoutRebuilder的分析，布局接口的触发规则已经被摸清楚了。</p><p>虽然UGUI组件中有一些组件都继承了ILayoutElement接口（例如：Image,Text,ScrollRect,InputField），但它们并不会涉及对接口方法的实现。这是因为这些组件主要是布局操作的接收方，只需要通过该接口被布局实施方所发现即可。而UGUI中负责这些接收物体的布局设置功能主要是由LayoutGroup衍生的子类组件来完成。</p><blockquote><p><strong>LayoutGroup</strong>，是布局组件的基类（GridLayoutGroup、HorizontalOrVerticalLayoutGroup）。先对纵横布局组件（HorizontalLayoutGroup、VerticalLayoutGroup）进行分析。</p></blockquote><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328212851.png"></p><p>Padding：内部边距，调整实际用于布局区域的大小<br>Spacing ：子物体直接的间隔<br>Child Alignment ：子物体对齐方式<br>Child Controls Size ：组件控制子物体尺寸开关，开启时组件可以更改物体尺寸。<br>Child Force Expand ：组件控制子物体填充区域开关，若可以修改尺寸则会改变子物体尺寸填充区域，若不可以修改尺寸，则根据区域大小均衡分布子物体。</p><h2 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h2><p>以HorizontalLayoutGroup为例。</p><p>1.对该GameObject下所有子物体（只做一次GetChild）进行遍历，获取其子节点下所有没有被标记<strong>ignoreLayout</strong>的物体。放到一个List中。</p><p>2.对List中的每一个Cell都进行尺寸与位置的计算。然后设置其属性。</p><h1 id="ContentSizeFitter"><a href="#ContentSizeFitter" class="headerlink" title="ContentSizeFitter"></a>ContentSizeFitter</h1><p>布局系统中尺寸调节组件。</p><p><strong>ContentSizeFitter</strong>，是用于调整组件区域使其自适的组件，一般用于与ScrollRect滑动列表以及纵横布局组件搭配，实现动态数量的滑动列表效果，以及与Text组件一起使用，可以根据文字长短进行区域尺寸的变化。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI学习 - 画布刷新、重建</title>
      <link href="/Tech/Game/UI/ugui_3/"/>
      <url>/Tech/Game/UI/ugui_3/</url>
      
        <content type="html"><![CDATA[<p>学习博客：</p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105746002">https://blog.csdn.net/qq_28820675/article/details/105746002</a></p><p><a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">https://blog.csdn.net/gaojinjingg/article/details/103565840</a></p><p>更好的入门文章：</p><p><a href="https://zhuanlan.zhihu.com/p/448293298">https://zhuanlan.zhihu.com/p/448293298</a></p><p><img src="https://img-blog.csdnimg.cn/20200425104339184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODIwNjc1,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>由Canvas控制，通过 ICanvasElement 接口，使用脏标记方法来统一更新CanvasElement</p></blockquote><h1 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h1><p>摘自<a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">大佬博客</a>。</p><ul><li>   <strong>Canvas</strong>， 是Unity渲染系统给层状几何体( layered geometry )提供的可以被画入、被放在上面或者放在世界空间的底层Unity组件。Canvas负责将它包含的几何体组合成batch，生成合适的渲染命令发送给Unity图形系统。这个过程在底层的C++代码中完成，这个过程被称为一次rebatch或者一次batch build。当一个Canvas被标记为包含需要rebatch的几何体时，这个Canvas被认为是dirty的。</li><li>   <strong>layered geometry</strong> , 由Canvas Renderer组件提供给Canvas。[ Canvas 负责进行渲染, Canvas Renderer负责采集/接收. ]</li><li>   **动静隔离 **, 一个子Canvas仅仅是一个嵌套在父Canvas中的组件，子Canvas将它的子物体和它的父Canvas隔离，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild，反之亦然。（这些在某些特殊情况下是不确定的，比如说改变父Canvas的大小导致子Canvas的大小改变。）</li><li>   <strong>Graphic</strong> , 是UGUI的C#库提供的一个基类。它是UGUI所有类的基类，给所有的UGUI类提供可以画在Canvas系统上的几何图形。大多数Unity内置的继承Graphic的类都是通过继承一个叫MaskableGraphic的子类来实现，这使得他们可以通过IMaskable接口来被隐藏。Drawable类的子类主要是image和text，已经提供了同名的组件。</li><li>  <strong>Layout</strong> , 组件控制着RectTransform的大小和位置，经常被用于要生成具有相似的大小和位置关系内容的复杂布局。它只依靠RectTransform，只影响与其相关的RectTransform的属性。这些layout组件不依赖于Graphic类，可以独立于UGUI的Graphic组件之外使用。</li><li>  <strong>CanvasUpdateRegistry</strong> , Graphic和Layout组件都依赖于CanvasUpdateRegistry类，它不会在Unity编辑器的界面中显示。这个类追踪那些Graphic和Layout组件必须被更新的时候，还有与其对应的Canvas触发了willRenderCanvases事件的时候。更新Graphic类和Layout类叫做rebuild。</li><li> <strong>Rebuild</strong> , 过程是指Layout和UGUI的C#的Graphic组件的网格被重新计算，这是在CanvasUpdateRegistry类中执行的。这是一个C＃类，它的源码可以在Unity的Bitbucket上找到。<br>   <strong>CanvasUpdateRegistry</strong> , 类中，PerformUpdate方法，当一个Canvas组件触发它的WillRenderCanvases事件时，这个方法就会被执行。这个事件每帧调用一次。<br>   <strong>PerformUpdate</strong> , 函数运行的三个步骤：<br>   1- 通过ICanvasElement.Rebuild函数，请求rebuild被Dirty的Layout组件。<br>   2- 所有被注册的裁剪组件（例如Mask），对需要被裁剪的组件进行剔除。这在ClippingRegistry.Cull中执行。<br>   3- dirty的Graphic组件被要求rebuild其图形元素。</li><li>   <strong>Layout Rebuild</strong> , 要重新计算一个或者多个Layout组件所包含的UI组件的适当位置（以及可能的大小），有必要对Layout应用层次的排序。在GameObject的hierarchy中靠近root的Layout可能会影响改变嵌套在它里面的其他Layout的位置和大小，所以必须首先计算。 </li><li>   <strong>Graphic Rebuild</strong> , 当Graphic组件被rebuild的时候，UGUI将控制传递给ICanvasElement接口的Rebuild方法。Graphic执行了这一步，并在rebuild过程中的PreRender阶段运行了两个不同的rebuild步骤：1.如果顶点数据已经被标为Dirty（例如组件的<strong>RectTransform</strong>已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的<strong>material或者texture</strong>已经被改变），则关联的Canvas Renderer的材质将被更新。Graphic的Rebuild不会按照Graphic组件的特殊顺序进行，也不会进行任何的排序操作。</li></ul><h1 id="入门理解"><a href="#入门理解" class="headerlink" title="入门理解"></a>入门理解</h1><p>这里对大佬的<a href="https://zhuanlan.zhihu.com/p/448293298">文章</a>进行摘要。</p><p><strong>Unity是怎么绘制UI元素的？</strong></p><p>Unity中渲染的物体都是由网格(Mesh)构成的，而网格的绘制单元是图元(点、线、三角面)。在unity中添加一个<em>Image</em>和<em>Text</em>，并且将<em>Shadings Mode</em>设置为<em>Wireframe</em>模式，可以看到一个<em>Image</em>由四个顶点和两个三角面构成，<em>Text</em>也是由许多顶点和三角面构成。</p><p>绘制信息都存储在<em>Vertexhelper</em>类中，除了顶点外，还包括法线、UV、颜色、切线以及一些函数。</p><p><strong>数据存储好了，那怎么绘制呢？</strong></p><p>这是依靠<em>CanvasRenderer</em>来完成的，它听起来可能比较陌生，但实际上当我们在项目中创建的一些UI元素，比如<em>Button</em>、<em>Image</em>、<em>Text</em>时，都包含组件<em>CanvasRenderer</em>，这个类提供了许多关键绘制信息，比如被渲染物体的颜色、材质和<em>Mesh</em>等，主要作用就是<strong>渲染包含在Canvas中的UI对象</strong>，但是在<em>Inspector</em>界面中并不会展示任何属性。</p><p><strong>总结一下就是，Unity会把要绘制的UI信息保存在Vertexhelper中，并且调用CanvasRenderer里面的方法进行绘制。</strong></p><h1 id="重建-Rebuild"><a href="#重建-Rebuild" class="headerlink" title="重建 Rebuild"></a>重建 Rebuild</h1><p><strong>UI重建分为两类，一类是布局重建(Layout Rebuild)，另一类是图形重建(Graphic Rebuild)。</strong></p><p>一个UI若要重建，必须继承自<em>ICanvasElement</em>接口，因为执行重建操作的时候会调用接口中的<em>Rebuild</em>函数。</p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>是Unity渲染系统给层状几何体( layered geometry )提供的可以被画入、被放在上面或者放在世界空间的底层Unity组件。</p><p>Canvas在<strong>渲染前</strong>会调用willRenderCanvases事件，也就是Registry的PerformUpdate方法，用委托的形式传进去的。</p><h2 id="CanvasUpdateRegistry"><a href="#CanvasUpdateRegistry" class="headerlink" title="CanvasUpdateRegistry"></a>CanvasUpdateRegistry</h2><p>画面刷新的注册工具类，在它的构造函数中会给Canvas注册回调：<code>Canvas.willRenderCanvases += PerformUpdate;</code></p><p>内部维护2个队列（都是 ICanvasElement类型 的）：</p><ul><li>  LayoutRebuildQueue：布局重建队列</li><li>  GraphicRebuildQueue：图像重建队列</li></ul><p>这2个队列提供了公开方法向其添加内容。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向m_LayoutRebuildQueue中添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向m_GraphicRebuildQueue中添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加内容时机"><a href="#添加内容时机" class="headerlink" title="添加内容时机"></a>添加内容时机</h2><p>那么什么时候对2个重建队列添加内容，也就是怎么确定哪些要重建呢？是通过脏数据实现的。</p><p>布局（Layout）、材质（Material）、顶点（Vertices）三部分，设置布局为脏，将进行布局重建；设置顶点或材质为脏，则进行图形重建。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetAllDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 略了，就是根据一些flag依次调用下面3个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLayoutDirty</span>(<span class="params"></span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!IsActive())</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//将元素加入布局重建队列</span></span><br><span class="line">     LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">     </span><br><span class="line">     Debug.Log(<span class="string">&quot;Rebuild:&quot;</span> + rectTransform.name);</span><br><span class="line">     <span class="keyword">if</span> (m_OnDirtyLayoutCallback != <span class="literal">null</span>)</span><br><span class="line">         m_OnDirtyLayoutCallback();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetVerticesDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m_VertsDirty = <span class="literal">true</span>;   </span><br><span class="line">    <span class="comment">//将元素加入图形重建队列</span></span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyVertsCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyVertsCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetMaterialDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    m_MaterialDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//将元素加入图形重建队列</span></span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyMaterialCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyMaterialCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发重建"><a href="#触发重建" class="headerlink" title="触发重建"></a>触发重建</h2><p>加入重建队列之后，CanvasUpdateRegistry就会在<code>PerformUpdate</code>函数中调用它的<code>Rebuild</code>进行重建。Graphic对Rebuild进行了实现：如果顶点或材质被标记为“脏”的话，会更新元素的几何网格(<em>UpdateGeometry</em>)和材质(<em>UpdateMaterial</em>)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate update</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (canvasRenderer == <span class="literal">null</span> || canvasRenderer.cull)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.PreRender:</span><br><span class="line">            <span class="keyword">if</span> (m_VertsDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdateGeometry();</span><br><span class="line">                m_VertsDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m_MaterialDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdateMaterial();</span><br><span class="line">                m_MaterialDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>UpdateGeometry</em>函数用于确定元素的网格(<em>Mesh</em>)信息，这些信息包括顶点、三角面、UV、颜色等，它们将会被填充到<em>s_VertexHelper</em>中，并最终调用<em>canvasRenderer.SetMesh(workerMesh)<em>设置</em>Mesh</em>信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoMeshGeneration</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rectTransform != <span class="literal">null</span> &amp;&amp; rectTransform.rect.width &gt;= <span class="number">0</span> &amp;&amp; rectTransform.rect.height &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//UI元素需要生成顶点时的回调函数，用以填充顶点缓冲区的数据</span></span><br><span class="line">        <span class="comment">//其子类重写了这个方法</span></span><br><span class="line">        OnPopulateMesh(s_VertexHelper);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s_VertexHelper.Clear();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前对象是否有IMeshModifier接口，</span></span><br><span class="line">    <span class="comment">//Text的描边和阴影都是通过它的ModifyMesh方法实现的</span></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    GetComponents(<span class="keyword">typeof</span>(IMeshModifier), components);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        ((IMeshModifier)components[i]).ModifyMesh(s_VertexHelper);</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line"></span><br><span class="line">    s_VertexHelper.FillMesh(workerMesh);</span><br><span class="line">    <span class="comment">//设置渲染所需的网格信息</span></span><br><span class="line">    canvasRenderer.SetMesh(workerMesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染前流程"><a href="#渲染前流程" class="headerlink" title="渲染前流程"></a>渲染前流程</h2><ul><li>  <em>PerformUpdate</em>函数对<em>m_LayoutRebuildQueue</em>中的元素进行排序，依据是父节点的多少。接下来依次将<em>Prelayout</em>、<em>Layout</em>和<em>PostLayout</em>作为参数传递给<em>Rebuild</em>进行布局重建，完成后通知布局队列中的元素重建完成。</li><li>  调用<em>ClipperRegistry</em>的<em>Cull</em>函数进行裁剪。</li><li>  进行图形重建，遍历<em>m_GraphicRebuildQueue</em>的值，分别将参数<em>PreRender</em>、<em>LatePreRender</em>作为参数传递给<em>Rebuild</em>函数进行图形重建。</li><li>  最后通知图形重建完成。</li></ul><h1 id="Rebuild时机：脏标记"><a href="#Rebuild时机：脏标记" class="headerlink" title="Rebuild时机：脏标记"></a>Rebuild时机：脏标记</h1><p>这里用脏标记，就是将重建的行为延迟到用户需要这个物体的时候才执行，一种优化重新渲染的手段。</p><p>在Graphic 中存在三种脏标记分别代表三种等待重建</p><ul><li><p>  尺寸改变时（RectTransformDimensions）：LayoutRebuild 布局重建</p></li><li><p>  尺寸、颜色改变时：Vertices to GraphicRebuild 图像顶点重建</p></li><li><p>  材质改变时：Material to GraphicRebuild 图像材质重建</p></li></ul><p>层级改变、应用动画属性（DidApplyAnimationProperties） ：All to Rebuild 重建所有</p><h2 id="案例1：Image"><a href="#案例1：Image" class="headerlink" title="案例1：Image"></a>案例1：Image</h2><p>举例Image的情况，Image间接继承自Graphic，当它的Sprite发生变化时，会调用SetAllDirty函数；设置Sprite大小的时候也会调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sprite sprite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Sprite; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Sprite != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_Sprite != <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_SkipLayoutUpdate = m_Sprite.rect.size.Equals(<span class="keyword">value</span> ? <span class="keyword">value</span>.rect.size : Vector2.zero);</span><br><span class="line">                m_SkipMaterialUpdate = m_Sprite.texture == (<span class="keyword">value</span> ? <span class="keyword">value</span>.texture : <span class="literal">null</span>);</span><br><span class="line">                m_Sprite = <span class="keyword">value</span>;</span><br><span class="line">                </span><br><span class="line">                SetAllDirty();</span><br><span class="line">                TrackSprite();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_SkipLayoutUpdate = <span class="keyword">value</span>.rect.size == Vector2.zero;</span><br><span class="line">            m_SkipMaterialUpdate = <span class="keyword">value</span>.texture == <span class="literal">null</span>;</span><br><span class="line">            m_Sprite = <span class="keyword">value</span>;</span><br><span class="line">            </span><br><span class="line">            SetAllDirty();</span><br><span class="line">            TrackSprite();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例more"><a href="#案例more" class="headerlink" title="案例more"></a>案例more</h2><ul><li>  <em>Text</em>控件 文本的内容及颜色变化、设置是否支持富文本、更改换行模式、设置字体最大最小值、变更文本使用的对齐锚点、设置是否通过几何对齐、变更字体大小、变更是否支持水平及垂直溢出、修改行间距、变更字体样式(正常、斜体…..)。</li><li>  <em>Image</em>控件 颜色变化、变更显示类型(<em>Simple</em>、<em>Sliced</em>、<em>Tiled</em>、<em>Filled</em>)、变更是否应保留<em>Sprite</em>宽高比(<em>Image.preserveAspect</em>属性的变更)，<em>FillCenter</em>属性变更(是否渲染平铺或切片图像的中心)、变更填充方式(<em>Horizontal</em>、<em>Vertical</em>、<em>Radial360</em>….)、变更图像填充率(<em>fillAmount</em>)、变更图像顺逆时针填充类型(<em>Image</em>.<em>fillClockwise</em>)、变更填充过程的原点(<em>Image.FillOrigin</em>)。</li><li>  <em>RawImage</em>控件 设置<em>Texture</em>、变更纹理使用的<em>UVRcet</em>。</li><li>  <em>Shadow</em>效果 改变效果的距离(<em>effectDistance</em>)及颜色(<em>effectColor</em>)、变更是否使用<em>Graphic</em>中的<em>Alpha</em>透明度(<em>useGraphicAlpha</em>)。</li><li>  <em>Mask</em>控件 设置是否展示与<em>Mask</em>渲染区域相关的图形(<em>showMaskGraphic</em>),<em>enable</em>发生变化</li><li>  所有继承<em>MaskableGraphic</em>的控件(<em>Image</em>、<em>RawImage</em>、<em>RectMask2D</em>、<em>Text</em>) 设置此图形是否允许被遮盖、<em>enable</em>发生变化、父节点发生变化(<em>TransFromParentChanged</em>)、在<em>Hierachy</em>面板上发生改变(<em>HierachyChanged</em>)。</li><li>  所有继承自<em>BaseMeshEffect</em>的效果类(目前只看到<em>Shadow</em>及<em>PositionAsUV1</em>)的<em>enable</em>变化及应用动画属性的操作。</li><li>  所有继承自<em>Graphic</em>的UI控件材质(<em>material</em>)发生变化。</li></ul><h1 id="一整轮Rebuild：PerformUpdate方法"><a href="#一整轮Rebuild：PerformUpdate方法" class="headerlink" title="一整轮Rebuild：PerformUpdate方法"></a>一整轮Rebuild：PerformUpdate方法</h1><p>1.在布局重建队列、图像重建队列中，<strong>剔除已销毁对象</strong>。</p><p>2.<strong>更新布局</strong>。根据父节点数量排序，先深后浅。更新类型依次为 Prelayout 、Layout 、PostLayout。详细见ugui_4。</p><p>3.执行<code>LayoutComplete</code>回调，也就是通知LayoutRebuild队列的所有元素，<strong>通知布局已完成</strong>。</p><p>4.布局完成，可以<strong>对UI（IClipper）进行裁剪</strong>了，显示不到的就不渲染</p><p>5.<strong>更新图像</strong>。依次 PreRender、LatePreRender、MaxUpdateValue：1.如果顶点数据已经被标为Dirty（例如组件的RectTransform已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的material或者texture已经被改变），则关联的Canvas Renderer的材质将被更新。</p><p>6.执行<code>GraphicUpdateComplete</code>回调，<strong>通知图像更新完成</strong>。</p><h1 id="顺序枚举"><a href="#顺序枚举" class="headerlink" title="顺序枚举"></a>顺序枚举</h1><p>CanvasUpdate，一个枚举类，很核心，代表着Canvas对Layout、Render的处理顺序：</p><ol start="0"><li>  Prelayout：Called before layout.</li><li>  Layout</li><li>  PostLayout：Called after layout.</li><li>  PreRender：Called before rendering.</li><li>  LatePreRender：Called late, before render.</li><li>  MaxUpdateValue：Max enum value. Always last.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 展示</title>
      <link href="/Intro/display/"/>
      <url>/Intro/display/</url>
      
        <content type="html"><![CDATA[<h1 id="Demo简介"><a href="#Demo简介" class="headerlink" title="Demo简介"></a>Demo简介</h1><p>个人Demo项目，所有代码都已在github开源。// <strong>个人博客</strong>：CodingCodingK.top    <strong>github首页</strong>：github.com/CodingCodingK</p><p>使用Unity客户端、.net core服务端实现类王者荣耀帧同步Moba手游。系统方面主要实现了背包系统；战斗方面，实现了主要游戏流程、实现了3个人物及其技能：亚瑟、后裔、金克斯(lol)。</p><ul><li>使用UDP通信、Protobuf协议实现帧同步网络通信库</li><li>使用Odin、xNode实现自定义可视化编辑器，且保持数据一致</li><li>使用Luban实现本地Excel数据配置导表方案</li><li>使用对象池、虚拟列表等进行背包系统优化</li><li>使用定点数实现碰撞环境生成、确定性物理碰撞检测</li><li>实现基于客户端负责计算的帧同步Moba战斗系统</li><li>不同客户端独立计算的显示结果统一与运动平滑</li><li>逻辑层与显示层分离，复用技能、Buff、子弹逻辑代码的战斗系统</li><li>业务内容上，大致实现了登陆系统、大厅主城、背包系统、匹配系统、选角系统、加载系统、战斗系统。</li></ul><h1 id="Demo演示视频⭐"><a href="#Demo演示视频⭐" class="headerlink" title="Demo演示视频⭐"></a>Demo演示视频⭐</h1><p>1P 游戏内容展示：登录客户端1 =&gt; 大厅、背包系统展示 =&gt; 登录客户端2 =&gt; 匹配、选人、加载读条系统展示 =&gt; 整个战斗流程展示 =&gt; 结束返回大厅。</p><p>2P 开发环境展示：Excel配置、自定义编辑器、服务器数据库等。</p><h2 id="视频地址-↓↓↓"><a href="#视频地址-↓↓↓" class="headerlink" title="视频地址 ↓↓↓"></a>视频地址 ↓↓↓</h2><p><a href="https://www.bilibili.com/video/BV1ML4y177hc">https://www.bilibili.com/video/BV1ML4y177hc</a></p><h2 id="Demo演示环境"><a href="#Demo演示环境" class="headerlink" title="Demo演示环境"></a>Demo演示环境</h2><p>服务器：使用腾讯云，配置 4核 8G 带宽10M 微型个人服务器。</p><p>真机测试：华为P40手机 鸿蒙OS。</p><h1 id="Demo源码"><a href="#Demo源码" class="headerlink" title="Demo源码"></a>Demo源码</h1><p>apk下载地址（可连远端服务器，支持安卓实机）：<a href="https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ">https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ</a> 提取码：1234 </p><p>MobaDemo（双端）源码地址：<a href="https://github.com/CodingCodingK/UnityMobaDemo">https://github.com/CodingCodingK/UnityMobaDemo</a></p><h1 id="Demo实现细节展示"><a href="#Demo实现细节展示" class="headerlink" title="Demo实现细节展示"></a>Demo实现细节展示</h1><p>限于篇幅以及可观赏性，很多东西没办法通过视频的形式呈现，</p><p>每个模块的demo代码以及个人笔记地址。</p><h2 id="项目实现细节"><a href="#项目实现细节" class="headerlink" title="项目实现细节"></a>项目实现细节</h2><p>技能系统、物理碰撞模拟等在项目中的运用：<a href="https://codingcodingk.top/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/">王者荣耀复刻项目 笔记目录</a></p><h2 id="使用Protobuf协议的UDP简易网络通信库"><a href="#使用Protobuf协议的UDP简易网络通信库" class="headerlink" title="使用Protobuf协议的UDP简易网络通信库"></a>使用Protobuf协议的UDP简易网络通信库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingK_Session">https://github.com/CodingCodingK/CodingK_Session</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/protobuf/">工具篇：protobuf序列化</a>    <a href="https://codingcodingk.top/Tech/Game/tools/CodingK_Session/">工具篇：帧同步网络库</a></p><h2 id="常用定时器"><a href="#常用定时器" class="headerlink" title="常用定时器"></a>常用定时器</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKTimer">https://github.com/CodingCodingK/CodingKTimer</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKTimer/">工具篇：定时系统</a></p><h2 id="自用定点数数学库"><a href="#自用定点数数学库" class="headerlink" title="自用定点数数学库"></a>自用定点数数学库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKMath">https://github.com/CodingCodingK/CodingKMath</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKMath/">工具篇：定点数运算数学库</a></p><h2 id="自用定点数物理碰撞模拟"><a href="#自用定点数物理碰撞模拟" class="headerlink" title="自用定点数物理碰撞模拟"></a>自用定点数物理碰撞模拟</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKPhysx">https://github.com/CodingCodingK/CodingKPhysx</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKPhysx/">工具篇：定点数物理碰撞库</a></p><h2 id="基于Luban实现的Excel配置方案"><a href="#基于Luban实现的Excel配置方案" class="headerlink" title="基于Luban实现的Excel配置方案"></a>基于Luban实现的Excel配置方案</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/luban_study/">工具篇：本地配置</a></p><h2 id="Odin、xNode自定义编辑器"><a href="#Odin、xNode自定义编辑器" class="headerlink" title="Odin、xNode自定义编辑器"></a>Odin、xNode自定义编辑器</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/odin_study/">工具篇：Odin 可视化编辑器</a>    <a href="https://codingcodingk.top/Project/Unity/Moba/HOK/skilleditor/">王者荣耀复刻项目 技能配置编辑器篇</a></p><h1 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h1><p>其实在开始这个Demo之前，为了能够学习游戏开发，在业余时间我也在各类网课学习了<a href="https://github.com/CodingCodingK/Unity_Studys">很多简单的游戏案例</a>，尝试理解一些框架诸如GameFramework、UGUI的源码。从2021年4月起学习Unity官方游戏案例Ruby，到如今正式求职一份Unity工作已经过去了一年。我还有很多想学习的，想做出更接近商业级的东西。</p><p>非常感谢也许是面试官也许是hr的您，能够看到这里。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么叫“二进制”配置方案？</title>
      <link href="/Tech/Game/tools/serialize/"/>
      <url>/Tech/Game/tools/serialize/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的很懵，刚好自己的demo有用，挖一下。</p><h1 id="先说二进制式存储"><a href="#先说二进制式存储" class="headerlink" title="先说二进制式存储"></a>先说二进制式存储</h1><p>要理解为什么二进制更优，先明白什么是二进制式存储。</p><h2 id="什么是二进制文件？"><a href="#什么是二进制文件？" class="headerlink" title="什么是二进制文件？"></a>什么是二进制文件？</h2><p>所有对计算机有所了解的人肯定都知道计算机的存储在物理上是二进制（01）形式的。所以文本文件与二进制文件的区别并不是物理上，而是逻辑上的。其本质是两者在编码层次上的差异。简单的来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据应用的具体情况自定义自己的编码。</p><p>从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。</p><h2 id="文本文件是怎么读取的？"><a href="#文本文件是怎么读取的？" class="headerlink" title="文本文件是怎么读取的？"></a>文本文件是怎么读取的？</h2><p>文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。</p><p>比如选取ASCII码形式（ASCII码的一个字符是8个比特），它就会8个比特地来解释这个文件流：”01000000 01000001 01000010 01000011”用ASCII码解析出来是“ABCD”，显示在文本编辑器上。</p><h2 id="二进制文件vs文本文件"><a href="#二进制文件vs文本文件" class="headerlink" title="二进制文件vs文本文件"></a>二进制文件vs文本文件</h2><p><strong>译码难度</strong>：一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。</p><p><strong>文件大小</strong>：关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。</p><h1 id="再聊二进制配置"><a href="#再聊二进制配置" class="headerlink" title="再聊二进制配置"></a>再聊二进制配置</h1><h2 id="二进制和json的关系"><a href="#二进制和json的关系" class="headerlink" title="二进制和json的关系"></a>二进制和json的关系</h2><p>要存储一个json文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot; = 133,</span><br><span class="line">  &quot;color&quot; = [233, 0, 0],</span><br><span class="line">  &quot;pos&quot; = [34, 22]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>json一般以utf-8格式保存成文本</strong>，utf-8是unicode编码的一种实现形式。也就是说，像程序中的数字类型133，233，22等，一个uint8就能存储下了，可是133在json中却占了3个字节，要是存个12.432312等数据要占用更多的空间。而本文所说的二进制配置，直接存133等的uint8二进制编码0x85，这样便减少了一部分文件大小。<strong>编码与解码可以商量好自己的规则</strong>，比如time，编解码都以t代替，又可以节省一部分空间，甚至可以不存储time，color，pos等key，直接顺序在配置中写value，解码时直接读value（为了说的清楚，后面的例子保留了key）这样又可以减少配置文件的大小。</p><h2 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h2><blockquote><p>  序列化是将对象or对象图(比如数组)转换成字节流的过程，反序列化是将字节流转换回对象图的过程。</p></blockquote><p>上面这段来自我clr笔记的定义，就可以明白大佬们说的“二进制来做”，做的是序列化反序列化。</p><p>不通过这种常规读取方式：</p><p>读取utf-8的.json文件 =&gt; 将utf-8读取成二进制流byte[] =&gt; 此时byte[]是json字符串，也就是json序列化后的产物，我们再通过反射(至少我常用的库是反射)反序列化 =&gt; 反序列化完成，返回一个对象。</p><p>那如果加入“二进制来做”的读取方式：</p><p>读取.bin文件 =&gt; 二进制文件更小读取很快，获取到二进制流byte[]，然后根据自己定好的的规则去读流(比如按顺序获取定长比特来读取)，反序列化 =&gt; 反序列化完成，返回一个对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大佬们说的“二进制来做”，其实想指的是一个解决方案而不是指最终存的文件是二进制式的这么简单。</p><p>你可以<strong>可以自己写规则</strong>，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Custom_MemoryStream</span> : <span class="title">MemoryStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReadInt</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">base</span>.Read(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = BitConverter.GetBytes(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">base</span>.Write(arr, <span class="number">0</span>, arr.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 类似的还有很多比如string，这里略了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entity <span class="title">MakeEntity</span>(<span class="params">MemoryStream ms</span>)</span>&#123;</span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity();</span><br><span class="line">    entity.Id = ms.ReadInt();</span><br><span class="line">    entity.Name = ms.ReadString();</span><br><span class="line">    entity.Path = ms.ReadString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用现成的解决方案比如protobuf、FlatBuffers，他们的最终文件也都是<strong>二进制式的而不是文本格式，且读取的时候读二进制流直接按长度转换成字段</strong>。</p><p>最后，接上导表工具，就算成了。</p><p>可能对于定义上还是有一点点误解，以后会来改。但是我相信，无论怎样，目的都是为了更快、更小。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：定点数物理碰撞库</title>
      <link href="/Tech/Game/tools/CodingKPhysx/"/>
      <url>/Tech/Game/tools/CodingKPhysx/</url>
      
        <content type="html"><![CDATA[<p>定点数基于《工具篇：定点数运算数学库》的定点数库。</p><h1 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h1><p>1.读取配置：初始化碰撞环境</p><p>2.读取配置：初始化玩家碰撞体</p><p>3.FixedUpdate（具体看《Unity生命流程》）：固定帧率检测碰撞发生</p><h1 id="碰撞配置"><a href="#碰撞配置" class="headerlink" title="碰撞配置"></a>碰撞配置</h1><p>ColldierConfig。</p><p>长方体类型：位置、长宽高、轴向。</p><p>圆柱体类型：位置、半径。</p><h1 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h1><h2 id="逻辑-视图分离"><a href="#逻辑-视图分离" class="headerlink" title="逻辑-视图分离"></a>逻辑-视图分离</h2><p>只维护逻辑值，视图则根据定点数逻辑值转换成浮点数来进行更新。但是，视图层更新后并不参与任何运算，只显示。</p><h1 id="碰撞环境"><a href="#碰撞环境" class="headerlink" title="碰撞环境"></a>碰撞环境</h1><p>环境初始化的前提是根据固定方式制作地图：<strong>只用 BoxCollider 和 CapsuleCollider 两种碰撞体，且全部放在一个EnvRoot结点下</strong>。</p><p>初始化时，遍历这个根节点，将所有的BoxCollider转化为定点数长方体形碰撞体，将所有的CapsuleCollider转化为定点数圆柱体形碰撞体。</p><p>生成下来，放到一个List中保存。</p><h1 id="碰撞检测-矫正计算（一对一）"><a href="#碰撞检测-矫正计算（一对一）" class="headerlink" title="碰撞检测+矫正计算（一对一）"></a>碰撞检测+矫正计算（一对一）</h1><h2 id="Cylinder碰到Box"><a href="#Cylinder碰到Box" class="headerlink" title="Cylinder碰到Box"></a>Cylinder碰到Box</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309232208.png"></p><p>1.求出 向量OK = Cylinder.Pos - Box.Pos。</p><p>2.求出 向量OK 分别在 Box.X方向向量、Box.Z方向向量 上的投影的长度：</p><p>使用点乘即可。具体推导是<a href="https://blog.csdn.net/liushao1031177/article/details/119776495">线代问题</a>，简单公式推导如下（向量v必须是方向向量也就是模为1）：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220308235857.png"></p><p>3.对上面求出的2段投影的长度进行钳制，让他们的范围小于的Box的半长和半宽。</p><p>4.由3的两断钳制后的投影距离 + Box.Pos ，简单计算出P点（表面最近的接触点）位置。</p><p>5.判断P点是否在Cylinder内部，不在就不需要矫正直接返回；在就需要矫正，往PO方向<strong>矫正距离</strong> Cylinder半径 - PO长度 即可。</p><p>6.如果需要矫正距离，那同时需要<strong>矫正速度方向</strong>，这可以利用向量的和来求出。求出 向量OV 在 向量PO 上的投影OT，和图中情况一致的话应该是个负数，用它可以求出 向量OT = 投影OT * 向量PO的单位向量。最后使用 向量OV - 向量OT ，得出向量TV，这就是修正后的方向向量。</p><h2 id="Cylinder碰到Cylinder"><a href="#Cylinder碰到Cylinder" class="headerlink" title="Cylinder碰到Cylinder"></a>Cylinder碰到Cylinder</h2><p>两个圆求是否相撞，直接用 两者半径之和 与 两者圆心距离 比较即可。</p><p>至于计算<strong>矫正距离</strong>就比较简单了，公式我在图中给出了。最后计算<strong>矫正速度方向</strong>，方法和上面的6是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309213302.png"></p><h1 id="碰撞检测-矫正计算（一对多）"><a href="#碰撞检测-矫正计算（一对多）" class="headerlink" title="碰撞检测+矫正计算（一对多）"></a>碰撞检测+矫正计算（一对多）</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220311014107.png"></p><p>碰撞检测如图。</p><p>目前采用一个有微小误差的办法：<br>检测速度向量OV和向量和OB的夹角：角VOB，<br>与Max(角AOB,角COB)进行比较，</p><p>如果角VOB更小，那么就当作不需要矫正；<br>如果角VOB更大，那么就当作需要矫正。</p><p>如果不需要矫正，就当作墙体的反作用力完美抵消了速度V，撤销本次预执行的位置更新，方向修正为Vector.zero。<br>如果需要矫正，使用之前的方法（步骤6）求出 速度V 与 与法线夹角最大的那个向量的法线向量（AO）情况下的 修正方向。而矫正位置就很好算了，直接取所有碰撞点（一对一）的位置矫正之和。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 物理碰撞库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展</title>
      <link href="/Tech/Game/UI/uiboy_4/"/>
      <url>/Tech/Game/UI/uiboy_4/</url>
      
        <content type="html"><![CDATA[<h1 id="初识编辑器拓展"><a href="#初识编辑器拓展" class="headerlink" title="初识编辑器拓展"></a>初识编辑器拓展</h1><h2 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h2><ul><li>  菜单栏选项</li><li>  菜单栏窗口</li><li>  面板式编辑器</li><li>  窗口式编辑器</li></ul><p>unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。 用于扩展editor的类需要放到名字为“Editor”的文件夹中，这个文件夹可以直接放到”Assets“文件夹下，也可以是项目目录任何文件夹下的子文件夹，比如”Assets/SkillSystem/Editor”。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>重新绘制画面，主要是通过重写OnGUI、OnInspectorGUI之类的函数来实现的。</p><p>这些函数是生命周期中的一员，具体看Unity生命流程图。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>对上面提出的支持进行简单实践。</p><h2 id="菜单栏选项"><a href="#菜单栏选项" class="headerlink" title="菜单栏选项"></a>菜单栏选项</h2><p>菜单栏里添加“Tools &gt; 打包工具”项。点击执行方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;Tools/打包工具&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputAB</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单栏窗口"><a href="#菜单栏窗口" class="headerlink" title="菜单栏窗口"></a>菜单栏窗口</h2><p>菜单栏里添加“Example &gt; 打包工具”项。点击跳出制作的窗口以及控件。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121155.png"></p><p>使用方法：</p><ol><li>  继承ScriptableWizard</li><li>  调用ScriptableWizard.DisplayWizard函数可以快速创建这个向导窗口。这个向导窗口只支持小于或等于两个按钮的定制（即提供的消息响应函数只有两个按钮的）。显示的按钮名字通过ScriptableWizard.DisplayWizard函数传入。</li></ol><p>ScriptableWizard的API中的消息响应函数：（当满足某些条件下执行这些函数）</p><p>OnWizardCreate ：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”createButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardOtherButton：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”otherButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardUpdate：当向导窗口打开时或者用户改变窗口内容时都会被调用。一般会在这里显示帮助文字和进行内容有效性验证。也可以动态改变按钮状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptableWizardButton</span> : <span class="title">ScriptableWizard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firstObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform secondObject = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Example/Show OnWizardOtherButton Usage&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard(<span class="string">&quot;Click info to know the distance between the objects&quot;</span>, <span class="keyword">typeof</span>(ScriptableWizardButton), <span class="string">&quot;Finish!&quot;</span>, <span class="string">&quot;Info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstObject == <span class="literal">null</span> || secondObject == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">false</span>;</span><br><span class="line">            errorString = <span class="string">&quot;Select the objects you want to measure&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">true</span>;</span><br><span class="line">            errorString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Info&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardOtherButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> distanceObjs = Vector3.Distance(firstObject.position, secondObject.position);</span><br><span class="line">        EditorUtility.DisplayDialog(</span><br><span class="line">            <span class="string">&quot;The distance between the objects is: &quot;</span> + distanceObjs + <span class="string">&quot; Units&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Finish!&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorUtility.DisplayDialog(<span class="string">&quot;OnWizardCreate &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口式编辑器"><a href="#窗口式编辑器" class="headerlink" title="窗口式编辑器"></a>窗口式编辑器</h2><p>菜单栏里添加“Window &gt; MyEditorWnd”。点击打开窗口式面板。</p><p>使用方法：继承EditorWindow，重写“OnGUI”函数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121422.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEditorWnd</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">bool</span> groupEnabled;</span><br><span class="line">    <span class="built_in">bool</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">float</span> myFloat = <span class="number">1.23f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add menu named &quot;My Window&quot; to the Window menu</span></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Window/MyEditorWnd&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get existing open window or if none, make a new one:</span></span><br><span class="line">        MyEditorWnd window = (MyEditorWnd)EditorWindow.GetWindow(<span class="keyword">typeof</span>(MyEditorWnd));</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Base Settings&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        myString = EditorGUILayout.TextField(<span class="string">&quot;Text Field&quot;</span>, myString);</span><br><span class="line">        groupEnabled = EditorGUILayout.BeginToggleGroup(<span class="string">&quot;Optional Settings&quot;</span>, groupEnabled);</span><br><span class="line">        myBool = EditorGUILayout.Toggle(<span class="string">&quot;Toggle&quot;</span>, myBool);</span><br><span class="line">        myFloat = EditorGUILayout.Slider(<span class="string">&quot;Slider&quot;</span>, myFloat, <span class="number">-3</span>, <span class="number">3</span>);</span><br><span class="line">        EditorGUILayout.EndToggleGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面板式编辑器"><a href="#面板式编辑器" class="headerlink" title="面板式编辑器"></a>面板式编辑器</h1><p>对于上面提到所有拓展方式中，第三种“面板式编辑器”是最常用的一种，单独开篇。</p><h2 id="是在做什么？"><a href="#是在做什么？" class="headerlink" title="是在做什么？"></a>是在做什么？</h2><p>是在将 EditorGUI 拓展在 Inspector 面板上。</p><p>EditorGUI 和 GUI 的用法几乎完全一致，目前来说前者多用于编辑器开发，后者多用于发布后调试编辑器。总之，它们都是起辅助作用的。 EditorGUI 提供的组件非常丰富，常用的绘制元素包括文本、按钮、图片和滚动框等。做一个好的编辑器，是离不开 EditorGUI 的。</p><p>至于EditorGUI 和 数据的交互，是借由一个继承了MonoBehaviour的脚本的数据字段实现的。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>常规使用方法：</p><ol><li>  首先得有一个MonoBehaviour常规脚本，我们取名为“Show.cs”，可以在内自定义一些字段比如Sprite、List之类的。</li><li>  新建脚本，继承Editor类，标上[CustomEditor(typeof(Show))]标签当挂Showt脚本时就会显示这个编辑器，用来让编辑器和脚本互通。</li><li>  对2中新建的脚本重写”OnInspectorGUI”函数，对自己扩展的组件的编辑界面进行定制。</li></ol><p>以上示例代码见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><p>见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity协程原理</title>
      <link href="/Tech/Game/UI/uiboy_5/"/>
      <url>/Tech/Game/UI/uiboy_5/</url>
      
        <content type="html"><![CDATA[<h1 id="开启一个协程发生了什么"><a href="#开启一个协程发生了什么" class="headerlink" title="开启一个协程发生了什么"></a>开启一个协程发生了什么</h1><p>分析如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ShowLog());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">IEnumerator <span class="title">ShowLog</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(i);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先描述一下里面用到的方法和类：</p><h2 id="StartCoroutine"><a href="#StartCoroutine" class="headerlink" title="StartCoroutine"></a>StartCoroutine</h2><p>StartCoroutine是 Monobehavior类的函数，有3个重载函数</p><blockquote><p>  public Coroutine StartCoroutine(string methodName);<br>  public Coroutine StartCoroutine(IEnumerator routine);<br>  public Coroutine StartCoroutine(string methodName, [DefaultValue(“null”)] object value);</p></blockquote><p>StartCoroutine的第一个和第三个methodName ，都是一个返回类型是IEnumerator的方法。</p><p>所以入参全是<strong>IEnumerator迭代器方法</strong>。返回类型全是<strong>Coroutine</strong>类。</p><h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>协同程序。继承自<strong>YieldInstruction</strong>类。</p><p><a href="https://docs.unity3d.com/cn/current/ScriptReference/MonoBehaviour.StartCoroutine.html">StartCoroutine函数</a> 返回 Coroutine。协同程序是一个可以暂停执行 (yield) 的函数，直到给定的 <a href="https://docs.unity3d.com/cn/current/ScriptReference/YieldInstruction.html">YieldInstruction</a> 完成。</p><h2 id="YieldInstruction"><a href="#YieldInstruction" class="headerlink" title="YieldInstruction"></a>YieldInstruction</h2><p>yield return后面可以是值，也可以是一个类型为继承自<strong>YieldInstruction的类</strong>。</p><p>如果yield return的是YieldInstruction的派生类，Unity就会将其理解为“持续等待”。比如WaitForEndOfFrame、WaitForFixedUpdate、WaitForSeconds、WWW、Coroutine（StartCoroutine的返回值），它们都是。</p><h2 id="yield-return"><a href="#yield-return" class="headerlink" title="yield return"></a>yield return</h2><p>yield return后面可以跟的表达式：</p><p>​        所有非YieldInstruction派生类（包括null）：协程将会在下一帧恢复，继续后续代码。</p><p>​        WaitForEndOfFrame：协程将会在这一帧结束之后（所有渲染、GUI）恢复，继续后续代码。</p><p>​        WaitForFixedUpdate：所有物理引擎计算完成之后恢复，继续后续代码。</p><p>​        WaitForSeconds：等待x秒后（以Unity内的计时系统为基准）恢复，继续后续代码。</p><p>​        WWW：等待一个web request结束后恢复，继续后续代码。</p><p>​        Coroutine 其他协程（协程嵌套）：等子协程Coroutine执行完后恢复，继续后续代码。如果子协程内有yield中断，那父协程会一直暂停，直到子协程运行完毕。</p><h2 id="CustomYieldInstruction"><a href="#CustomYieldInstruction" class="headerlink" title="CustomYieldInstruction"></a>CustomYieldInstruction</h2><p>想实现自定义和<code>YieldInstruction</code>一样，拥有“持续等待”逻辑的协程，就用这个。继承自<code>IEnumerator</code>类。</p><p>重写<code>keepWaiting</code>函数即可。要使协同程序保持暂停，则返回<code>true</code>；要使协同程序继续执行， 则返回<code>false</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Left mouse button up&quot;</span>);</span><br><span class="line">            StartCoroutine(waitForMouseDown());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">waitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Right mouse button pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaitForMouseDown</span> : <span class="title">CustomYieldInstruction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> keepWaiting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !Input.GetMouseButtonDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Waiting for Mouse right button down&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程原理"><a href="#协程原理" class="headerlink" title="协程原理"></a>协程原理</h1><p>如果代码中对<code>gameObject.SetActive(false)</code>，协程就会失效，即使再次激活，也不能继续执行。原因是协程是在StartCoroutine时被注册到的GameObject上，他的生命期受限于GameObject的生命期，因此受GameObject是否active的影响。</p><p><strong>不难得出，协程和Update一样是在每一帧被调用执行的。经过测试，一般是在LastUpdate之后执行的。</strong></p><p>而具体怎么执行，是利用了<strong>迭代器</strong>：每一帧检测yield的返回情况（想想StartCoroutine估计就是<code>while(MoveNext)</code>）。也就是<strong>每一帧都执行MoveNext</strong>，如果为true下一帧就继续执行MoveNext，如果为false就结束协程将其从协程队列中剔除。</p><h1 id="自己实现携程"><a href="#自己实现携程" class="headerlink" title="自己实现携程"></a>自己实现携程</h1><p>// 当然也可以考虑用async-await替代协程，ETTask就是这样的。具体以后再看，粗看应该是最后将回调放到<code>同步上下文.Post</code>里做了。</p><p>找到一个不错的实践，<a href="https://www.cnblogs.com/zblade/p/9857808.html">转载</a>一下。可以手动控制携程顺序、执行片长。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Profiling;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QuotaCoroutine</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每帧的额度时间，全局共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">float</span> frameQuotaSec = <span class="number">0.001f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">LinkedList</span>&lt;<span class="title">IEnumerator</span>&gt; s_tasks</span> = <span class="keyword">new</span> LinkedList&lt;IEnumerator&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartQuotaCoroutine(Task(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleTask();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartQuotaCoroutine</span>(<span class="params">IEnumerator task</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        s_tasks.AddLast(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ScheduleTask</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> timeStart = Time.realtimeSinceStartup;</span><br><span class="line">        <span class="keyword">while</span> (s_tasks.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> t = s_tasks.First.Value;</span><br><span class="line">            <span class="built_in">bool</span> taskFinish = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (Time.realtimeSinceStartup - timeStart &lt; frameQuotaSec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 执行任务的一步, 后续没步骤就是任务完成</span></span><br><span class="line">                Profiler.BeginSample(<span class="built_in">string</span>.Format(<span class="string">&quot;QuotaTaskStep, f:&#123;0&#125;&quot;</span>, Time.frameCount));</span><br><span class="line">                taskFinish = !t.MoveNext();</span><br><span class="line">                Profiler.EndSample();</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (taskFinish)</span><br><span class="line">                &#123;</span><br><span class="line">                    s_tasks.RemoveFirst();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 任务没结束执行到这里就是没时间额度了</span></span><br><span class="line">            <span class="keyword">if</span> (!taskFinish)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">IEnumerator <span class="title">Task</span>(<span class="params"><span class="built_in">int</span> taskId, <span class="built_in">int</span> stepCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; stepCount)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;, frame:&#123;2&#125;&quot;</span>, taskId, i, Time.frameCount);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI屏幕自适应</title>
      <link href="/Tech/Game/UI/uiboy_1/"/>
      <url>/Tech/Game/UI/uiboy_1/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="面板基本"><a href="#面板基本" class="headerlink" title="面板基本"></a>面板基本</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217103517.png"></p><p>当我们点击一个GUI物体是它具有的属性为：</p><p><strong>Rect Transform</strong>：继承自Transform组件，它表示的是控件的Location位置，和一些基本的属性。这个控件的参数类型会随着锚点情况而改变，具体在下一节展示。</p><p><strong>Pivot</strong>：设置轴心（不是蓝色的，那个叫中心锚点）的位置，中心点的位置【0,0】表示的是控件的左下角的位置，【1,1】表示的是右上角的位置，【0.5,0.5】表示的是图像中心的位置。</p><p><strong>Anchors</strong>：它的取值和Pivot一个逻辑，也是0~1之间。Min点和Max点是2个点，2个点可以沿着x、y方向，确定出一个矩形。而这个矩形的4个点就是4个锚点。我们也可以直接拖动画面的锚点来快捷设置。</p><h2 id="Pivot-和-Center"><a href="#Pivot-和-Center" class="headerlink" title="Pivot 和 Center"></a>Pivot 和 Center</h2><p>Pivot上面说了，是轴心，可以自己在Rect Transform的面板里设置；</p><p>Center是中心，是在Unity中根据模型的mesh信息计算得到的中心位置，是所有物体共同的中心，如果同时选中了多个物体，则坐标是所有模型共同参与计算出来的坐标。</p><p>Center是由Unity计算出来的而不是设置出来的。Pivot在锚点重合情况下，代表着PosX和PosY画出来的的点。</p><h2 id="锚点、纽扣和中心点-Center"><a href="#锚点、纽扣和中心点-Center" class="headerlink" title="锚点、纽扣和中心点(Center)"></a>锚点、纽扣和中心点(Center)</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217104252.png"></p><p>这里先对3个点下定义，下面一节进行讨论。</p><p>单击图形显示着的的小篮圈，到底表示的是Pivot还是Center，是在Unity里设置的，两者完全不是一个东西。设置的话，在Global边上的选项里选择即可。</p><p>正常的二维UI，中心点总是在正中间，而轴心就可以自己设置了。</p><h1 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h1><h2 id="情况一：两个锚点重合"><a href="#情况一：两个锚点重合" class="headerlink" title="情况一：两个锚点重合"></a>情况一：两个锚点重合</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>两个锚点重合的情况，Image UI（也就是红色Image）的锚点和Pivot连成一条线，这条线会永远保持（也就是两点的距离会永远保持）。<strong>在这种情况下调整画面，Image UI不会变形，只会根据Pivot点到Anchor点的距离一致的原则调整位置。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120309.png"></p><p>一个值得关注的点是，此时Image UI的Rect Transform控件是Pos + Width,Height的组合。这个PosX和Y，指的是Anchor和Pivot之间的相对位置。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120631.png"></p><h3 id="示例动图"><a href="#示例动图" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored1.gif"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored2.gif"></p><h2 id="情况二：锚框"><a href="#情况二：锚框" class="headerlink" title="情况二：锚框"></a>情况二：锚框</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>当两个锚点（AnchorMin和AnchorMax）不重合时，两点就会确定一个矩形，这个矩形就是我们的锚框。<strong>这种情况会保持锚点到纽扣的距离保持不变。</strong></p><p>此时Image UI的Rect Transform控件是Left,Top + Right,Bottom的组合。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217121839.png"></p><p>这四个点什么意思呢？是纽扣的相对位置，相对的是锚点组成的坐标系。看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217134116.png"></p><p>所以明白了，锚点到纽扣的距离保持不变，那就意味着4条（图中2条以及左上右下未画出来的）绿线始终保持不变。同时意味着，代表这4个点相对位置的Rect Transform控件里的Left,Top,Right,Bottom值也都不变。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217135538.png"></p><h3 id="示例动图-1"><a href="#示例动图-1" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored3.gif"></p><h2 id="anchoredPosition属性"><a href="#anchoredPosition属性" class="headerlink" title="anchoredPosition属性"></a>anchoredPosition属性</h2><p>他本身是一个点，如果在AnchorMin和AnchorMax是重合的场合（情况一）下，anchoredPosition就是表示锚点到Pivot的位置。</p><p>但是如果AnchorMin和AnchorMax不重合的时候（情况二），anchoredPosition就比较复杂了，在这种情况下，Unity会根据Pivot、AnchorMin和AnchorMax计算出一个锚点，然后在通过Pivot和锚点来得出anchoredPosition的位置。</p><h2 id="offsetMin和offsetMax详解"><a href="#offsetMin和offsetMax详解" class="headerlink" title="offsetMin和offsetMax详解"></a>offsetMin和offsetMax详解</h2><p>offsetMin和offsetMax这两个属性。其中offsetMin表示物体（本文中的红框）左下角相对AnchorMin的偏移，offsetMax表示物体右上角相对AnchorMax的偏移。</p><p>情况一 anchor(0, 0)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151909.png"></p><p>情况二 anchorMin(0,0) anchorMax(1,1)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151935.png"></p><h2 id="sizeDelta详解"><a href="#sizeDelta详解" class="headerlink" title="sizeDelta详解"></a>sizeDelta详解</h2><p>sizeDelta就是offsetMax - offsetMin的值，即物体左下角到右上角的变量：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152058.png"></p><h1 id="画布缩放器-Canvas-Scaler"><a href="#画布缩放器-Canvas-Scaler" class="headerlink" title="画布缩放器 Canvas Scaler"></a>画布缩放器 Canvas Scaler</h1><p>Canvas新建时自带的脚本，专门解决屏幕适配问题的脚本，负责伸缩所有UI对象。以下内容主要取自<a href="https://docs.unity3d.com/cn/current/Manual/script-CanvasScaler.html">Unity中文手册</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152713.png"></p><p>三种模式：</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>UI Scale Mode</strong></td><td align="left">确定画布中的 UI 元素的缩放方式。</td></tr><tr><td align="left"><strong>Constant Pixel Size</strong></td><td align="left">无论屏幕大小如何，UI 元素都保持相同的像素大小。</td></tr><tr><td align="left"><strong>Scale With Screen Size</strong></td><td align="left">屏幕越大，UI 元素越大。</td></tr><tr><td align="left"><strong>Constant Physical Size</strong></td><td align="left">无论屏幕大小和分辨率如何，UI 元素都保持相同的物理大小。</td></tr></tbody></table><p>一般来说的配置方案是：<br>Canvas Scaler 选择 Scale With Screen Size<br>Screen Match Mode 选择 Match Width Or Height，</p><p>横屏游戏比例设为1，即只和高度进行适配；</p><p>竖屏游戏比例设为0，即只和宽度进行适配。</p><h2 id="1、Constant-Pixel-Size"><a href="#1、Constant-Pixel-Size" class="headerlink" title="1、Constant Pixel Size"></a>1、Constant Pixel Size</h2><p>一般美术拿它来做缩放图片，因为不同Size不失真。</p><p>使用 Constant Pixel Size 模式时，可在屏幕上按像素指定 UI 元素的位置和大小。这也是画布在未附加任何画布缩放器时的默认功能。但是，借助画布缩放器中的“Scale Factor”设置，可以向画布中的所有 UI 元素应用常量缩放。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Scale Factor</strong></td><td align="left">按此系数缩放画布中的所有 UI 元素。画布的缩放比例。默认况下为1，表示正常大小。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。每单位代表的像素量。</td></tr></tbody></table><h2 id="2、Scale-With-Screen-Size"><a href="#2、Scale-With-Screen-Size" class="headerlink" title="2、Scale With Screen Size"></a>2、Scale With Screen Size</h2><p>使用 Scale With Screen Size 模式时，可以根据指定参考分辨率的像素来指定位置和大小。如果当前屏幕分辨率大于参考分辨率，则画布会保持只具有参考分辨率的分辨率，但是会放大以便适应屏幕。如果当前屏幕分辨率小于参考分辨率，则画布会相应缩小以适应屏幕。</p><p>如果当前屏幕分辨率的宽高比与参考分辨率不同，则单独缩放每个轴以适应屏幕会形成非一致缩放，通常不希望发生这种情况。相反，ReferenceResolution 组件会使画布分辨率偏离参考分辨率，以便遵循屏幕的宽高比。可以使用 Screen Match Mode 设置控制此偏离的行为方式。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Reference Resolution</strong></td><td align="left">UI 布局设计的目标分辨率。如果屏幕分辨率较大，则 UI 会放大，如果较小，则 UI 会缩小。</td></tr><tr><td align="left"><strong>Screen Match Mode</strong></td><td align="left">在当前分辨率的宽高比不适应参考分辨率时，用于缩放画布区域的模式。</td></tr><tr><td align="left"><strong>Match Width or Height</strong>⭐常用</td><td align="left">以宽度、高度或二者的某种平均值作为参考来缩放画布区域。</td></tr><tr><td align="left"><strong>Expand</strong></td><td align="left">水平或垂直扩展画布区域，使画布不会小于参考。</td></tr><tr><td align="left"><strong>Shrink</strong></td><td align="left">水平或垂直裁剪画布区域，使画布不会大于参考。</td></tr><tr><td align="left"><strong>Match</strong></td><td align="left">确定是否以宽度、高度或二者的某种平均值作为参考进行缩放。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。</td></tr></tbody></table><h2 id="3、Constant-Physical-Size"><a href="#3、Constant-Physical-Size" class="headerlink" title="3、Constant Physical Size"></a>3、Constant Physical Size</h2><p>使用 Constant Physical Size 模式时，可按物理单位（如毫米、点或派卡）指定 UI 元素的位置和大小。此模式要求设备正确报告其屏幕 DPI。对于不报告 DPI 的设备，可以指定回退 DPI。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Physical Unit</strong></td><td align="left">用于指定位置和大小的物理单位。</td></tr><tr><td align="left"><strong>Fallback Screen DPI</strong></td><td align="left">在屏幕 DPI 未知时采用的 DPI。</td></tr><tr><td align="left"><strong>Default Sprite DPI</strong></td><td align="left">用于精灵的每英寸像素，使其“Pixels Per Unit”设置与“Reference Pixels Per Unit”设置匹配。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则其 DPI 将与“Default Sprite DPI”设置匹配。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity生命流程</title>
      <link href="/Tech/Game/UI/uiboy_3/"/>
      <url>/Tech/Game/UI/uiboy_3/</url>
      
        <content type="html"><![CDATA[<h1 id="生命流程图"><a href="#生命流程图" class="headerlink" title="生命流程图"></a>生命流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221094846.png"></p><h1 id="FixedUpdate"><a href="#FixedUpdate" class="headerlink" title="FixedUpdate"></a>FixedUpdate</h1><p>1、和Update主帧循环不同，Unity的刚体系统通过固定的时间来驱动也就是FixedUpdate。在刚体系统运算开始前，<strong>Unity会根据上一次刚体运算完成的时间再加上Fixed Timestep的所设置的值来作为这一次刚体运算时间的限定范围</strong>。然后刚体系统会开始计算，直到达到这个时间限制临界点。</p><p>2、FixedUpdate与Update的不同在于，Update在每帧被调用，但是调用时间不确定，所以我们要实现一个物体匀速运动是，是无法通过Update准确实现的，但是我们可以在FixedUpdate中实现，因为它在确定的时间间隔中被调用。FixedUpdate有可能在Update之前调用多次。FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。</p><p>3、FixedUpdate的频率可以自己设置，如果频率过高，导致一次Update的时间片内执行了多次FixedUpdate进行物理运算，那对CPU就是一种浪费（因为根本不显示出来）；而适当的低频率FixedUpdate，虽然偶尔会造成人物有顿感，但是往往是可以接受的。</p><p>4、FixedUpdate的最高值也是可以设置的。Time Manager中的Maximum Allowed Timestep就是给处理物体运算的FixedUpdate加上一个限制。如果某一帧的物理运算时间超过了这个值，物理引擎就会立即停止运算，以便让主循环Update可以追上,一旦这一帧主循环Update运行完成，物理引擎就会从它暂停的地方恢复计算就像它从来没有停止过一样。</p><h1 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate"></a>LateUpdate</h1><p>3、LateUpdate它会在所有update被调用后调用，这个函数可以在我们编写ai时被使用，因为我们要当所有物体和怪物移动过后再判断物体的一些策略，比如开枪等，这个时候就可以在LateUpdate中编写，因为LateUpdate基本可以保证所有物体在本帧的移动等操作均已经完成。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI常见优化</title>
      <link href="/Tech/Game/UI/uiboy_2/"/>
      <url>/Tech/Game/UI/uiboy_2/</url>
      
        <content type="html"><![CDATA[<p>收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。</p><h1 id="Unity性能优化"><a href="#Unity性能优化" class="headerlink" title="Unity性能优化"></a>Unity性能优化</h1><h2 id="优化关键"><a href="#优化关键" class="headerlink" title="优化关键"></a>优化关键</h2><p>先找到性能瓶颈。影响图形性能的关键因素主要有一下几个方面。</p><ol><li> GPU填充率和存储器带宽。</li><li> CPU经常是渲染物体的数量（也就是常常大家说的Draw Calls）。</li><li> 系统内存容量也是优化的一个关键指标。</li></ol><h2 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h2><p>GPU优化主要有下面几点：</p><ol><li>  减少三角形的使用数量（去掉不必要的三角形面）。</li><li>  尽量避免使用实时光照，能使用Static Lighting就使用烘焙光照，只计算一次。</li><li>  压缩纹理和多重纹理-mipmap（这样可以提高加载速度和降低内存占用），也极大提高渲染的性能。</li><li>  LOD（多细节层次），不同距离使用不同精度的模型。</li><li>  编写高性能着色器，将能能处理的逻辑放在定点着色器里面处理，减少片段着色器的计算量。</li></ol><h2 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h2><p>CPU主要开销在，显卡在渲染一个对象之前，CPU需要计算一些着色器和灯光影响，然后想显卡驱动发送绘制指令，单物体来说，不会太影响性能，累计就会产生性能问题。这里优化点主要从以下几个方面讨论，这里只是说出优化常用的方案，后面如果在下在项目里面遇到更加好的方案，或者是方法，我将会在这里补充出来。也欢迎大家指出错误，或者是更好的CPU优化方案。</p><ol><li> 合并材质球相同的对象，进而减少绘制指令的发送。合并的方式有，手工合并或者是使用Unity内置的选项合并，或者是使用自制脚本合并模型对象，但是注意的是:非相同材质对象，合并不会对性能有任何的提高。</li><li> 在对象或场景中使用更少的材质。可以将独立的纹理合并成一个更大的纹理图集，但是合并时注意，合并要以方便开发，节省资源为基础。</li><li> 避免使用物体被渲染多次的效果，这里主要体现在（反射，阴影，像素光照等）。</li><li> 优化游戏代码，也是优化CPU的一个关键点。</li></ol><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>性能优化最后一点，就是内存的优化，要优化Unity的内存资源，就首先必须了解内存的资源管理模式，以及Unity资源加载的方式，Unity资源动态加载主要有下面两种方式：</p><ol><li> Resource方式资源加载。</li><li> AssetBundle资源加载方式。</li></ol><p>这两种资源加载方式都提供同步和异步加载API。资源加载到内存里面的规范到底是什么样的，观察下面的图就一目了然。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210105112.png"></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity常见UI基础问题手册</title>
      <link href="/Tech/Game/UI/Guide_UnityUI/"/>
      <url>/Tech/Game/UI/Guide_UnityUI/</url>
      
        <content type="html"><![CDATA[<p>仅作个人笔记用途。</p><h1 id="UI顶层显示"><a href="#UI顶层显示" class="headerlink" title="UI顶层显示"></a>UI顶层显示</h1><h2 id="方法一-做一个新的UI摄像机"><a href="#方法一-做一个新的UI摄像机" class="headerlink" title="方法一.做一个新的UI摄像机"></a>方法一.做一个新的UI摄像机</h2><p>① Canvas的Render Mode设置为<strong>Screen Space - Camera</strong></p><p>② 新建摄像机（后面称之为UI摄像机），放到原先摄像机的下面</p><p>③ 拖拽UI摄像机到Canvas的Render Camera</p><p>④ UI摄像机的 Clear Flags 设置为 <strong>Depth only</strong>，用来去掉背景；Culling Mask设置为 <strong>UI</strong>。</p><p>⑤ 确保 UI摄像机的Depth &gt; 其他摄像机的Depth （值小的会先渲染，所以值大的会在前面）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1dK4y1b7be?spm_id_from=333.999.0.0">超级细致的调试教学视频</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity个人积累 </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI学习 - Base篇</title>
      <link href="/Tech/Game/UI/ugui_1/"/>
      <url>/Tech/Game/UI/ugui_1/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><a href="https://github.com/Unity-Technologies/uGUI">源码地址</a></p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105619250">学习博客</a></p><p>GF源码看了，UGUI自适应用了，自定义编辑器写了，但是对于UGUI却一直是纯黑盒使用。想体系化学习一遍UGUI。</p><p>学习目的：按照博客阅读源码，理解后整理成自己的笔记，方便回忆。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h1><p>好图，转自大佬<a href="https://blog.csdn.net/qq_28820675/article/details/105619250">博客</a>！</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220316142853.png"></p><h1 id="UIBehaviour"><a href="#UIBehaviour" class="headerlink" title="UIBehaviour"></a>UIBehaviour</h1><blockquote><p>  namespace UnityEngine.EventSystems :</p><p>  public abstract class UIBehaviour : MonoBehaviour</p></blockquote><p>是一个抽象类，里面提供了一系列虚方法：</p><ul><li>  生命周期（Awake,OnEnable,Start,OnDisable,OnDestroy）</li><li>  UnityEditor 辅助方法</li><li>  UGUI 通用方法（IsActive,OnValidate,OnRectTransformDimensionsChange等锚点相关）</li></ul><p>和一个非虚方法 IsDestroyed：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsDestroyed</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI学习 - 事件系统、射线检测</title>
      <link href="/Tech/Game/UI/ugui_2/"/>
      <url>/Tech/Game/UI/ugui_2/</url>
      
        <content type="html"><![CDATA[<p>图片转自<a href="https://blog.csdn.net/qq_28820675/article/details/105619356">大佬博客</a>，非常好的入门：<a href="https://zhuanlan.zhihu.com/p/437704772%E3%80%82">https://zhuanlan.zhihu.com/p/437704772。</a></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220321175024.png"></p><h1 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h1><p>总的来说事件系统分为3个大组件：</p><ul><li>  EventSystem组件 负责管理 所有的输入检测模块（InputModule）并在Update中每帧调用Module的执行（Process）。</li><li>  InputModule组件 负责输入（点击、拖拽、选中等），调用Raycaster获得返回值PointerEventData，最后通过ExecuteEvents触发事件（IPointerClickHandler 等）。</li><li>  Raycaster组件 负责确定目标对象，返回结果PointerEventData给InputModule组件。</li></ul><h2 id="相互之间的协作⭐"><a href="#相互之间的协作⭐" class="headerlink" title="相互之间的协作⭐"></a>相互之间的协作⭐</h2><p><code>EventSystem</code>会在<code>Update</code>中调用输入模块的<code>Process</code>方法来处理输入消息；</p><p><code>PointerInputModule</code>的<code>Process</code>方法会调用<code>EventSystem</code>中的<code>RaycastAll</code>方法进行射线检测；</p><p><code>RaycastAll</code>又会调用所有<code>BastRaycaster</code>的<code>Raycast</code>方法执行具体的射线检测操作，用以获取屏幕某个点下的所有目标；</p><p>获取完点击目标后，又会回到<code>PointerInputModule</code>，对其触发那些事件接口（IPointerClickHandler之类的）并传入PointerEventData参数 =&gt; 使用冒泡排序通知，直到有能处理对应<code>IEventSystemHandler</code>的UI接收为止（比如Button上的Text无点击事件，那就父物体Button接收）。</p><h2 id="协作举例"><a href="#协作举例" class="headerlink" title="协作举例"></a>协作举例</h2><p>举个例子来体验上面的协作。</p><p>比如你点击了一个Button组件，首先会在<code>EventSystem</code>的<code>Update</code>中被输入模块的<code>Process</code>方法被抓取到，之后输入模块就会调用<code>RaycastAll</code>方法来得到所有屏幕下点击到的目标，最后通过冒泡的方式来找到第一个可以接收点击事件的UI目标。确定好UI目标后，对其执行点击事件。</p><h2 id="管理者-EventSystem"><a href="#管理者-EventSystem" class="headerlink" title="管理者 EventSystem"></a>管理者 EventSystem</h2><blockquote><p>  平时新建一个Canvas时，会创建EventSystem组件，这个组件所挂载的脚本就是EventSystem和InputModule。</p></blockquote><p>EventSystem组件主要负责<strong>处理输入、射线投射以及发送事件</strong>，一个场景中只能有一个EventSystem组件。</p><ul><li>  管理哪个游戏对象被认为是选中的</li><li>  管理正在使用的输入模块</li><li>  管理射线检测(如果需要)</li><li>  根据需要更新所有输入模块</li></ul><h2 id="输入-InputModule"><a href="#输入-InputModule" class="headerlink" title="输入 InputModule"></a>输入 InputModule</h2><blockquote><p>  平时新建一个Canvas时，会创建EventSystem组件，这个组件所挂载的脚本就是EventSystem和InputModule。</p></blockquote><p>BaseInputModule基类，负责发送输入事件（点击、拖拽、选中等）到具体对象，可以自己派生实现输入模块而官方提供2个：</p><ul><li>  标准输入模块（StandaloneInputModule）</li><li>  触摸输入模块（TouchInputModule， 现在已经不需要了它整合进StandaloneInputModule中了！）</li></ul><p>这2个官方提供的模块会检测一些输入操作，以事件的方式（message系统）通知目标对象，所以给摇杆的mono脚本实现接口（IPointerClickHandler 等）就可以触发事件 。</p><h2 id="射线-Raycaster"><a href="#射线-Raycaster" class="headerlink" title="射线 Raycaster"></a>射线 Raycaster</h2><ul><li>  对于UI对象，在平时新建一个Canvas时，如果Canvas的渲染模式是SceenSpace-Overlay，Canvas会挂载GraphRaycaster脚本。</li><li>  场景中的非UI对象，如果想要接收输入模块的事件，也需要给摄像机挂上一个射线检测组件（3D是PhysicsRaycaster、2D是Physics2Draycaster）。然后需要给想被检测到的物体添加collider脚本，否则检测不到。</li></ul><h2 id="事件执行器-ExecuteEvents"><a href="#事件执行器-ExecuteEvents" class="headerlink" title="事件执行器 ExecuteEvents"></a>事件执行器 ExecuteEvents</h2><p>事件执行器，InputModule在通过射线确定了最近的命中物体后，会用ExecuteEvents触发Click等事件。</p><p>Execute方法：获取物体上所有包含IEventSystemHandler且可用的组件，根据情况调用执行接口方法，传入PointerEventData参数。</p><h1 id="射线检测流程"><a href="#射线检测流程" class="headerlink" title="射线检测流程"></a>射线检测流程</h1><p>0.在EventSystem的Update中，每帧调用InputModule.Process，进行点击/触击检测。</p><p>1.如果InputModule检测到了点击/触击，就会向EventSystem请求发射射线。 <code>eventSystem.RaycastAll(pointerData, m_RaycastResultCache);</code></p><p>2.将屏幕触击点投影到相机切面(near)上的位置，生成一条射线，将射线所有命中的物体保存到 hitDistance击中点数组 和 <strong>RaycastResult被命中物体数组</strong> 中。具体射线怎么计算命中的，是<code>UnityEngine.Physics</code>内的接口，没开源。</p><p>3.遍历所有Graphic，获取可接收射线广播的Graphic信息。</p><p>4.取出RaycastResult数组中，距离最近的那个物体作为射线检测的结果返回。</p><p>5.射线检测结果PointerEventData 返回到了InputModule中，对其触发那些事件接口（IPointerClickHandler之类的）并传入PointerEventData参数。</p><p>// 2中具体还会记录射线起点到相机渲染终点的切面(far)之间的距离，如果射线触点不在范围内会判定为不触发点击事件。这个具体看<a href="https://www.cnblogs.com/w-wfy/p/7243459.html">下图</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220321164508.png"></p><h1 id="UI穿透"><a href="#UI穿透" class="headerlink" title="UI穿透"></a>UI穿透</h1><p>就是说，在UGUI和3D场景混合的情况下，点击UI区域同时也会触发3D中物体的⿏标事件。</p><p>解决1.一般新窗口和底层窗口之间，都会有一个暗灰色的透明背景，可以把这个透明背景的Raycast Target勾选上，这样就终止了射线检测到后面的窗口。</p><p>解决2.自己实现一个简单的射线检测，射线使用graphicRaycaster射线，这是针对UI检测的射线。</p><p>ps.针对UI检测的射线：其实每个组件在创建的时候已经被添加进了一个公共列表（我们使用的UGUI中的每个组件都是继承自Graphic或者依赖一个继承自Graphic的组件）。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 同步异步、多线程篇</title>
      <link href="/Tech/CSharp/Essence/tongbuyibu_obsolete/"/>
      <url>/Tech/CSharp/Essence/tongbuyibu_obsolete/</url>
      
        <content type="html"><![CDATA[<h1 id="零-为什么我会理解错"><a href="#零-为什么我会理解错" class="headerlink" title="零.为什么我会理解错"></a>零.为什么我会理解错</h1><p>在看完clr之前，我曾对异步同步探究看了十几篇文章，但很可惜，没有完全理解，只知道了一大堆概念：IRP、异步要借用多线程…</p><p>在看完之后，我理解并甚至尝试实现一个简单的异步的时候才明白，之前无法理解是因为我不懂：</p><p><strong>异步编程 和 异步函数 是不同的东西。也就是说，异步函数async/await 只是异步编程的一种罢了，你大可以利用ContinueWith或ThreadPool等来实现异步。</strong></p><p>很多博客混淆了这两个概念，我不知道他们是否真正理解了，但是这会导致我这种代码先行基础后补的菜b无法理解。</p><p>所以这篇文章的理解是片面的，等有空了我再整理一下。</p><h1 id="一-同步与异步"><a href="#一-同步与异步" class="headerlink" title="一.同步与异步"></a>一.同步与异步</h1><p>  项目中每天都在接触，但是对这俩概念比较模糊。看《CLR via C#》刚好提到了，就去网上找到几篇好文，理解写篇自己的笔记。首先得说明的是，这一节讨论的只是概念，都是单纯的、不考虑多线程处理的同步与异步区别。</p><h3 id="IO-概念区分"><a href="#IO-概念区分" class="headerlink" title="IO 概念区分"></a>IO 概念区分</h3><ul><li><p>同步（Synchronous）</p></li><li><p>异步( Asynchronous)</p></li><li><p>阻塞( Blocking )</p></li><li><p>非阻塞( Nonblocking)</p></li></ul><p>那首先，要弄清楚同步异步、阻塞非阻塞之间的关系。</p><ul><li><p>同步异步 指的是在客户端，<br>同步意味着 客户端提出了一个请求以后，在回应之前只能等待。<br>异步意味着 客户端提出一个请求以后，还可以继续提其他请求。</p></li><li><p>阻塞非阻塞 指的是服务器端，<br>阻塞意味着 服务器接受一个请求后，在返回结果以前不能接受其他请求。<br>非阻塞意味着 服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求。</p></li></ul><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><ol><li>同步与异步意图<br>这个层级的还是很好理解，它们的核心是消息通信机制。</li></ol><ul><li>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。也就是说，代码执行会等着它，卡在那不动，直到执行结束把返回值给我才继续。</li><li>异步则是相反，调用在发出之后，这个调用就直接返回了，没有返回结果，我记得如果还没返回就去拿的话好像是null。也就是说，代码执行不会等它，你管你运行，返回值我不需要所以我继续往下跑，你运行完执行你自己的回调函数就行。用途有点类似于子线程。</li></ul><ol start="2"><li>阻塞与非阻塞意图<br>区分是调用结果返回之前，是否将调用的线程挂起，暂时不理其他请求。</li></ol><h3 id="不同模型的理解"><a href="#不同模型的理解" class="headerlink" title="不同模型的理解"></a>不同模型的理解</h3><p>直接把别人博客的图整理下拿过来了，<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211104120820.png"></p><ol><li>说的是单线程普通情况下，是这么执行的。按顺序一个个，等A有返回值回来了再B，B有返回值回来了再C。</li><li>说的是多线程同步的情况，并行运行，不展开，图简单，但实际交互非常复杂，通道、共享内存啥的。这里提这个是为了体现异步的作用。</li><li>说的是单线程异步执行，看得到ABC这运行，理论上是没有什么执行顺序可言的（项目经验告诉我，实际上这句话不对，但是概念上这么理解就够了，毕竟不可靠），属于是把程序执行顺序直接丢了。看上去事件花销和1的同步一样，那为什么要引入这个概念呢？看4。</li><li>可以看到，其实3还是比同步的情况下省了很多时间，这个waiting可能是方法里人工delay，也可能是在等待磁盘坑长的I/O操作返回结果，所以如果异步，灰色的部分就省下来了。由此也可知，异步唯一存在的阻塞情况，是无方法可执行的时候（ABC都在灰色段等着I/O给结果）。</li></ol><p>以上用于理解概念是够了，但是实际应用会多很多（比如异步有很多方法可以实现，每种方法可控性等不同）。</p><p>搞懂最基本的同步异步之后，开始结合c#的用法，看下怎么用。</p><h1 id="二-Async-and-Await"><a href="#二-Async-and-Await" class="headerlink" title="二.Async and Await"></a>二.Async and Await</h1><p>  一篇不错的文章，虽然是2012年（也就是Async/Await语法糖出来的时候）的还是英文，但是把两者分析的非常透彻。刚好作为实际应用的补充。</p><h3 id="先来介绍一下这两个C-关键字"><a href="#先来介绍一下这两个C-关键字" class="headerlink" title="先来介绍一下这两个C#关键字"></a>先来介绍一下这两个C#关键字</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoSomethingAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// In the Real World, we would actually do something...</span></span><br><span class="line">  <span class="comment">// For this example, we&#x27;re just going to (asynchronously) wait 100ms.</span></span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <font color='red'>async </font>只有2个作用。一是是允许await这个关键字的使用，二是改变了方法结果的处理方式。async在执行开始时，是和同步运行一样的。也就是说在遇到await之前，它是同步的。</p><p>  <font color='red'>await </font>是异步操作的启动器。它会持续监视一个<font color='red'>异步操作 </font>（asynchronous operation）的执行，<br>  如果这个异步操作已经完成了，那他就会继续跑后续代码；<br>  如果这个异步操作未完成，就开始真正的<font color='red'>异步</font>：调用者会将这个async任务暂时挂起，直到await监视的异步操作处理完后，才继续执行后续代码。注意了，这个处理完后的执行，是会根据遇到await之前捕捉下来的<font color='red'>上下文（Context） </font>环境来继续运行。u1s1，这听着很像unity的协程好吧。<br>  通过上面知道了，async方法体里遇到个await、且await后面跟了个需要时间去处理的方法（上面叫异步操作，举个例子比如I/O操作吧），这个时候这个async方法会被阻塞住，但是整个线程并不会被阻塞住，而是在做其他的异步方法了，直到其他方法也卡住。</p><h3 id="Asynchronous-Operation"><a href="#Asynchronous-Operation" class="headerlink" title="Asynchronous Operation"></a>Asynchronous Operation</h3><p>  上面提到的异步操作。从上可知，你只需要提供<font color='red'>异步操作</font>就可以实现一个异步。你可以直接用微软提供支持的Task或者<code>Task&lt;T&gt;</code>，或者将各种方法转换成一个异步操作，或者是Task.Yield会返回不是Tasks的异步操作。<br>  关于异步操作的一个要点是:异步操作，指的不是async关键词修饰的就是异步操作，而是他是一个可以异步操作的类型。换句话说，你可以await一个类型为Task的async method，这是因为方法返回Task，而不是因为它是async的。所以你也可以await一个返回Task的非async方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">NewStuffAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use await and have fun with the new stuff.</span></span><br><span class="line">  <span class="keyword">await</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">MyOldTaskParallelLibraryCode</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 最开始就说的，因为这个方法没有async关键词修饰，所里方法体里不能用await关键词</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ComposeAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// We can await Tasks, regardless of where they come from.</span></span><br><span class="line">  <span class="keyword">await</span> NewStuffAsync();</span><br><span class="line">  <span class="keyword">await</span> MyOldTaskParallelLibraryCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Return-Types"><a href="#Return-Types" class="headerlink" title="Return Types"></a>Return Types</h3><p>  Async方法可以返回<code>Task&lt;T&gt;</code>、Task以及void，但是在大部分情况我们都会选择前两个而不是void，因为<code>Task&lt;T&gt;</code>、Task是可以等待的，而void不行。<br>  那什么时候用void呢？原文是这么说的：</p><blockquote><p>You have to return void when you have async event handlers.</p></blockquote><h3 id="Returning-Values"><a href="#Returning-Values" class="headerlink" title="Returning Values"></a>Returning Values</h3><p>  这个和上面不同，这个是返回值。Task和void一样都没有返回值，但是<code>Task&lt;T&gt;</code>有T类型的返回值。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>  上下文。上面提到过，当await的异步操作结束后，将会根据遇到await之前捕捉下来的上下文环境继续执行代码。上下文是什么？简单来说：</p><ul><li>如果你在一个UI线程上，那么就是个UI Context</li><li>如果你在一个ASP.NET请求上，那么就是个ASP.NET request context</li><li>否则，通常会是一个线程池环境（a thread pool context）。<br>好嘛，听君一席话。那么复杂点说呢？</li><li>如果<font color='red'>SynchronizationContext.Current</font>不是null的，那么SynchronizationContext.Current就是它的上下文（UI、ASP.NET）</li><li>其他情况，就是当前的<font color='red'>TaskScheduler</font><br>这两个名词暂时先不展开了。<br>下面看一个示例。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinForms 例子 (当然wpf也一样).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当这个异步方法DownloadFileAsync在await的时候，UI线程并不会被阻塞。</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASP.NET 例子</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">MyButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await之后，ASP.NET线程并不会因此被阻塞</span></span><br><span class="line">  <span class="comment">// 这使得这个线程仍然可以接受其他的request</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(...);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复ASP.NET Context，然后就可以连接到当前请求了</span></span><br><span class="line">  <span class="comment">// 也许结束那一瞬间，我们在其他的线程上，但是也能拥有同样的ASP.NET Context</span></span><br><span class="line">  Response.Write(<span class="string">&quot;File downloaded!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Avoiding-Context"><a href="#Avoiding-Context" class="headerlink" title="Avoiding Context"></a>Avoiding Context</h3><p>  上下文有个大概的概念了，关键词还是await。那么，有的时候不需要去抓取整个main的上下文，比如下面的例子，一个Task中并不需要UI的上下文。<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadFileAsync</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这一个调用http api的下载任务</span></span><br><span class="line">  <span class="keyword">var</span> fileContents = <span class="keyword">await</span> DownloadFileContentsAsync(fileName).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为上面设置了ConfigureAwait(false),我们不在原来的上下文中</span></span><br><span class="line">  <span class="comment">// 那我们在什么上下文中？在线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将文件数据写入磁盘</span></span><br><span class="line">  <span class="keyword">await</span> WriteToDiskAsync(fileName,fileContents).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WinForms、Wpf例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await后，UI线程并没有被这个下载任务所阻塞</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上述例子还需要注意的是，每个层级的async方法都有自己的上下文。<code>DownloadFileButton_Click</code>方法中是由UI上下文启动的，随后进入<code>DownloadFileAsync</code>也是由UI上下文启动的，但是随着<code>ConfigureAwait(false)</code>的设置，又会跳出UI上下文，转到线程池上下文中继续运行。最后，当<code>DownloadFileAsync</code>方法执行结束回到<code>DownloadFileButton_Click</code>方法后，又会回到UI上下文继续。<br>  所以有一个优化方法就是，设置不需要UI上下文的异步方法<code>ConfigureAwait(false)</code>。</p><h3 id="Async-Composition"><a href="#Async-Composition" class="headerlink" title="Async Composition"></a>Async Composition</h3>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoOperationsConcurrentlyAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Task[] tasks = <span class="keyword">new</span> Task[<span class="number">3</span>];</span><br><span class="line">  tasks[<span class="number">0</span>] = DoOperation0Async();</span><br><span class="line">  tasks[<span class="number">1</span>] = DoOperation1Async();</span><br><span class="line">  tasks[<span class="number">2</span>] = DoOperation2Async();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个时间点，所有任务都在并行执行</span></span><br><span class="line">  <span class="comment">// 我们对所有任务都进行等待</span></span><br><span class="line">  <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetFirstToRespondAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Call two web services; take the first response.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt;[] tasks = <span class="keyword">new</span>[] &#123; WebService1Async(), WebService2Async() &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Await for the first one to respond.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt; firstTask = <span class="keyword">await</span> Task.WhenAny(tasks);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the result.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> firstTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-非常重要，暂停一下"><a href="#三-非常重要，暂停一下" class="headerlink" title="三.非常重要，暂停一下"></a>三.非常重要，暂停一下</h1><p>  从上可知，异步和同步大概是什么了。根据上两篇去理解，异步就是为了去解决I/O阻塞画面线程问题而推出的技术，而在C#里就是<code>async await Task</code>这三个关键词组合去实现的。执行起来是你做A遇到了子任务B，结果子任务B里有I/O卡壳了，你就立刻回头去做A剩下的直到B结束了会做B这样，看上去就是主线程自己的事。那么实际上呢？直接实践一下：<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Chinese Output</span></span><br><span class="line">Console.OutputEncoding = Encoding.GetEncoding(<span class="number">936</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;头部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">CallerWithAsync(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;尾部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Test Wait</span></span><br><span class="line">Console.Read();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallerWithAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;异步调用头部执行，当前线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> result = <span class="keyword">await</span> SayHiAsync(name);</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">SayHiAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点1，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点2，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">$&quot;Hello,<span class="subst">&#123;name&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211109113849.png"></p><p>  可以看到“测试断点2，此刻线程为: 4”，并不是主线程1，所以说C#的异步实践并不是和第一篇里说的一样，并不是在一个线程上解决的！！！当然还有很多其他方法，这个就不拓展了，只讨论最常用最简洁的实践方案。<br>  原因是什么呢？最直接地说，是因为第一篇的文章是基于单线程的最简单情况去理解同步与异步的，而C#实现不是，毕竟考虑到性能后的实现是很复杂的。而且，你要把一个任务挂起等执行完毕，那总得有线程去处理它对吧。<br>  为了明白这是什么意思，需要理解一下多线程与异步之间的关系。<br>  异步同步，其实和多线程还是单线程并不是一个维度的概念。我的理解是异步是一种程序运行的优化机制、是运行过程最终目的，而多线程还是单线程是一种可供你选择的条件，你可以单线程异步也可以多线程异步。</p><p>  传统异步（第一篇里诉说的）：遇到await时，将目前线程挂起，去做其他的事，不停调度。<br>  实际上基于多线程的异步编程（C#异步实现方法之一）：<font color='red'>遇到<code>Task.Run()</code>的多开线程指令或者真正需要异步挂起某任务时</font>，会从线程池取一个新线程（如果不够用就开新的），然后把这个线程拿来处理挂起的任务，主线程则是返回到方法体外去执行剩下的代码。<font color='red'>注意了，新开线程（也就是真正开始异步）的情况，并不是遇到await那一刻，就像图中的log那样，直到断点1都还是同步的，但是Task.Delay就会开始真正的异步。</font><br>  总结：C#中的异步可以简单的用async 和 await 配合来实现，使用异步的函数，在没有调用await前，还是按顺序单线程执行的，当运行到await的时候，系统才会异步调用其他的方法来运行，如果没有await, 函数就是同步按顺序的运行。所以，await才是异步中的关键部分，在await 范围内的代码，是多线程方式运行的（当然没有Task就不会取线程），可以将需要异步处理的代码放在await中运行，或者简单的用一个Task.Delay来延时，以达到异步切换代码运行的效果。await 后面接的是一个Task, 每一个Task在运行时，由系统的Task池来分配，以实现异步的功能。<br>这里再来说说用aysnc和直接用thread的区别，其实简单来讲，就是效率的问题，async用的线程池，在await中运行的代码是由线程池分配的线程，根据系统的任务，自动分配和释放，而用 new thread的方法，通常是需要手动控制的。很显然，在处理一些短时间，且对运行的时间性和稳定性不是特别严格的问题时，用async会很有优势，但是对于一些在后台需要长时间稳定运行的程序，用thread会更好，可以保证它在运行的过程中，不过有别的代码来插队。</p><h1 id="四-I-O操作时，没有线程在执行"><a href="#四-I-O操作时，没有线程在执行" class="headerlink" title="四.I/O操作时，没有线程在执行"></a>四.I/O操作时，没有线程在执行</h1><p>  <a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">There is no thread</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">微软Docs：异步编程</a> ，两篇文章大意是，当遇到await进行I/O操作时，因为现在的磁盘很牛逼，支持Direct Memory Access (DMA)操作，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。所以程序遇到I/O异步时，只是从线程池里拿了个线程，进行一次CPU操作命令之后这个线程就没事了，他不负责执行I/O、也不实时监视I/O的运行情况、更不会被阻塞。它理论来说直接送回线程池了，然后可以去处理其他操作，此时硬件自己和内存交换数据。I/O完成之后，硬件会触发一个中断来通知操作完成。</p><p>  以下来自微软官方文档：</p><blockquote><p>调用系统 API 后，请求位于内核空间，一路来到操作系统的网络子系统（例如 Linux 内核中的 <code>/net</code>）。 此处操作系统将对网络请求进行异步 处理。 所用操作系统不同，细节可能有所不同（可能会将设备驱动程序调用安排为发送回运行时的信号，或者会执行设备驱动程序调用然后 有一个信号发送回来），但最终都会通知运行时网络请求正在进行中。 此时，设备驱动程序工作处于已计划、正在进行或是已完成（请求已“通过网络”发出），但由于这些均为异步进行，设备驱动程序可立即着手处理其他事项！</p><p>例如，在 Windows 中操作系统线程调用网络设备驱动程序并要求它通过表示操作的中断请求数据包 (IRP) 执行网络操作。 设备驱动程序接收 IRP，调用网络，将 IRP 标记为“待定”，并返回到操作系统。 由于现在操作系统线程了解到 IRP 为“待定”，因此无需再为此作业进行进一步操作，将其“返回”，这样它就可用于完成其他工作。</p><p>请求完成且数据通过设备驱动程序返回后，会经由中断通知 CPU 新接收到的数据。 处理中断的方式因操作系统不同而有所不同，但最终都会通过操作系统将数据传递到系统互操作调用（例如，Linux 中的中断处理程序将安排 IRQ 的下半部分通过操作系统异步向上传递数据）。 这也是异步发生的！ 在下一个可用线程能执行异步方法且“解包”已完成任务的结果前，结果会排入队列。</p></blockquote><h1 id="五-思考"><a href="#五-思考" class="headerlink" title="五.思考"></a>五.思考</h1><p>  看了十几篇文章之后，对异步稍微是理解进了一小步。在此留下我的最简短理解：<br><font color='red'>  异步，就是为了让单个线程不会因为某个长时间I/O操作而卡死自己，从而达到压榨线程剩余价值的目的。（特别是UI主线程对于客户端来说的剩余价值特别大）</font></p><p>  关于应用上，整理了一下工作会用到的：</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>  当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。<br>  而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。工作中用到过的：</p><p> <code>大数据量Collection.AsParallel.ForEach(Task.Run(你的任务))</code>　　</p><h3 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h3><table><thead><tr><th>使用以下方式…</th><th>而不是…</th><th>若要执行此操作…</th></tr></thead><tbody><tr><td>await</td><td>Task.Wait 或 Task.Result</td><td>检索后台任务的结果</td></tr><tr><td>await Task.WhenAny</td><td>Task.WaitAny</td><td>等待任何任务完成</td></tr><tr><td>await Task.WhenAll</td><td>Task.WaitAll</td><td>等待所有任务完成</td></tr><tr><td>await Task.Delay</td><td>Thread.Sleep</td><td>等待一段时间</td></tr></tbody></table><p>补充：</p><p>再深入的话，可能要自己尝试实现一下线程池+异步I/O。以后再补吧。</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</a></p><p>ref:</p><p><a href="https://blog.csdn.net/qq_36936155/article/details/78991050">https://blog.csdn.net/qq_36936155/article/details/78991050</a></p><p><a href="https://blog.stephencleary.com/2012/02/async-and-await.html">https://blog.stephencleary.com/2012/02/async-and-await.html</a></p><p><a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">https://blog.stephencleary.com/2013/11/there-is-no-thread.html</a></p><p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">https://docs.microsoft.com/zh-cn/dotnet/csharp/async</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth">https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth</a></p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - Mono篇</title>
      <link href="/Tech/CSharp/Essence/mono/"/>
      <url>/Tech/CSharp/Essence/mono/</url>
      
        <content type="html"><![CDATA[<h1 id="IL是什么？"><a href="#IL是什么？" class="headerlink" title="IL是什么？"></a>IL是什么？</h1><p>IL的全称是 Intermediate Language，是一种中间语言。它是一种属于通用语言架构和.NET框架的低阶（lowest-level）的人类可读的编程语言。目标为.NET框架的语言被编译成IL代码，然后汇编成字节码。</p><p>具体过程是：C#或者VB这样遵循CLI规范的高级语言，被先被各自的编译器编译成中间语言IL。等到需要真正执行的时候，这些IL会被加载到运行时库，也就是CLR中，由CLR动态编译（JIT）成汇编代码然后在执行。</p><h1 id="JIT是什么？"><a href="#JIT是什么？" class="headerlink" title="JIT是什么？"></a>JIT是什么？</h1><p>just-in-time compiler，即时编译器。它将IL翻译成汇编语言，它自身会对运行环境做出许多假定，从而进行自己的优化方案。</p><p>比如第一次调用一个方法时，JIT会把遇到的IL代码进行验证+编译，最后放进内存中。方法仅在首次调用时才会有一些性能损失，以后对该方法的所有调用都以本机代码的形式全速运行。</p><h1 id="Mono是什么？"><a href="#Mono是什么？" class="headerlink" title="Mono是什么？"></a>Mono是什么？</h1><p>是支持.net跨平台的一种方式。因为.net本身不支持跨平台只能运行在Windows上，所以需要一个<strong>跨平台的第三方.net库，这就是Mono</strong>。</p><p>mono作为一个中间层将IL代码的处理分出好多个分支，分别对应不同的平台。Mono其实和.net framework 是同一个东西，只不过Mono支持更多的平台，但.net的运行效率更高。<br>Unity打包时会将mono一同打包进来，同时Unity将脚本编译为IL代码打包，这样只要是Mono支持的平台，都可以在Mono中编译成平台本地代码。</p><h1 id="IL2CPP是什么？"><a href="#IL2CPP是什么？" class="headerlink" title="IL2CPP是什么？"></a>IL2CPP是什么？</h1><p>把IL中间语言转换成CPP文件。</p><p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p><p>但是GC还是C#方式来处理。</p><h1 id="为什么有了Mono还需要IL2CPP？"><a href="#为什么有了Mono还需要IL2CPP？" class="headerlink" title="为什么有了Mono还需要IL2CPP？"></a>为什么有了Mono还需要IL2CPP？</h1><p>主要是2点。</p><p>1.Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成。Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，非常耗时耗力。</p><p>2.根据官方的实验数据，Mono换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p><h1 id="工作中怎么涉及到Mono呢"><a href="#工作中怎么涉及到Mono呢" class="headerlink" title="工作中怎么涉及到Mono呢"></a>工作中怎么涉及到Mono呢</h1><p>可以在Unity工程打包得选项中，选择是用Mono还是IL2CPP方式输出。</p><p>IL2CPP能把IL中间码转为C++代码，然后交给各平台的C++编译器处理，有自己的代码裁剪规则。是一种目前效率更高的选择。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 反射篇</title>
      <link href="/Tech/CSharp/Essence/reflection/"/>
      <url>/Tech/CSharp/Essence/reflection/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射提供了封装程序集、模块和类型的对象（Type 类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性。如果代码中使用了属性，可以利用反射对它们进行访问。</p><p>Assembly类可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并创建该类型的实例。</p><p>Type类可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性等等，通过Type类可以得到这些要素的信息，并且调用之。</p><p>MethodInfo包含方法的信息，通过这个类可以得到方法的名称、参数、返回值等，并且可以调用之。</p><p>反射：反射提供了封装程序集，模块和类型对象，可以用反射动态地创建类型的实例，将类型绑定到现有对象，或者从现有对象类型里获取类型，然后调用类型的方法或访问字段和属性。</p><p>序列化：将对象转换为另一种媒介传输的格式过程。如，序列化一个对象，用Http通过internet在客户端和服务器之间传递该对象，在另一端用反序列化从该流中重新得到对象。 </p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 委托与事件篇</title>
      <link href="/Tech/CSharp/Essence/delegate/"/>
      <url>/Tech/CSharp/Essence/delegate/</url>
      
        <content type="html"><![CDATA[<h1 id="委托和事件的区别是什么？"><a href="#委托和事件的区别是什么？" class="headerlink" title="委托和事件的区别是什么？"></a>委托和事件的区别是什么？</h1><p>委托本质是一个继承自System.MulticastDelegate的类；而事件是一个类型成员，是对委托的封装，就和属性是对字段的封装一样。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>通过event关键词来定义。是对委托的封装。</p><h2 id="为什么封装？"><a href="#为什么封装？" class="headerlink" title="为什么封装？"></a>为什么封装？</h2><p>为了让委托链的意义，从一个方法执行队列变成一个可订阅、可通知（触发）的中介。</p><h2 id="怎么封装的？"><a href="#怎么封装的？" class="headerlink" title="怎么封装的？"></a>怎么封装的？</h2><p>随便在类内定义一个public事件，再查看IL代码多帮我们做了什么：</p><p>1.生成一个私有的委托字段（没错还是委托链实现的）</p><p>2.生成add和remove方法，内部处理是对生成的委托字段进行Delegate.Combine、Delegate.Remove。</p><h2 id="怎么设计？"><a href="#怎么设计？" class="headerlink" title="怎么设计？"></a>怎么设计？</h2><p>举个例子的话，WPF的画面交互事件用的EventHandler其实就是一个sender加一个args参数，自定义可以如下的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params">EventSender sender,MyEventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托本质是一个继承自System.MulticastDelegate的类，所以像类一样使用即可。</p><h2 id="新建一个委托发生了什么？"><a href="#新建一个委托发生了什么？" class="headerlink" title="新建一个委托发生了什么？"></a>新建一个委托发生了什么？</h2><p>当你写delegate的时候，编译器就视为你继承了System.MulticastDelegate类，且生成以下几个字段：</p><p>1.构造器</p><p><strong>它获取2个参数：一个是对象引用，另一个是引用了回调方法的整数</strong>。类似于<code>public MyDelegate(Object @object, IntPtr method)</code>。但是我们new的时候，不需要这么复杂的参数，直接<code>new MyDelegate(MyMethod)</code>就可以了，编译器会分析。</p><p>最后这2个参数会作为MulticastDelegate的2个重要字段！</p><p>2.Invoke方法</p><p>用于调用。<code>myDelegate(1);</code>其实编译器内部就会变成<code>myDelegate.Invoke(1);</code></p><p>3.BeginInvoke、EndInvoke方法</p><p>用于异步回调。</p><h2 id="MulticastDelegate类是什么？"><a href="#MulticastDelegate类是什么？" class="headerlink" title="MulticastDelegate类是什么？"></a>MulticastDelegate类是什么？</h2><p>又称多播委托，是所有委托的父类。</p><p>它的内部有3个重要字段和1个内部机制来实现委托链。</p><h3 id="3个重要字段"><a href="#3个重要字段" class="headerlink" title="3个重要字段"></a>3个重要字段</h3><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_target</td><td>System.Object</td><td>这个字段引用的是回调方法要操作的对象。当委托对象包装静态方法时，这个字段返回null；当委托对象包装实例方法时，这个字段引用回调方法要操作的对象。在委托构造器中将对象引用作为参数获取、赋值给_target。</td></tr><tr><td>_methodPtr</td><td>System.IntPtr</td><td>一个内部的整数值，CLR用它标识要回调的方法。在委托构造器中将回调方法IntPtr作为参数获取、赋值给_methodPtr。</td></tr><tr><td>_invocationList</td><td>System.Object</td><td>只有单个委托时为null。构造委托链时它引用一个委托数组。</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211210173655.png"></p><h3 id="1个机制"><a href="#1个机制" class="headerlink" title="1个机制"></a>1个机制</h3><p>从外部新建一个委托的整个生命流程来理解：</p><p>1.申明一个委托实例fbChain，为null。</p><p>2.对其进行 += 操作（Delegate.Combine语法糖），Combine方法内部发现fbChain是null，所以直接返回一个_invocationList为null的委托。</p><p>3.对其再进行 += 操作，Combine方法内部发现fbChain内部已经包含了一个委托,就会构造一个新的委托对象，这个新委托对象的_invocationList字段引用了一个委托对象数组，里面按顺序包含着之前的所有委托。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211213095622.png"></p><p>4.对委托实例fbChain进行调用，实际就是对整个委托链传入参数，依次遍历进行Invoke。</p><p>5.对委托实例fbChain进行 -= 操作（Delegate.Remove语法糖），Remove方法内部倒序循环遍历_invocationList数组，匹配_target和_methodPtr字段相同的元素进行删除，只删除一个元素。</p><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p><strong>Action和Func</strong></p><p>微软定义好的泛型委托就是Action和Func，Action有16个Func有17个。为啥Action少一个？看下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span>;<span class="comment">// 这个不是泛型，所以不算，少在这了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">TResult</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">TResult</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>, <span class="title">TResult</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 异步篇</title>
      <link href="/Tech/CSharp/Essence/async/"/>
      <url>/Tech/CSharp/Essence/async/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h1><p>异步是一种任务执行的机制或者说方式，它的目的在于解决<strong>I/O等待会阻塞线程</strong>这个问题（最常见的就是GUI线程阻塞造成画面卡顿），它的实现依托于硬件底层的<strong>IRP</strong>(I/O Request Packet)，它的本质其实是回调。</p><p>我可以使用比如 ReadAsync + Task.ContinueWith 的组合，来实现一个<a href="https://blog.51cto.com/huangxincheng/2525748">异步实践</a>；</p><p>而更简单的方式是通过微软后续推出 .net4.5 的 <strong>async-await</strong> 这套关键词来实践。</p><h1 id="异步函数-async-await"><a href="#异步函数-async-await" class="headerlink" title="异步函数 async-await"></a>异步函数 async-await</h1><p>异步函数，实际通过 核心类TaskAwaiter + 状态机 实现。</p><h2 id="核心类-TaskAwaiter"><a href="#核心类-TaskAwaiter" class="headerlink" title="核心类 TaskAwaiter"></a>核心类 TaskAwaiter</h2><p>这个类比较简单，每个异步Task都有。我把它看作黑盒不细究，只看对外接口：</p><ul><li>  IsCompleted 属性：表示Task是否完成</li><li>  GetResult() 方法：结束异步任务完成的等待</li><li>  UnsafeOnCompleted(Action) 方法：设置延续任务</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>await必须在有async标记的方法内使用。如果async方法内部没有await，那它就和同步方法一样执行。</p><p>如果执行中遇到了await，就把需要await执行的Task交给线程池来执行，而原来那个线程则退出async方法的方法体，去执行外部的后续代码，直到await的Task执行完毕返回结果后，这个线程会回到方法体await处继续执行。整体流程看上去很像ContinueWith。</p><p>接下来研究编译器做的事。</p><h2 id="外部调用层"><a href="#外部调用层" class="headerlink" title="外部调用层"></a>外部调用层</h2><p>1.首先编译器看到方法有async标记，就会为其生成一个实现了IAsyncStateMachine接口的类，这个接口意味着它是一个<strong>异步状态机</strong>。</p><p>2.async方法自身则会被标记<strong>AsyncStateMachine特性</strong>，意味着这是个异步方法。</p><p>3.async方法内部则是new了一个异步状态机实例，先初始化，然后调用它的Start方法来启动状态机。Start方法内部主要是调用了状态机的<strong>MoveNext方法</strong>。</p><p>4.最后将指示方法运行状态的<code>builder.Task</code>对象 return 。</p><h2 id="内部状态机层"><a href="#内部状态机层" class="headerlink" title="内部状态机层"></a>内部状态机层</h2><p>每个异步状态机都有2个核心字段和一个核心方法：</p><ul><li>  builder：负责异步相关的操作，是方法实现异步执行的核心</li><li>  state：状态机的当前状态，<strong>初始化时赋值为 -1</strong>。</li><li>  MoveNext方法：状态机切换状态、执行任务、设置延续任务的方法</li></ul><p>我们直接讲MoveNext方法。</p><p><strong>第一次MoveNext时，我把它分成3块流程：</strong></p><p>1.第一次进入状态机时<code>state!=0</code>，await之前的代码被包裹到了MoveNext方法体内，照常顺序执行。</p><p>2.await那一行的代码，变成了获取任务的awaiter <code>Task.GetAwaiter()</code>。然后对任务的awaiter进行判断：</p><p>​      - 如果awaiter.IsCompleted 为true，意味着任务已经执行完了，执行第3步。</p><p>​      - 如果awaiter.IsCompleted 为false，意味着任务还未执行完（一般初始化完第一次进来，都是false）那就会做以下操作：</p><p>将<strong>state赋值为0</strong>，将awaiter存到自身字段内供后续使用，然后<strong>设置延续任务</strong><code>builder.AwaitUnsafeOnCompleted</code>，设置完之后会<strong>return掉而不执行第3步</strong>。</p><p>延续任务内部<a href="https://www.cnblogs.com/xiaoxiaotank/p/14303803.html">怎么设置的</a>比较复杂，我觉得不需要理解深入，理解为调了awaiter的接口就行了，反正最终效果是<strong>await的任务完成后再次调用MoveNext转动状态机</strong>。</p><p>3.结束awaiter <code>TaskAwaiter.GetResult() </code>。执行原先await那一行之后的后续代码。执行完成后，将state赋值为-2，并为builder标记任务成功<code>AsyncTaskMethodBuilder.SetResult()</code>。</p><p><strong>如果不是第一次MoveNext，就会省去1、2步：</strong></p><p>如果await的任务完成，就会触发延续任务：再次调用MoveNext。但是和第一次进不一样，此时因为<code>state==0</code>会跳过第1步第2步，将state设置为-1之后直接跳入第3步。</p><h2 id="多层嵌套async-await"><a href="#多层嵌套async-await" class="headerlink" title="多层嵌套async-await"></a>多层嵌套async-await</h2><p>其实实现也只是多层嵌套异步状态机而已，是一样的。</p><h2 id="一个async中多个await"><a href="#一个async中多个await" class="headerlink" title="一个async中多个await"></a>一个async中多个await</h2><p>在同一个异步状态机中，生成更多的awaiter、更多的state。</p><p>state的-2（完成）、-1（初始）是定好的，所以只会从0开始生成，而有几个await就有几个awaiter、state。</p><p>一旦state多起来，内部就不再 if-else 了，而是 switch-case + goto 。</p><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><p>接触的主要是，</p><p>SynchronizationContext 同步上下文：<strong>捕获</strong>提供在各种同步模型中传播同步上下文的基本功能。它有一个<code>Post()</code>虚方法，Winform、WPF等等会重写它，让它被调用时能产生不同的过程，但目的都是一个：实现使用GUI线程执行Post过去的委托。</p><p>ExecutionContext 执行上下文：<strong>流动</strong>。在执行委托时恢复另一个线程的状态环境。</p><h2 id="WPF中使用-async-await"><a href="#WPF中使用-async-await" class="headerlink" title="WPF中使用 async await"></a>WPF中使用 async await</h2><p>上面我们都是通过控制台举的例子，这是没有任何<code>SynchronizationContext</code>的，但是WPF（Winform同理）就不同了，在UI线程中，它拥有属于自己的<code>DispatcherSynchronizationContext</code>。</p><p>这个工作中有体会，就是<code>View.xmal.cs</code>文件内写诸如点击事件的async-await，延续任务会默认借调GUI线程而非await内分配的任务池线程。。</p><p>而我可以改成使用<code>SynchronizationContext.Post()</code>来实现类似的效果。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>用SynchronizationContext可以实现确定性使用GUI线程来执行委托，我的理解只到此。</p><p>// TODO 光看不行，还是得自己实现一套简单的Task封装才行，以后参考UniTask。</p><p>参考：</p><p><a href="https://www.cnblogs.com/xiaoxiaotank/p/14303803.html">https://www.cnblogs.com/xiaoxiaotank/p/14303803.html</a></p><p><a href="https://www.cnblogs.com/xiaoxiaotank/p/13666913.html">https://www.cnblogs.com/xiaoxiaotank/p/13666913.html</a></p><p><a href="https://codingcodingk.top/2022/01/14/Tech/CSharp/CLR-Via-CSharp/cp7/">https://codingcodingk.top/2022/01/14/Tech/CSharp/CLR-Via-CSharp/cp7/</a></p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 常用数据结构篇</title>
      <link href="/Tech/CSharp/Essence/arrary_list_dic/"/>
      <url>/Tech/CSharp/Essence/arrary_list_dic/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>最基本的数组类型。</p><h2 id="真实类型"><a href="#真实类型" class="headerlink" title="真实类型"></a>真实类型</h2><p>所有数组类型都隐式从<strong>System.Array抽象类</strong>派生，System.Array又从Object派生，所以数组都是<strong>引用类型</strong>。Array实现了IEnumerable、ICollection、IList接口。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>在内存中是连续存储的，所以它的索引速度非常快。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在new的时候，就必须指定它的Length大小。</p><p>数组单个元素的类型：</p><p>如果是值类型比如Int32，就会在托管堆上分配100个未装箱Int32所需的内存块，并给每个Int32实例都附上default值0；<br>如果是引用类型比如Control，就会在托管堆上分配50个Control引用的内存块，并给每个引用都附上null。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>无法动态扩容，只能手动调用接口<code>Array.Resize (ref T[] array, int newSize)</code>。</p><p>内部创建新数组，使用<code>Array.Copy</code>将原数组拷贝到新数组中，再修改传入指针指向新数组。如果新Length还不如原数组Length大，会采用新Length，多的直接截断不要了。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>接口<code>Array.Find (T[] array, Predicate&lt;T&gt; match)</code>。传进去的match是一个签名为“参数为T返回值为bool”的委托，也就是一个比较器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; array.Length; ++index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (match(array[index])) <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话很麻烦，还不如自己遍历。</p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>在数组的基础上加入了动态扩容的概念，因此插入数据更方便了。</p><h2 id="真实类型-1"><a href="#真实类型-1" class="headerlink" title="真实类型"></a>真实类型</h2><p>实现了接口 IList、ICollection、IEnumerable、ICloneable。</p><p>而<strong>内部的数据其实还是用一个object[ ]来装</strong>，字段名是items。没错可以理解ArrayList为对Array的包装。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>虽然比数组多了很多快捷操作接口，但是内部用object[ ]，这导致会频繁发生拆装箱、且类型非常不安全导致你可以塞各种类型到一个ArrayList里。</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>在<code>new ArrayList()</code>中可以指定容量大小，也可以不指定。</p><p>如果不指定，那就将内部items数组设置为<code>ArrayList.emptyArray</code>，一个定义好的定数，实际就是 <code>new object[0]</code>。</p><p>如果指定，那就是<code>new object[capacity]</code>。</p><h2 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h2><p>引入动态扩容，调用接口<code>ArrayList.Add (object val)</code>即可。</p><p>先说结论，如果容量为0则设置为4，否则一旦触发扩容就翻倍，也就是<strong>二倍扩容</strong>。扩容方式就是新建数组替换items。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnsureCapacity</span>(<span class="params"><span class="built_in">int</span> min</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._items.Length &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">int</span> num = <span class="keyword">this</span>._items.Length == <span class="number">0</span> ? <span class="number">4</span> : <span class="keyword">this</span>._items.Length * <span class="number">2</span>; <span class="comment">// num起始值为4，后续只会2倍2倍扩容，因此永远是2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">uint</span>) num &gt; <span class="number">2146435071U</span>)</span><br><span class="line">        num = <span class="number">2146435071</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; min)</span><br><span class="line">        num = min;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.Capacity = num; <span class="comment">// 扩容代码写在 属性Capacity 的set里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Capacity&#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="comment">// 只看核心部分，防错的if判断都被我删了</span></span><br><span class="line">        <span class="built_in">object</span>[] objArray = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="keyword">value</span>];</span><br><span class="line">        Array.Copy((Array) <span class="keyword">this</span>._items, <span class="number">0</span>, (Array) objArray, <span class="number">0</span>, <span class="keyword">this</span>._size);</span><br><span class="line">        <span class="keyword">this</span>._items = objArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>接口<code>ArrayList.Insert (int index, object val)</code></p><p>也就是判断一下 size+1 是否触发动态扩容，然后把index之后的数组值用<code>Array.Copy</code>拷贝到index+1起始位置，然后更新数组index的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.Copy((Array) <span class="keyword">this</span>._items, index, (Array) <span class="keyword">this</span>._items, index + <span class="number">1</span>, <span class="keyword">this</span>._size - index);</span><br><span class="line"><span class="keyword">this</span>._items[index] = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>接口<code>ArrayList.IndexOf (object value)</code></p><p>全遍历。内部for循环遍历，通过<code>obj.Equals(value)</code>比对罢了。</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>接口<code>ArrayList.Remove (object obj)</code></p><p>先用<code>ArrayList.IndexOf</code>查找到index，然后调用<code>ArrayList.RemoveAt</code>。</p><p>RemoveAt内部用了<code>Array.Copy</code>，把 index+1 之后的数组值拷贝到index起始位置，那么原来位于index的值就没了，且数组最后一位会是一个废数据，给它赋null。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.Copy((Array) <span class="keyword">this</span>._items, index + <span class="number">1</span>, (Array) <span class="keyword">this</span>._items, index, <span class="keyword">this</span>._size - index);</span><br><span class="line"><span class="keyword">this</span>._items[<span class="keyword">this</span>._size] = (<span class="built_in">object</span>) <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>在ArrayList的基础上，加入了泛型的概念。类型是<code>List&lt;T&gt;</code>，又叫泛型List。</p><h2 id="真实类型-2"><a href="#真实类型-2" class="headerlink" title="真实类型"></a>真实类型</h2><p>实现接口：IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>。</p><p><strong>内部维持的是一个泛型数组</strong>，<code>T[] _items;</code>。</p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>使用泛型，完美解决了ArrayList的拆装箱问题。</p><h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><p>和ArrayList一样，可以指定可以不指定，不指定就给item赋值<code>new T[0]</code>。</p><h2 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h2><p>和ArrayList一摸一样的<strong>初始为4，后续二倍扩容</strong>。</p><h2 id="插入、查找、移除"><a href="#插入、查找、移除" class="headerlink" title="插入、查找、移除"></a>插入、查找、移除</h2><p>没啥好看的，和前面一样，没有优化。</p><p>接口<code>public T Find (Predicate&lt;T&gt; match)</code>就是传入bool比较器，和Array的一样。接口<code>IndexOf</code>也是直接调用了Array自己的IndexOf，找不到就返回-1。</p><h2 id="linq"><a href="#linq" class="headerlink" title="linq"></a>linq</h2><p>linq拓展方法接口<code>FirstOrDefault</code>内部利用迭代器foreach遍历+bool比较器。</p><p>linq拓展方法接口<code>Where</code>内部利用迭代器，返回一个新的List指针（浅拷贝）。</p><h1 id="散列表、哈希"><a href="#散列表、哈希" class="headerlink" title="散列表、哈希"></a>散列表、哈希</h1><p>在看哈希表、字典这两个类型前，必须掌握的基础数据结构。</p><h2 id="在看之前"><a href="#在看之前" class="headerlink" title="在看之前"></a>在看之前</h2><p>在.Net  模仿java 的过程中   抛弃了 HashMap ，所以以后再去面试.Net的时候当别人问你HashTable 和HashMap 的区别的时候，请告诉他，C#.Net 中  没有HashMap。同时C#中也没有Java中的TreeMap和TreeSet（即底层是由红黑树实现的数据结构）。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数是<strong>单向映射</strong>，因为一个Key只可以映射出一个hashCode，但是一个hashCode却可以被多个Key映射到（这就叫哈希冲突，要我们去解决的）。</p><p>1、直接寻址法：取keyword或者keyword的某个线性函数值为散列地址，即H(key)=key或者H(key)=a·key+b，当中a和b为常数（这样的散列函数叫做自身函数）。这个的应用就是，比如我们世界地图的掩码，直接用坐标x*1000+坐标y，得到key。</p><p>2、数字分析法：找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。分析一组数据，比方一组员工的出生年月日，这时，我们发现出生年月日的前几位数字大体相同，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构造散列地址，则冲突几率就会明显减少。</p><p>3、平方取中法：取keyword平方后的中间几位作为散列地址。</p><p>4、折叠法：将keyword切割成位数同样的几部分，最后一部分分数能够不同，然后取这及部分的叠加和（去除进位）作为散列地址。</p><p>5、随机数法：选择一随机函数，取keyword的随机值作为散列地址，通常适用于keyword长度不同的场合。</p><p>6、除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即H(key)=key MOP p , p&lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算后取模，对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞。</p><h2 id="C-散列表"><a href="#C-散列表" class="headerlink" title="C#散列表"></a>C#散列表</h2><p>建立一个确定的对应关系，使得每个key值都和一个地址一一对应。</p><ul><li>  存储记录时，通过 散列函数+key值 计算记录的散列地址，并用该地址存储记录。</li><li>  查找记录时，通过同样的 散列函数+key值 计算记录的散列地址，并访问该记录。</li></ul><p>上述的只是完美散列表，理论存在。但是 .NET 的 <em>GetHashCode</em> 方法返回的是Int32，也就是一一对应就只能有最多2^32个key值。但实际肯定不止这么点情况（比如key你可以用Int64），那么会出现问题：多个key值通过算法映射出来的HashCode是相同的，这叫做<strong>哈希冲突</strong>。</p><p>如何解决、减少哈希冲突就成了性能瓶颈。</p><h2 id="C-解决哈希冲突"><a href="#C-解决哈希冲突" class="headerlink" title="C#解决哈希冲突"></a>C#解决哈希冲突</h2><p><strong>Hashtable</strong>：开放定址法（尝试的第一个单元被占了，那么就尝试下一个空单元）。</p><p><strong>Dictionary</strong>：拉链法/链地址法（将所有key取哈希码相同的记录存储在同一线性链表）。</p><p>其他：再哈希法（冲突后再用其他哈希函数哈希，直到不冲突）…</p><h2 id="为什么哈希表长要取质数？"><a href="#为什么哈希表长要取质数？" class="headerlink" title="为什么哈希表长要取质数？"></a>为什么哈希表长要取质数？</h2><p>.net解决哈希冲突：扩容、取质数（质数也叫素数）。</p><p>扩容部分在下面哈希表里再阐述，有一个词叫因子。</p><p><strong>那为什么哈希表长要取质数？</strong>因为表长也就是容量是拿来求模的，如果和被取模的数有公因子，会导致同模的数（也就是冲突的数）之间有更多规律（存在公因子），而现实中我们的 数据源、哈希函数 往往就是有一定的关系比如取长运算就是存在公因子2。那么结果就是，冲突很可能更频繁，当然并不是一定的具体得看你的数据源和哈希函数实现。</p><p>举例：</p><p>默认长度设置为6，则2的倍数（这里不提6自己的倍数毕竟质数也一样）的整数将固定散列在0、2、4这几个数内；3的倍数将固定散布在0、3这几个数内。 此时，GetHashCode你可能写成取一系列运算之后*2，那么结果是2、4、6、8、10、12…这样的数，他们取模后分别是2、4、0、2、4、0…，这种 GetHashCode + 表长 实现下的哈希散列表，冲突的概率就非常之大。而换成7这样的质数，取模后是2、4、6、1、3、5…有改进了对吧？</p><h2 id="自己避免哈希冲突"><a href="#自己避免哈希冲突" class="headerlink" title="自己避免哈希冲突"></a>自己避免哈希冲突</h2><p>开发者自己想避免哈希冲突，在.net里就是设计更好的散列表也就是设计更好的GetHashCode，使映射出来的int32值尽可能不重合。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>这里只指.net提供的Hashtable类型。又称哈希表、散列表。机制关键字是<strong>2倍质数扩容、装填因子确定装载数、双重散列法（属于开放定址法）</strong>这3个要点。</p><p><a href="https://blog.csdn.net/exiaojiu/article/details/51206024">https://blog.csdn.net/exiaojiu/article/details/51206024</a></p><p><a href="https://www.cnblogs.com/millionsmultiplication/p/9409290.html">https://www.cnblogs.com/millionsmultiplication/p/9409290.html</a></p><h2 id="真实类型-3"><a href="#真实类型-3" class="headerlink" title="真实类型"></a>真实类型</h2><p>内部数据是<strong>哈希桶</strong>，key-value对均为<strong>object类型</strong>，还有一个hash_coll是<strong>哈希码</strong>。</p><p>数据存在数组buckets里。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Hashtable.bucket[] buckets;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> bucket</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> val;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hash_coll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><p>使用双重散列法，查找内存的时间复杂度为<strong>常数级</strong>。key-val类型是object，因此类型并不安全。</p><h2 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h2><p>装填因子（loadFactor）是 装载数/哈希表长。<strong>它决定了装载数。</strong>值越小，表长越大也就是内存损耗更大，但是哈希冲突更少。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.loadsize = (<span class="built_in">int</span>) ((<span class="built_in">double</span>) <span class="keyword">this</span>.loadFactor * (<span class="built_in">double</span>) newsize); <span class="comment">// 装载数 是被 装填因子 所控制的。newsize是由buckets.Length取得的质数。</span></span><br></pre></td></tr></table></figure><p>加载因子是用户可以控制的，范围是0.1f ~ 1，默认是1。在Hashtable的构造函数中可以输入。</p><p>装填因子默认取0.72，是微软认为的最佳性能默认值。</p><p>最后，装填因子 = 加载因子*装填因子的范围是0.072 ~ 0.72，默认是0.72。</p><h2 id="装载数"><a href="#装载数" class="headerlink" title="装载数"></a>装载数</h2><p>装载数loadsize，装载数比桶数小。</p><p>当装满的桶数count超过装载数时会发生扩容，扩容后装载数随之更新（具体看“插入”）。</p><p>更新公式：loadsize = 装填因子 * 桶数bullets.Length（质数）</p><h2 id="双重散列法⭐"><a href="#双重散列法⭐" class="headerlink" title="双重散列法⭐"></a>双重散列法⭐</h2><p>双重散列法是开放地址法中最好的方法之一。</p><p>简单说就是有2个哈希函数，第一个哈希函数算出key的直接映射值(seed)，第二个哈希函数算出冲突时使用的增量(incr)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">uint</span> <span class="title">InitHash</span>(<span class="params">Object key, <span class="built_in">int</span> hashsize, <span class="keyword">out</span> <span class="built_in">uint</span> seed, <span class="keyword">out</span> <span class="built_in">uint</span> incr</span>)</span> &#123;      </span><br><span class="line">    <span class="built_in">uint</span> hashcode = (<span class="built_in">uint</span>) GetHash(key) &amp; <span class="number">0x7FFFFFFF</span>;<span class="comment">//取整数</span></span><br><span class="line">    seed = (<span class="built_in">uint</span>) hashcode;</span><br><span class="line">    </span><br><span class="line">    incr = (<span class="built_in">uint</span>)(<span class="number">1</span> + ((seed * HashPrime) % ((<span class="built_in">uint</span>)hashsize - <span class="number">1</span>))); <span class="comment">// HashPrime是101定数，暂不知道数学意义</span></span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取好了2个seed、incr两个数据之后，<strong>第一次会去找 bucketNumber = seed % buckets.Length 的值</strong>，如果冲突再找 bucketNumber + incr) % buckets.Length的值，直到匹配。</p><p>注意！注意！注意！上面说的 bucketNumber = seed % buckets.Length ，这很重要，这是哈希桶映射的核心，毕竟算出来的hashCode比buckets.Length（桶数）大太常见了，所以需要取模。<strong>这意味着扩容后， buckets.Length发生改变，buckets内部全体都需要重新排列。</strong></p><h2 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h2><p>可以输入加载因子和容量，默认的加载因子是1。</p><p>初始化时，**loadFactor = 0.72f * 加载因子(0.1f ~ 1)**。容量则最小为3（最小质数）。</p><h2 id="扩容-3"><a href="#扩容-3" class="headerlink" title="扩容"></a>扩容</h2><p>首先将冲突数occupancy归零，创建新buckets，然后开始拷贝旧数据。</p><p>1.创建新buckets。那它的数组长度（桶数）怎么确定？</p><p>​    如果是常规扩容（不是因为冲突数超过了预装载量），就会去质数表里找一个最小的、大于等于 bullets长度 * 2 的质数作为新的bullets长度。质数表：HashHelpers里的一个枚举数组，是个并不连续的质数表，从3开始一共有72个。</p><p>​    如果是冲突扩容（冲突数超过了预装载量），就按照目前bullets长度进行拷贝旧数据操作。所以实际并没有扩容，只做了拷贝旧数据操作，应该是因为冲突太多希望重新排列一次数据。</p><p>2.拷贝旧数据。并不是简单的复制粘贴，而是<strong>遍历buckets数组、利用putEntry重新添加元素</strong>。putEntry是Hashtable的内部插值方法，仍然是双重散列法插。为什么不直接复制粘贴？很简单，因为buckets.Length（桶数）变了，那么所有的<code>hashCode % buckets.Length</code>的下标位置都得变。</p><p>大规模的putEntry终究是高时耗的，所以新建hashtable时最好选择一个稍大的容量，避免频繁扩容。</p><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>Insert的内部操作分三个步骤：</p><p>1.判断key是否为空，如果空，哈希函数是无法计算地址的。</p><p>2.判断<strong>bullets实际使用条目数count（装满的桶数） 是否大于等于装载数</strong>，如果满足，哈希表需要扩容为原来装载数的2倍以上（从质数表里取）；如果前一条不满足，则继续判断<strong>冲突数是否大于装载数</strong>，如果大于，则扩容。</p><p>3.接着在循环体内按照双重散列法寻找对应键值的桶并为对应键值的桶赋值。</p><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><p>就是双重散列法。</p><h2 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h2><p>核心就是按照双重散列法寻找对应键值的桶后将桶变成空桶，然后count–（实际桶数）。</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p><code>Dictionary&lt;TKey, TValue&gt;</code>泛型字典，解决Hashtable拆装箱。机制关键字是<strong>buckets+entries双数组、拉链法基础上改进、FreeList单链表</strong>这3个要点。</p><p><a href="https://www.cnblogs.com/xiaomowang/">https://www.cnblogs.com/xiaomowang/</a></p><h2 id="真实类型-4"><a href="#真实类型-4" class="headerlink" title="真实类型"></a>真实类型</h2><p>这里哈希桶主要用来进行Hash碰撞（和Hashtable类不一样），Entry数组用来存储字典的内容，并且标识下一个元素的位置。</p><p>Entry数组是一个单链表。</p><p>KeyCollection、ValueCollection内部真实数据就是这个字典本身。然后KeyCollection和ValueCollection实现了一些常用接口，比如GetEnumerator返回的时候帮你把字典的迭代返回类型<code>KeyValuePair&lt;TKey, TValue&gt;</code>转换成<code>TKey / TValue</code>了再返回。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] buckets; <span class="comment">// Hash桶，桶的下标是hashCode，桶内的int值是entries单链表的链下标</span></span><br><span class="line"><span class="keyword">private</span> Entry[] entries; <span class="comment">// Entry数组，存放元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> count; <span class="comment">// 当前entries的index位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> version; <span class="comment">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeList; <span class="comment">// 被删除Entry在entries中的下标index，这个位置是空闲的</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeCount; <span class="comment">// 有多少个被删除的Entry，有多少个空闲的位置</span></span><br><span class="line"><span class="keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer; <span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> KeyCollection keys; <span class="comment">// 存放Key的集合，内部用 Dictionary&lt;TKey, TValue&gt; dictionary</span></span><br><span class="line"><span class="keyword">private</span> ValueCollection values; <span class="comment">// 存放Value的集合，内部用 Dictionary&lt;TKey, TValue&gt; dictionary</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> Entry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hashCode;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> next; <span class="comment">// 证明entries是一个单链表！这样使得哈希冲突得以解决！</span></span><br><span class="line">    <span class="keyword">public</span> TKey key;</span><br><span class="line">    <span class="keyword">public</span> TValue <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><p>字典和哈希表不一样！它内部可不是用双重散列法了。</p><h2 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h2><p>如果不指定capacity，那么就基本什么也不做。内部方法<code>Initialize (capacity)</code>的调用，则会在第一次<code>Add</code>时进行。</p><p>如果指定了capacity，那么就会调用内部方法<code>Initialize (capacity)</code>。</p><p>1.首先，去质数表找一个大于等于capacity的质数（和Hashtable一样），作为哈希桶容量。</p><p>2.new哈希桶，全部赋值-1。</p><p>3.new Entry数组。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> prime = HashHelpers.GetPrime(capacity);</span><br><span class="line">    <span class="keyword">this</span>.buckets = <span class="keyword">new</span> <span class="built_in">int</span>[prime];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; <span class="keyword">this</span>.buckets.Length; ++index)</span><br><span class="line">        <span class="keyword">this</span>.buckets[index] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.entries = <span class="keyword">new</span> Dictionary&lt;TKey, TValue&gt;.Entry[prime];</span><br><span class="line">    <span class="keyword">this</span>.freeList = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容-4"><a href="#扩容-4" class="headerlink" title="扩容"></a>扩容</h2><h3 id="扩容时机"><a href="#扩容时机" class="headerlink" title="扩容时机"></a>扩容时机</h3><p>1.非冲突扩容。触发时机是Entries实际使用 == Entries元素总数。</p><p>2.冲突扩容（其实不是扩容，是重排序，但不用一个一个插入）</p><h3 id="扩容方式"><a href="#扩容方式" class="headerlink" title="扩容方式"></a>扩容方式</h3><p>先建新Buckets、Entries数组。新数组大小没有装填因子的概念，就是二倍扩容找质数罢了。</p><p>再直接拷贝Entries数组，直接<code>Array.Copy</code>（和Hashtable不一样）。</p><p>// 如果是冲突重排序，那么此时还需要把Entries里所有的元素重新计算一遍HashCode（当然我觉得没啥用）。</p><p>最后遍历Entries，对每个元素都进行<strong>重新映射赋值Buckets、重建链表</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> index1 = <span class="number">0</span>; index1 &lt; <span class="keyword">this</span>.count; ++index1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> index2 = entryArray[index1].hashCode % newSize; <span class="comment">// 重新赋值Buckets映射，因为扩容导致Size变了所以需要%newSize！</span></span><br><span class="line">entryArray[index1].next = numArray[index2]; <span class="comment">// 重链</span></span><br><span class="line">numArray[index2] = index1; <span class="comment">// 重链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h2><p><code>Add</code>接口，会直接调用内部方法<code>Insert</code>。</p><p>1.首先检测是不是没有执行初始化（new时没有输入capacity），没的话就执行<code>Initialize (0)</code>。</p><p>2.和下图一样，先<strong>哈希 + 位与intMax + 取模</strong>映射到Buckets下标，</p><p>  如果发现对应的桶内装的是-1，那就是没冲突过的哈希，不用处理；</p><p>  如果发现对应的桶内装的不是-1，那就是冲突了的哈希，就取找对应Entries里的元素，这个元素就是链头，获取它的Next，一直往后找，找到链尾（Next == -1），记录出冲突数num。</p><p>3.有个叫FreeList的单链表，它本身是个int（具体看“移除”节）。总之，会先去FreeList找碎片形式的Entry位，如果FreeList是空的（FreeCount == 0 ）就直接往后找从没用过的Entry位（具体就是用count++）。</p><p>找到新的Entry位后，如果没冲突过就将其Next设置成-1，如果冲突过就将它设置为新的链头。转化为代码很简单，就是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entries[没用过的Entry位].Next = Buckets[hashCode]; <span class="comment">// Buckets[hashCode]默认是-1，否则是链头</span></span><br><span class="line">Buckets[hashCode] = 没用过的Entry位;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220314144040.png"></p><h2 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h2><p>找起来就挺容易的，毕竟处理操作都在插入、移除的时候做好了。简单来说就是<strong>链地址法</strong>。</p><h2 id="移除-2"><a href="#移除-2" class="headerlink" title="移除"></a>移除</h2><p><code>Remove</code>接口。</p><p>分2步，第一步是根据Key算出哈希映射值，找到对应桶中指向的Entry结点。根据清空进行 <strong>更新链头or清空桶 / 更新链表</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (桶内指向的是链头)</span><br><span class="line">    <span class="keyword">this</span>.buckets[index1] = <span class="keyword">this</span>.entries[index3].next; <span class="comment">// 桶内指向新的链头。如果Entry无后续结点（Next是-1），相当于直接把桶也清空了。</span></span><br><span class="line"><span class="keyword">else</span> (桶内指向的是链中的某个结点)</span><br><span class="line">    <span class="keyword">this</span>.entries[index2].next = <span class="keyword">this</span>.entries[index3].next; <span class="comment">// 在链中删除结点</span></span><br></pre></td></tr></table></figure><p>第二步，<strong>把上面去掉的Entry节点清空内容后，作为FreeList的新链头</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.entries[index3].hashCode = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span>.entries[index3].key = <span class="literal">default</span> (TKey);</span><br><span class="line"><span class="keyword">this</span>.entries[index3].<span class="keyword">value</span> = <span class="literal">default</span> (TValue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.entries[index3].next = <span class="keyword">this</span>.freeList;</span><br><span class="line"><span class="keyword">this</span>.freeList = index3;</span><br><span class="line">++<span class="keyword">this</span>.freeCount;</span><br><span class="line">++<span class="keyword">this</span>.version;</span><br></pre></td></tr></table></figure><h1 id="哈希表vs字典"><a href="#哈希表vs字典" class="headerlink" title="哈希表vs字典"></a>哈希表vs字典</h1><p>解决冲突的方法不同。Hashtable用的是基于开放地址法的<strong>双重散列法</strong>；Dictionary用的是<strong>拉链法</strong>。</p><p>内部数组数量不同。Hashtable只用1个数组；Dictionary用2个数组。</p><p>桶装的东西不同。内部都用到了桶的概念，但是Hashtable的桶装的是数据实体；Dictionary桶装的是int，存放着实体数组Entries的链头。</p><p>都是二倍质数扩容，但是扩容的时机不同。Hashtable多了<strong>装填因子、装载数</strong>的概念；Dictionary就直接<strong>比对count和Entries.Length</strong>。</p><h1 id="线程安全字典"><a href="#线程安全字典" class="headerlink" title="线程安全字典"></a>线程安全字典</h1><p>ConcurrentDictionary。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConcurrentDictionary&lt;TKey, TValue&gt;.Tables m_tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Tables</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;TKey, TValue&gt;.Node[] m_buckets;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> <span class="built_in">object</span>[] m_locks;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">volatile</span> <span class="built_in">int</span>[] m_countPerLock;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> IEqualityComparer&lt;TKey&gt; m_comparer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上很多对比ConcurrentDictionary和Dictionary+Lock效率的文章，说大规模情况下ConcurrentDictionary读快、Dictionary+Lock写快。所以更多会选择Dictionary+Lock的方案。</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="IEnumerable和IEnumerator区别"><a href="#IEnumerable和IEnumerator区别" class="headerlink" title="IEnumerable和IEnumerator区别"></a>IEnumerable和IEnumerator区别</h2><p>IEnumerable<strong>可迭代的</strong>是一个声明式的接口，声明实现该接口的类就是“可迭代的”，但并没用说明如何实现迭代器(iterator)。</p><p>IEnumerator<strong>迭代器</strong>是一个实现式的接口，它提供了具体怎么实现“可迭代的”。</p><p>我们自己写代码，一般给类实现IEnumerable接口即可。</p><p>IEnumerable：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;<span class="comment">// 返回一个循环访问集合的枚举器/迭代器。用于外部循环访问。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IEnumerator：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IDisposable</span>, <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    T Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach支持"><a href="#foreach支持" class="headerlink" title="foreach支持"></a>foreach支持</h2><p>用foreach遍历，并不需要实现IEnumerable接口，只要显式的实现IEnumerator GetEnumberator 无参方法即可。</p><p>foreach本质也是个语法糖，编译器帮你获取对象迭代器然后<code>while(MoveNext)&#123; Current &#125;</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator enumerator = test.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> current = enumerator.Current;</span><br><span class="line">    <span class="comment">// 下面是自己的代码</span></span><br><span class="line">    Console.WriteLine(current.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield使用"><a href="#yield使用" class="headerlink" title="yield使用"></a>yield使用</h2><p>普通使用迭代器的话，无效代码太多了。下面就是一个我选择最简单实现的例子，可以正常foreach。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Test_Iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Iterator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] datas = <span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> point = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        point++;</span><br><span class="line">        <span class="keyword">return</span> point &lt; datas.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        point = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = point % datas.Length;</span><br><span class="line">            <span class="keyword">return</span> datas[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是c#引入了yield语法糖，实现就容易多了。</p><p>可以在<strong>方法</strong>，<strong>属性</strong> 和 <strong>索引器</strong>中使用 <strong>yield 来</strong>实现<strong>迭代器</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">string</span>[] datas = <span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; datas.Length; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> datas[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yiled解析"><a href="#yiled解析" class="headerlink" title="yiled解析"></a>yiled解析</h2><p>yield语法糖，其实是编译器帮你在你定义的类中，生成了一个新的 IEnumerator实现类。接口需要的<strong>MoveNext、Reset、Current</strong>编译器都帮你用默认方式实现好了。</p><p>而<code> yield return; yield break;</code> 语法糖自动生成的代码，就是在MoveNext里写case。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (&lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="literal">default</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// yield return 3;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             &lt;&gt;<span class="number">2</span>__current = <span class="number">3</span>;</span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// yield return 5;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             &lt;&gt;<span class="number">2</span>__current = <span class="number">5</span>;</span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">2</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// yield break;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 类内成员篇</title>
      <link href="/Tech/CSharp/Essence/classMember/"/>
      <url>/Tech/CSharp/Essence/classMember/</url>
      
        <content type="html"><![CDATA[<h1 id="类成员初始化顺序"><a href="#类成员初始化顺序" class="headerlink" title="类成员初始化顺序"></a>类成员初始化顺序</h1><p>一般初始化顺序：</p><ol><li> 子类静态字段内联</li><li> 子类静态构造</li><li> 子类实例字段内联</li><li> 父类静态字段内联</li><li> 父类静态构造</li><li> 父类实例字段内联</li><li> 父类实例构造</li><li> 子类实例构造</li></ol><p>原则就是：先内联后构造；先静态后实例；先子类后父类（除了实例构造器）。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>abstract抽象方法、virtual方法、隐式实现接口方法，它们本质上、在IL代码层中，都是virtual方法。</p><p>IL提供两种方式去调用方法：</p><p>call：可用于调用实例方法、虚方法和静态方法。// 我个人测下来感觉只有静态方法是用call…</p><p>callvirt：可用于调用实例方法、虚方法。过程会比call复杂一些，事前会check null，执行时也会去查虚函数表。</p><h2 id="非虚方式调用-call"><a href="#非虚方式调用-call" class="headerlink" title="非虚方式调用 call"></a>非虚方式调用 call</h2><p>call 调用的，是编译时确定的类型，也就是申明类型。</p><p>如果变量申明的类型没有对应的方法，就检查基类型来查找匹配方法。</p><h2 id="虚方法调用-callvirt"><a href="#虚方法调用-callvirt" class="headerlink" title="虚方法调用 callvirt"></a>虚方法调用 callvirt</h2><p>callvirt 调用的，是运行时确定的类型，也就是变量指向对象的实际类型（new的类型）。</p><p>上面说的是结果，但如果深究过程，在IL代码层的话，多态方法全部都是 callvirt 最初父类的同一个方法。</p><p>c++版本 虚表、虚函数调用整体流程：</p><p>1.编译器发现一个类中有虚函数时，便为该类<strong>生成虚函数表</strong>，虚表各表项为指向对应虚函数的指针。父类虚函数地址在前，子类在后，按照声明顺序。</p><p>2.<strong>生成子类</strong>时，如果发现子类中函数重写了父类中的虚函数，则用子类虚函数的地址<strong>覆盖</strong>掉对应父类虚函数的地址。</p><p>3.<strong>虚函数调用</strong>过程：</p><p>查自己类型的虚函数表，找到对应位置的虚函数。</p><p>​    有覆盖：该指针指向子类函数，调用子类的函数。</p><p>​    无覆盖：调用父类自己的函数。</p><p>4.每一个有虚函数的类都有一个虚函数表（V-Tablle），每个这些类的对象都会生成一个指向虚函数表的指针。</p><p>c#版本 虚表、虚函数调用整体流程：</p><p>网上很难找到c#版本的虚函数实现，全只有猜测。我自己整理了一下，目前理解是：</p><p>可以确定的是，在IL代码层，多态方法全部都是 callvirt 最初父类的同一个方法。</p><p>因此估计JIT是根据 <strong>推上栈的实际变量指向的对象 + callvirt最初父类的同一个方法</strong> 来获取偏移量、再根据偏移量确定具体调用方法，内部则可能和c++一样是用V-Table。</p><p><strong>那么最终结论就是</strong>，每个带有虚函数的类型，都会有一张V表；他们的每个子类，也有自己的V表，起始布局和父类一致，如果override了就替换自己的V表的方法指针；这些子类在堆上的对象，都有一个指针指向子类类型的V表。</p><p><a href="https://blog.csdn.net/li1914309758/article/details/79916414">文章推荐1</a>： <a href="http://c.biancheng.net/view/267.html">文章推荐2</a></p><h2 id="自己实现虚方法"><a href="#自己实现虚方法" class="headerlink" title="自己实现虚方法"></a>自己实现虚方法</h2><p>用静态方法就可以实现，将对象自己作为参数传入静态方法，然后根据其type来switch-case就可以简单实现一个。</p><p>总的来说，虚方法这么复杂的内部机制就是为了实现多态。</p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>常量，const关键字，是指值从不变化的符号，它的值必须能在编译时确定，最后会在元数据中嵌入。它总是隐式static的。</p><p>const 与 static readonly 的区别是，const要求必须能在编译时确定，readonly只是后续不能修改，是可以跟运行时确定的 <code>= new A()</code>的。</p><table><thead><tr><th>C#关键字</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>默认</td><td>实例字段</td><td>该字段只与对象的一个实例关联，而不是与类型本身关联</td></tr><tr><td>static</td><td>静态字段</td><td>该字段是类型状态的一部分，而不是对象状态的一部分</td></tr><tr><td><strong>readonly</strong></td><td>只读字段</td><td><strong>该字段只能由一个构造器方法中的代码写入</strong>（但是可以通过反射修改）</td></tr></tbody></table><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>属性的本质是方法（get、set访问器），是对字段的封装。C#提供<code>&#123;get;set;&#125;</code>语法糖，编译时自动实现创建一个字段。</p><p>无参属性：我们常规说的属性。</p><p>有参属性：get、set访问器接受一个或多个参数，就叫有参属性。有参属性一般用处是索引器，索引器的实现是通过对<code>this[]</code>操作符进行重载。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] name = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//索引器必须以this关键字定义，其实这个this就是类实例化之后的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name[index]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; name[index] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">...</span><br><span class="line">Console.WriteLine(Students[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>具体见《C#精要 - 委托与事件篇》。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>避免拆装箱的最佳选择。最好的例子就是 ArrayList ( Object[ ] ) =&gt; List&lt; T &gt;；Action&lt; T &gt; (T arg)、Func&lt;in T, out TResult&gt; (T arg)。</p><p>它可以用where约束。</p><ul><li>  **逆变量(contravariant)**，意味着泛型类型参数可以从一个类更改为它的某个派生类。C#中用<code>in</code>来标记，只能出现在输入位置，比如入参。</li><li>  **协变量(covariant)**，意味着泛型类型参数可以从一个类更改为它的某个基类。C#中用<code>out</code>来标记，只能出现在输出位置，比如返回值。</li></ul><p>这两个概念看着挺复杂，其实就是 Func&lt;in T, out TResult&gt; (T arg)。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：定点数运算数学库</title>
      <link href="/Tech/Game/tools/CodingKMath/"/>
      <url>/Tech/Game/tools/CodingKMath/</url>
      
        <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="什么是定点数？"><a href="#什么是定点数？" class="headerlink" title="什么是定点数？"></a>什么是定点数？</h2><p><strong>约定计算机中小数点的位置</strong>，且这个位置固定不变，小数点前、后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中存储起来，这种表示方式叫做「定点」表示法，用这种方法表示的数字叫做「定点数」。</p><h2 id="为什么不用浮点数？"><a href="#为什么不用浮点数？" class="headerlink" title="为什么不用浮点数？"></a>为什么不用浮点数？</h2><h2 id="具体怎么使用？"><a href="#具体怎么使用？" class="headerlink" title="具体怎么使用？"></a>具体怎么使用？</h2><p>定点数参与逻辑运算，转换回浮点数后不再用浮点数参与任何逻辑运算。</p><h1 id="定点数型Int"><a href="#定点数型Int" class="headerlink" title="定点数型Int"></a>定点数型Int</h1><h2 id="从浮点数转换到定点数"><a href="#从浮点数转换到定点数" class="headerlink" title="从浮点数转换到定点数"></a>从浮点数转换到定点数</h2><p><strong>放大1024倍</strong>，从而使得浮点数小数误差变小。</p><p>用long存储防止高位越界。</p><p>使用<strong>移位运算</strong>实现，比直接乘更优。</p><p>int型转换可以不损失精度；float型转换需要损失一些精度：<code>(long)Math.Round(f * 1024)</code>。</p><h2 id="乘除运算出现问题"><a href="#乘除运算出现问题" class="headerlink" title="乘除运算出现问题"></a>乘除运算出现问题</h2><p>乘法运算相当于多乘了一次倍数，所以直接除以1024（右移10位）即可。1024(原数1) * 2048(原数2) = 2^21 (原数是2^11而不是期待的2)</p><p>除法运算相当于多除了一次倍数，所以直接乘以1024（左移10位）即可。2048(原数2)  / 1024(原数1)= 2 (原数是2^-9而不是期待的2)</p><h2 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h2><p>简单重写operator。</p><h2 id="定点数转换回浮点数"><a href="#定点数转换回浮点数" class="headerlink" title="定点数转换回浮点数"></a>定点数转换回浮点数</h2><p><strong>缩小1024倍</strong>之后强转float，右移10位强转int。但这样会导致负数位移出现问题，见下。</p><h2 id="位移运算问题"><a href="#位移运算问题" class="headerlink" title="位移运算问题"></a>位移运算问题</h2><p>在计算机中，<strong>负数使用二进制补码表示</strong>。原因是方便直接进行逻辑电路（与非门）运算，把减法直接变成加法。比如-3 <code>1 011</code>的补码是<code>1 101</code>，那么实现3-3就是0 011 + 1 101刚好意味着<code>0 000</code>。</p><p>而.net的位移运算用的是<strong>算数位移</strong>，比如对int或long进行右位移时，如果左侧符号位为非负(0)，高位补0；如果左侧操作数为负(1)，高位补1。</p><p>以上2点就导致，<strong>c#中int型和long型的正数和负数的位移是不对等的</strong>，也就是两者位移完的非符号位原码不一样！</p><p>比如</p><p>0 011(3)右位移1次 =&gt; 0 001 = 0 001(原码) = 1;</p><p>1 101(-3以补码形式出现)右位移1次 =&gt; 1 110 = 1 010(原码) = -2;</p><p>都是右移一位，一个是1，一个是-2而不是-1，这就叫不对等。</p><p>解决方案在理解原理之后就很简单：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> BIT_MOVE_COUNT = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> RawInt</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (scaledValue &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">int</span>)(scaledValue &gt;&gt; BIT_MOVE_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -(<span class="built_in">int</span>)(-scaledValue &gt;&gt; BIT_MOVE_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定点向量Vector3"><a href="#定点向量Vector3" class="headerlink" title="定点向量Vector3"></a>定点向量Vector3</h1><p>用上面实现的 定点数型Int 来实现一个Vectors：</p><ul><li>定点数Int型的xyz值</li><li>索引、操作数</li><li>常用向量定义</li><li>与UnityEngine.Vector3的转换</li><li>求向量长度平方 与 向量的长度也就是模（取平方根）</li><li>规格化（1/向量的模  * 向量）</li><li>点乘、叉乘、夹角</li></ul><p>其中，计算向量长度（模）需要自己实现取定点数的平方根，使用<strong>牛顿迭代法</strong>求平方根。简单来说就是通过多次迭代求接近于平方根的数据。</p><p>而计算夹角也需要用到反余弦值，所以要自己实现定点数求反余弦函数。</p><p>下面对两者详解：</p><h2 id="牛顿迭代法优化"><a href="#牛顿迭代法优化" class="headerlink" title="牛顿迭代法优化"></a>牛顿迭代法优化</h2><p>求模公式|a|=√(x^2+y^2+z^2），需要实现定点数平方根。原理部分如下，这里感谢Plane大神提供的笔记和思路！</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220306210358.png"></p><p>优化因为比较简单，直接上代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> iteratorCount = <span class="number">8</span>;<span class="comment">// 默认迭代8次</span></span><br><span class="line">===================================================================================</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化前：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iteratorCount;i ++)</span><br><span class="line">&#123;</span><br><span class="line">    result = (result + val / result) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然默认迭代8次，但是可能因为数值原因导致有的不需要8次就已经很接近了，优化点就在这</span></span><br><span class="line"><span class="comment">// 优化后：</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    history = result;</span><br><span class="line">    result = (result + val / result) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (result != history &amp;&amp; count &lt; iteratorCount);</span><br></pre></td></tr></table></figure><h2 id="点乘叉乘"><a href="#点乘叉乘" class="headerlink" title="点乘叉乘"></a>点乘叉乘</h2><p><a href="https://zhuanlan.zhihu.com/p/359975221">https://zhuanlan.zhihu.com/p/359975221</a></p><p>除此之外，补充一下，我个人的理解：</p><p>首先确定是左手还是右手坐标系。在【右手坐标系】下，如果两个向量的叉乘结果为正值，表示向量a经过不大于180°的【逆时针】旋转可以与向量b的方向一致；如果为负，那么就需要转180°到360°（右手法则）。</p><p>至于为什么，思考一下<code>a X b = |a|*|b|*sinθ</code>，其中sin的值范围是0°-180°为正，180°-360°为负，就可以知道了。点乘几何意义也是同理，靠cos的值判断的。</p><h2 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h2><p>向量夹角使用公式：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220308101411.png"></p><p>也就是说实现向量的 <strong>点乘运算、求模运算、反余弦函数</strong>，就可以由2个向量计算出夹角了。</p><p>点乘、求模（牛顿法）上面已实现。夹角需要自己实现求反余弦函数，实现方法如下。</p><h3 id="反余弦值分割成一张表"><a href="#反余弦值分割成一张表" class="headerlink" title="反余弦值分割成一张表"></a>反余弦值分割成一张表</h3><p>直接通过枚举1024份对应的x-y数值来获得，而作为结果的反余弦函数的弧度制的值[0,π] 则通过小数值放大10000倍取整。</p><p>原理部分如下原理部分如下，这里感谢Plane大神提供的笔记和思路！</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220306223103.png"></p><h3 id="级数映射查表"><a href="#级数映射查表" class="headerlink" title="级数映射查表"></a>级数映射查表</h3><p>上面提到的枚举1024份的反余弦函数弧度制的值，就是一张有1025个数值（分割成1024份就有1025个点）的表，需要用级数查到对应的表值。</p><p>根据公式，x就是向量积/模。所以映射也就是将 [-1,1] 映射成 [0,1024]。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求反余弦。val就是向量积/模，范围是[-1,1]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CodingKArgs <span class="title">Acos</span>(<span class="params">CodingKInt val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CodingKInt rate = (val * AcosTable.HalfIndexCount) + AcosTable.HalfIndexCount; <span class="comment">// 将 [-1,1] 映射成 [0,1024]</span></span><br><span class="line">    rate = Clamp(rate, CodingKInt.zero, AcosTable.IndexCount);<span class="comment">// 限制rate范围为 0 ~ 1024</span></span><br><span class="line">    <span class="built_in">int</span> rad = AcosTable.table[rate.RawInt];<span class="comment">// 查表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CodingKArgs(rad, AcosTable.Multipler);<span class="comment">// 返回查表结果（弧度值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 定点数库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 线程篇</title>
      <link href="/Tech/CSharp/Essence/thread/"/>
      <url>/Tech/CSharp/Essence/thread/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是线程、进程？"><a href="#什么是线程、进程？" class="headerlink" title="什么是线程、进程？"></a>什么是线程、进程？</h1><p><strong>线程</strong>是对物理CPU进行虚拟化，也是操作系统能调度的最小单位。</p><p><strong>进程</strong>实际是应用程序的实例要使用的资源的集合，每个进程都被赋予了一个虚拟地址空间来避免被其它进程访问。</p><p>一个线程确定由某一进程拥有，一般不能跨进程。</p><h1 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h1><p>线程有空间（内存耗用）和时间（上下文调度）上的开销。</p><h2 id="内存耗用"><a href="#内存耗用" class="headerlink" title="内存耗用"></a>内存耗用</h2><p>① 线程内核对象 (thread kernel object)</p><p>主要是有对线程的描述属性。x64使用约1240字节。</p><p>值得注意的是<strong>线程上下文</strong>(thread context)：线程上下文是是线程上一次执行完毕后，CPU寄存器的状态（内存块）。</p><p>② 线程环境块 (thread environment block,TEB)</p><p>有GDI(图形设备接口)和OpenGL用的一些数据，以及<strong>异常处理链首</strong>：线程每进入一个try块，都会在链首(head)中插入一个节点(node)，退出try块时删除该节点。x64中4KB。</p><p>③ 用户模式栈 (user- mode stack)</p><p>堆栈概念中的栈说的就是这个了，默认分配1MB内存（其实windows是保留1MB容量，等用了才调拨给你）。</p><p>④ 内核模式栈 (kernel- mode stack)</p><p>应用程序代码向OS中的内核模式函数传递实参时，会复制 用户模式栈 传去的实参并加以验证并不允许修改。最后OS内核代码开始处理复制的值。分配x86是12KB，x64是24KB。</p><h2 id="上下文调度"><a href="#上下文调度" class="headerlink" title="上下文调度"></a>上下文调度</h2><p>Windows任何时刻都只将一个线程分配给一个CPU(或CPU核，下面称CPU)。</p><p>CPU会为线程执行一个**时间片 (quantum)**的时长，大概30ms吧，等时间片到期了，就会进行上下文调度切换执行另一个线程。</p><p>上下文调度具体流程：</p><ol><li> 将CPU寄存器的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。</li><li>从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有（而不是CPU上一次调度的线程的所属进程）， Windows在<br> 开始执行任何代码或者接触任何数据之前，还必须切换CPU“看见”的虚拟地址空间。</li><li> 将所选上下文结构中的值加载到CPU的寄存器中。</li></ol><p>上下文调度之后线程切换完成，CPU就会执行所选的线程，直到下一个时间片过了又要切换。</p><p>这是<strong>净开销</strong>，只是为了能够提供一个健壮的、响应灵敏的操作系统。具体就是cpu运行的某个线程卡死了，过一个时间片后也会被分配其他线程执行（比如任务管理器线程来终止卡死程序）。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>系统调度CPU执行哪一个线程，是由线程自己的优先级决定的，所以可能出现高优先级线程太多导致长时间没有处理低优先级线程，这种情况叫<strong>饥饿</strong>。</p><p>低优先级的线程哪怕时间片没用完，也会被立刻挂起执行优先级更高的线程，这是Windows称作<strong>抢占式多线程操作系统</strong>的原因。</p><p>优先级是0~31。</p><p>0是系统启动时会创建一个特殊的<strong>零页线程</strong>，优先级为0，在没有其他线程需要“干活儿”的时候，零页线程将系统RAM的所有空闲页清零。</p><p>自己创建的线程可以通过<code>ThreadA.Priority = ThreadPriority.AboveNormal;</code>的方式，指定优先级。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程的执行是<strong>事件分发式</strong>的，也就是内部维护一个操作请求队列。</p><h2 id="生命流程"><a href="#生命流程" class="headerlink" title="生命流程"></a>生命流程</h2><p>CLR初始化时，线程池中是没有线程的。在内部，线程池维护了一个<strong>操作请求队列</strong>。应用程序执行一个异步操作时，就会对线程池进行请求，具体是将一个记录项(entry)追加到队列中。</p><p>线程池会从这个队列中提取记录项，将这个记录项派发(dispatch)给一个线程池的线程；如果线程池没有线程，就创建一个新线程。当这个线程完成任务后并不销毁，而是返回线程池、进入空闲状态。</p><p>但是如果一个线程在线程池里闲太久了（应用程序很久不向线程池发出请求），为了避免资源浪费，CLR才会终止它。</p><h2 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h2><p>也就是具体是怎么分发任务的。</p><p>（线程池）全局队列：当调用ThreadPool.QueueUserWorkItem、Task时，新追加的任务会被添加进<strong>全局队列</strong>中，全局队列采用<strong>先进先出FIFO</strong>的方式，让工作者线程们自己去取任务。全局队列使用<strong>线程同步锁</strong>，这是为了避免多个线程同时取到一个任务。</p><p>（线程）本地队列：在全局队列中领完的任务会放入工作者线程各自的<strong>本地队列</strong>，本地队列采用<strong>后入先出LIFO</strong>的方式来执行任务。本地队列一般不锁，因为只有对应的工作者线程访问它。</p><p>如果工作者线程发现自己<strong>本地队列空</strong>了，就会尝试从另一个工作者线程的本地队列“偷”一个Task。这个Task在本地队列的队尾，并会要求获取一个线程同步锁。</p><p>如果<strong>所有本地队列都空</strong>了，工作者线程会使用FIFO算法从全局队列取出一个工作项并获得它的锁。</p><p>如果<strong>全局队列也为空</strong>，工作者线程会进入睡眠状态。</p><p>如果<strong>工作者线程睡眠时间很长</strong>，它会自己醒来并销毁自身，释放线程使用的资源（内核、栈等）。</p><h2 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h2><p>可以使用辅助类<strong>CancellationToken</strong>，它有一个bool字段可以用来判断是否取消执行了任务，只要执行Cancel方法就可以让他变成false。</p><p>自己传到线程里判断就行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">CancellationToken token = cts.Token;</span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">token.Register(() =&gt; Console.WriteLine(<span class="string">&quot;Count is cancelled, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">ThreadPool.QueueUserWorkItem(_ =&gt; Count(token, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Press &lt;Enter&gt; to cancel Thread Works&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line">cts.Cancel();</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params">CancellationToken token, <span class="built_in">int</span> countTo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> count = <span class="number">0</span>; count &lt; countTo; count++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 当Source执行Cancel时，会变成false</span></span><br><span class="line"><span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;break, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Console.WriteLine(count);</span><br><span class="line">Thread.Sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - GC篇</title>
      <link href="/Tech/CSharp/Essence/gc/"/>
      <url>/Tech/CSharp/Essence/gc/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是GC？为什么需要GC？"><a href="#什么是GC？为什么需要GC？" class="headerlink" title="什么是GC？为什么需要GC？"></a>什么是GC？为什么需要GC？</h1><p>GC，即Garbage Collection，意为垃圾回收。</p><p>.Net不同于原生C++这种需要程序员手动管理内存的机制，存在<strong>自动释放内存的一套机制</strong>，这就叫GC。</p><p>GC可以让程序员<strong>不必关心资源的管理</strong>，也就是一个对象的生命流程中的4：</p><ol><li> 调用IL指令newobj，为代表资源的类型分配内存（C#中用new操作符完成）。</li><li> 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。</li><li> 访问类型的成员来使用资源（有必要可以重复）。</li><li> 摧毁资源的状态以进行清理。</li><li> 释放内存。垃圾回收器独自负责这一步。</li></ol><p>当然可以自己<strong>重写Finalize方法</strong>或手动<strong>调用GC.Collect</strong>。</p><h1 id="简单列举GC的优势（对比手动管理）"><a href="#简单列举GC的优势（对比手动管理）" class="headerlink" title="简单列举GC的优势（对比手动管理）"></a>简单列举GC的优势（对比手动管理）</h1><p>1.让程序员可以不必关心资源的管理。</p><p>2.避免手动管理时，顺序搞错，先销毁后调用导致空引用抛错。</p><p>3.避免手动管理时，由于标记引用未清空导致的内存泄露。</p><h1 id="讲讲GC算法"><a href="#讲讲GC算法" class="headerlink" title="讲讲GC算法"></a>讲讲GC算法</h1><p>三个方向上讲：从总体流程上来说，它有<strong>标记 -&gt; 压缩</strong>两个阶段；从确定是否销毁的方式上来说，它是<strong>从根遍历</strong>的；从销毁处理方式上来说，它是<strong>分代</strong>的。它解决了<strong>引用计数法</strong>循环引用的问题。</p><h2 id="先说下“引用计数法”是什么？为什么不行？"><a href="#先说下“引用计数法”是什么？为什么不行？" class="headerlink" title="先说下“引用计数法”是什么？为什么不行？"></a>先说下“引用计数法”是什么？为什么不行？</h2><p>引用计数是COM(Component Object Model)使用的办法，GC并不是用这个，而是用的从根遍历。说的是堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一“部分”到达代码某个不再需要对象的地方，就递减这个计数，直到0就可以删除了。</p><p>不行的理由很简单，它没有办法处理循环引用的关系，也就是A、B两个对象互相引用，各自引用计数为1，就没法销毁对方。</p><h1 id="1-先从流程上说：标记-gt-压缩"><a href="#1-先从流程上说：标记-gt-压缩" class="headerlink" title="1.先从流程上说：标记 -&gt; 压缩"></a>1.先从流程上说：标记 -&gt; 压缩</h1><p>标记：这个阶段，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含**可达(已标记)与不可达(未标记)**对象。</p><p>标记完成后，进入压缩阶段。</p><p>压缩：在这个阶段中，垃圾回收器线性的遍历堆、并对其进行内存碎片整理。让幸存对象都紧挨在一起，使内存的地址空间得到释放。操作完了之后，对引用了这些堆内对象的指针进行偏移，保持引用与之前一致。</p><p>压缩结束后，如果本次GC并没有分出足够的内存给接下来的new操作，意味着该进程的内存已耗尽，会抛出OutOfMemoryException。</p><h1 id="2-再从确定是否销毁上说：从根遍历"><a href="#2-再从确定是否销毁上说：从根遍历" class="headerlink" title="2.再从确定是否销毁上说：从根遍历"></a>2.再从确定是否销毁上说：从根遍历</h1><h2 id="根（Root）"><a href="#根（Root）" class="headerlink" title="根（Root）"></a>根（Root）</h2><p>我们将所有引用类型的变量都成为<strong>根</strong>，类中定义的任何静态字段，方法的参数，局部变量(仅限引用类型变量)等一系列”引用者”，都是根，根是CLR在堆之外可以找到的各种入口点。</p><h2 id="可达和不可达（Objects-reachable-and-unreachable）"><a href="#可达和不可达（Objects-reachable-and-unreachable）" class="headerlink" title="可达和不可达（Objects reachable and unreachable）"></a>可达和不可达（Objects reachable and unreachable）</h2><p>如果一个根引用了堆中的一个对象，则该对象为“可达”，否则即是“不可达”。不可达的对象是本次销毁的目标。</p><h2 id="引用跟踪"><a href="#引用跟踪" class="headerlink" title="引用跟踪"></a>引用跟踪</h2><p>也就是标记阶段是怎么标记的。</p><p>在这个阶段，CLR会先遍历堆中的所有对象，并全部设置为可回收状态的，然后检查所有活动根，查看他们引用了哪些对象，</p><p>如果一个根包含null，CLR会忽略这个根并检查下一个根；</p><p>如果根引用了堆上的对象，CLR会标记那个对象，并检查这个对象中的根，继续标记它们引用的对象。如果过程中发现对象已标记，则不重新检查，避免了循环引用而造成的死循环。</p><p>检查完毕后，堆中的对象要么已标记，要么未标记。已标记对象的叫做<strong>可达的</strong>，未标记的对象叫做<strong>不可达的</strong>。</p><h1 id="3-最后说分代回收"><a href="#3-最后说分代回收" class="headerlink" title="3.最后说分代回收"></a>3.最后说分代回收</h1><p>CLR一共有3代：0、1、2代。这是在对可达对象进行处理。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>开始时：CLR初始化会为每一代选择一个<strong>预算容量</strong>。当有对象新分配时，会塞到第0代。</p><p>触发时机：当第0代满了，就会触发GC，没被回收的对象就会成为第1代对象。此时第0代空间中已经不包含任何对象，原来的对象可能已被回收，可能已被放置到第1代中。</p><p>触发特点1：当触发了GC时，第1代内的对象远小于它的预算，那么就不会对第1代进行检查。</p><p>触发特点2：当触发了GC时，可能存在老对象引用了新对象的可能性（比如1代引用0代）。这时新代回收时没有检查到来自老代的引用就会出现错误的回收。为了解决这个问题，垃圾回收器利用了JIT编译器内部的一个机制，这个机制在<strong>对象的引用字段发生变化时，会设置一个对应的标记位</strong>，这样一来垃圾回收器就会知道自上一次垃圾回收以来，哪些老对象的引用字段发生了变化，这样就算这次回收只回收新生代，也会去检测引用字段发生了变化的老对象，是否引用了新生代对象。</p><h2 id="分代回收的意义"><a href="#分代回收的意义" class="headerlink" title="分代回收的意义"></a>分代回收的意义</h2><p>为什么明明是不打算丢弃的可达对象，还要用分代去推出1代、2代呢？全部放0代不就完了？</p><p>事实上是，CLR做出了预设：<strong>回收堆的一部分，速度快于回收整个堆。</strong>事实一般也是如此。</p><p>所以只检查一部分，会比每次都检查全部快很多。</p><h2 id="代预算的动态调节"><a href="#代预算的动态调节" class="headerlink" title="代预算的动态调节"></a>代预算的动态调节</h2><p>在回收第0代后发现存活下来的对象很少，就可能减少第0代的预算，这意味着会更加频繁地执行垃圾回收，但每次回收需要检查的范围更小了。相反，如果回收了第0代后发现还有很多存活的对象，没有多少内存可以回收，就会增大第0代的预算，这样垃圾回收的次数就会减少。</p><h1 id="GC的触发时间点"><a href="#GC的触发时间点" class="headerlink" title="GC的触发时间点"></a>GC的触发时间点</h1><p>除了上文说到的检测到第0代超出预算的时候会触发垃圾回收，还有以下的：</p><h2 id="代码显式调用System-GC的静态Collect方法"><a href="#代码显式调用System-GC的静态Collect方法" class="headerlink" title="代码显式调用System.GC的静态Collect方法"></a>代码显式调用System.GC的静态Collect方法</h2><p>代码可显式请求CLR进行垃圾回收，但微软强烈反对这种请求，托管语言应该信任它本身的垃圾回收机制。</p><p>我日常会在印刷操作的时候调用它。</p><h2 id="Windows报告低内存情况"><a href="#Windows报告低内存情况" class="headerlink" title="Windows报告低内存情况"></a>Windows报告低内存情况</h2><p>如果Windows报告低内存，CLR会强制执行垃圾回收。</p><h2 id="CLR正在卸载AppDomain"><a href="#CLR正在卸载AppDomain" class="headerlink" title="CLR正在卸载AppDomain"></a>CLR正在卸载AppDomain</h2><p>当一个AppDomain卸载时，CLR认为其中一切都不是根，会执行涵盖所有代的垃圾回收。</p><h2 id="CLR正在关闭"><a href="#CLR正在关闭" class="headerlink" title="CLR正在关闭"></a>CLR正在关闭</h2><p>CLR在进程正常终止时关闭，CLR认为其中一切都不是根，对象有机会进行资源清理，但CLR不会试图压缩或释放内存。进程终止时，Windows会回收进程的全部内存。</p><h1 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h1><p>前面讨论的都是小对象，对于大对象（书中说是85000字节以上），CLR会区分对待：</p><p>内存不是在小对象的地址空间分配，而是进程地址空间的其他地方分配；总是第2代；目前不支持压缩。</p><p>所以GC一般不处理他们。</p><h1 id="Finalize方法"><a href="#Finalize方法" class="headerlink" title="Finalize方法"></a>Finalize方法</h1><p>System.Object定义了受保护的虚方法Finalize，如果类型重写了这个方法，对象在被GC判定销毁时会调用它。重写它一般是为了清理非托管资源。</p><h2 id="1-new时"><a href="#1-new时" class="headerlink" title="1.new时"></a>1.new时</h2><p>如果对象的类型定义了Finalize方法，那么这个实例在被构造之前，会将一个指向该对象的指针放到一个终结列表中（finalization list）。</p><h2 id="2-被回收时"><a href="#2-被回收时" class="headerlink" title="2.被回收时"></a>2.被回收时</h2><p>在被GC回收时，如果发现这个对象在终结列表中，就先不销毁，而是把指向它的指针扔到<strong>freachable队列中</strong>。</p><h2 id="3-在freachable队列时"><a href="#3-在freachable队列时" class="headerlink" title="3.在freachable队列时"></a>3.在freachable队列时</h2><p>freachable队列也是垃圾回收器的一种内部数据结构，队列中每一个引用都代表准备要调用Finalize方法的对象。当垃圾回收器把对象的引用从终结列表移到freachable队列时，对象不再被认为是垃圾，我们可以说对象被<strong>复活</strong>了。同时，该对象内引用的对象也会被标记、复活。</p><h2 id="4-复活"><a href="#4-复活" class="headerlink" title="4.复活"></a>4.复活</h2><p>说是复活，其实也就是本该销毁的对象延迟销毁了，没有在本该销毁的一次GC下被销毁。</p><p>这些复活的对象会被提升到老一代，之后CLR会用特殊的终结线程去调用freachable队列中每个对象的Finalize方法，并清空队列。之后他们就真正被销毁了。</p><h2 id="5-复活的思考"><a href="#5-复活的思考" class="headerlink" title="5.复活的思考"></a>5.复活的思考</h2><p>由3、4可知，这些定义了Finalize方法的“可终结”的对象，由于在第一次回收时，会被“复活”以执行Finalize方法，并可能会被提升到老一代，所以至少需要执行两次垃圾回收才能释放掉它们占用的托管堆内存，更需要注意到的是，这些对象中的引用字段所引用的对象也会存活下来并提升到老一代，会造成更大的性能负担。所以，要尽量避免为引用类型的字段定义为“可终结”对象。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 技能编辑器篇</title>
      <link href="/Project/Unity/Moba/HOK/skilleditor/"/>
      <url>/Project/Unity/Moba/HOK/skilleditor/</url>
      
        <content type="html"><![CDATA[<p>从 技能配置可视化+纯业务 的角度，将原来的技能系统换个角度刨析一遍。</p><h1 id="大体分类"><a href="#大体分类" class="headerlink" title="大体分类"></a>大体分类</h1><p>按照可配置的文件来分类，可分为以下五大类：</p><ul><li>碰撞关系配置</li><li>buff配置</li><li>skill配置</li><li>单位配置</li><li>bullet配置</li></ul><p>下面对这几类的核心配置数据进行列举。</p><h1 id="碰撞关系配置"><a href="#碰撞关系配置" class="headerlink" title="碰撞关系配置"></a>碰撞关系配置</h1><ul><li>目标队伍</li><li>目标选择规则</li><li>目标单位</li><li>目标查找范围</li></ul><h1 id="buff配置"><a href="#buff配置" class="headerlink" title="buff配置"></a>buff配置</h1><ul><li>buff类型</li><li>buff附着目标</li><li>buff位置确定方式</li><li>碰撞关系配置</li></ul><h1 id="skill配置"><a href="#skill配置" class="headerlink" title="skill配置"></a>skill配置</h1><ul><li>  图片、音效资源路径</li><li>  技能动画名</li><li>  技能目标确定方式、范围等</li><li>  技能指示器类型</li></ul><h1 id="单位配置"><a href="#单位配置" class="headerlink" title="单位配置"></a>单位配置</h1><p>UnitInfoCfg，比较特殊，为了方便导表，逻辑碰撞体这块只提供一个Enum，在实际加载时使用它的派生类，根据Enum读取出不同的真实逻辑碰撞数据。</p><ul><li>  单位基础属性（基础血量、防御等）</li><li>  单位资源位置</li><li>  单位逻辑碰撞体类型（受击点高度 + 碰撞体大小、形状）</li></ul><h1 id="实现协作"><a href="#实现协作" class="headerlink" title="实现协作"></a>实现协作</h1><p>即想要结点编辑器、又想要表格式的批量填写。将他们协作起来需要多写一些代码，且他们的数据都必须来自同一套数据源——我采用Json数据源。</p><h2 id="Luban"><a href="#Luban" class="headerlink" title="Luban"></a>Luban</h2><p>由Luban提供2套类型：Editor专用的类型，用于和Json数据源交互；运行时使用的类型，也就是真实类型，用于和bytes数据源交互。</p><p>由Luban提供多种格式数据转换：2种Editor可视化面板中填写数据 =&gt; Editor专用Json类 =&gt; Json数据源；Json数据源 =&gt; bytes数据源；bytes数据源 =&gt; 填充运行时对象。</p><h2 id="Odin"><a href="#Odin" class="headerlink" title="Odin"></a>Odin</h2><p>实现在Unity中，表格式的批量填写配置数据。数据依赖于Json数据源，可视化面板需要单独写一套。</p><h2 id="xNode"><a href="#xNode" class="headerlink" title="xNode"></a>xNode</h2><p>实现在Unity中，结点式的树形填写配置数据。数据依赖于Json数据源，可视化面板需要单独写一套。</p><p>要点小记：</p><p>1.比如<code>List&lt;int&gt;</code>类型外键，实现结点连接。<br>2.多个不同类型的buff实现结点。<br>3.如何全遍历图，输出json。</p><h1 id="完全基于数据驱动的xNode连点图"><a href="#完全基于数据驱动的xNode连点图" class="headerlink" title="完全基于数据驱动的xNode连点图"></a>完全基于数据驱动的xNode连点图</h1><p>不依赖于SerializableObj的数据持久化内的数据，每次打开图，全部清空，只根据json数据来重新绘制整张图。这样就能保证多种编辑方式（普通编辑器、连点编辑器、excel）修改同一主体后，保持数据一致。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>需要人为保障准确的，只有Graph的命名，因为这代表着要读取数据的文件路径。按照统一风格标准来命名即可。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ol><li>  根据命名去取对应路径下的json数据源文件，读取；</li><li>  获取依赖的其他json文件（比如skill下的buffList），读取；</li><li>  将所有取得的文件可视化成对应的Node；</li><li>  根据1中获取的信息，对图中Node进行连线。</li></ol><h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><p>一点是，xNode在这里的用途非常小，数据层已完全分离、存于硬盘，graph是打开绘制的也不依赖于SerializableObj；另一点是，xNode效率真的太低了，实时刷新造成结点一多就卡顿。</p><p><strong>所以其实应该基于odin（甚至直接脱离unity用wpf）自己写一套简单的数据可视化连点器</strong>，再去掉它的高频刷新。会比xNode实现轻便的多，画面板也更轻松。最后<strong>加上Timeline，行为树和状态机的模板</strong>，就可以复用了。</p><p><strong>另外，关于luban的使用方式上有一点改进</strong>。比如SKillCfg.BuffList并不需要以int[]的形式去写数据了，而是直接以BuffCfg[]的形式，因为luban是支持多态记录json的。不过由于luban和editor都是UnityMobaDemo搭建完技能系统后才引入的，本次作罢。</p><p>考虑以后采用的技术方案选择：</p><p>时间线编辑器：timline flux slate</p><p>可视化连点器：NodeGraphProcessor</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：Odin 可视化编辑器</title>
      <link href="/Tech/Game/tools/odin_study/"/>
      <url>/Tech/Game/tools/odin_study/</url>
      
        <content type="html"><![CDATA[<h1 id="可视化方案"><a href="#可视化方案" class="headerlink" title="可视化方案"></a>可视化方案</h1><h2 id="什么是Unity的可视化方案"><a href="#什么是Unity的可视化方案" class="headerlink" title="什么是Unity的可视化方案"></a>什么是Unity的可视化方案</h2><p>很多，直接举例一些。</p><h3 id="通用型"><a href="#通用型" class="headerlink" title="通用型"></a>通用型</h3><p>github开源：</p><ul><li>Node_Editor_Framework</li><li>xNode</li></ul><h3 id="特化型"><a href="#特化型" class="headerlink" title="特化型"></a>特化型</h3><p><strong>行为树</strong></p><ul><li>NodeCanvas</li><li>Behavior Designer</li></ul><p><strong>状态机</strong></p><ul><li>FlowCanvas</li><li>Bolt</li><li>PlayerMaker</li></ul><h2 id="行为树编辑器有什么作用"><a href="#行为树编辑器有什么作用" class="headerlink" title="行为树编辑器有什么作用"></a>行为树编辑器有什么作用</h2><ul><li>剧情（对话）编辑</li><li>AI编辑</li><li>技能编辑</li><li>碰撞关系编辑（纯数据，技能和单位是否可以碰撞）</li><li>装备合成路径编辑</li><li>其他</li></ul><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><ul><li>批量配置并不如Excel方便。</li><li>非常适合配合<strong>树状结构</strong>的数据。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>实现Excel和可视化编辑器之间的相互转化，会方便很多。</p><p>下面只进行odin的使用，不再对行为树、状态机一类的可视化插件进行关注。</p><h1 id="原生编辑器"><a href="#原生编辑器" class="headerlink" title="原生编辑器"></a>原生编辑器</h1><h2 id="精灵、List、字典"><a href="#精灵、List、字典" class="headerlink" title="精灵、List、字典"></a>精灵、List、字典</h2><p>show.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Show</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Sprite m_OriginSprite;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">int</span>&gt; m_OriginList</span> = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>&lt;<span class="title">int</span>, <span class="title">int</span>&gt; m_OriginDic</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Show_EditorExtension.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(Show))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Show_EditorExtension</span> : <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Show show = (Show) target;</span><br><span class="line">        show.m_OriginSprite = EditorGUILayout.ObjectField(<span class="string">&quot;这是一个精灵&quot;</span>, show.m_OriginSprite, <span class="keyword">typeof</span>(Sprite), <span class="literal">true</span>) <span class="keyword">as</span> Sprite;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;这是一个按钮&quot;</span>,GUILayout.Width(<span class="number">200</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;点击了按钮&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220220214646.png"></p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><h2 id="精灵、List、字典-1"><a href="#精灵、List、字典-1" class="headerlink" title="精灵、List、字典"></a>精灵、List、字典</h2><p>Show_EditorExtensionBasedOnOdin.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Show_EditorExtensionBasedOnOdin</span> : <span class="title">SerializedMonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">PreviewField</span>]</span><br><span class="line">    [<span class="meta">LabelText(<span class="meta-string">&quot;这是一个精灵&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">public</span> Sprite m_OriginSprite;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">int</span>&gt; m_OriginList</span> = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    [<span class="meta">LabelText(<span class="meta-string">&quot;这是一个字典&quot;</span>)</span>] </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>&lt;<span class="title">int</span>, <span class="title">int</span>&gt; m_OriginDic</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(<span class="meta-string">&quot;这是一个按钮&quot;</span>, 30), GUIColor(0.7f, 0.3f, 1.0f)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;点击了按钮。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220220215442.png"></p><h2 id="简单实现Window"><a href="#简单实现Window" class="headerlink" title="简单实现Window"></a>简单实现Window</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyHybridEditorWindowOne</span> : <span class="title">OdinEditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;My Game/My Hybrid Editor&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetWindow&lt;MyHybridEditorWindowOne&gt;().Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">EnumToggleButtons, BoxGroup(<span class="meta-string">&quot;Settings&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> ScaleMode ScaleMode;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">FolderPath(RequireExistingPath = true), BoxGroup(<span class="meta-string">&quot;Settings&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> OutputPath;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">HorizontalGroup(0.5f)</span>]<span class="comment">//占比0.5</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Texture&gt; InputTextures;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HorizontalGroup, InlineEditor(InlineEditorModes.LargePreview)</span>]</span><br><span class="line">    <span class="keyword">public</span> Texture Preview;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(ButtonSizes.Gigantic), GUIColor(0, 1, 0)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PerformSomeAction</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单实现Menu"><a href="#简单实现Menu" class="headerlink" title="简单实现Menu"></a>简单实现Menu</h2><ol><li>  继承OdinMenuEditorWindow</li><li>  使用OdinMenuTree中的<code>Add</code>和<code>AddAllAssetsAtPath</code>函数添加菜单。</li></ol><p><strong>Add：</strong> 设置菜单名称并传入对应需要渲染的类</p><p><strong>AddAllAssetsAtPath：</strong>设置菜单名称，传入路径，示例中的第一个bool是指是否包含子路径，第二bool表示是否子路径的所有可用类都在一个层级中渲染，也就是要不要分Menu子选项。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyMenuEditorWindow</span> : <span class="title">OdinMenuEditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;My Game/My Menu Editor&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetWindow&lt;MyMenuEditorWindow&gt;().Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> OdinMenuTree <span class="title">BuildMenuTree</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tree = <span class="keyword">new</span> OdinMenuTree();</span><br><span class="line">        tree.Selection.SupportsMultiSelect = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        tree.Add(<span class="string">&quot;Settings&quot;</span>, GeneralDrawerConfig.Instance);</span><br><span class="line">        tree.Add(<span class="string">&quot;Utilities&quot;</span>, <span class="keyword">new</span> TextureUtilityEditor());</span><br><span class="line">        tree.AddAllAssetsAtPath(<span class="string">&quot;Odin Settings&quot;</span>, <span class="string">&quot;Assets/Plugins/Sirenix&quot;</span>, <span class="keyword">typeof</span>(ScriptableObject), <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TextureUtilityEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BoxGroup(<span class="meta-string">&quot;Tool&quot;</span>), HideLabel, EnumToggleButtons</span>]</span><br><span class="line">    <span class="keyword">public</span> Tool Tool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Texture&gt; Textures;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(ButtonSizes.Large), HideIf(<span class="meta-string">&quot;Tool&quot;</span>, Tool.Rotate)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeAction</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(ButtonSizes.Large), ShowIf(<span class="meta-string">&quot;Tool&quot;</span>, Tool.Rotate)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeOtherAction</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="xNode插件"><a href="#xNode插件" class="headerlink" title="xNode插件"></a>xNode插件</h1><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><h1 id="odin与luban-导表工具-结合"><a href="#odin与luban-导表工具-结合" class="headerlink" title="odin与luban(导表工具)结合"></a>odin与luban(导表工具)结合</h1><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>luban 生成编辑器专用类型代码 =&gt; 编辑器中制作生成原始数据 json（编译器读存专用） =&gt; luban 处理json，导出成 运行时用的bytes 或 运行时用的json =&gt; 程序使用。</p><p>也就是说，每一个Cfg类型，如果想要在编辑器中调试，需要额外准备一套类型代码（继承自 EditorBeanBase，luban可以生成），与运行时中使用的类型相同。</p><ol><li>写[xml/excel]定义数据类型</li><li>[xml/excel]生成Editor专用class类型，对其代码进行标签处理（odin在这里派上用场，美化编辑器页面）</li><li>——————————-以下为需要重复的操作——————————-</li><li>使用Editor生成json数据 / 使用Editor读取json文件</li><li>json数据 + [xml/excel] 生成bytes数据</li><li>bytes数据作为运行时配置</li></ol><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>这一套工作流，我已经写成了一个简单的示例。</p><p>开源地址：<a href="https://github.com/CodingCodingK/odin_study">https://github.com/CodingCodingK/odin_study</a></p><p>在这里感谢一下luban作者！教了我很多关于工作流搭建的思路和为什么这么做。</p><h1 id="手册收藏"><a href="#手册收藏" class="headerlink" title="手册收藏"></a>手册收藏</h1><p>方便自己写的时候查询。</p><p><a href="https://www.jianshu.com/p/a37bd00d12f2">非常全面的中文教程</a></p><p><a href="https://odininspector.com/attributes">odin官方手册</a></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 背包系统篇</title>
      <link href="/Project/Unity/Moba/HOK/bag/"/>
      <url>/Project/Unity/Moba/HOK/bag/</url>
      
        <content type="html"><![CDATA[<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>数据库中只存储物品id、物品数量；客户端本地二进制式存储cfg，来显示物品详情；服务端本地二进制式存储cfg，来确定物品效果。</p><p>整体流程如下：</p><ol><li>  客户端登录时，获取到背包信息（物品id、物品数量）。</li><li>  客户端打开背包时，根据内存中的背包信息 + 本地cfg，来展示物品。</li><li>  客户端使用物品时，发送请求到服务端并让服务端在数据库验证数量。</li><li>  如果数量不足，则失败；</li><li>  如果数量足够，则根据服务端本地cfg来计算出账号收益，更新数据库后返回结果给客户端。</li><li>  客户端获得返回结果，刷新内存数据。</li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>  虚拟列表</li><li>  对象池</li><li>  异步加载</li></ul><h1 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h1><h2 id="Scroller-View"><a href="#Scroller-View" class="headerlink" title="Scroller View"></a>Scroller View</h2><p>Viewport，遮罩，决定能看到的内容。（视野）</p><p>Content，真实内容。（履带）</p><p>设置格子锚点到左上角。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>主要分为3块。</p><ul><li>  BagMgr，用来获取道具信息。</li><li>  BagItem，背包格子类。</li><li>  BagPanel，背包页面逻辑。</li></ul><h2 id="显式获取"><a href="#显式获取" class="headerlink" title="显式获取"></a>显式获取</h2><p>要计算出 起始显示的格子索引值、结束显示的格子索引值：</p><p>=====================================================================</p><p>  <strong>可视范围的起始位置Y</strong> / 一个格子的高 = 可视范围中，起始显示的是哪一行（向下取整），</p><p>  可视范围中，起始显示的是哪一行 * 一行有多少格子 = <strong>起始显示的格子索引值</strong>，</p><p>  用同样的方法，根据<strong>可视范围的结束位置Y</strong>也可以计算出<strong>结束显示的格子索引值</strong>。</p><p>=====================================================================</p><p>将上面计算出来的索引值取下来记录，放到 Dictionary&lt;int索引,格子对象&gt; 里。这些就是画面正要显示的格子们。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220215101132.png"></p><h2 id="格子位置确定"><a href="#格子位置确定" class="headerlink" title="格子位置确定"></a>格子位置确定</h2><p>物品位置确定。通过简单计算获得：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index是物品下标, oneRowColumns是一行几个, childWidth是格子宽度, paddingWidth是格子横向间隔</span></span><br><span class="line">go.transform.localPosition = <span class="keyword">new</span> Vector3((index % oneRowColumns) * (childWidth + paddingWidth), - (index / oneRowColumns) * (childHeight + paddingHeight),<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="未显示就不加载的虚拟列表"><a href="#未显示就不加载的虚拟列表" class="headerlink" title="未显示就不加载的虚拟列表"></a>未显示就不加载的虚拟列表</h2><p>显式获取 + 格子位置确定 就可以实现。</p><h1 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h1><p>在上面<strong>未显示就不加载的虚拟列表</strong>的实现基础上，进行优化。</p><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>对物品进行对象池管理，加载从池中取，销毁就返回池。</p><h2 id="去掉加载过、现在不显示的物品"><a href="#去掉加载过、现在不显示的物品" class="headerlink" title="去掉加载过、现在不显示的物品"></a>去掉加载过、现在不显示的物品</h2><p>在update中调用刷新物品方法，</p><p>计算显示下标 =&gt; 根据本次下标范围与上次记录下来的下标范围，算出哪些不再显示 =&gt; 把他们放回对象池。</p><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><p>将<strong>异步加载</strong>的过程<strong>放入协程</strong>中执行。</p><p>简单地说就是一帧不加载完物品，至少是2帧，异步加载成功后触发回调。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步加载协程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">AsyncLoad</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> path, UnityAction&lt;T&gt; callBack</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        ResourceRequest rr = Resources.LoadAsync&lt;T&gt;(path);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> rr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rr.asset <span class="keyword">is</span> GameObject)</span><br><span class="line">        &#123;</span><br><span class="line">            callBack?.Invoke(GameObject.Instantiate&lt;T&gt;(rr.asset <span class="keyword">as</span> T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            callBack?.Invoke(rr.asset <span class="keyword">as</span> T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>demo已上传<a href="https://github.com/CodingCodingK/bag_study">github</a>。</p><h1 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h1><p>实际项目使用更为复杂。这里只展示一下实现了什么。</p><ul><li>  物品数量数据库存储：使用字符串标记，规则<code>物品id:数量</code>类似于<code>1:2#3:1#5:10</code>。</li><li>  物品选择状态显示：简单业务实现。</li><li>  服务端物品检测：数据处理使用服务端本地cfg读表，避免客户端作弊。</li><li>  二进制读表：luban 二进制读表，在加载流程中读取物品配置。</li><li>  优化：虚拟列表 + 对象池。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Enum转换List</title>
      <link href="/Tech/CSharp/experience/20220209_1/"/>
      <url>/Tech/CSharp/experience/20220209_1/</url>
      
        <content type="html"><![CDATA[<h1 id="EnumToList"><a href="#EnumToList" class="headerlink" title="EnumToList"></a>EnumToList</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">EnumToList</span>&lt;<span class="title">T</span>&gt;(<span class="params">Type enumType</span>) <span class="keyword">where</span> T : ComboBoxSourceItem, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (enumType.BaseType == <span class="keyword">typeof</span>(System.Enum))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> enumValue <span class="keyword">in</span> System.Enum.GetValues(enumType))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 値の説明を取得する</span></span><br><span class="line">                    FieldInfo fi = enumType.GetField(System.Enum.GetName(enumType, enumValue));</span><br><span class="line">                    <span class="keyword">if</span> (fi != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> description =</span><br><span class="line">                            (DescriptionAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(DescriptionAttribute));</span><br><span class="line">                        <span class="keyword">var</span> content =</span><br><span class="line">                            (DefaultValueAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(DefaultValueAttribute));</span><br><span class="line">                        <span class="keyword">var</span> code = (CodeAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(CodeAttribute));</span><br><span class="line">                        <span class="keyword">var</span> descriptionEn =</span><br><span class="line">                            (DescriptionEnAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(DescriptionEnAttribute));</span><br><span class="line">                        <span class="keyword">var</span> isKarte =</span><br><span class="line">                            (IsKarteAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(IsKarteAttribute));</span><br><span class="line">                        <span class="keyword">var</span> isIji =</span><br><span class="line">                            (IsIjiAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(IsIjiAttribute));</span><br><span class="line"></span><br><span class="line">                        T obj = <span class="keyword">new</span> T();</span><br><span class="line">                        obj.Content = content?.Value.ToString() ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.Value = Convert.ToInt32(enumValue);</span><br><span class="line">                        obj.Description = description?.Description ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.DescriptionEn = descriptionEn?.DescriptionEn ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.Code = code?.Code ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.IsKarte = isKarte?.IsKarte ?? <span class="literal">false</span>;</span><br><span class="line">                        obj.IsIji = isIji?.IsIji ?? <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                        result.Add(obj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> 一些坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：本地配置</title>
      <link href="/Tech/Game/tools/luban_study/"/>
      <url>/Tech/Game/tools/luban_study/</url>
      
        <content type="html"><![CDATA[<p>非常感谢 luban 的作者，提供了如此好用的工具，并热心的教了我很多关于实际工作流的思路，对于我来说，这些都是很宝贵的。</p><h1 id="初识luban"><a href="#初识luban" class="headerlink" title="初识luban"></a>初识luban</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>就目前我的使用来说，luban可以用于excel导出配置数据、可以用于生成proto协议（并使用Bright.Net的序列化框架）、可以用于编辑器交互、可以用于编辑器数据源与运行时真实配置数据交互。是一个各方面都非常成熟的配置文件、通信协议的解决方案。</p><p>开源地址 ： <a href="https://github.com/focus-creative-games/luban">github</a></p><p>案例开源地址：<a href="https://github.com/focus-creative-games/luban_examples">github</a></p><blockquote><p>luban高效地处理游戏开发中常见的excel、json、xml之类的数据，检查数据错误，生成c#等各种语言的代码，导出成bytes或json等多种格式。</p><ul><li>强大的数据解析和转换能力 {excel(csv,xls,xlsx), json, bson, xml, yaml, lua, unity ScriptableObject} =&gt; {binary, json, bson, xml, lua, yaml, erlang}</li><li>增强的excel格式，可以简洁地配置出像简单列表、子结构、结构列表，以及任意复杂的深层次的嵌套结构。</li><li>完备的类型系统，<strong>支持OOP类型继承</strong>，搭配excel、json、lua、xml等格式数据<strong>灵活优雅</strong>表达行为树、技能、剧情、副本之类复杂GamePlay数据</li><li>支持生成 protobuf(schema + binary + json)、flatbuffers(schema + json)、msgpack(binary)</li><li>强大的数据校验能力。ref引用检查，path资源路径检查等等</li><li>支持生成c#,java,go,c++,lua,python,javascript,typescript,erlang,rust代码</li><li>完善的本地化支持</li><li>强大灵活的自定义能力，支持代码模板和数据模板</li><li>**==通用型生成和缓存工具==**。也可以用于生成协议、数据库之类的代码，甚至可以用作对象缓存服务</li><li><strong>良好支持主流引擎、全平台、主流热更新方案、主流前后端框架</strong>。支持unity、unreal、cocos2x、微信小游戏等主流引擎。工具自身跨平台，能在Win,Linux,Mac平台良好工作。<a href="https://focus-creative-games.github.io/lubandoc/feature.html#%E6%94%AF%E6%8C%81%E4%B8%BB%E6%B5%81%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80">详见</a></li></ul></blockquote><h1 id="配置第一个Unity项目"><a href="#配置第一个Unity项目" class="headerlink" title="配置第一个Unity项目"></a>配置第一个Unity项目</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>1.下载<a href="https://dotnet.microsoft.com/en-us/download/dotnet/6.0">.net 6.0 sdk</a>。</p><p>2.下载案例luban_examples。</p><p>3.创建Unity工程，从luban_examples\Projects的Csharp_Unity_json中复制 <strong>luban_Libs</strong>目录到Unity Assets工程下。</p><p>4.在Project Settings菜单的Player里，设置开启unsafe。</p><p>5.从luban_examples\Tools复制 <strong>Luban.ClientServer工具库</strong> 和 <strong>MiniDesignerConfigsTemplate文件夹</strong> 到Unity工程（不能放到Assets！这个不是给Unity加载的所以其实放外面都行）下。</p><h2 id="6-配置bat文件"><a href="#6-配置bat文件" class="headerlink" title="6.配置bat文件"></a>6.配置bat文件</h2><p>从luban_examples\Projects的Csharp_Unity_json中复制 <strong>gen_code_json.bat 文件</strong> 到5中的同级目录。之后开始编辑bat文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> WORKSPACE=.. -- unity工程目录地址</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> GEN_CLIENT=%WORKSPACE%\Luban\Luban.ClientServer\Luban.ClientServer.exe -- 运行exe文件地址</span><br><span class="line"><span class="built_in">set</span> CONF_ROOT=%WORKSPACE%\Luban\MiniDesignerConfigsTemplate -- 自己的配置表的根目录地址</span><br><span class="line"></span><br><span class="line">%GEN_CLIENT% -j cfg --^</span><br><span class="line"> -d %CONF_ROOT%\Defines\__root__.xml ^</span><br><span class="line"> --input_data_dir %CONF_ROOT%\Datas ^ -- 配置表目录地址</span><br><span class="line"> --output_code_dir %WORKSPACE%/Assets/Gen ^ -- 配置表输出地址</span><br><span class="line"> --output_data_dir ..\GenerateDatas\json ^</span><br><span class="line"> --gen_types code_cs_unity_json,data_json ^</span><br><span class="line"> -s all </span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="7-配置表"><a href="#7-配置表" class="headerlink" title="7.配置表"></a>7.配置表</h2><p>上面CONF_ROOT的地址里就是我们的工作文件夹，这里采用案例的 MiniDesignerConfigsTemplate文件夹，在里面的Datas文件夹里有已经做好excel表格案例。</p><h2 id="8-执行bat文件并调用"><a href="#8-执行bat文件并调用" class="headerlink" title="8.执行bat文件并调用"></a>8.执行bat文件并调用</h2><p>调用后生成的就是json了，可以直接用。下面简单使用一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Tables table = <span class="keyword">new</span> Tables(Loader);</span><br><span class="line">    Item item = table.TbItem.Get(<span class="number">10010</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;<span class="subst">&#123;item.Name&#125;</span>    <span class="subst">&#123;item.Desc&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JSONNode <span class="title">Loader</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JSON.Parse(File.ReadAllText(Application.dataPath + <span class="string">&quot;/../GenerateDatas/json/&quot;</span> + fileName + <span class="string">&quot;.json&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="excel基本：自定义类型"><a href="#excel基本：自定义类型" class="headerlink" title="excel基本：自定义类型"></a>excel基本：自定义类型</h1><p>从小到大：enum &gt; bean &gt; table。</p><h2 id="enums"><a href="#enums" class="headerlink" title="enums"></a>enums</h2><p>自定义枚举enum。</p><ul><li>full_name，必选。枚举名。命名空间为当前module的完整命名空间（包含父module）。</li><li>flags，可选。是否为bit标志位类型。默认false。</li><li>unique，可选。枚举值是否唯一。默认true。</li><li>comment，可选。注释。</li><li>var.name，必选。枚举名。</li><li>var.alias，可选。别名。</li><li>var.value，可选。枚举值，不填则为上一个枚举项目值+1。</li><li>var.comment，可选。注释。</li><li>可以填枚举的 枚举项名，别名 或者 相应整数值 表达这个枚举。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210002955.png"></p><h2 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h2><p>自定义class，也就是数据表每行的结构。</p><ul><li>full_name，必选。结构（类）名，包含命名空间。</li><li>sep，可选。分割符。该结构以复合模式填写，例如MyIntVector3包含x,y,z三个int字段，通过sep=”,”，则所有读取MyIntVector3时，都会将读入的字符串用<code>,</code>拆分成三个整数。</li><li>var.name，必选。字段名。</li><li>var.type，必选。类型名。</li><li>var.group，可选。所属分组。可以多个，以<code>,</code>分割，每个值必须是root.xml中定义的group中的一个；如果不填，则该字段属于所有分组。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210003206.png"></p><h2 id="tables"><a href="#tables" class="headerlink" title="tables"></a>tables</h2><p>数据索引表，将excel们联系起来。只有记载在本表的文件，才会被输出。</p><ul><li>define_from_file，必选。false是取已有定义（也就是类型写在beans.excel里了）；true是取未有定义，也就是直接根据数据表的表头、标题等自动生成定义。</li><li>full_name，必选。资源字典全名(包含模块和名字)，一般习惯取名<code>TbXXX</code>，以后调用的时候就直接<code>table.TbXXX.Get(key);</code>来获取到资源。</li><li>value_type，必选。生成的类名，也是全名，要包含namespace。如果需要读取beans表里定义好的类型，那必须与那边的 namespace.类名 完全一致。</li><li>input，必选。文件列表，也就是数据表的地址。</li><li>index，可选。就是<code>table.TbXXX.Get(key);</code>的key，不写默认是类型第一个字段。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210003331.png"></p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>这个就是数据了，表的名字就是类名。</p><ul><li>前三行分别填写 字段名、字段类型、字段中文注释，后面的行就是数据了。</li><li>可以根据数据表直接生成对应的类结构，并不是必须要写beans表，只要table表里设置define_from_file就好。</li><li>对于枚举值，可以填枚举的 <strong>枚举项名，别名 或者 相应整数值</strong> 表达这个枚举。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210003523.png"></p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> cfg;</span><br><span class="line"><span class="keyword">using</span> cfg.Datas; </span><br><span class="line"><span class="keyword">using</span> SimpleJSON;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Tables table = <span class="keyword">new</span> Tables(Loader);</span><br><span class="line">        Equip equip = table.Weapon.Get(<span class="number">1</span>);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;equip.Name&#125;</span>    <span class="subst">&#123;equip.Color&#125;</span>    <span class="subst">&#123;equip.Quality&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JSONNode <span class="title">Loader</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.Parse(File.ReadAllText(Application.dataPath + <span class="string">&quot;/../GenerateDatas/json/&quot;</span> + fileName + <span class="string">&quot;.json&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weapon.json</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;眼球&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;次元碎片&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">120</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;无限&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">999</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">999</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;塔拉夏的眼球&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;眼光&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;NPC赌来的法杖&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">120</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="excel进阶：List与关联外键"><a href="#excel进阶：List与关联外键" class="headerlink" title="excel进阶：List与关联外键"></a>excel进阶：List与关联外键</h1><p>光上面这样是不够的，我研究了一下手册，根据自己的项目需求整理了最合适的方案来解决List和外键的连接。不得不说，luban真的好用。</p><h2 id="List与关联外键"><a href="#List与关联外键" class="headerlink" title="List与关联外键"></a>List与关联外键</h2><h3 id="excel配置"><a href="#excel配置" class="headerlink" title="excel配置"></a>excel配置</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212193619.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212194113.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212194245.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212194348.png"></p><h3 id="生成-json"><a href="#生成-json" class="headerlink" title="生成 json"></a>生成 json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;眼球&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">&quot;Skill&quot;</span>: [</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"> ... <span class="comment">// 后面略了</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>和前面一样方法，json加载全表。使用的时候，有一个<code>equip.Skill_Ref</code>，这个Ref就是外键加载进来的<code>List&lt;Skills.SkillCfg&gt;</code>类型数据。</p><h2 id="分隔符sep"><a href="#分隔符sep" class="headerlink" title="分隔符sep"></a>分隔符sep</h2><p><code>list,string</code> =&gt; <code>  (list#sep=,),string</code></p><h1 id="excel进阶：使用luban生成protobuf协议并接上自己的网络库"><a href="#excel进阶：使用luban生成protobuf协议并接上自己的网络库" class="headerlink" title="excel进阶：使用luban生成protobuf协议并接上自己的网络库"></a>excel进阶：使用luban生成protobuf协议并接上自己的网络库</h1><h2 id="1-准备xml"><a href="#1-准备xml" class="headerlink" title="1.准备xml"></a>1.准备xml</h2><p><strong>luban的root配置</strong></p><p><code>__root__.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">topmodule</span> <span class="attr">name</span>=<span class="string">&quot;proto&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">name</span>=<span class="string">&quot;.&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;client&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefix</span> <span class="attr">value</span>=<span class="string">&quot;proto&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;server&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefix</span> <span class="attr">value</span>=<span class="string">&quot;proto&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>protobuf协议</strong>（不是最佳实践，CMD可以去掉，因为会生成协议号）：</p><p><code>test.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">&quot;CMD&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;None&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;Ping&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;ReqLogin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;RspLogin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">enum</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;Ping&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;isOver&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bool&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;ReqLogin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;acct&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;psd&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;RspLogin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span> <span class="attr">type</span>=<span class="string">&quot;list,LoginInfo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;LoginInfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;lv&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;exp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">proto</span> <span class="attr">name</span>=<span class="string">&quot;NetMsg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;cmd&quot;</span> <span class="attr">type</span>=<span class="string">&quot;CMD?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;ping&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Ping?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;reqLogin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ReqLogin?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;rspLogin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;RspLogin?&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proto</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-配置bat文件"><a href="#2-配置bat文件" class="headerlink" title="2.配置bat文件"></a>2.配置bat文件</h2><p>注意这么写的话，protobuf的xml 和 root.xml 需要放一块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> WORKSPACE=..</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> GEN_CLIENT=%WORKSPACE%\Luban\Luban.ClientServer\Luban.ClientServer.exe</span><br><span class="line"><span class="built_in">set</span> PROTO_ROOT=%WORKSPACE%\Luban\MiniDesignerConfigsTemplate\ProtoDefines</span><br><span class="line"></span><br><span class="line">%GEN_CLIENT% -j proto --^</span><br><span class="line"> -d %PROTO_ROOT%\__root__.xml ^</span><br><span class="line"> --output_code_dir %WORKSPACE%\Assets\Gen ^</span><br><span class="line"> --gen_type cs ^</span><br><span class="line"> --cs:use_unity_vector ^</span><br><span class="line"> -s all </span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="3-迁移unity"><a href="#3-迁移unity" class="headerlink" title="3.迁移unity"></a>3.迁移unity</h2><p>代码生成完毕后，Unity会显示缺失很多文件。把<code>luban_examples-main\ProtoProjects\Csharp_Unity\Assets</code>下的三个文件夹移到Unity目录下。</p><p>分别是：Bright.Core Bright.Net Bright.Serialization。</p><p>这是luban所依赖的protobuf序列化器。</p><h2 id="4-简单实用示例"><a href="#4-简单实用示例" class="headerlink" title="4.简单实用示例"></a>4.简单实用示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ProtoSerialize</span>&lt;<span class="title">T</span>&gt;(<span class="params">T msg</span>) <span class="keyword">where</span> T : Protocol,<span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> bf = <span class="keyword">new</span> ByteBuf();</span><br><span class="line">    msg.Serialize(bf);</span><br><span class="line">    <span class="keyword">return</span> bf.CopyData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">ProtoDeSerialize</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">byte</span>[] bytes</span>) <span class="keyword">where</span> T : Protocol, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> bf = <span class="keyword">new</span> ByteBuf(bytes);</span><br><span class="line">    T instance = <span class="keyword">new</span> T();</span><br><span class="line">    instance.Deserialize(bf);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-接上自己的网络库"><a href="#5-接上自己的网络库" class="headerlink" title="5.接上自己的网络库"></a>5.接上自己的网络库</h2><p>我自己的kcp网络库使用了这一套东西，替换了protobuf-net。开源地址：</p><p><a href="https://github.com/CodingCodingK/CodingK_Session">https://github.com/CodingCodingK/CodingK_Session</a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="bat命令"><a href="#bat命令" class="headerlink" title="bat命令"></a>bat命令</h2><p>禁止名字优化：</p><p> –naming_convention:module none  ^<br> –naming_convention:bean_member none  ^<br> –naming_convention:enum_member none  ^</p><p>二进制data+cs生成类型：</p><p> –gen_types code_cs_bin,data_bin ^</p><p>其他：<a href="https://focus-creative-games.github.io/lubandoc/command_tools.html#luban-client-%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">github手册</a></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>直接去luban_examples-main文件夹里拷贝bat吧！</p><h1 id="二进制配置文件优化"><a href="#二进制配置文件优化" class="headerlink" title="二进制配置文件优化"></a>二进制配置文件优化</h1><h2 id="原理部分"><a href="#原理部分" class="headerlink" title="原理部分"></a>原理部分</h2><p>原理部分，写在<a href="https://codingcodingk.top/Tech/Game/serialize/">另外一篇</a>里了。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 网络库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：定时系统</title>
      <link href="/Tech/Game/tools/CodingKTimer/"/>
      <url>/Tech/Game/tools/CodingKTimer/</url>
      
        <content type="html"><![CDATA[<h1 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h1><p><a href="https://github.com/CodingCodingK/CodingKTimer">CodingKTimer</a></p><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="为什么需要定时系统"><a href="#为什么需要定时系统" class="headerlink" title="为什么需要定时系统"></a>为什么需要定时系统</h2><p>Unity侧：</p><ol><li>  简化协程计时写法。</li><li>  协程基于Monobehaviour来实现，而物体激活属性变化会导致中断调用。这可由定时器解决。</li><li>  不需要依赖于unityAPI。</li></ol><p>服务端侧：</p><p>​       简化代码 =&gt; 支持多线程、指定线程。</p><h1 id="三种定时器"><a href="#三种定时器" class="headerlink" title="三种定时器"></a>三种定时器</h1><h2 id="TickTimer-高频高精度的毫秒级定时"><a href="#TickTimer-高频高精度的毫秒级定时" class="headerlink" title="TickTimer (高频高精度的毫秒级定时)"></a>TickTimer (高频高精度的毫秒级定时)</h2><ul><li>  支持多线程；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  可使用外部循环驱动计时，也可使用驱动线程（内部new的）来执行；</li><li>  定时回调默认是线程池工作线程运行，也就是在<strong>驱动线程</strong>中运行，也可<strong>外部自己驱动Handle</strong>运行；</li></ul><p>内部使用线程安全字典ConcurrentDictionary来存储Task，遍历过程中Remove无影响。</p><h3 id="调用线程"><a href="#调用线程" class="headerlink" title="调用线程"></a>调用线程</h3><p>线程可以使用新工作线程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用新线程：</span></span><br><span class="line">timerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(StartTick));</span><br><span class="line">timerThread.Start();</span><br></pre></td></tr></table></figure><p>也可以在Unity的Update中调用计时器内部 UpdateTask() 方法，确定性地使用Unity主线程。</p><p>另外还有一种方式就是自己调用<strong>Handle</strong>，也可以确定性地使用外部线程（比如Unity主线程）来执行任务：</p><ol><li><p>内部的新工作线程不再负责执行任务，而是对一个 线程安全队列 进行任务添加。</p></li><li><p>在<strong>外部 调用HandleTask()方法</strong> 来执行 内部队列 中的任务。</p></li></ol><h2 id="AsyncTimer-大量并发任务的定时"><a href="#AsyncTimer-大量并发任务的定时" class="headerlink" title="AsyncTimer (大量并发任务的定时)"></a>AsyncTimer (大量并发任务的定时)</h2><ul><li>  支持多线程；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  使用 async await异步语法计时，运行在线程池中；</li><li>  定时回调可以在驱动线程中运行，也可在外部 Handle 运行</li></ul><h3 id="时间修正"><a href="#时间修正" class="headerlink" title="时间修正"></a>时间修正</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">task.fixDelta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 限次循环任务</span></span><br><span class="line">     --task.count;</span><br><span class="line">     ++task.loopIndex;</span><br><span class="line">     <span class="comment">// ③ 修正误差</span></span><br><span class="line">     <span class="built_in">int</span> delay = (<span class="built_in">int</span>)(task.delay + task.fixDelta);</span><br><span class="line">     <span class="keyword">if</span> (delay &gt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(delay, task.ct);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// ① 计算出实际开销时间</span></span><br><span class="line">     TimeSpan ts = DateTime.UtcNow - task.startTime;</span><br><span class="line">     <span class="comment">// ② 修正实际时间值 = 理论开销时间 - 实际开销时间</span></span><br><span class="line">     task.fixDelta = (<span class="built_in">int</span>)(task.delay * task.loopIndex - ts.TotalMilliseconds);</span><br><span class="line"></span><br><span class="line">     CallBackTaskCB(task);</span><br><span class="line">&#125; <span class="keyword">while</span> (task.count &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>由于delay的累加会出现问题（主要是因为执行代码本身需要时间），导致出现 真实运行时间 与 逻辑运行时间 有偏差，所以需要修正每次delay的值从而保证真实运行时间。</p><p>比如14:00:00起了个定时任务，delay为1小时，结果15:00:00的时候开始执行任务，任务本身花掉了10s，那么就变成14:00:10的时候去+了一小时的delay。下一次执行就变成16:00:10了而不是计划中的16:00:00。用delta修正即可。</p><h2 id="FrameTimer-主要用于逻辑帧数的定时"><a href="#FrameTimer-主要用于逻辑帧数的定时" class="headerlink" title="FrameTimer (主要用于逻辑帧数的定时)"></a>FrameTimer (主要用于逻辑帧数的定时)</h2><ul><li>  只可在单线程当中运行；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  只能由外部循环驱动计数；</li><li>  定时回调只可以在驱动线程中运行；</li></ul><p>内部不创建线程计时，只能外部驱动。内部没有时间概念，<strong>完全不再计时只计数</strong>。</p><p>在服务端中或和客户端中，按自己的执行帧来每次调用，调用一次算一帧。其实就相当于只有前面两种Timer的Handle方法。</p><p>delay不再是时间，而是帧数。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 定时系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：protobuf序列化</title>
      <link href="/Tech/Game/tools/protobuf/"/>
      <url>/Tech/Game/tools/protobuf/</url>
      
        <content type="html"><![CDATA[<h1 id="Protobuf-初识"><a href="#Protobuf-初识" class="headerlink" title="Protobuf 初识"></a>Protobuf 初识</h1><h2 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h2><blockquote><p>  Google Protocol Buffers(简单Protobuf或PB) 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关 、可扩展的序列化结构数据格式 。目前，几乎支持所有主流编程语言 。</p></blockquote><p>他和xml、json一样，都属于数据标记语言。</p><h2 id="Protobuf优势"><a href="#Protobuf优势" class="headerlink" title="Protobuf优势"></a>Protobuf优势</h2><ol><li>  序列化与反序列化速度极快。</li><li>  与语言及平台无关，兼容性好，通过 proto文件生成多种语言文件 =&gt; 实现 服务端、客户端之间 跨语言平台的数据转换。</li><li>  数据高度压缩 =&gt; 占用空间少，节省带宽。</li></ol><h2 id="Protobuf使用"><a href="#Protobuf使用" class="headerlink" title="Protobuf使用"></a>Protobuf使用</h2><p><a href="https://github.com/protocolbuffers/protobuf">google官方全版本支持</a></p><p><a href="https://github.com/protobuf-net/protobuf-net">.net专用版本 作者Marc Gravell(本篇使用)</a></p><h2 id="Protobuf对比C-常规序列化"><a href="#Protobuf对比C-常规序列化" class="headerlink" title="Protobuf对比C#常规序列化"></a>Protobuf对比C#常规序列化</h2><p><strong>标签不同</strong>，常规只需要对类打上<code>[Serializable]</code>，而Protobuf需要对类打上<code>[ProtoContract]</code>，再对属性打上<code>[ProtoMember(1)]</code>，中间的数字是tag对应一个属性。</p><p><strong>调用不同</strong>，常规需要 Stream 配合 BinaryFormatter 来实现，protobuf的话是 Stream 配合 ProtoBuf.Serializer：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProtoBuf Serialize</span></span><br><span class="line"><span class="built_in">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    ProtoBuf.Serializer.Serialize(ms, person);</span><br><span class="line">    bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[ms.Length];</span><br><span class="line">    Buffer.BlockCopy(ms.GetBuffer(), <span class="number">0</span>, bytes, <span class="number">0</span>, (<span class="built_in">int</span>)ms.Length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoBuf DeSerialize</span></span><br><span class="line">PersonInfo newPerson = <span class="keyword">new</span> PersonInfo();</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream(bytes))</span><br><span class="line">&#123;</span><br><span class="line">    newPerson = ProtoBuf.Serializer.Deserialize&lt;PersonInfo&gt;(ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoBuf 本地存储读取</span></span><br><span class="line">PersonInfo newPerson_file = <span class="keyword">new</span> PersonInfo();</span><br><span class="line"><span class="keyword">using</span> (FileStream file = File.Create(<span class="string">&quot;person.bytes&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ProtoBuf.Serializer.Serialize(file, person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (FileStream file = File.OpenRead(<span class="string">&quot;person.bytes&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    newPerson_file = ProtoBuf.Serializer.Deserialize&lt;PersonInfo&gt;(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节量大幅优化</strong>，对2种bytes都进行输出，简单使用能直接缩10倍以上：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220201211810.png"></p><h2 id="需求提纯"><a href="#需求提纯" class="headerlink" title="需求提纯"></a>需求提纯</h2><p>那么最后，我们要做什么？</p><ol><li>使用protobuf通信，且<strong>自动化解决</strong>最基础的打标签方式，因为那太过繁琐。</li><li>需要<strong>支持多平台</strong>，所以直接排除<code>[Serializable]</code>。</li></ol><h1 id="Protobuf-网络通信解决方案"><a href="#Protobuf-网络通信解决方案" class="headerlink" title="Protobuf 网络通信解决方案"></a>Protobuf 网络通信解决方案</h1><h2 id="1-制定协议"><a href="#1-制定协议" class="headerlink" title="1.制定协议"></a>1.制定协议</h2><h2 id="2-获取工具"><a href="#2-获取工具" class="headerlink" title="2.获取工具"></a>2.获取工具</h2><p>在 <a href="https://github.com/protobuf-net/protobuf-net">.net专用版本 作者Marc Gravell(本篇使用)</a> 中，编译源码获取 <strong>protoc.exe</strong> 和 压缩包中的 <strong>protogen.exe</strong> 两个文件。</p><h2 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3.生成代码"></a>3.生成代码</h2><h3 id="定义文件-proto"><a href="#定义文件-proto" class="headerlink" title="定义文件  .proto"></a>定义文件  .proto</h3><p><strong>相当于把之前C#实现的整个协议重写一遍。建议使用IDE VSCode来检查语法。</strong></p><p>syntax - 使用proto    package - 定义头文件名</p><p>message - 类    enum - 枚举类</p><p>required - 必须的    optional - 非必须的    repeated - 重复的，用于List</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> LogicProtocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum写法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CMD</span> </span>&#123;</span><br><span class="line">    LogicLogin = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据包写法(支持嵌套类)</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Pkg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> Head head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> Body body = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> CMD cmd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> seq = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> error = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> ReqLogicLogin reqLogicLogin = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> RspLogicLogin rspLogicLogin = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用工具-protogen-exe"><a href="#使用工具-protogen-exe" class="headerlink" title="使用工具 protogen.exe"></a>使用工具 protogen.exe</h3><p>protoc.exe也可以用于生成c#代码，但是数据更多，所以直接使用protogen.exe。</p><ol><li>cmd进入对应路径。</li><li>可以使用<code>protogen -h</code>命令来获取命令help。</li><li>输入指令<code>.\soft\protogen.exe --csharp_out=.\ .\NetProtocol.proto</code>来生成代码。</li></ol><p>指令解析：</p><ul><li>.\soft\protogen.exe 工具位置</li><li>–csharp_out=.\ 输出位置</li><li>.\NetProtocol.proto 文件位置</li></ul><h2 id="4-对比cs和proto协议区别"><a href="#4-对比cs和proto协议区别" class="headerlink" title="4.对比cs和proto协议区别"></a>4.对比cs和proto协议区别</h2><p>proto中的package转换成 <code>namespace</code>。</p><p>为每一个class和enum打上标签 <code>[global::ProtoBuf.ProtoContract()]</code>。括号里面是反射时识别的类名，不写就直接是类名。</p><p>为每一个属性打上标签 <code>[global::ProtoBuf.ProtoMember(1)]</code>。括号里是proto文件中定义的数字。</p><h1 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h1><h2 id="我的可视化GUI"><a href="#我的可视化GUI" class="headerlink" title="我的可视化GUI"></a>我的可视化GUI</h2><p>我将集成这些功能到自己做的wpf工具中（.proto生成.cs）。</p><p><a href="https://github.com/CodingCodingK/CodingKExcelParser">github地址</a></p><h2 id="我的UDP-C-S服务器通信解决方案"><a href="#我的UDP-C-S服务器通信解决方案" class="headerlink" title="我的UDP C-S服务器通信解决方案"></a>我的UDP C-S服务器通信解决方案</h2><p>基于KCP优化UDP传输可靠性的 Unity/.net Client - .net Server 通信解决方案，可以选择proto协议，内有案例。</p><p><a href="https://github.com/CodingCodingK/CodingK_Session">github地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具篇：帧同步网络库</title>
      <link href="/Tech/Game/tools/CodingK_Session/"/>
      <url>/Tech/Game/tools/CodingK_Session/</url>
      
        <content type="html"><![CDATA[<h1 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h1><p><a href="https://github.com/CodingCodingK/CodingK_Session">CodingK_Session</a></p><h1 id="聊聊网络"><a href="#聊聊网络" class="headerlink" title="聊聊网络"></a>聊聊网络</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>起源于1969年美国国防部的军用项目，最初只是一个单个的分组交换网ARPANET（并不是一个互连的网络）。1983年TCP/IP协议成为ARPANET上的标准协议，使所有使用 TCP/IP协议 的计算机都能利用互连网相互通信。因此1983年被当作因特网（Internet）诞生的时间。之后经过不断发展，形成了如今的英特网（Internet）。</p><h3 id="网络通信是指什么？"><a href="#网络通信是指什么？" class="headerlink" title="网络通信是指什么？"></a>网络通信是指什么？</h3><p>计算设备之间通过网络交换数据，更通俗地说法就是：主机A上的某个程序（进程）与主机B上的某个程序（进程）进行数据交换。</p><h3 id="网络通信如何实现？"><a href="#网络通信如何实现？" class="headerlink" title="网络通信如何实现？"></a>网络通信如何实现？</h3><p>计算设备之间通过共同遵守的 网络协议（network protocol） ，以约定好的规则来交换数据。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>五层协议的体系结构</p><p>OSI七层协议：概念清楚，理论完整，但它复杂不实用。</p><p><strong>TCP/IP四层</strong>协议：应用非常广泛。实质上，TCP/IP只有上面三层，最下层的网络接口层并没有什么具体内容。</p><p>综合前面两者，我们一般采用<strong>五层协议的体系结构</strong>来学习理解计算机网络原理。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220123211028.png"></p><h3 id="五层协议功能划分"><a href="#五层协议功能划分" class="headerlink" title="五层协议功能划分"></a>五层协议功能划分</h3><p><strong>应用层</strong>：直接为用户的应用进程提供服务。这一层的协议很多，比如HTTP协议（浏览器）、SMTP协议（邮件）、FTP协议（文件传输）等。</p><p><strong>运输层</strong>：运输应用层的数据，多个应用进程可同时使用运输层的服务，以及分发运输层的信息到应用层中相应的进程上。运输层主要使用两种协议：</p><ul><li><p>传输控制协议TCP(Transmission Control Protocol）: 面向连接 ，以报文段（segment）为传输单位，保证传输的可靠性。</p></li><li><p>用户数据报协议UDP(User Datagram Protocol）: 无连接 以用户数据报为传输单位，不保证传输的可靠性。</p></li></ul><p><strong>网络层</strong>：把运输层的报文段或用户数据报封装成 分组或包 进行传送。网络层使用IP协议，因此分组也叫作 IP数据报 ，简称数据报。此外网络层还要选择合适的路由，使运输层里的数据通过网络中的路由器找到目的主机。</p><p><strong>数据链路层</strong>：数据在网络上传输时总是在一段一段的链路上传送的（主机和路由器之间或者两个路由器之间），这时需要链接层的协议将网络层交下来的IP数据报组装成 帧（framing） ，以便在相邻的链路之间传送。数据帧里包含了必要的 传输控制信息 。</p><p><strong>物理层</strong>：在物体层上所传数据就是比特流。用不同的电压代表「0」或「1」，在硬件设备上实现数据传输。</p><p>注意：现在我们常提到的TCP/IP并不一定单指TCP和IP两个具体的协议，而是指组成因特网时所使用的整个 TCP/IP协议族 （protocol suite），还包括了其它协议，比如：DNS协议（域名转换为IP地址）、ARP协议（IP地址转换为mac地址）等等。</p><h2 id="TCP对比UDP"><a href="#TCP对比UDP" class="headerlink" title="TCP对比UDP"></a>TCP对比UDP</h2><h3 id="简易TCP通信案例"><a href="#简易TCP通信案例" class="headerlink" title="简易TCP通信案例"></a>简易TCP通信案例</h3><p>TCP所谓的建立连接并不是在物理层面建立什么连接，而是通过在通信两端建立一定的数据结构来维护双方交互的状态，用这样的<strong>数据结构</strong>来保证所谓的面向连接的特性，实现可靠传输。</p><h3 id="简易UDP通信案例"><a href="#简易UDP通信案例" class="headerlink" title="简易UDP通信案例"></a>简易UDP通信案例</h3><p>UDP在局域网基本不会丢包，很多内网的服务都是用UDP开发，简单高效易用。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在.net core使用以下2个包实现TCP/UDP通信，1个包实现指定数据流格式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br></pre></td></tr></table></figure><p>个人简易demo源码（UDP、TCP）：</p><h1 id="实现帧同步网络库"><a href="#实现帧同步网络库" class="headerlink" title="实现帧同步网络库"></a>实现帧同步网络库</h1><p>作为HOK demo的工具组之一。</p><h2 id="为什么使用UDP"><a href="#为什么使用UDP" class="headerlink" title="为什么使用UDP"></a>为什么使用UDP</h2><p>使用帧同步需要非常频繁交互。UDP更快，没有TCP那么繁琐的机制和包头额外数据。</p><h2 id="KCP入门"><a href="#KCP入门" class="headerlink" title="KCP入门"></a>KCP入门</h2><p>一套高效确认算法，可以让数据传输变得可靠有序 。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220124203153.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126215129.png"></p><h3 id="KCP源码"><a href="#KCP源码" class="headerlink" title="KCP源码"></a>KCP源码</h3><p><a href="https://github.com/skywind3000/kcp">源码地址</a>，手册很细致，里面也有一些原理性质的概念。</p><p><a href="https://github.com/KumoKyaku/KCP">C#版本</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>会话ID必须由服务器统一分配，不可重复。</p><p>实现模拟连接以便识别不同客户端数据。</p><p>双端复用代码，抽象网络会话类，进行数据收发。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>在NuGet市场上就有，不用非去github下源码。</p><h2 id="基于KCP实现的可靠UDP通信"><a href="#基于KCP实现的可靠UDP通信" class="headerlink" title="基于KCP实现的可靠UDP通信"></a>基于KCP实现的可靠UDP通信</h2><h3 id="发番协定"><a href="#发番协定" class="headerlink" title="发番协定"></a>发番协定</h3><p>初次连接，传4个空字节过去。</p><p>当服务端收到后知道是新客户端，就生成全局唯一uuid并返回，返回的形式是“4个空字节+uuid”。客户端收到后设置KCPSession的sid。</p><p>kcp添加控制信息的包里，头4个字节的数字对应传入的int值，每一个字节可以转化为对应的0~255的数字。而4个字节刚好对应一个uint32，也就是传入<code>new Kcp(sid, m_handle)</code>的sid。</p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>客户端和服务端分别实现Session，两边通用一样的结构（KCPNet），但是用不一样的遍历逻辑（ClientSession、ServerSession）和管理层（ClientStart、ServerStart）。</p><p>客户端会定期发送Ping Message到服务端。</p><p>服务端有一个字典存放所有的Session，也就是ServerSession类型，超过设定时长未收到来自客户端传来的消息，就在本地字典内清除这个客户端的信息。</p><h1 id="基于KCPNet的解决方案"><a href="#基于KCPNet的解决方案" class="headerlink" title="基于KCPNet的解决方案"></a>基于KCPNet的解决方案</h1><p>本人基于KCPNet项目，集成proto协议、KCP算法的 Unity客户端 +.net core/framework服务端 解决方案。</p><p><a href="https://github.com/CodingCodingK/CodingK_Session">CodingK_Session</a></p><p>教程就不写了，我在里面写了2个使用案例。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 工具组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具组 </tag>
            
            <tag> 网络库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework框架学习：应用篇</title>
      <link href="/Tech/Game/gf_demo/"/>
      <url>/Tech/Game/gf_demo/</url>
      
        <content type="html"><![CDATA[<p>参考写在前面！！！</p><p>本文是在腾讯大佬<a href="https://www.drflower.top/">花桑</a>的GF解析文章的基础上，自己阅读源码并尝试总结、应用、拓展的<strong>个人笔记</strong>！水印以示尊敬。</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>其实半年前就知道gf，但是那时候刚入门unity没多久，看了猫仙人的simple gf来学习，很可惜只学到了皮毛也就是一些常见的设计模式比如状态机、对象池、优先队列轮询在游戏中的应用。经过半年的unity学习与项目积累，再回来看gf的源码觉得，不难且实现优雅，但是内容实在是太多了，记不下来。为了让自己学的结构能穿起来，刨析demo并自己做，很必要。</p><p>参考的也是<a href="https://www.drflower.top/posts/6e65184/#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE">花桑</a>和gf官方的demo。</p><p><font color="red">// TODO 目前只做了刨析demo的流程</font></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://blog-1300673521.cos.ap-guangzhou.myqcloud.com/images/GameFramework%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%BC%96%E5%86%99%E6%B8%B8%E6%88%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="img"></p><h1 id="启动场景全流程"><a href="#启动场景全流程" class="headerlink" title="启动场景全流程"></a>启动场景全流程</h1><h2 id="自己的GameEntry-cs"><a href="#自己的GameEntry-cs" class="headerlink" title="自己的GameEntry.cs"></a>自己的GameEntry.cs</h2><p>是自己的GameEntry类，而不是<code>UnityGameFramework.Runtime</code>中的GameEntry静态类。</p><p>作为游戏的入口，它需要继承MonoBehaviour并在Start方法中进行初始化。因为gf所有控件的初始化是在Awake内结束的，所以Start内拿到他们的时候已经可以安心使用了。</p><ol><li>  将所有默认的 GameFrameworkComponent 通过<code>UnityGameFramework.Runtime.GameEntry.GetComponent</code>获取，赋值到静态字段中，提供全局访问。<strong>这一块不同项目可以通用。</strong></li><li>  将项目中自己创建的 GameFrameworkComponent 派生类 ，与上面一样的操作进行赋值提供访问。</li></ol><h2 id="ProcedureLaunch-流程"><a href="#ProcedureLaunch-流程" class="headerlink" title="ProcedureLaunch 流程"></a>ProcedureLaunch 流程</h2><blockquote><p>  进行一些游戏启动的必要的初始化，支撑后续的启动流程，如：</p><p>  1.初始化构建信息：如版本检测和资源更新的URL信息，更新界面资源等<br>  2.语言设置：若有上次设置记录则使用上次设置记录，若没有则使用默认或系统语言<br>  3.初始化变体：根据当前语言设置，通知后续底层加载对应的资源变体<br>  4.初始本地化文本资源：根据当前语言设置选择对应的文本</p><p>  以上涉及到的资源，包括更新信息文件、更新界面资源、本地化文本等都是build-in资源，也就是发布时就在包内，不可更新的。试想我们发布的游戏是一个仅仅支撑启动的包，所有游戏资源都需要在启动后的热更流程中下载，但一些启动图片，以及热更时的界面本身也是需要资源的，需要给出基本的文本、确认框等，以提供给玩家确认是否下载、下载进度预览，还涉及到更新请求的URL。这部分资源就是我们需要放在包内的不可更新资源，主要用来支撑热更的启动，而ProcedureLaunch流程就是负责初始化这些资源和相关配置。</p></blockquote><p>顺从gf的流程，从这个流程结点开始启动项目。做的是加载在进入热更阶段之前的画面，这些画面和配置不可更新，发布在包内。</p><p><strong>流程转变</strong>发生在OnUpdate，也就是Awake、Start之后的第一帧 进入ProcedureSplash。</p><h3 id="初始化变体"><a href="#初始化变体" class="headerlink" title="初始化变体"></a>初始化变体</h3><ol><li>  根据语言选项，设置对应的 m_CurrentVariant （”en-us”、”zh-cn”、”zh-tw” 其中之一）。</li><li>  m_CurrentVariant 会显示在 LabelField 中。</li><li>  在资源加载中起到作用：ResourceManager.ResourceIniter类的 <strong>OnLoadPackageVersionListSuccess方法</strong> 中，会遍历资源的Variant是否一致。</li></ol><h2 id="ProcedureSplash-流程"><a href="#ProcedureSplash-流程" class="headerlink" title="ProcedureSplash 流程"></a>ProcedureSplash 流程</h2><blockquote><p>  闪屏流程，该流程会播放一个闪屏动画，然后根据当前的资源模式选择下一个流程，分别有</p><p>  1.编辑器模式-&gt;ProcedurePreload<br>  2.整包模式（不可更新）-&gt;ProcedureInitResources<br>  3.可更新模式-&gt;ProcedureCheckVersion</p><p>  编辑器模式下将使用EditorResourceComponent作为资源组件，里面使用的是AssetDatabase的接口直接加载Editor下资源，不涉及任何打包资源，不需要做资源列表初始化等操作。可直接进入ProcedurePreload流程。</p><p>  这个并非必要流程，若不需要闪屏，去掉此流程，把逻辑挪到上一个流程中即可。</p></blockquote><p>其实就是一个switch，决定下一个去往的流程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GameEntry.Base.EditorResourceMode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编辑器模式</span></span><br><span class="line">    ChangeState&lt;ProcedurePreload&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (GameEntry.Resource.ResourceMode == ResourceMode.Package)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 单机模式</span></span><br><span class="line">    ChangeState&lt;ProcedureInitResources&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可更新模式</span></span><br><span class="line">    ChangeState&lt;ProcedureCheckVersion&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProcedureInitResources-流程"><a href="#ProcedureInitResources-流程" class="headerlink" title="ProcedureInitResources 流程"></a>ProcedureInitResources 流程</h2><blockquote><p>  对于整包模式这个分支流程很简单，主要逻辑就是调用ResourceManager.InitResources()，加载包内资源列表，并解析到ResourceManager中，这样就初始化完毕资源的相关信息了，包括AB包、Asset、资源组、文件系统、版本号等。因为整包模式下所有资源都在包体内，只需要一步初始化即可获得所有资源信息，且后续不需要进行更新，所以初始化后便进入ProcedurePreload流程。</p></blockquote><p>单机模式，不需要资源热更的情况，只需要加载资源。</p><p>看代码层层包装，实际做的事就是：</p><ol><li><p>  将所给的地址转化成 带有<code>file://</code> 或 <code>http://</code> 前缀的远端格式。</p></li><li><p>  根据1是否成功的结果，启用携程来发送web请求，获取到返回值后执行对应的 Success 或 Failed 函数（我个人觉得这里可以换成用异步等待）</p></li><li><p><strong>Success函数</strong>：OnLoadPackageVersionListSuccess ，将请求的返回值反序列化成一个<code>PackageVersionList</code>，从中获得版本信息、Asset、Resource、FileSystem、ResourceGroup并装载。</p><p>  <strong>Failed函数</strong>：OnLoadPackageVersionListFailure，抛出GameFrameworkException。</p></li><li><p>  切换状态到 ProcedurePreload 流程。</p></li></ol><h2 id="ProcedureCheckVersion-流程"><a href="#ProcedureCheckVersion-流程" class="headerlink" title="ProcedureCheckVersion 流程"></a>ProcedureCheckVersion 流程</h2><blockquote><p>  此流程主要是调用ResourceManager.UpdateVersionList()，更新版本资源列表，其实就是更新最新的GameFrameworkVersion.dat文件，此文件记录了服务器上最新资源的信息，包括一些校验信息等，这些信息将被用来在下一个ProcedureCheckResources流程中进行资源校验。</p></blockquote><ol><li><p>  向EventPool添加成功失败情况的2个回调。</p></li><li><p>  向服务器请求版本信息。</p></li><li><p>根据版本信息来决策：</p><p>  <strong>需要版本更新</strong>：设置VersionList并切换流程到 ProcedureUpdateVersion 流程。</p><p>  <strong>不需要版本更新</strong>：切换流程到 ProcedureCheckResources 流程。</p></li></ol><h2 id="ProcedureUpdateVersion-流程"><a href="#ProcedureUpdateVersion-流程" class="headerlink" title="ProcedureUpdateVersion 流程"></a>ProcedureUpdateVersion 流程</h2><blockquote><p>  此流程主要是调用ResourceManager.UpdateVersionList()，更新版本资源列表，其实就是更新最新的GameFrameworkVersion.dat文件，此文件记录了服务器上最新资源的信息，包括一些校验信息等，这些信息将被用来在下一个ProcedureCheckResources流程中进行资源校验。</p></blockquote><p>基本上面就是全部了，唯一值得补充的是下载用的是 <strong>DownloadTask 类</strong>，然后放到 DownloadManager 的任务池里。</p><p>成功后执行回调，进入 ProcedureCheckResources 流程。</p><h2 id="ProcedureCheckResources-流程"><a href="#ProcedureCheckResources-流程" class="headerlink" title="ProcedureCheckResources 流程"></a>ProcedureCheckResources 流程</h2><blockquote><p>  资源检测流程，核心逻辑是调用ResourceManager.CheckResources()，GF内部会解析以下3个文件：</p><p>  ​    1.可读写路径下的GameFrameworkVersion.dat，文件记录着服务器上最新的资源信息<br>  ​    2.只读路径下的GameFrameworkList.dat，文件记录着只读路径（包内）下的资源信息<br>  ​    3.可读写路径下的GameFrameworkList.dat，文件记录着可读写路径下（以前通过热更下载的）的资源信息</p><p>  资源模块内部会根据本地资源信息和服务器资源信息作对比，标记出每个资源的状态，包括是否需要更新、是否可用、是否需要删除等。后续可以根据这些状态来加载或更新资源。</p><p>  检测完资源后，有哪些资源是需要更新的就已经明确了，这个时候可以根据项目具体需求选择是否进入更新流程。</p><p>  ​    a.若游戏要求所有资源都为最新时才能进入游戏，则有资源变化就必须进入更新流程更新资源<br>  ​    b.若游戏做了分包下载，进入初始场景不需要更新（初始场景资源无变化），待用到对应资源时才更新，也可以不进入更新流程，在游戏中玩家需要访问未更新资源时，再在后台更新。</p></blockquote><p>看上面就够。实际执行的代码就是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OnEnter：</span><br><span class="line"><span class="comment">// 3项加载解析</span></span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadWritePath, RemoteVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadUpdatableVersionListSuccess, OnLoadUpdatableVersionListFailure), <span class="literal">null</span>);</span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadOnlyPath, LocalVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadReadOnlyVersionListSuccess, OnLoadReadOnlyVersionListFailure), <span class="literal">null</span>);</span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadWritePath, LocalVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadReadWriteVersionListSuccess, OnLoadReadWriteVersionListFailure), <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 完成后执行回调，标记出每个资源的状态，包括是否需要更新、是否可用、是否需要删除等。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCheckResourcesComplete</span>(<span class="params">...</span>)</span>;</span><br><span class="line"></span><br><span class="line">OnUpdate：</span><br><span class="line"><span class="comment">// 根据上面标记的值：是否需要更新，来确定下一个状态。</span></span><br><span class="line">需要版本更新：设置UpdateResourceCount并切换流程到 ProcedureUpdateResources 流程。</span><br><span class="line">不需要版本更新：切换流程到 ProcedurePreload 流程。</span><br></pre></td></tr></table></figure><p><strong>需要版本更新</strong>：设置UpdateResourceCount并切换流程到 ProcedureUpdateResources 流程。<br><strong>不需要版本更新</strong>：切换流程到 ProcedurePreload 流程。</p><h2 id="ProcedureUpdateResources-流程"><a href="#ProcedureUpdateResources-流程" class="headerlink" title="ProcedureUpdateResources 流程"></a>ProcedureUpdateResources 流程</h2><blockquote><p>  资源更新流程，如上文所说，在本流程可以根据项目具体需求，更新此刻需要更新的资源。例如游戏内做了资源分组，把一些活动、副本等资源单独分组了，则可以在此时只更新基础资源，待玩家访问到还没更新的活动、副本相关资源时，再在后台更新活动、副本的资源。更新的最小单位为一个资源组。</p><p>  另外这个流程还需要实现热更时的当前进度、下载速度、剩余大小等界面表现。</p><p>  更新完成后正式进入游戏业务流程。</p></blockquote><p>获取上个流程传来的 UpdateResourceCount，之后传入委托到EventPool。这4个委托的核心是维护一个<code>List&lt;UpdateLengthData&gt;</code>队列 <strong>m_UpdateLengthData</strong>（下称进度队列） 。而这个进度队列的数据结构，只有 Name、Length、TotalZipLength 三个属性。</p><p>花桑的demo里用了4个委托的情况：</p><ol><li>  OnResourceUpdateStart：为进度队列添加内容。</li><li>  OnResourceUpdateChanged：为进度队列更新进度。</li><li>  OnResourceUpdateSuccess：修改 m_UpdateSuccessCount++，并为进度队列更新进度。</li><li>  OnResourceUpdateFailure：Retry并为进度队列回退进度。如果Retry次数超过设定次数，就直接返回。</li></ol><p>设置好委托后，执行 StartUpdateResources方法。这个方法内将资源列表放到了一个 资源等待更新队列。ResourceManager的Update里会去轮询这个 资源等待更新队列，一帧一个（TODO why？）地，加入DownloadManager的TaskPool里。</p><p>等待更新任务完成后，切换到最终流程 ProcedurePreload流程。</p><h2 id="ProcedurePreload-流程"><a href="#ProcedurePreload-流程" class="headerlink" title="ProcedurePreload 流程"></a>ProcedurePreload 流程</h2><blockquote><p>   预加载流程，这一流程已经属于游戏业务层，但大部分游戏其实都需要这么一个流程，所以这里也把他规划到通用流程中，流程中主要负责设置框架的功能模块，预加载数据表，初始化游戏中的功能系统等。</p></blockquote><p>找到 Config（配置） 和 Localization（本地化组件） 的路径，传入GF进行异步加载。再对所有Data进行Preload。</p><p>完成后进入 ProcedureLoadingScene流程。</p><h2 id="ProcedureLoadingScene-流程"><a href="#ProcedureLoadingScene-流程" class="headerlink" title="ProcedureLoadingScene 流程"></a>ProcedureLoadingScene 流程</h2><p>加载Scene流程，也是通用的。先根据id获取一个SceneData类型，这个SceneData类型是装在一个字典中的，在ProcedurePreload 流程的时候会初期化。</p><p>SceneData类型附带了场景名字路径等，以及，下一个流程的名字。当Scene加载完后，根据上面取得的配置，切换到下一个流程中。</p><p>按正常顺序走，第一个场景是 Menu场景。</p><h2 id="ProcedureMenu-流程"><a href="#ProcedureMenu-流程" class="headerlink" title="ProcedureMenu 流程"></a>ProcedureMenu 流程</h2><p>对应的是游戏选关卡的界面。其实就是主城啦。</p><p>展示UI、展示关卡等等。当选择关卡后，会进入 ProcedureLoadingScene流程，一样读取SceneData切换到对应关卡并进入 ProcedureLevel流程。</p><h2 id="ProcedureLevel-流程"><a href="#ProcedureLevel-流程" class="headerlink" title="ProcedureLevel 流程"></a>ProcedureLevel 流程</h2><p>战斗流程。</p><p>根据关卡配置创建关卡 LevelControl类型，里面包含了所有战斗需要的东西，有点类似于自己常写的“BattleMgr”。</p><p>LevelControl并不继承Mono，只继承一个IReference接口。它由<strong>ProcedureLevel.OnUpdate</strong>驱动每一帧做的事，同时OnUpdate还会检测一个flag判断是否要执行切换场景了（进入 ProcedureLoadingScene流程）。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> GameFramework框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework框架学习：原理篇</title>
      <link href="/Tech/Game/GF/"/>
      <url>/Tech/Game/GF/</url>
      
        <content type="html"><![CDATA[<p>参考写在前面！！！</p><p>本文是在腾讯大佬<a href="https://www.drflower.top/">花桑</a>和大佬<a href="http://www.maodaodao.top/">猫刀刀</a>的GF解析文章的基础上，阅读源码并尝试总结、应用、拓展的<strong>个人笔记</strong>！无其他用途，水印以示尊敬。</p><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>基于MonoBehaviour来实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GameFrameworkComponent</span> : <span class="title">MonoBehaviour</span> &#123; </span><br><span class="line">    <span class="comment">// 游戏框架组件初始化。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameEntry.RegisterComponent(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GameEntry</span> &#123;</span><br><span class="line">    <span class="comment">// 提供api方便外部访问这个链队，从而获取组件</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">readonly</span> <span class="title">GameFrameworkLinkedList</span>&lt;<span class="title">GameFrameworkComponent</span>&gt; s_GameFrameworkComponents</span> = <span class="keyword">new</span> GameFrameworkLinkedList&lt;GameFrameworkComponent&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterComponent</span>(<span class="params">GameFrameworkComponent gameFrameworkComponent</span>)</span>&#123;</span><br><span class="line">        Type type = gameFrameworkComponent.GetType();</span><br><span class="line">        ... <span class="comment">// 确保链队未添加过同type元素</span></span><br><span class="line">        s_GameFrameworkComponents.AddLast(gameFrameworkComponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------执行完上述base.Awake()后，回到各自的Awake()逻辑。下面用ProcedureComponent举例。------------------</span></span><br><span class="line">ProcedureComponent.<span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.Awake(); <span class="comment">// 上面做的事</span></span><br><span class="line">    m_ProcedureManager = GameFrameworkEntry.GetModule&lt;IProcedureManager&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="GameFrameworkModule"><a href="#GameFrameworkModule" class="headerlink" title="GameFrameworkModule"></a>GameFrameworkModule</h3><p>GameFrameworkModule（GF层中各个模块的基类）采用懒加载。在Awake中GetModule的时候时，GameFrameworkEntry会先检测内部有没有这个模块对象，没有时再调用内部的CreateModule来实例化该模块。</p><p>CreateModule是通过传入的接口去掉第一个字符I，然后反射调用构造器的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------GameFrameworkEntry.GetModule&lt;T&gt;() where T : class-----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的 type 是接口 (比如 IProcedureManager)</span></span><br><span class="line"><span class="built_in">string</span> typeName = Utility.Text.Format&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;&quot;</span>, type.Namespace, type.Name.Substring(<span class="number">1</span>));</span><br><span class="line">...</span><br><span class="line">GameFrameworkModule instance = (GameFrameworkModule) Activator.CreateInstance(Type.GetType(typeName));</span><br><span class="line">... <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br></pre></td></tr></table></figure><p>最后这个类（比如 ProcedureManager），就在GF框架里而不是UGF框架了。这个是一个很好的解耦。</p><p>然后我们讲讲CreateModule方法里省略的代码，①里做的事：</p><p>根据<code>instance.Priority</code>优先级，插入到<code>GameFrameworkEntry。s_GameFrameworkModules</code>全局队列中合适的节点位置。这么做是为了保证链队始终保持优先级从大到小排序，等后面Update的时候就直接foreach遍历就完事了！</p><h2 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220120143413.png"></p><p>Tick部分逻辑比较轻：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GameFrameworkComponent</span> : <span class="title">MonoBehaviour</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BaseComponent</span> : <span class="title">GameFrameworkComponent</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameFrameworkEntry.Update(Time.deltaTime, Time.unscaledDeltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GameFrameworkEntry</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接foreach就可以！初始化① 的时候保证了链队是按优先级顺序排的</span></span><br><span class="line">        <span class="keyword">foreach</span> (GameFrameworkModule gameFrameworkModule <span class="keyword">in</span> GameFrameworkEntry.s_GameFrameworkModules)</span><br><span class="line">            gameFrameworkModule.Update(elapseSeconds, realElapseSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ShutDown"><a href="#ShutDown" class="headerlink" title="ShutDown"></a>ShutDown</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220120150856.png"></p><p>卸载。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ShutdownType : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仅关闭游戏框架。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭游戏框架并重启游戏。</span></span><br><span class="line">    Restart,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭游戏框架并退出游戏。</span></span><br><span class="line">    Quit,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameEntry.Shutdown(ShutdownType shutdownType)&#123;</span><br><span class="line">    baseComponent.Shutdown();</span><br><span class="line">    s_GameFrameworkComponents.Clear();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.None) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.Restart)</span><br><span class="line">    &#123;</span><br><span class="line">        SceneManager.LoadScene(GameFrameworkSceneId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.Quit)</span><br><span class="line">    &#123;</span><br><span class="line">        Application.Quit();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------下面只讨论None：仅关闭游戏框架。-----------------------</span></span><br><span class="line"></span><br><span class="line">BaseComponent.Shutdown()</span><br><span class="line">&#123;</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseComponent.OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">    GameFrameworkEntry.Shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameFrameworkEntry.Shutdown()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>() &#123; ... &#125; <span class="comment">// 从后往前遍历 s_GameFrameworkModules 所有成员执行 Shutdown(); </span></span><br><span class="line">    </span><br><span class="line">    GameFrameworkEntry.s_GameFrameworkModules.Clear();</span><br><span class="line">    ReferencePool.ClearAll();</span><br><span class="line">    Utility.Marshal.FreeCachedHGlobal();</span><br><span class="line">    GameFrameworkLog.SetLogHelper((GameFrameworkLog.ILogHelper) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GF书写习惯"><a href="#GF书写习惯" class="headerlink" title="GF书写习惯"></a>GF书写习惯</h1><p>GF整体代码的书写习惯是利用 接口 + Dictionary + List 来实现对外的api调用。</p><p>而<strong>接口的实际对象</strong>正如前面所说，绝大部分都是Awake的时候反射构造 <strong>同名实现类</strong> 实现的。</p><p>这一点对于扩展来说非常开闭，就是提高了熵。</p><p>知道了这一点后，下面的探究就不再对GF的接口进行关注了，而是只看他们的实现类了。</p><h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;Player&gt; fsm; <span class="comment">//一个状态机</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;FsmState&lt;Player&gt;&gt; stateList; <span class="comment">//状态结点List</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建状态列表</span></span><br><span class="line">        stateList = <span class="keyword">new</span> List&lt;FsmState&lt;Player&gt;&gt;() &#123; <span class="keyword">new</span> IdleState(), <span class="keyword">new</span> MoveState() &#125;;</span><br><span class="line">        <span class="comment">//创建状态机，注意，对于所有持有者为Player类型的状态机的名字参数&quot;name&quot;不能重复</span></span><br><span class="line">        fsm = GameEntry.fsmComponent.fsmManager.CreateFsm&lt;Player&gt;(<span class="string">&quot;name&quot;</span>, <span class="keyword">this</span>, stateList);</span><br><span class="line">        <span class="comment">//以IdleState为初始状态，启动状态机</span></span><br><span class="line">        fsm.Start&lt;IdleState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FsmManager"><a href="#FsmManager" class="headerlink" title="FsmManager"></a>FsmManager</h2><p>FsmManager 和 IFsmManager。状态机最外层的存在，有Update会被循环，外部直接调用它的<code>CreateFsm</code>方法。</p><p>值得注意的是（下面）用了2次foreach完成1次轮询，为什么要这么做？</p><p><strong>因为如果在第一次foreach的时候就直接调用fsm.Update很可能导致m_Fsms的更改，从而导致迭代器的损坏。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级60</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FsmManager</span> : <span class="title">GameFrameworkModule</span>, <span class="title">IFsmManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> Dictionary&lt;TypeNamePair, FsmBase&gt; m_Fsms;</span><br><span class="line">    <span class="keyword">readonly</span> List&lt;FsmBase&gt; m_TempFsms;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        m_TempFsms.Clear();</span><br><span class="line">        <span class="keyword">foreach</span>(m_Fsms) &#123; ... &#125; <span class="comment">// 将m_Fsms全部放入干净的m_TempFsms中。</span></span><br><span class="line">        <span class="keyword">foreach</span>(m_TempFsms) &#123; fsm.Update(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fsm-lt-T-gt"><a href="#Fsm-lt-T-gt" class="headerlink" title="Fsm&lt; T &gt;"></a>Fsm&lt; T &gt;</h2><p>一个状态机。继承自FsmBase，也就是上面字典的申明类型。<strong>FsmBase抽象类</strong> 就不介绍了，是一些状态机的通用属性比如Name、IsDestory之类的属性。</p><p>T传进去的是你的数据类型，和结点<code>FsmState&lt;T&gt;</code>传的T一致。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Fsm</span>&lt;<span class="title">T</span>&gt; : <span class="title">FsmBase</span>, <span class="title">IReference</span>, <span class="title">IFsm</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> Dictionary&lt;Type, FsmState&lt;T&gt;&gt; m_States;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, Variable&gt; m_Datas;</span><br><span class="line">    <span class="keyword">private</span> FsmState&lt;T&gt; m_CurrentState;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>&lt;<span class="title">TState</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        FsmState&lt;T&gt; state = GetState&lt;TState&gt;();</span><br><span class="line">        m_CurrentState = state;</span><br><span class="line">        m_CurrentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_CurrentState.OnUpdate(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个是对FsmState结点提供的方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">ChangeState</span>&lt;<span class="title">TState</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type stateType = <span class="keyword">typeof</span>(TState);</span><br><span class="line">        FsmState&lt;T&gt; state = GetState(stateType); <span class="comment">// GetState 就是从m_States里查找</span></span><br><span class="line">        m_CurrentState.OnLeave(<span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">        m_CurrentState = state;</span><br><span class="line">        m_CurrentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FsmState-lt-T-gt"><a href="#FsmState-lt-T-gt" class="headerlink" title="FsmState&lt; T &gt;"></a>FsmState&lt; T &gt;</h2><p>一个状态结点。一个状态机对应多个状态结点，想象一下状态机的图就行了。</p><p><strong>一般来说，我们需要自己实现的就只有这个类。</strong></p><p>对上面调用过的方法进行展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FsmState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 生命周期（全是虚方法，具体行为要自己实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params">IFsm&lt;T&gt; fsm, <span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnLeave</span>(<span class="params">IFsm&lt;T&gt; fsm, <span class="built_in">bool</span> isShutdown</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不对外提供的方法，在自己实现的状态结点代码内互相切换状态。当然你可以在子类里选择公开它。</span></span><br><span class="line">    <span class="comment">// 一般在OnUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ChangeState</span>&lt;<span class="title">TState</span>&gt;(<span class="params">IFsm&lt;T&gt; fsm</span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        Fsm&lt;T&gt; fsmImplement = (Fsm&lt;T&gt;)fsm;</span><br><span class="line">        fsmImplement.ChangeState&lt;TState&gt;(); <span class="comment">// 调用上面的 Fsm.ChangeState方法 来实现切换状态。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己实现这个抽象类的时候，ChangeState调用的时机一般写在 <strong>OnUpdate</strong> 方法里。比如每帧都判断一个flag，flag为true就切换到其他状态。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实可以更深层次的拓展出<strong>状态栈</strong>：如果状态被某个状态打断，可以恢复到之前的状态。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>在ProcedureComponent组件（下面）中提到，是通过m_AvailableProcedureTypeNames来创建实例，并以m_EntranceProcedure为起始状态，启动流程状态机，那么这两个变量是怎么来的呢。</p><p>如图所示，我们直接通过流程组件的Inspector来配置，<strong>GF会通过反射获取所有继承ProcedureBase的子类，并展示在此面板</strong>，我们只需要勾选需要流程即可把它加入到m_AvailableProcedureTypeNames中，而面板上的Entrance Procedure则代表了m_EntranceProcedure，这里我们选择了StarForce.ProcedureLaunch作为起始状态，那么ProcedureLaunch类中的OnEnter方法中的逻辑，就是我们游戏启动后最先执行的游戏业务逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/GameFramework_Procedure_Config.png"></p><p>代码上看，是对有限状态机的封装。功能上看，如果把游戏整体看作一部电影的话，那玩家游玩时刻总是在整个游戏的某个流程结点罢了。</p><p>常见的二次元游戏流程线：打开游戏app &gt; 热更 &gt; 登陆 &gt; 主城： 各种丰富的业务（任务系统、商城系统、养成系统、etc） ，选择了副本系统 &gt; 战斗，战斗结束回到主城</p><p>我个人认为这么划分基本就涵盖了所有的业务。在花卷的博客里写了：</p><blockquote><p>  一般地说，一个游戏拥有的流程数量是非常有限的，如果规划出数十个流程出来，很可能是对流程的理解有所偏差。例如一个塔防游戏有数十个关卡，每个关卡的内容都不一样，但关卡中的地图，炮塔，敌人生成等，其实都是数据驱动的，而他们的逻辑其实是一样的，只是数据不同造成表现不同，所以无论是哪个关卡，他们都应该属于同一个流程。</p></blockquote><p>所以我觉得 主城系统里的各种养成系统，都是一个流程结点；战斗系统里各种副本，也属于一个流程结点。</p><h2 id="ProcedureBase"><a href="#ProcedureBase" class="headerlink" title="ProcedureBase"></a>ProcedureBase</h2><p>非常简单，就是继承了一下 FsmState 并指定类型 IProcedureManager 罢了。本质就是个状态结点。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ProcedureBase</span> : <span class="title">FsmState</span>&lt;<span class="title">IProcedureManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProcedureManager"><a href="#ProcedureManager" class="headerlink" title="ProcedureManager"></a>ProcedureManager</h2><p>内部包裹了<strong>一个 FsmManager 和 一个Type为ProcedureManager的状态机</strong>，也就是状态机的最外层。</p><ol><li>  字段m_FsmManager为有限状态机管理器，会在Initialize方法初始化时作为参数传入，m_ProcedureFsm为管理流程用的有限状态机。</li><li>  方法Initialize会取得FsmManager实例和包括所有流程（继承ProcedureBase的对象）的列表，并用FsmManager创建出一个状态机实例储存于m_ProcedureFsm中。</li><li>  与Fsm模块类似，流程模块提供HasProcedure、GetProcedure接口来查询和获取指定流程对象，CurrentProcedure获得当前处于的流程，CurrentProcedureTime获取当前流程持续时间。</li><li>  <strong>StartProcedure</strong>方法，令状态机从指定流程启动，这里是游戏框架正式启动游戏的关键入口。该方法其实就是调用了内部状态机的Start。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级-10</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ProcedureManager</span> : <span class="title">GameFrameworkModule</span>, <span class="title">IProcedureManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsmManager m_FsmManager;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;IProcedureManager&gt; m_ProcedureFsm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">IFsmManager fsmManager, <span class="keyword">params</span> ProcedureBase[] procedures</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_FsmManager = fsmManager;</span><br><span class="line">        m_ProcedureFsm = m_FsmManager.CreateFsm(<span class="keyword">this</span>, procedures); <span class="comment">// procedures就是所有流程！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProcedureComponent"><a href="#ProcedureComponent" class="headerlink" title="ProcedureComponent"></a>ProcedureComponent</h2><p>ProcedureManager的<strong>Initialize</strong>方法会取得FsmManager实例和包括所有流程（继承ProcedureBase的对象）的列表，并用FsmManager创建出一个状态机实例储存于m_ProcedureFsm中。这些是在ProcedureComponent里完成的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ProcedureComponent</span> : <span class="title">GameFrameworkComponent</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所有流程的列表</span></span><br><span class="line">        ProcedureBase[] procedures = <span class="keyword">new</span> ProcedureBase[m_AvailableProcedureTypeNames.Length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_AvailableProcedureTypeNames.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Type procedureType = Utility.Assembly.GetType(m_AvailableProcedureTypeNames[i]);</span><br><span class="line">            procedures[i] = (ProcedureBase)Activator.CreateInstance(procedureType);</span><br><span class="line">            <span class="keyword">if</span> (m_EntranceProcedureTypeName == m_AvailableProcedureTypeNames[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据名字，寻找初始流程</span></span><br><span class="line">                m_EntranceProcedure = procedures[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Initialize，把 所有流程的列表procedures 传进去了</span></span><br><span class="line">        m_ProcedureManager.Initialize(GameFrameworkEntry.GetModule&lt;IFsmManager&gt;(), procedures);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始流程，游戏运行！</span></span><br><span class="line">        m_ProcedureManager.StartProcedure(m_EntranceProcedure.GetType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcedureComponent继承了Mono类，上面的Start方法会被Unity内部主动调用，调用后会根据<strong>m_AvailableProcedureTypeNames通过反射来创建流程对象</strong>，进行一系列初始化，再以<strong>m_EntranceProcedure为起始状态</strong>，启动流程状态机。</p><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>其实 流程模块 完全是状态机实例完成，那么功能上没必要单独做成一个模块，但是GF却单独提取成一个模块。很大的原因是因为状态机的状态内部对外是不希望透明的，而流程内部的流程结点是希望对外透明、可访问的。</p><h2 id="完整的启动流程"><a href="#完整的启动流程" class="headerlink" title="完整的启动流程"></a>完整的启动流程</h2><p><a href="">GameFramework框架学习：应用篇</a></p><p><a href="https://www.drflower.top/posts/6e65184/#ProcedureLaunch">花桑启动流程博文</a></p><h1 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126163846.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://www.drflower.top/posts/16213a73/#UIFormInfo">花卷博客UI篇</a>很细，这里只简述。</p><h3 id="UIManager"><a href="#UIManager" class="headerlink" title="UIManager"></a>UIManager</h3><p>UIManager是外部访问框架UI模块的入口。</p><p><strong>UIManager</strong> 持有 Dictionary&lt;string, **UIGroup**&gt;。</p><blockquote><p>  UIManager内部会用GF的对象池模块创建一个对象池，用于缓存UIForm对象的GameObject实例，外部调用OpenUIForm来打开UI时，会先尝试从对象池获取该界面，若对象池中有同类型的空闲实例，则直接取出使用，若没有则从资源模块加载，加载成功后，会注册到对象池中，再交给UIManager使用。而调用CloseUIForm来关闭UI时，UIForm会被加到Queue类型的字段m_RecycleQueue中，在下一次Update时，会把队列所有元素取出，回收到对象池中。</p><p>  内部维护了一个私有字段m_Serial，每次调用OpenUIForm的时候，m_Serial都会自增1，他表示了每个UIForm在其生命周期内的唯一标识符，即使是同一个UIForm实例，被关闭后放回对象池，再被取出来使用，其m_Serial也会发生变化。</p></blockquote><h3 id="UIGroup"><a href="#UIGroup" class="headerlink" title="UIGroup"></a>UIGroup</h3><p>UIGroup是一系列窗口集合，内部用链队存储了一个 LinkedListNode&lt; **UIFormInfo** &gt;，用链表来模栈式结构（链头在最上层）。有Depth的概念。</p><blockquote><p>  Refresh：UIGroup的核心逻辑，根据链表顺序以及UIForm的属性，去调用UIForm的OnDepthChanged、OnCover、OnReveal、OnPause、OnResume这些方法。</p></blockquote><h3 id="UIFormInfo"><a href="#UIFormInfo" class="headerlink" title="UIFormInfo"></a>UIFormInfo</h3><p>UIFormInfo持有<strong>UIForm</strong>的引用。</p><p>既然UIForm是窗口，那为什么要对它再包一层Info呢？它只多了Paused和Covered两个状态，用来表示状态，提供给UIGroup或外界。</p><h3 id="UIForm"><a href="#UIForm" class="headerlink" title="UIForm"></a>UIForm</h3><p>UIForm是UI窗口类，被UIGroup直接管理，每个UI窗口都会有一个UIForm实例，同时也拥有一个<strong>UIFormLogic</strong>实例（一般是它的派生类）。有唯一标识符字段m_SerialId。</p><h3 id="UIFormLogic"><a href="#UIFormLogic" class="headerlink" title="UIFormLogic"></a>UIFormLogic</h3><p>UIFormLogic为UI界面的具体逻辑类，类内有UIForm的所有生命周期方法。</p><p>游戏业务层不对UIForm做扩展，而是<strong>对UIFormLogic继承进行扩展</strong>，也就是自己的脚本继承UIFormLogic，正常写。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126175427.png"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126181213.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126181431.png"></p><h1 id="引用池"><a href="#引用池" class="headerlink" title="引用池"></a>引用池</h1><p>就是对象池结构。</p><p>关于对象池我的一些个人理解：对象池本身的存在理由是，因为频繁创建-销毁对象，会让堆产生大量的内存碎片，导致gc的压缩更频繁。这不好，所以直接申请一大块内存，保持在游戏运行时不释放它。 </p><p>但在GF中并不要求开发者在创建的时候就传入引用池capacity，默认会是0，然后动态扩容。我个人认为，可能是因为分配大量内存而不用的危害远比频繁压缩大，所以<strong>gf中对象池的核心作用只是复用对象，也就是减少mono对象和类对象的创建</strong>。</p><p>每个对象的内存大小是固定的，未使用的对象会保留在内存中。</p><blockquote><p>  GF中池子有两种，一种叫引用池，一种叫对象池，两者原理一样，但具体实现和针对的对象不同，引用池一般用来储存普通的C#类型对象，而对象池则一般用于储存UnityEngine下的对象（如Unity中的GameObject对象）。</p></blockquote><h2 id="ReferencePool"><a href="#ReferencePool" class="headerlink" title="ReferencePool"></a>ReferencePool</h2><p>ReferencePool 静态类，是外部访问引用池模块的入口。</p><p>内部维护了一个Dictionary&lt;Type, **ReferenceCollection**&gt;，这个字典就是所有的引用池，Typa对应引用池类型。</p><p>采用惰性初始化：当内部有需要获取某引用池实例（比如外界调用API获取引用，内部就先需要get到这个池子），如果在这个字典里Type的池子并不存在，则构造一个加入字典再返回。</p><h2 id="ReferenceCollection"><a href="#ReferenceCollection" class="headerlink" title="ReferenceCollection"></a>ReferenceCollection</h2><p>引用池。每一个引用池都有自己对应的Type，不同类型的对象储存在各自类型的池子中。</p><p>① 需要对构造器传入一个Type，在初期化时会保存好Type。</p><p>② <strong>Queue存储引用</strong>：内部维护了一个Queue&lt; **IReference** &gt;，来储存池子中的对象。</p><p>③ <strong>池容量动态扩容</strong>：创建时不需要指定池的capacity，设置为0。容量的扩大，完全靠动态扩容（具体思考看本节开头）。</p><h2 id="IReference"><a href="#IReference" class="headerlink" title="IReference"></a>IReference</h2><blockquote><p>   IReference接口只包含一个Clear方法，此方法会在对象回收池被调用，每一个需要被引用池储存的类型都需要实现此接口，以能清空当前状态，恢复到初始状态，供下次使用。</p></blockquote><p>引用池-&gt;对象复用 的根本。</p><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>引用池一般用来储存普通的C#类型对象。</p><p>比如可以实现复用状态机的状态：</p><ol><li>  状态内实现Create方法，去引用池Acquire（取）一个空闲的相同状态。</li><li>  状态内实现Clear方法（IReference接口），清空所有字段变回初始值。</li></ol><p>之后调用，只需要在new状态机的时候Create，Destory时Clear就可以了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 花桑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;Player&gt; fsm;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建状态列表(不用引用池)</span></span><br><span class="line">        <span class="comment">//List&lt;FsmState&lt;Player&gt;&gt; stateList = new List&lt;FsmState&lt;Player&gt;&gt;() &#123; new IdleState(), new MoveState() &#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建状态列表(使用引用池)</span></span><br><span class="line">        List&lt;FsmState&lt;Player&gt;&gt; stateList = <span class="keyword">new</span> List&lt;FsmState&lt;Player&gt;&gt;() &#123; IdleState.Create(), MoveState.Create() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --------------------------下面和原来一样--------------------------</span></span><br><span class="line">        <span class="comment">//创建状态机，注意，对于所有持有者为Player类型的状态机的名字参数不能重复，这里用自增ID避免重复</span></span><br><span class="line">        fsm = GameEntry.Fsm.CreateFsm&lt;Player&gt;((SERIAL_ID++).ToString(), <span class="keyword">this</span>, stateList);</span><br><span class="line">        <span class="comment">//以IdleState为初始状态，启动状态机</span></span><br><span class="line">        fsm.Start&lt;IdleState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出状态机所有状态</span></span><br><span class="line">        FsmState&lt;Player&gt;[] states = fsm.GetAllStates();</span><br><span class="line">        <span class="comment">//销毁状态机</span></span><br><span class="line">        GameEntry.Fsm.DestroyFsm(fsm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把状态实例归还引用池</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> states)</span><br><span class="line">        &#123;</span><br><span class="line">            ReferencePool.Release((IReference)item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inspector面板监视"><a href="#Inspector面板监视" class="headerlink" title="Inspector面板监视"></a>Inspector面板监视</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220127141559.png"></p><p><strong>Enable Strick Check</strong>：开启类型检测。对象池内部操作时，一方面检测Type是不是非抽象Class且实现了IReference接口的Class；另一方面是释放对象（也就是把对象放回对象池时），需要检查这个对象是不是已经空闲着了。如果 类型不满足、空闲还要求释放 ，就抛错。不过这个检测开启会影响性能，所以只建议测试时开。</p><p><strong>面板用途</strong>：可以通过此面板方便地检查业务逻辑中有没有正确使用引用池，例如某个对象只会在某个流程中会使用，我们可以检测在流程循环中，这个对象的Acquire和Release是否相等，而流程结束时，Using是否为0，Unused是否与Add相等。</p><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>GF中对象池与引用池作用类似，一般用于储存UnityEngine下的对象（如Unity中的GameObject对象）。</p><p>对象池的实现我们可以把他分成3部分，上图中从上到下每一行就是一部分，分别是</p><ol><li>  <strong>物体部分</strong>（抽象类ObjectBase，Object&lt; T &gt;，结构体ObjectInfo），</li><li>  <strong>对象池部分</strong>（抽象类ObjectPoolBase，ObjectPool&lt; T &gt;，委托ReleaseObjectFilterCallback），</li><li>  <strong>对象池管理器部分</strong>（接口IObjectPoolManager，类ObjectPoolManager）。</li></ol><p>其中Object和ObjectPool是ObjectPoolManager的内部私有类。</p><h2 id="整体关系⭐"><a href="#整体关系⭐" class="headerlink" title="整体关系⭐"></a>整体关系⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220127173856.png"></p><p>对象池：ObjectPool&lt; T &gt;类。它继承 ObjectPoolBase抽象类，且内部持有一个**Object&lt; T &gt;**一对多GF字典。</p><p>对象：Object&lt; T &gt; 类。它内部持有一个T对象的引用，且要求T必须继承自 <strong>ObjectBase抽象</strong>类。它实现 IReference接口，所以Create的时候是从引用池分配的。</p><p>对象抽象：ObjectBase 类，也就是上面2个类中限定的T 。内部持有一个<strong>object字段（m_Target）</strong>，这才是真正的 System.Object对象。</p><h2 id="物体部分"><a href="#物体部分" class="headerlink" title="物体部分"></a>物体部分</h2><h3 id="ObjectBase"><a href="#ObjectBase" class="headerlink" title="ObjectBase"></a>ObjectBase</h3><p>通过Initialize方法可把目标对象传递给m_Target字段，这才是object。通过重写OnSpawn、OnUnspawn方法实现对象获取、回收时执行的逻辑。</p><h3 id="Object-lt-T-gt"><a href="#Object-lt-T-gt" class="headerlink" title="Object&lt; T &gt;"></a>Object&lt; T &gt;</h3><p>它实现 IReference接口，Create的时候是从引用池分配的，Release。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object&lt;T&gt; <span class="title">Create</span>(<span class="params">T obj, <span class="built_in">bool</span> spawned</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    internalObject = ReferencePool.Acquire&lt;Object&lt;T&gt;&gt;();</span><br><span class="line">    internalObject.m_Object = obj; <span class="comment">// m_Object就是持有的ObjectBase对象引用</span></span><br><span class="line">    internalObject.m_SpawnCount = spawned ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> internalObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"><span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Object.Release(isShutdown);</span><br><span class="line">    ReferencePool.Release(m_Object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象池-1"><a href="#对象池-1" class="headerlink" title="对象池"></a>对象池</h2><h3 id="ObjectPool-lt-T-gt"><a href="#ObjectPool-lt-T-gt" class="headerlink" title="ObjectPool&lt; T &gt;"></a>ObjectPool&lt; T &gt;</h3><p>对象池，继承自 ObjectPoolBase抽象类 和 IObjectPool接口。两者其实很相似，但是却要做成2个是因为IObjectPool是泛型接口，而ObjectPoolBase不是泛型，后者在使用起来的时候可以不需要明确ObjectBase类型。</p><p>内部持有：一个<code>&lt;string, Object&lt;T&gt;&gt;</code>类型类型的一对多GF字典，一个<code>&lt;object, Object&lt;T&gt;&gt;</code>类型的普通字典。</p><p>Spawn方法：获取对象。字典中，有空闲的就返回，没有就返回null。也就是说，<strong>并不会新建对象</strong>。</p><p>Register方法：创建对象。</p><p>AutoReleaseInterval 属性：执行Release的频率。</p><p>Release方法：自动释放，频率由AutoReleaseInterval 决定，每个池可不同。Release过程会先获取可释放对象序列，然后通过委托ReleaseObjectFilterCallback对可释放物体序列进行筛选后，最后仅对筛选后的对象调用ReleaseObject进行释放。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">T obj, <span class="built_in">bool</span> spawned</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object&lt;T&gt; internalObject = Object&lt;T&gt;.Create(obj, spawned); <span class="comment">// Create方法在上面一小节有展示</span></span><br><span class="line">    m_Objects.Add(obj.Name, internalObject);</span><br><span class="line">    m_ObjectMap.Add(obj.Target, internalObject);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_ObjectMap.Count &gt; m_Capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        Release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    toReleaseCount = Count - m_Capacity; <span class="comment">// 当前对象池中对象的数量 - 池容量</span></span><br><span class="line">    expireTime = DateTime.UtcNow.AddSeconds(-m_ExpireTime); <span class="comment">// 计算出过期时间点</span></span><br><span class="line">    ...</span><br><span class="line">    GetCanReleaseObjects(m_CachedCanReleaseObjects);</span><br><span class="line">    List&lt;T&gt; toReleaseObjects = releaseObjectFilterCallback(m_CachedCanReleaseObjects, toReleaseCount, expireTime);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">foreach</span> (T toReleaseObject <span class="keyword">in</span> toReleaseObjects)</span><br><span class="line">    &#123;</span><br><span class="line">        ReleaseObject(toReleaseObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① <code>GetCanReleaseObjects(m_CachedCanReleaseObjects);</code> 方法：遍历m_ObjectMap的Value值，非使用中状态、非锁定状态、以及自定义释放标记为True时被认为是可释放对象。将所有可释放对象传入m_CachedCanReleaseObjects。</p><p>② <code>releaseObjectFilterCallback(m_CachedCanReleaseObjects, toReleaseCount, expireTime)</code> 委托方法：这个方法负责从可释放对象序列中进一步选出符合要求的对象，之后再进行释放。默认有DefaultReleaseObjectFilterCallback方法，也可以自己传入委托。</p><p>③ ReleaseObject 方法：会把从对应的<code>Object&lt;T&gt;</code>对象从m_Objects和m_ObjectMap中移除。</p><h2 id="对象池管理"><a href="#对象池管理" class="headerlink" title="对象池管理"></a>对象池管理</h2><h3 id="ObjectPoolManager"><a href="#ObjectPoolManager" class="headerlink" title="ObjectPoolManager"></a>ObjectPoolManager</h3><p>在内部使用字典保存所有对象池 ObjectPool&lt; T &gt;。</p><p>CreateSingleSpawnObjectPool方法 和 CreateMultiSpawnObjectPool方法 创建对象池，分别对应一个对象同时只能被获取一次的对象，以及一个对象能被同时获取多次两种类型的对象池。正常对象是必须用Single模式的，只有一些资源部分可以用Multi。</p><p>这一层在</p><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>需要一个逻辑物体<strong>ObjectBase</strong>，以及继承Mono的表现物体<strong>GameFrameworkComponent</strong>。</p><p>官方Demo的示例：</p><p><strong>HPBarItemObject</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HPBarItemObject</span> : <span class="title">ObjectBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HPBarItemObject <span class="title">Create</span>(<span class="params"><span class="built_in">object</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HPBarItemObject hpBarItemObject = ReferencePool.Acquire&lt;HPBarItemObject&gt;();</span><br><span class="line">        hpBarItemObject.Initialize(target);</span><br><span class="line">        <span class="keyword">return</span> hpBarItemObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"><span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 销毁血条的GameObject</span></span><br><span class="line">        HPBarItem hpBarItem = (HPBarItem)Target;</span><br><span class="line">        Object.Destroy(hpBarItem.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HPBarComponent</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HPBarComponent</span> : <span class="title">GameFrameworkComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> HPBarItem m_HPBarItemTemplate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Transform m_HPBarInstanceRoot = <span class="literal">null</span>; <span class="comment">// 设置生成物体的Root</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_InstancePoolCapacity = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IObjectPool&lt;HPBarItemObject&gt; m_HPBarItemObjectPool = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HPBarItem&gt; m_ActiveHPBarItems = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Canvas m_CachedCanvas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_HPBarInstanceRoot == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Error(<span class="string">&quot;You must set HP bar instance root first.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_CachedCanvas = m_HPBarInstanceRoot.GetComponent&lt;Canvas&gt;();</span><br><span class="line">        <span class="comment">// 传入对象池名字、对象池容量作为参数，并持有这个对象池的接口引用</span></span><br><span class="line">        m_HPBarItemObjectPool = GameEntry.ObjectPool.CreateSingleSpawnObjectPool&lt;HPBarItemObject&gt;(<span class="string">&quot;HPBarItem&quot;</span>, m_InstancePoolCapacity);</span><br><span class="line">        m_ActiveHPBarItems = <span class="keyword">new</span> List&lt;HPBarItem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HideHPBar</span>(<span class="params">HPBarItem hpBarItem</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不再需要该对象时</span></span><br><span class="line">        hpBarItem.Reset();</span><br><span class="line">        m_ActiveHPBarItems.Remove(hpBarItem);</span><br><span class="line">        m_HPBarItemObjectPool.Unspawn(hpBarItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HPBarItem <span class="title">CreateHPBarItem</span>(<span class="params">Entity entity</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HPBarItem hpBarItem = <span class="literal">null</span>;</span><br><span class="line">        HPBarItemObject hpBarItemObject = m_HPBarItemObjectPool.Spawn();</span><br><span class="line">        <span class="keyword">if</span> (hpBarItemObject != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果对象池里有空闲对象,就直接返回</span></span><br><span class="line">            hpBarItem = (HPBarItem)hpBarItemObject.Target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果对象池里无空闲对象,就自己在外部建好物体,然后由此创建为ObjectBase,最后丢到池里注册</span></span><br><span class="line">            hpBarItem = Instantiate(m_HPBarItemTemplate);</span><br><span class="line">            Transform transform = hpBarItem.GetComponent&lt;Transform&gt;();</span><br><span class="line">            transform.SetParent(m_HPBarInstanceRoot);</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">            m_HPBarItemObjectPool.Register(HPBarItemObject.Create(hpBarItem), <span class="literal">true</span>); <span class="comment">// true:注册时就立马使用; false:注册时不立马使用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hpBarItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inspector面板监视-1"><a href="#Inspector面板监视-1" class="headerlink" title="Inspector面板监视"></a>Inspector面板监视</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220128142351.png"></p><h2 id="引用池与对象池的区别"><a href="#引用池与对象池的区别" class="headerlink" title="引用池与对象池的区别"></a>引用池与对象池的区别</h2><ol><li>  引用池从池子内部通过默认构造方法创建对象，只适合普通的C#对象。对象池是在外部自行创建对象后再注册进去，能用于必须通过Unity API才能实例化的对象。</li><li>  引用池仅提供Clear接口来清除对象状态，在移除对象时没有任何额外处理，仅仅是去掉引用，适用于受GC管理的类型。而对象池提供OnSpawn，OnUnspawn两个操作，且在移除对象时，提供Release接口，对于Unity中的GameObject需要在Release写上Destroy(gameObject)的逻辑才能销毁。</li><li>  对象池提供自行释放的机制，可指定每个池子自动释放周期、物体过期时长、池子容量，并在可一定程度上自定义每个池子的释放策略。引用池没有以上机制，仅可通过Remove接口主动移除对象。</li><li>  对象池提供锁定物体、自定义释放标记功能，可进一步定制释放策略。</li></ol><h2 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h2><p><strong>同一个对象池中，为什么还要以Name区分对象集合？</strong></p><p>在同一个prefab上挂上相同的脚本，最后以他们的资源路径名字作为Name，则可在一个对象池中对不同外形的陨石进行区分，以实现向一个对象池取不同外型的陨石的需求。</p><blockquote><p>  官方Demo StarForce中的陨石对象池，虽然他们都是同一个类型，具有相同的逻辑，但他们可能有不一样的外型。我们把外型不同的陨石做成单独prefab，并在这些prefab上挂上相同的脚本，最后以他们的资源路径名字作为Name，则可在一个对象池中对不同外形的陨石进行区分，以实现向一个对象池取不同外型的陨石的需求。</p></blockquote><p><strong>在同一个对象池中以Name区分对象，与用多个对象池储存不同Name的对象有什么区别？</strong></p><p>让开发者能更好地规划释放策略。</p><blockquote><p>  主要区别就在于一个对象池执行同一个释放逻辑，而多个对象池是各自执行各自的释放逻辑。继续以上面的陨石为例子，我们一共有3种陨石，我希望储存陨石的对象池总容量是60，我们随机去生成不同种类的陨石，如果随机结果不均匀，最终池子里可能有种类一40个，种类二15个，种类三5个，在我们把他们放在同一对象池下管理情况下，这没有什么问题，无论怎样它都很好地以总数量为60个的策略去管理。但如果我们把不同外形的陨石分到不同的对象池去管理，我们很难去动态调整3个池子的容量平衡，以达到总数量为60的策略。</p></blockquote><p><strong>为什么既有引用池又有对象池，全部用对象池不是就可以满足需求了吗？</strong></p><p>对象池太繁琐，引用池使用更轻便。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> GameFramework框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 小概念篇</title>
      <link href="/Tech/CSharp/Essence/tips/"/>
      <url>/Tech/CSharp/Essence/tips/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。但该变量提供的值并非变量创建时的值，而是<strong>在外部新建一个对象再把对象的引用传给内层函数</strong>。</p><h2 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h2><p>比如在winform想实现：当用户关闭窗体时，给用户一个提示框。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">string</span> tipWords = <span class="string">&quot;您将关闭当前对话框&quot;</span>;</span><br><span class="line">       <span class="keyword">this</span>.FormClosing += <span class="built_in">delegate</span></span><br><span class="line">       &#123;</span><br><span class="line">            MessageBox.Show(tipWords);</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h2><p>因为内层函数取得的外层函数是其“在父函数范围内（看闭包实现可以知道这不准确）”的最终值，所以遇到需要变动的值（比如循环变量）很容易写错代码。</p><p>比如说你想输出1-100的数字：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     Console.WriteLine(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 100 100 ...</span></span><br></pre></td></tr></table></figure><p>你会发现和你想做的事，根本不一样，这就是闭包陷阱！正确的做法是<strong>使用临时变量保存</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">        Console.WriteLine(j);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然还是利用了闭包特性，但是临时变量j的最终值是1-100的100个数字！</p><h2 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h2><p>通过反编译再精简代码，看看C#编译器帮我们做了什么。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TempClass tempClass = <span class="keyword">new</span> TempClass();</span><br><span class="line">    tempClass.i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tempClass.i &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Run(<span class="keyword">new</span> Action(tempClass.tempMethod));</span><br><span class="line">        tempClass.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TempClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">tempMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来只是帮我们新建了一个类，然后在循环内部大家<strong>共用一个对象</strong>！</p><p>但是只是共用一个对象，为什么输出全是100？线程输出的时候，又不一定是100啊。确实是这样，当我将循环次数改到10000（或者在循环中加入Delay）的时候，发现结果不一样了，输出了好多10000以外的数字。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     Console.WriteLine(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 7086 8755 8787 7366 9888 ... 10000 10000 10000 10000 10000 ...</span></span><br></pre></td></tr></table></figure><p>所以只是循环的太快了而已！确实跟反编译的结果一致，是<strong>共用一个对象，而不是父函数范围内的最终值</strong>。</p><p>最后再来看一下加了临时变量后的反编译结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TempClass tempClass = <span class="keyword">new</span> TempClass();</span><br><span class="line">        tempClass.j = i;</span><br><span class="line">        Task.Run(<span class="keyword">new</span> Action(tempClass.tempMethod));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TempClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">tempMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，优化的跟前面结构完全不一样了，使用临时变量后，现在是大家<strong>不共用一个对象</strong>了。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 值类篇</title>
      <link href="/Tech/CSharp/Essence/structAndObject/"/>
      <url>/Tech/CSharp/Essence/structAndObject/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是值类型，什么是引用类型？"><a href="#什么是值类型，什么是引用类型？" class="headerlink" title="什么是值类型，什么是引用类型？"></a>什么是值类型，什么是引用类型？</h1><p>结构体、枚举是值类型，类是引用类型。当然，所有类型都是隐式继承自Object的。</p><h2 id="值类型有哪些"><a href="#值类型有哪些" class="headerlink" title="值类型有哪些"></a>值类型有哪些</h2><p>结构体、枚举。</p><p>所有“结构体struct”都是抽象类System.ValueType的直接派生类，因此它不能再继承类了。而System.ValueType本身又直接从System.Object派生。</p><p>所有“枚举enum”都从System.Enum抽象类派生，System.Enum本身有直接从System.ValueType派生。</p><h2 id="哦？你说System-Enum和System-ValueType抽象类？"><a href="#哦？你说System-Enum和System-ValueType抽象类？" class="headerlink" title="// 哦？你说System.Enum和System.ValueType抽象类？"></a>// 哦？你说System.Enum和System.ValueType抽象类？</h2><p>是的，虽然所有的枚举（enum type）都是值类型、内存分配也在栈上、会被装箱，但他们都继承自System.Enum抽象类，而System.Enum抽象类本身是引用类型。</p><p>结构体（struct type）也是一样的，System.ValueType抽象类型本身也是个类，是引用类型。</p><p>至于为什么，这是一种隐式继承，是由编译器做到的。怎么实现的我没有了解，但知道他们的IL代码不一样的，内部有很多字面值关键词 literal。</p><h2 id="值类型特点"><a href="#值类型特点" class="headerlink" title="值类型特点"></a>值类型特点</h2><ul><li>  值类型实例一般在线程栈上分配（当然也可以作为字段嵌入引用类型的对象中，那就在堆上了）。</li><li>  在代表值类型的实例中包含的是实例本身的字段，而不是引用or指针。</li><li>  值类型的实例不受GC垃圾回收器的控制，意思是不会引起GC，从而有效减少了GC回数。当然，它在线程栈里，所以 <strong>方法体结束、栈帧展开后</strong> 他就没了。</li></ul><h2 id="引用类型有哪些"><a href="#引用类型有哪些" class="headerlink" title="引用类型有哪些"></a>引用类型有哪些</h2><p>像所有的class都是引用类型，隐式继承Object类型。</p><p><strong>abstarct</strong>是抽象类型，它不可以被实例化。用它是因为它可以在内部定义抽象成员（方法、属性、索引器、事件），编译器要求派生类必须实现这些成员。</p><h2 id="⭐abstarct方法-和-virtual方法-区别是什么？"><a href="#⭐abstarct方法-和-virtual方法-区别是什么？" class="headerlink" title="⭐abstarct方法 和 virtual方法 区别是什么？"></a>⭐abstarct方法 和 virtual方法 区别是什么？</h2><p>首先是定义上，abstarct方法只能在抽象类里定义，virtual方法则是所有类。</p><p>其次是使用上，抽象方法要求派生类必须override实现（因为它没有方法实体），而虚方法可以被派生类override重写、也可以不重写（因为它有方法实体）。</p><p>但是注意！abstarct方法 和 virtual方法 本质上是一样的：剥开外衣，它们的IL代码定义都是virtual。这里不展开，详细看《C#精要 - 类内成员篇》。</p><h2 id="引用类型特点"><a href="#引用类型特点" class="headerlink" title="引用类型特点"></a>引用类型特点</h2><ul><li>  引用类型只能在堆上分配。</li><li>  引用类型的资源清理交给GC处理。</li><li>  堆上分配的每个对象都有2个额外成员：类型对象指针和同步块索引。</li></ul><h1 id="装箱拆箱是什么？"><a href="#装箱拆箱是什么？" class="headerlink" title="装箱拆箱是什么？"></a>装箱拆箱是什么？</h1><p>实质是<strong>内存迁移</strong>。而这个“箱”其实就是托管堆。</p><p>装箱：值类型转换引用类型的时候，将栈上的数据拷贝到堆上。</p><p>拆箱：之前由值类型转换而来的对象类型再转回值类型，从堆拷贝回栈上。</p><h2 id="装箱步骤"><a href="#装箱步骤" class="headerlink" title="装箱步骤"></a>装箱步骤</h2><ol><li> 分配内存: 在托管堆中分配好内存，内存的大小是值类型的各个字段需要的内存量加上托管堆的所有对象都有的两个额外成员—类型对象指针和同步块索引—所需要的内存量之和。</li><li> 复制对象: 将值类型的字段复制到新分配的内存中。</li><li> 返回地址: 将已装箱的值类型对象的地址返回给引用类型的变量。</li></ol><h2 id="拆箱步骤"><a href="#拆箱步骤" class="headerlink" title="拆箱步骤"></a>拆箱步骤</h2><ol><li> 检查实例：首先检查变量的值是否为null，如果是则抛出NullReferenceException异常；再检查变量的引用指向的对象是不是给定值类型的已装箱对象，如果不是，则抛出InvalidCastException异常。</li><li> 返回地址：返回已装箱实例中属于原值类型字段的地址，而两个额外成员（类型对象指针和同步块索引）则不会返回。</li></ol><h1 id="聊一下String"><a href="#聊一下String" class="headerlink" title="聊一下String"></a>聊一下String</h1><h2 id="String是什么类型？"><a href="#String是什么类型？" class="headerlink" title="String是什么类型？"></a>String是什么类型？</h2><p>是个特殊的引用类型。</p><h2 id="怎么个特殊法呢？"><a href="#怎么个特殊法呢？" class="headerlink" title="怎么个特殊法呢？"></a>怎么个特殊法呢？</h2><p>String类型对象直接派生自Object，所以String是引用类型，它在堆上分配内存。</p><p>但是String类型却又有值类型的特性，具体来说它用的时候像值类型一样，也就是不变性，两个变量赋一样的String类型，修改其中一个并不会让另一个变量跟着变。</p><h2 id="聊聊不变性"><a href="#聊聊不变性" class="headerlink" title="聊聊不变性"></a>聊聊不变性</h2><p>不变性简单来说就是String对象一旦创建，就不能再更改，包括不能变长、变短或修改其中任何字符。</p><p>所以上面我提到的“修改其中一个变量”，实际上做的事是创建了一个新的String对象并让变量指向这个新对象。</p><p>不变性的好处：</p><ol><li>  项目里用ToUpper、Substring之类的获取新字符串，不会影响到原对象。</li><li>  因为不可变，所以不会有线程同步问题</li></ol><p>不变性的坏处：</p><ol><li>  项目里拼接的时候，比如我想用+操作符拼接字符串，过程中每一步都会生成一个新字符串。这样就增加了额外开销，影响GC。</li></ol><p>想避免坏处可以使用StringBuilder类。不过呢，CLR有对string有着留用机制、字符串池这两项优化手段，所以一般来说问题不算大。</p><h2 id="CLR字符串留用"><a href="#CLR字符串留用" class="headerlink" title="CLR字符串留用"></a>CLR字符串留用</h2><p>比如你对两个变量都赋值一个字符串字面值，那么它们指向的都是堆上的同一个对象。这是CLR帮你优化的。</p><p>CLR初始化时，会在内部创建一个哈希表，这个表中，key是字符串，value则是托管堆中String对象的引用。然后编译时，CLR默认会对程序集的元数据中描述的所有字面值字符串进行留用，也就是让他们指向同一个对象。但是这并不可靠，有CompilationRelaxationsArrtibute和NoStringInterning两个特性会让CLR不留用，而且运算时确定的string值也是不会被留用的。</p><p>只有显示调用<code>Intern</code>方法（获取参数String对象的哈希码，并在内部哈希表中检查是否有相匹配，没有就创建再返回引用）才能确定可靠的被留用。</p><h2 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h2><p>是和元数据量有关的。编译源代码时，编译器必须处理每个字面值字符串，并在托管模块的元数据中嵌入。为了让元数据小点，对于相同的字面值，在元数据中第一次会写入，后面只会引用元数据的同一个字符串。</p><h2 id="使用StringBuilder避免坏处"><a href="#使用StringBuilder避免坏处" class="headerlink" title="使用StringBuilder避免坏处"></a>使用StringBuilder避免坏处</h2><p>由于String类型是不可变的，FCL推出StringBuilder类对应可变字符串的需求。</p><p>StringBuilder 对象包含一个字段，该字段引用了由Char结构构成的数组（字符数组）。StringBuilder提供很多方法来操作这个字符数组。<strong>正是这样避免了不可变性带来的坏处，每次操作不会像String一样新建对象。</strong></p><p>它还会动态扩容。如果字符串变大，超过了事先分配的字符数组大小，StringBuilder会新建一个StringBuilder对象并对构造器传入自己，再将其作为前结点，然后将自己维护的char数组重新赋值为需要额外分配的chunk大小（new char[]）。<strong>所以StringBuilder其实是一个单链表。</strong></p><p>最后调用ToString方法把他转换为String型，就能正常使用了。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR Via C#个人笔记7 - 线程处理</title>
      <link href="/Tech/CSharp/CLR-Via-CSharp/cp7/"/>
      <url>/Tech/CSharp/CLR-Via-CSharp/cp7/</url>
      
        <content type="html"><![CDATA[<h1 id="大章26：线程基础"><a href="#大章26：线程基础" class="headerlink" title="大章26：线程基础"></a><center>大章26：线程基础</center></h1><h2 id="Widnows的线程概念"><a href="#Widnows的线程概念" class="headerlink" title="Widnows的线程概念"></a>Widnows的线程概念</h2><p>在<strong>没有线程概念</strong>的时候，机器都是“单线程”运行的，长时间运行的任务会阻止其他任务执行（16位windows下打印文档很容易“冻结”整个机器导致各种程序出错）。</p><p>所以微软设计新的OS内核来改进这些问题，该内核决定在进程中运行应用程序的每个实例。<strong>进程</strong>实际是应用程序的实例要使用的资源的集合，每个进程都被赋予了一个虚拟地址空间来避免被其它进程访问。</p><p>但是光这样还不够，如果机器只有一个CPU，应用程序死循环仍然会导致其他程序无法运行。<strong>线程</strong>就是微软交出的解决方案，它是一个Windows概念，它的职责是对CPU进行虚拟化，为每个进程都提供该进程专用的线程（功能相当于原来的一个物理CPU）。所以单物理CPU机器，一个进程死循环，不影响其他进程。</p><h2 id="线程开销⭐"><a href="#线程开销⭐" class="headerlink" title="线程开销⭐"></a>线程开销⭐</h2><p>和一切虚拟化机制一样，线程有空间（内存耗用）和时间（运行时的执行性能）上的开销。</p><p>下面对每个线程都有的开销一一介绍。</p><h3 id="①线程内核对象-thread-kernel-object"><a href="#①线程内核对象-thread-kernel-object" class="headerlink" title="①线程内核对象 (thread kernel object)"></a>①线程内核对象 (thread kernel object)</h3><p>这是OS为系统中创建的每个线程都分配并初始化的数据结构之一。</p><p>对象中包括对线程进行描述的属性、**线程上下文(thread context)**：线程上下文是包含CPU寄存器集合的内存块，x64使用约1240字节的内存。上下文是线程上一次执行完毕后，CPU寄存器的状态。</p><h3 id="②线程环境块-thread-environment-block-TEB"><a href="#②线程环境块-thread-environment-block-TEB" class="headerlink" title="②线程环境块 (thread environment block,TEB)"></a>②线程环境块 (thread environment block,TEB)</h3><p>TEB耗用一个内存页（x64中4KB），</p><p>里面有**异常处理链首(head)**：线程每进入一个try块，都会在链首(head)中插入一个节点(node)，退出try块时删除该节点。</p><p>此外，TEB中还有<strong>GDI(图形设备接口)和OpenGL</strong>用的一些数据。</p><h3 id="③用户模式栈-user-mode-stack"><a href="#③用户模式栈-user-mode-stack" class="headerlink" title="③用户模式栈 (user- mode stack)"></a>③用户模式栈 (user- mode stack)</h3><p>堆栈概念中的栈说的就是这个了，默认分配1MB内存（其实windows是保留1MB容量，等用了才调拨给你）。</p><p>用户模式栈存储传给方法的<strong>局部变量和实参</strong>。还包含一个<strong>返回地址</strong>：指出当前方法返回时线程该从什么地方执行。</p><h3 id="④内核模式栈-kernel-mode-stack"><a href="#④内核模式栈-kernel-mode-stack" class="headerlink" title="④内核模式栈 (kernel- mode stack)"></a>④内核模式栈 (kernel- mode stack)</h3><p>分配x86是12KB，x64是24KB。</p><p>应用程序代码向OS中的内核模式函数传递实参时，会复制 用户模式栈 传去的实参并加以验证并不允许修改。最后OS内核代码开始处理复制的值。</p><p><strong>应用程序代码发起内核模式函数调用 -&gt; 用户模式栈 -&gt; 内核模式栈 -&gt; 内核模式函数</strong></p><h3 id="⑤DLL线程连接-attach-和线程分离-detach-通知"><a href="#⑤DLL线程连接-attach-和线程分离-detach-通知" class="headerlink" title="⑤DLL线程连接 (attach)和线程分离 (detach)通知"></a>⑤DLL线程连接 (attach)和线程分离 (detach)通知</h3><p>一个Windows机制：在进程中创建线程时，都会调用进程中加载的所有非托管DLL的 DllMain方法并向该方法传递 <strong>DLL_THREAD_ATTACH</strong>标志；终止线程时，同样调用 DllMain方法并向该方法传递 <strong>DLL_THREAD_DETACH</strong>标志。</p><p>有的DLL需要这些通知才能为进程中 创建/销毁 的每个线程执行特殊的 初始化/资源清理 ，比如C-Runtime库DLL。</p><h3 id="上下文调度"><a href="#上下文调度" class="headerlink" title="上下文调度"></a>上下文调度</h3><p>首先搞清楚一点，下面讨论的都是<strong>单物理CPU（或者单核CPU）且线程数&gt;CPU数</strong>的情况！！！想看Windows的调度，去看“线程调度和优先级”节。</p><p>Windows任何时刻都只将一个线程分配给一个CPU(或CPU核，下面称CPU)。</p><p>CPU会为线程执行一个<strong>时间片 (quantum)<strong>的时长，大概30ms吧，等时间片到期了，就会进行</strong>上下文调度</strong>切换执行另一个线程。<strong>上下文</strong>是线程上一次执行完毕后，CPU寄存器的状态。</p><p>上下文调度具体流程：</p><ol><li>  将CPU寄存器的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。</li><li>从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有， Windows在<br>  开始执行任何代码或者接触任何数据之前，还必须切换CPU“看见”的虚拟地址空间。</li><li>  将所选上下文结构中的值加载到CPU的寄存器中。</li></ol><p>上下文调度之后线程切换完成，CPU就会执行所选的线程，直到下一个时间片过了又要切换。</p><p>毫无疑问，这个机制是一个非常大的开销，特别是数据不在cache中的时候访问会很慢导致还没做点啥就切换别的线程了。</p><p>上下文切换是<strong>净开销</strong>，也就是说它所产生的开销不会换来任何内存或性能上的收益，只是为了能够提供一个健壮的、响应灵敏的操作系统。比如，一个应用程序的线程进入死循环， Windows会定期抢占( preempt)它，将新线程分配给CPU从而使新线程有机会运行。假如新线程是任务管理器线程，就能终止包含了死循环线程的进程。</p><h4 id="多核情况"><a href="#多核情况" class="headerlink" title="多核情况"></a>多核情况</h4><p>理解了上面说的机制，再来理解多核心CPU的情况：</p><p>安装了多个CPU（或者一个多核CPU）的计算机可以真正同时运行几个线程，Windows为每个CPU内核都分配一个线程，每个内核都自己执行到其他线程的上下文切换，<strong>且Windows确保单个线程不会同时在多个内核上调度</strong>。</p><h2 id="停止疯狂"><a href="#停止疯狂" class="headerlink" title="停止疯狂"></a>停止疯狂</h2><p>知道了上下文调度机制，不难得出：<strong>如果只关心性能，线程数和CPU核心数一致才是最好的。</strong>如果线程数超过了CPU的数目，就会产生上下文切换和性能损失。如果每个CPU只有一个线程，就不会有上下文切换，线程将全速运行。</p><p>但是仍然选择这么做，是因为能让Windows整体更不容易崩溃、提高响应能力。</p><p>那么标题为什么要叫停止疯狂呢？</p><p>因为打开我的任务管理器一看，发现一台4核的cpu跑了300多个进程4000个线程，光给线程就分配掉了4GB的内存，离大谱！而大部分线程压根没被调用就是挂着，是一种极大的浪费。</p><h3 id="CPU发展趋势"><a href="#CPU发展趋势" class="headerlink" title="CPU发展趋势"></a>CPU发展趋势</h3><p>了解即可，讲讲硬件有个概念。</p><p>CPU厂商过去只知道一味地提高CPU速度。但CPU厂商没有延续这个趋势，因为高速运行的CPU会产生大量热量。</p><p>所以发展方向变成了实现多线程，物理上有这么些手段：</p><ul><li>  多个CPU，不适合普通用户。</li><li>  超线程芯片，硬件上实现多线程。通过分支预测错误和缓存未命中和等待数据的优化，来不停切换线程，实现1个线程能当2个用。WindowsOS层面并不知道硬件CPU其实是超线程的，他只知道有2个线程在并发执行。</li><li>  多核芯片，适合普通用户。</li></ul><h2 id="CLR线程和-Windows线程"><a href="#CLR线程和-Windows线程" class="headerlink" title="CLR线程和 Windows线程"></a>CLR线程和 Windows线程</h2><p>CLR使用 Windows的线程处理功能。</p><h2 id="使用专用线程"><a href="#使用专用线程" class="headerlink" title="使用专用线程"></a>使用专用线程</h2><h3 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h3><p>创建线程来执行异步的计算限制(compute- bound)操作，不过这门技术并不推荐，<strong>推荐使用线程池来执行异步</strong>。</p><p>但还是说回来，不用线程池而是显式创建线程来专门执行一个计算限制的操作的情况，一般是线程池方式做不到的事，比如以下几种：</p><ul><li>  线程需要以非普通线程优先级运行。（所有线程池线程都以普通优先级运行）</li><li>  需要线程表现为一个前台线程，防止应用程序在线程结束任务前终止。</li><li>  计算限制的任务需要长时间运行。（线程池为了判断是否需要创建一个额外的线程）</li><li>  要启动线程，并可能调用 Thread的 Abort方法来提前终止它。</li></ul><h3 id="创建专用线程，并执行异步的计算限制操作"><a href="#创建专用线程，并执行异步的计算限制操作" class="headerlink" title="创建专用线程，并执行异步的计算限制操作"></a>创建专用线程，并执行异步的计算限制操作</h3><p>为了创建专用线程，要构造 System.Threading.Thread类的实例，向构造器传递一个方法<br>名。以下是 Thread的构造器的原型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Thread</span> : <span class="title">CriticalFinalizerObject</span>, ... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span>(<span class="params">ParameterizedThreadStart start</span>)</span>;</span><br><span class="line">    <span class="comment">// 未列出不常用的构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start参数表示<strong>专用线程要执行的方法</strong>，这个方法必须和 ParameterizedThreadStart委托的签名匹配：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">ParameterizedThreadStart</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;</span><br></pre></td></tr></table></figure><p>光创建线程还不算完，并不会真的创建一个操作系统线程。要实际创建一个操作系统线程，并让它开始执行回调方法，必须调用 <strong>Thread的Start方法</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="comment">// Main thread: starting a dedicated thread (专用线程)</span></span><br><span class="line">    Thread dedicatedThread = <span class="keyword">new</span> Thread(ComputeBoundOp);</span><br><span class="line">    dedicatedThread.Start(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>); <span class="comment">// 模拟做其他工作(10秒)</span></span><br><span class="line">    dedicatedThread.Join();<span class="comment">// 等待线程终止。Join：在此实例表示的线程终止前，阻止调用线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法的签名必须和 ParameterizedThreadStart委托匹配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ComputeBoundOp</span> (<span class="params"><span class="built_in">object</span> state</span>)</span> &#123;</span><br><span class="line">    WriteLine(state);</span><br><span class="line">    Thread. Sleep(<span class="number">1000</span>); <span class="comment">// 模拟做其他任务(1秒)</span></span><br><span class="line">    <span class="comment">// 这个方法返回后，专用线程将终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 5</span></span><br></pre></td></tr></table></figure><h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><h4 id="画面响应（通常是对于客户端GUI应用程序）"><a href="#画面响应（通常是对于客户端GUI应用程序）" class="headerlink" title="画面响应（通常是对于客户端GUI应用程序）"></a>画面响应（通常是对于客户端GUI应用程序）</h4><p>Windows为每个进程提供它自己的线程，确保发生死循环的应用程序不会妨碍其他应用程序。类似的，在客户端GUI应用程序中，可以将一些工作交给一个线程进行，使GUI线程能灵敏地响应用户输入。</p><h4 id="性能（对于客户端和服务器应用程序）"><a href="#性能（对于客户端和服务器应用程序）" class="headerlink" title="性能（对于客户端和服务器应用程序）"></a>性能（对于客户端和服务器应用程序）</h4><p>由于Windows每个CPU调度一个线程，而且多个（核）CPU能并发执行这些线程，所以能提升性能。</p><h2 id="线程调度和优先级⭐"><a href="#线程调度和优先级⭐" class="headerlink" title="线程调度和优先级⭐"></a>线程调度和优先级⭐</h2><h3 id="Windows的线程调度"><a href="#Windows的线程调度" class="headerlink" title="Windows的线程调度"></a>Windows的线程调度</h3><p>前面讲过单核CPU的上下文切换，属于是线程调度的最初级理论，下面由Windows的机制深入。</p><h4 id="重温一下上下文切换流程"><a href="#重温一下上下文切换流程" class="headerlink" title="重温一下上下文切换流程"></a>重温一下上下文切换流程</h4><p>**上下文(context)**结构反映了线程上一次执行完毕后CPU寄存器的状态。</p><p>在一个**时间片(time-slice)**之后，Windows检查现存的所有线程内核对象，在这些对象中只有那些没有正在等待什么的线程才合适调度。</p><h4 id="饥饿-starvation"><a href="#饥饿-starvation" class="headerlink" title="饥饿(starvation)"></a>饥饿(starvation)</h4><p>而在这些线程中，系统调度CPU执行哪一个线程，是由线程自己的<strong>优先级</strong>决定的，有0<del>31(31最高)的优先级。只要存在可调度的优先级31的线程，系统就永远不会调度CPU给0</del>30的任何线程。高优先级的线程占用CPU太久，使低优先级线程无法运行，这种情况称为**饥饿(starvation)**。</p><p><strong>多处理器</strong>的机器很少出现饥饿情况，因为能同时并行执行很多线程。</p><h4 id="抢占式操作系统"><a href="#抢占式操作系统" class="headerlink" title="抢占式操作系统"></a>抢占式操作系统</h4><p>Windows是<strong>抢占式多线程(preemptive multithreaded)操作系统</strong>，线程可在任何时间停止（被抢占）并调度另一个线程。</p><p>Windows是<strong>抢占式</strong>，低优先级的线程哪怕时间片没用完，也会被立刻挂起执行优先级更高的线程。</p><h4 id="零页线程-zero-page-thread"><a href="#零页线程-zero-page-thread" class="headerlink" title="零页线程(zero page thread)"></a>零页线程(zero page thread)</h4><p>系统启动时会创建一个特殊的<strong>零页线程</strong>，优先级为0，在没有其他线程需要“干活儿”的时候，零页线程将系统RAM的所有空闲页清零。Windows不允许其他线程的优先级为0。</p><h3 id="线程优先级and进程优先级"><a href="#线程优先级and进程优先级" class="headerlink" title="线程优先级and进程优先级"></a>线程优先级and进程优先级</h3><p>前面讲过了优先级是0~31，现在看一下自己写的程序可控制的优先级映射。</p><p>进程可通过**优先级类(priority class)**来控制优先级，一共6种；线程7种。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112120814.png"></p><p>注意，表中没有值为0的线程优先级。这是因为0优先级保留给零页线程了，系统不允许其他线程的优先级为0。而且，以下优先级也不可获得：17,18,19,20,21,27,28,29或者30。以内核模式运行的设备驱动程序才能获得这些优先级。</p><p>我们可以通过System.Diagnostics的<strong>Process类和ProcessThread类</strong>获取进程线程的windows视图。也可以通过<strong>AppDomain和Thread类</strong>获取线程的CLR视图。</p><h2 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h2><p>CLR将每个线程要么视为前台线程，要么视为后台线程。一个进程的所有<strong>前台线程</strong>停止运行时，CLR强制终止仍在运行的任何<strong>后台线程</strong>。这些后台线程被直接终止；不抛出异常。</p><p>每个AppDomain都可运行一个单独的应用程序，而每个应用程序都有自己的前台线程。如果应用程序退出，造成它的前台线程终止，则CLR仍需保持活动并运行，使其他应用程序能继续运行。所有应用程序都退出，它们的所有前台线程都终止后，整个进程就可以被销毁了。</p><p>用<strong>Thread类</strong>新建线程默认是前台线程，<strong>线程池</strong>线程默认是后台线程。当然，可以通过<strong>Thread.Isbackground属性</strong>随时修改线程是前台还是后台。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>一般我们拿前台线程做画面，后台线程IO，这样用户关闭了程序界面 =&gt; 前台线程关闭 =&gt; 后台IO线程自动被关闭 =&gt; IO不执行下去（比如写入数据到Excel），是合理的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新线程（默认为前台线程）</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(Worker);</span><br><span class="line">    <span class="comment">// 使线程成为后台线程</span></span><br><span class="line">    t.IsBackground = <span class="literal">true</span>;</span><br><span class="line">    t.Start();<span class="comment">// 启动线程</span></span><br><span class="line">    <span class="comment">// ⭐如果t是前台线程，则应用程序大约10秒后才终止</span></span><br><span class="line">    <span class="comment">// ⭐如果t是后台线程，则应用程序立即终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Thread. sleep(<span class="number">10000</span>);<span class="comment">// 模拟做10秒钟的工作</span></span><br><span class="line">    <span class="comment">// 下面这行代码只有在由一个前台线程执行时才会显示</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Returning from Worker&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大章27：计算限制的异步操作"><a href="#大章27：计算限制的异步操作" class="headerlink" title="大章27：计算限制的异步操作"></a><center>大章27：计算限制的异步操作</center></h1><h2 id="CLR线程池基础"><a href="#CLR线程池基础" class="headerlink" title="CLR线程池基础"></a>CLR线程池基础</h2><p>一个CLR拥有一个**线程池(thread pool)**。如果一个CLR下有多个AppDomain，那么它们共享一个线程池；如果一个进程中加载了多个CLR，那么每个CLR都有自己的线程池。</p><h3 id="向线程池请求流程⭐"><a href="#向线程池请求流程⭐" class="headerlink" title="向线程池请求流程⭐"></a>向线程池请求流程⭐</h3><p>CLR初始化时，线程池中是没有线程的。在内部，线程池维护了一个<strong>操作请求队列</strong>。应用程序执行一个异步操作时，就会对线程池进行请求，具体是将一个<strong>记录项(entry)<strong>追加到队列中。线程池会从这个队列中提取记录项，将这个记录项</strong>派发(dispatch)<strong>给一个线程池的线程；如果线程池没有线程，就创建一个新线程。当这个线程完成任务后并</strong>不销毁，而是返回线程池、进入空闲状态</strong>。但是如果一个线程在线程池里闲太久了（应用程序很久不向线程池发出请求），为了避免资源浪费，CLR才会<strong>终止</strong>它。</p><h2 id="使用ThreadPool"><a href="#使用ThreadPool" class="headerlink" title="使用ThreadPool"></a>使用ThreadPool</h2><p>使用ThreadPool执行简单的计算限制操作。</p><p>调用<code>ThreadPool.QueueUserWorkItem(WaitCallback cb);</code>或<code>ThreadPool.QueueUserWorkItem(WaitCallback cb, object state);</code>。这两个方法向线程池的队列添加一个**工作项(work item)**以及可选的状态数据，然后方法立刻返回。</p><p>传递的回调方法必须满足<code>delegate void WaitCallback(Object state);</code>。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面演示一下如何让一个线程池线程以异步方式调用一个方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem(DoSth, <span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread start ,id:&quot;</span> + + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread end ,id:&quot;</span> + +Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;thread from ThreadPool is doing sth ,state:&quot;</span> + state + <span class="string">&quot; thread id: &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于是异步进行的，所以有时会输出</span></span><br><span class="line"><span class="comment">//main thread start ,id:1</span></span><br><span class="line"><span class="comment">//thread from ThreadPool is doing sth ,state:5 thread id: 3</span></span><br><span class="line"><span class="comment">//main thread end ,id:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时会输出</span></span><br><span class="line"><span class="comment">//thread from ThreadPool is doing sth ,state:5 thread id: 3</span></span><br><span class="line"><span class="comment">//main thread start ,id:1</span></span><br><span class="line"><span class="comment">//main thread end ,id:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是不难看出，执行任务的线程是从线程池拿的，不再是主线程</span></span><br></pre></td></tr></table></figure><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>每个线程都关联了一个**执行上下文(execution context)**数据结构。它包含了安全设置(压缩栈、 Thread的 Principal属性和 Windows身份)、宿主设置、逻辑调用上下文数据。</p><p>每当一个**线程(初始线程)<strong>使用另一个</strong>线程(辅助线程，也就是线程使用的线程)<strong>执行任务时，为了确保两者的操作使用相同的安全设置和宿主设置，前者的上下文应</strong>流向 flow(复制到)**辅助线程。复制，这要耗费不少时间。</p><h3 id="阻断上下文的流向-flow"><a href="#阻断上下文的流向-flow" class="headerlink" title="阻断上下文的流向(flow)"></a>阻断上下文的流向(flow)</h3><p>可以使用<code>System.Threading.ExecutionContext</code>类来控制线程的执行上下文流到另一个线程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ExecutionContext</span> : <span class="title">IDisposable</span>, <span class="title">ISerializable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncFlowControl <span class="title">SuppressFlow</span>(<span class="params"></span>)</span>; <span class="comment">// 取消执行上下文在异步线程之间的流动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RestoreFlow</span>(<span class="params"></span>)</span>; <span class="comment">// 恢复执行上下文在异步线程之间的流动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFlowSuppressed</span>(<span class="params"></span>)</span>; <span class="comment">// 指示当前是否取消了执行上下文的流动</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个类，你可以<strong>阻止执行上下文的流动</strong>。当初始线程的上下文不流向辅助线程，辅助线程会使用上一次和它关联的任意执行上下文。所以你想要阻止流动，就需要确保<strong>辅助线程不应执行任何要依赖于执行上下文状态</strong>，比如用用户的Windows身份。</p><p>一般只拿来优化服务端应用程序，这样做对客户端程序优化甚微。</p><h4 id="阻断例子"><a href="#阻断例子" class="headerlink" title="阻断例子"></a>阻断例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将一些数据放到Main线程的逻辑调用上下文中</span></span><br><span class="line">    CallContext.LogicalSetData(<span class="string">&quot;Name&quot;</span>,<span class="string">&quot;Jeffrey&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化要由一个线程池线程做的一些工作,</span></span><br><span class="line">    <span class="comment">// 线程池线程能访问逻辑调用上下文数据</span></span><br><span class="line">    ThreadPool.QueueUserWorkItem (state =&gt; Console.WriteLine(<span class="string">&quot;Before:&quot;</span> + CallContext.LogicalGetData(<span class="string">&quot;Name&quot;</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在，阻止Main线程的执行上下文的流动</span></span><br><span class="line">    ExecutionContext.SuppressFlow();</span><br><span class="line">    <span class="comment">// 然后，再做同样的事</span></span><br><span class="line">    ThreadPool.QueueUserWorkItem (state =&gt; Console.WriteLine(<span class="string">&quot;After:&quot;</span> + CallContext.LogicalGetData(<span class="string">&quot;Name&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Before:Jeffrey</span></span><br><span class="line"><span class="comment">// After:</span></span><br></pre></td></tr></table></figure><p>阻断后的输出After，为空。注意，无论是对于ThreadPool还是Task对象，都有效。</p><h2 id="线程池如何管理线程"><a href="#线程池如何管理线程" class="headerlink" title="线程池如何管理线程"></a>线程池如何管理线程</h2><h3 id="设置线程池限制"><a href="#设置线程池限制" class="headerlink" title="设置线程池限制"></a>设置线程池限制</h3><p>CLR允许开发人员设置线程池要创建的最大线程数。书中说默认大概1000。不推荐自己设置，但是可以使用ThreadPool类提供的几个静态方法：GetMaxThreads、SetMaxThreads、GetMinThreads、SetMinThreads、GetAvailableThreads 来获取或更改线程数信息。</p><h3 id="线程池调度机制"><a href="#线程池调度机制" class="headerlink" title="线程池调度机制"></a>线程池调度机制</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220114141818.png"></p><h4 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h4><p>当调用ThreadPool.QueueUserWorkItem、Timer类、Task时，任务会被添加进<strong>全局队列</strong>中，全局队列采用<strong>先进先出FIFO</strong>的方式，让工作者线程们自己去取任务。</p><p>全局队列使用<strong>线程同步锁</strong>，这是为了避免多个线程同时取到一个任务。</p><h4 id="本地队列"><a href="#本地队列" class="headerlink" title="本地队列"></a>本地队列</h4><p>在全局队列中领完的任务会放入工作者线程各自的<strong>本地队列</strong>，本地队列采用<strong>后入先出LIFO</strong>的方式来执行任务。</p><p>本地队列一般不锁，因为只有对应的工作者线程访问它。但是也有例外，看下面。</p><h4 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h4><p>下面从工作者线程的角度去理解整体调度流程。</p><p>如果工作者线程发现自己<strong>本地队列空</strong>了，就会尝试从另一个工作者线程的本地队列“偷”一个Task。这个Task在本地队列的队尾，并会要求获取一个线程同步锁。</p><p>如果<strong>所有本地队列都空</strong>了，工作者线程会使用FIFO算法从全局队列取出一个工作项并获得它的锁。</p><p>如果<strong>全局队列也为空</strong>，工作者线程会进入睡眠状态。</p><p>如果<strong>工作者线程睡眠时间很长</strong>，它会自己醒来并销毁自身，释放线程使用的资源（内核、栈等）。</p><h2 id="协作式取消和超时"><a href="#协作式取消和超时" class="headerlink" title="协作式取消和超时"></a>协作式取消和超时</h2><p>讲的是可以用一个辅助类，可以传递自己的一个bool字段作为参数给线程，也可以注册一些回调事件。当执行这个辅助类的<strong>Cancel方法</strong>时，会将bool字段设置成false并执行那些回调。从而实现操控线程停止事务。</p><p>无论是ThreadPool方法还是Task，都能使用这种方法。</p><h3 id="CancellationTokenSource"><a href="#CancellationTokenSource" class="headerlink" title="CancellationTokenSource"></a>CancellationTokenSource</h3><p>System.Threading.CancellationTokenSource就是上面说的辅助类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CancellationTokenSource</span>: <span class="title">IDisposable</span><span class="comment">// 一个引用类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CancellationTokenSource</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;<span class="comment">// 释放资源,比如WaitHandle</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean IsCancellationRequested &#123; <span class="keyword">get</span>; &#125;<span class="comment">// 执行Cancel后就会变成false</span></span><br><span class="line">    <span class="keyword">public</span> CancellationToken Token &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cancel</span>(<span class="params"></span>)</span>;<span class="comment">// 内部调用 Cancel并传递 false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cancel</span>(<span class="params">Boolean throwOnFirstException</span>)</span>;<span class="comment">// 如果true,回调执行一遇到抛错就立刻返回;如果false,直到全部回调执行结束才会抛出一个报错list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类通过<strong>Token</strong>方法可以获得一个或多个CancellationToken（一个值类型），可以对它<strong>注册回调</strong>，当Source.Cancel的时候会触发Token们的回调</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CancellationToken &#123; <span class="comment">// 一个值类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CancellationToken None &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean IsCancellationRequested &#123; <span class="keyword">get</span>; &#125; <span class="comment">// 由非通过Task调用的操作调用(ThreadPool)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThrowIfCancellationRequested</span>(<span class="params"></span>)</span>; <span class="comment">// 由通过Task调用的操作调用(Task)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CancellationTokenSource， WaitHandle会收到信号</span></span><br><span class="line">    <span class="keyword">public</span> Waithandle Waithandle &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">// Gethashcode, Equals, operator==和 operator!=成员未列出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean Canbecanceled &#123; <span class="keyword">get</span>; &#125;<span class="comment">// 很少使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CancellationTokenRegistration <span class="title">Register</span>(<span class="params">Action&lt;<span class="built_in">object</span>&gt; callback, Object state, Boolean useSynchronizationContext</span>)</span>;<span class="comment">// 未列出更简单的重载版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">CancellationToken token = cts.Token;</span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">token.Register(() =&gt; Console.WriteLine(<span class="string">&quot;Count is cancelled, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">ThreadPool.QueueUserWorkItem(_ =&gt; Count(token, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Press &lt;Enter&gt; to cancel Thread Works&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line">cts.Cancel();</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params">CancellationToken token, <span class="built_in">int</span> countTo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> count = <span class="number">0</span>; count &lt; countTo; count++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 当Source执行Cancel时，会变成false</span></span><br><span class="line"><span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;break, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Console.WriteLine(count);</span><br><span class="line">Thread.Sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Press &lt;Enter&gt; to cancel Thread Works</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Count is cancelled, thread 1</span></span><br><span class="line"><span class="comment">// break, thread 3</span></span><br></pre></td></tr></table></figure><p>可以考虑这么用<strong>IsCancellationRequested字段</strong>以及<strong>Token回调事件</strong>。</p><p>注意了，输出的线程号不一样：**回调事件是调用线程做的(就是主线程thread 1)**。</p><h2 id="使用任务-Task"><a href="#使用任务-Task" class="headerlink" title="使用任务(Task)"></a>使用任务(Task)</h2><p>使用<strong>ThreadPool</strong>的方法，很容易就能发起一次异步的计算限制操作。但是它不透明，你无法知道什么时候完成，也无法对其添加回调函数。所以我们通过<strong>System.Threading.Tasks</strong>中的类型来使用任务。</p><h3 id="Task与ThreadPool等价写法"><a href="#Task与ThreadPool等价写法" class="headerlink" title="Task与ThreadPool等价写法"></a>Task与ThreadPool等价写法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(DoSth, <span class="number">5</span>);<span class="comment">// 用线程池方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Task(DoSth, <span class="number">5</span>).Start();<span class="comment">// 用Task做相等的事</span></span><br><span class="line">Task.Run(() =&gt; Dosth(<span class="number">5</span>));<span class="comment">// 与上面等价</span></span><br></pre></td></tr></table></figure><p>注意！<strong>无论是ThreadPool还是Task.Run，他们都是从线程池取线程</strong>。</p><h3 id="等待任务"><a href="#等待任务" class="headerlink" title="等待任务"></a>等待任务</h3><p>使用<code>Task.Wait();</code>可以让线程等待返回结果，返回类型在创建线程<code>Task&lt;TResult&gt;</code>的时候指定，返回值通过<code>Task.Result</code>获取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">            Thread.Sleep(<span class="number">3000</span>); <span class="comment">// 模拟做其他工作(3秒)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    task.Start(); <span class="comment">// 此时才开始执行任务</span></span><br><span class="line">    </span><br><span class="line">    task.Wait(); <span class="comment">// 进行3秒的等待</span></span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(task.Result); <span class="comment">// Result属性内部会调用Wait !!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3秒后output: 100</span></span><br></pre></td></tr></table></figure><p>如果在Task中抛错，异常会被吞噬并存储到一个集合中，线程会回到线程池。等到再调用Wait或Result时，会抛出<strong>System.AggregateException对象</strong>，它就是那个存储异常的集合。</p><p>但是如果一直不调用Wait或Result，就抛不出错。你可以通过向TaskScheduler.UnobservedTaskException事件登记回调函数来使Task被GC时抛出其异常。</p><h4 id="Task-WaitAny"><a href="#Task-WaitAny" class="headerlink" title="Task.WaitAny"></a>Task.WaitAny</h4><p>WaitAny静态方法 会阻塞调用线程，直到数组中的任何Task对象完成。方法返回一个int索引值，指明完成的是数组中哪个Task对象。方法返回后，线程被唤醒并继续运行，如果发生超时返回-1。</p><h4 id="Task-WaitAll"><a href="#Task-WaitAll" class="headerlink" title="Task.WaitAll"></a>Task.WaitAll</h4><p>WaitAll静态方法 也会阻塞调用线程，直到数组中的所有Task对象完成。方法返回一个bool值，true代表完成，false代表超时。</p><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>前面使用CancellationTokenSource的IsCancellationRequested属性来取消ThreadPool事务，这边Task类似，不过用的是Source的<strong>ThrowIfCancellationRequested方法</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Dosth</span>(<span class="params">CancellationToken ct, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(; n &gt; <span class="number">0</span>; n--)&#123;</span><br><span class="line">        <span class="comment">// 调用该Source的Cancel方法后,会抛出OperationCanceledException,否则不会抛出。</span></span><br><span class="line">        ct.ThrowIfCancellationRequested();</span><br><span class="line">        </span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和正常Task抛错一样会被吞，直到你调用Wait或Result才会抛出来。</p><h3 id="延续任务"><a href="#延续任务" class="headerlink" title="延续任务"></a>延续任务</h3><p>任务完成时自动启动新任务，用<strong>ContinueWith方法</strong>。在任务结束后，会调用线程池的<strong>其他线程</strong>继续帮你完成任务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; t = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;thread id &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">Thread.Sleep(<span class="number">3000</span>); <span class="comment">// 模拟做其他工作(3秒)</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">Task cwt = t.ContinueWith(task =&gt; Console.WriteLine(task.Result + <span class="string">&quot;,thread id &quot;</span> + Thread.CurrentThread.ManagedThreadId)); <span class="comment">// 结束后调用线程池的其他线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// thread id 3</span></span><br><span class="line"><span class="comment">// 100,thread id 4</span></span><br></pre></td></tr></table></figure><p>具体看thread id，执行任务 和 执行延续任务 的线程不是同一个。</p><p>可以传递一个<strong>TaskContinuationOptions位标志</strong>枚举类给延续任务，默认是None，有一个可能用到的TaskContinuationOptions.OnlyOnRanToCompletion枚举值，传这个代表只有在第一个任务成功执行（无抛错无取消）的情况才会执行延续任务。</p><h3 id="任务启动子任务"><a href="#任务启动子任务" class="headerlink" title="任务启动子任务"></a>任务启动子任务</h3><p>套娃。直到所有子任务运行结束，父任务才认为自己结束。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    Task t = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;main task,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub1,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line"><span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub2,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line"><span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub3,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line">        <span class="comment">// 这回咱们不sleep了,就看看是不是用了回收的线程,结果确实用了!</span></span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// main,thread id:1</span></span><br><span class="line"><span class="comment">// main task,thread id:3</span></span><br><span class="line"><span class="comment">// sub1,thread id:4</span></span><br><span class="line"><span class="comment">// sub3,thread id:3</span></span><br><span class="line"><span class="comment">// sub2,thread id:4</span></span><br></pre></td></tr></table></figure><p>看输出，顺便测试了一下子线程会不会借助已经回收到线程池的父线程来完成任务，结果是<strong>肯定</strong>的！</p><h3 id="任务内部揭秘"><a href="#任务内部揭秘" class="headerlink" title="任务内部揭秘"></a>任务内部揭秘</h3><p>Task比起ThreadPool多了很多可控性，但是这不是无偿的，Task方式起线程会比ThreadPool方法至少多了：</p><ul><li>  Task唯一标识id，从1开始递增分配。只有查询时才分配，一经分配不会重复发放相同数字。</li><li>  执行状态id。通过Task.Status属性查询。</li><li>  父任务引用、回调方法引用、回调方法需要参数的引用</li><li>  一个CancellationToken、ContinueWithTask对象集合</li><li>  etc.</li></ul><h4 id="Task的生命周期"><a href="#Task的生命周期" class="headerlink" title="Task的生命周期"></a>Task的生命周期</h4><p>可通过<strong>Task.Status属性</strong>查询执行状态id。只展开聊这个，透过它能理解Task的生命周期。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> TaskStatus &#123;</span><br><span class="line">    <span class="comment">// -----------这里只贴出生命周期内的状态-----------</span></span><br><span class="line">    </span><br><span class="line">    Created, <span class="comment">// 任务已显式创建：可以手动 Start()这个任务</span></span><br><span class="line">    WaitingForActivation, <span class="comment">// 任务已隐式创建：会自动开始</span></span><br><span class="line">    </span><br><span class="line">    WaitingToRun, <span class="comment">// 任务已调度，但尚末运行</span></span><br><span class="line">    Running, <span class="comment">// 任务正在运行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务正在等待它的子任务完成，子任务完成后它才完成</span></span><br><span class="line">    WaitingForChildrenToComplete,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务的最终状态是以下3个之一</span></span><br><span class="line">    RanToCompletion,</span><br><span class="line">    Canceled,</span><br><span class="line">    Faulted,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面贴出微软文档的这个类，补全一下，看的话看上面的就行。</p><table><thead><tr><th>枚举</th><th>值</th><th>详细</th></tr></thead><tbody><tr><td>Canceled</td><td>6</td><td>该任务已通过对其自身的 CancellationToken 引发 OperationCanceledException 对取消进行了确认，此时该标记处于已发送信号状态；或者在该任务开始执行之前，已向该任务的 CancellationToken 发出了信号。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/task-cancellation">任务取消</a>。</td></tr><tr><td>Created</td><td>0</td><td>该任务已初始化，但尚未被计划。</td></tr><tr><td>Faulted</td><td>7</td><td>由于未处理异常的原因而完成的任务。</td></tr><tr><td>RanToCompletion</td><td>5</td><td>已成功完成执行的任务。</td></tr><tr><td>Running</td><td>3</td><td>该任务正在运行，但尚未完成。</td></tr><tr><td>WaitingForActivation</td><td>1</td><td>该任务正在等待 .NET 基础结构在内部将其激活并进行计划。</td></tr><tr><td>WaitingForChildrenToComplete</td><td>4</td><td>该任务已完成执行，正在隐式等待附加的子任务完成。</td></tr><tr><td>WaitingToRun</td><td>2</td><td>该任务已被计划执行，但尚未开始执行。</td></tr></tbody></table><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h3><p>就是<strong>TaskScheduler</strong>，它负责执行被调度的任务，同时向VS调试器公开任务信息。</p><p>官方提供2种TaskScheduler：</p><ul><li>  线程池任务调度器(thread pool task scheduler)</li><li>  同步上下文任务调度器(synchronization context task scheduler)</li></ul><p>默认情况，应用程序使用<strong>线程池任务调度器</strong>。它将任务调度给线程池的工作者线程。调用<code>TaskScheduler.Default</code>方法获取线程池任务调度器引用。</p><p>同步上下文任务调度器将借助画面线程！调用<code>TaskScheduler.FromCurrentSynchronizationContext</code>方法获取同步上下文任务调度器引用。</p><h4 id="同步上下文任务调度器"><a href="#同步上下文任务调度器" class="headerlink" title="同步上下文任务调度器"></a>同步上下文任务调度器</h4><p>同步上下文任务调度器适合提供了图形用户界面的应用程序，比如wpf。它将所有任务都调度给应用程序的GUI线程，使所有任务代码都能成功更新UI组件。</p><p><strong>该调度器不使用线程池，它调度的还是画面线程</strong>。如果用Default调度器的策略，线程池线程执行更新UI组件，会抛InvalidOperationException。</p><h4 id="用Task更新UI例子-♥wpf"><a href="#用Task更新UI例子-♥wpf" class="headerlink" title="用Task更新UI例子 ♥wpf"></a>用Task更新UI例子 ♥wpf</h4><p>wpf与unity一样，都是单ui线程的，其他线程没有办法调用它的api来修改ui。</p><p>所以下面可以看到，用上下文同步给Task从而实现更新UI，**实际上仍然是借调了主线程(ui线程)**，这个Task执行的时候你可以明显感觉到画面卡顿，因为画面线程在干活。</p><p>从来就没有什么魔法…</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> TaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        taskScheduler = TaskScheduler.FromCurrentSynchronizationContext();</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GUI thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t = Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;timing 1 thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.ContinueWith(o =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;timing 2 thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            myTextBox.Text = t.Result.ToString();</span><br><span class="line">        &#125;, taskScheduler); <span class="comment">// 注意!!! 如果这里不使用上下文同步的taskScheduler,会抛InvalidOperationException且更新UI失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// GUI thread id:1</span></span><br><span class="line"><span class="comment">// timing 1 thread id:3</span></span><br><span class="line"><span class="comment">// timing 2 thread id:1</span></span><br></pre></td></tr></table></figure><h4 id="其他自定义调度器"><a href="#其他自定义调度器" class="headerlink" title="其他自定义调度器"></a>其他自定义调度器</h4><p>![image-20220113173939283](E:\My Github\hexo\blog\source_posts\Tech\CSharp\CLR-Via-CSharp\cp7.assets\image-20220113173939283.png)</p><h2 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h2><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><p>静态 <strong>System.Threading.Tasks.Parallel 类</strong>，内部使用Task对象，可以用线程池的线程来<strong>并行执行</strong>操作。</p><p>要注意，并行执行对应<strong>顺序执行</strong>，它是无法保证顺序的。</p><h4 id="For、ForEach、Invoke"><a href="#For、ForEach、Invoke" class="headerlink" title="For、ForEach、Invoke"></a>For、ForEach、Invoke</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池的线程并行完成</span></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">1000</span>, i=&gt; DoSth(i));</span><br><span class="line">Parallel.ForEach(collection, item =&gt; DoSth(item)); <span class="comment">// ForEach要用迭代器遍历,比For稍慢</span></span><br><span class="line"></span><br><span class="line">Parallel.Invoke(</span><br><span class="line">    () =&gt; Method1(),</span><br><span class="line">    () =&gt; Method2(),</span><br><span class="line">    () =&gt; Method3(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另外，Invoke有一个可控性极强的重载，指定 <strong>localInit、body、localFinally委托</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parallel.ForEach&lt;TSource,TLocal&gt; (IEnumerable&lt;TSource&gt; item, Func&lt;&gt; localInit, Func&lt;&gt; body, Func&lt;&gt; localFinally);</span><br><span class="line"></span><br><span class="line"><span class="comment">// item 是集合的每个子元素。</span></span><br><span class="line"><span class="comment">// localInit(初始化委托) 为参与工作的每个任务都调用一次该委托,在body前调用。</span></span><br><span class="line"><span class="comment">// body(主体委托) 为参与工作的每个任务都调用一次该委托。</span></span><br><span class="line"><span class="comment">// localFinally(终结委托) 为参与工作的每个任务都调用一次该委托,在body后调用。</span></span><br></pre></td></tr></table></figure><h4 id="返回值ParallelLoopResult"><a href="#返回值ParallelLoopResult" class="headerlink" title="返回值ParallelLoopResult"></a>返回值ParallelLoopResult</h4><p>For、ForEach都返回一个ParallelLoopResult实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ParallelLoopResult &#123;</span><br><span class="line">    <span class="comment">// 如果操作提前终止，以下方法返回 false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">// 保证得到处理的最低一项的索引</span></span><br><span class="line">    <span class="keyword">public</span> Int64? LowestBreakIteration &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 IsCompleted == true 说明全部运行完成，</p><p>如果 IsCompleted == false、LowestBreakIteration == null 说明某个线程调用了Stop，</p><p>如果 IsCompleted == false、LowestBreakIteration != null 说明某个线程break了。</p><h3 id="并行语言继承查询-PLINQ"><a href="#并行语言继承查询-PLINQ" class="headerlink" title="并行语言继承查询(PLINQ)"></a>并行语言继承查询(PLINQ)</h3><p>当只用一个线程来<strong>顺序执行</strong>调用LINQ时，我们称之为<strong>LINQ</strong>；当用<strong>并行的方式</strong>执行LINQ时，我们称之为**PLINQ(Parallel LINQ)**。</p><p>使用扩展方法<strong>AsParallel</strong>实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ParallelQuery</span>&lt;<span class="title">TSource</span>&gt; <span class="title">AsParallel</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParallelQuery <span class="title">Asparallel</span> (<span class="params"><span class="keyword">this</span> IEnumerable source</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="执行定时计算限制操作"><a href="#执行定时计算限制操作" class="headerlink" title="执行定时计算限制操作"></a>执行定时计算限制操作</h2><h3 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h3><p>定时器，在<code>System.Threading</code>中定义的。</p><p>Timer的构造函数需要传入一个<strong>TimerCallback委托</strong> 回调函数，在时间到达后使用线程池线程调用这个回调函数。</p><h3 id="TimerCallback委托"><a href="#TimerCallback委托" class="headerlink" title="TimerCallback委托"></a>TimerCallback委托</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object state</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="Timer内部实现"><a href="#Timer内部实现" class="headerlink" title="Timer内部实现"></a>Timer内部实现</h3><p>在内部，线程池为所有Timer对象<strong>只打算使用一个线程</strong>。这个线程知道下一个Timer对象在什么时候到期（计时器还有多久触发）。下一个Timer对象到期时，线程就会唤醒，在内部调用 Threadpool的 QueueUserWorkItem,将一个工作项添加到线程池的队列中，使你的回调方法得到调用。</p><p>那么如果new了很多个Timer，那么有可能出现并行执行的情况，这个时候会用<strong>新的线程</strong>来帮你同时执行回调方法。</p><p>想避免用新线程，可以在构造Timer时传入<strong>period参数指定Timeout.Infinite</strong>，这样，计时器就只触发一次。然后，在你的回调方法中，调用 Change方法来指定一个新的<strong>dueTime</strong>，dueTime告诉CLR在首次调用回调方法之前需要等待多少毫秒，可以传递0立刻执行。</p><h3 id="例子、await允许线程返回"><a href="#例子、await允许线程返回" class="headerlink" title="例子、await允许线程返回"></a>例子、await允许线程返回</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Timer timer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Timer(回调, 回调参数, dueTime, period)</span></span><br><span class="line">    timer = <span class="keyword">new</span> Timer(Status, <span class="literal">null</span>, <span class="number">0</span>, Timeout.Infinite);</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Status</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Timer.Change(dueTime, period)</span></span><br><span class="line">    timer.Change(<span class="number">2000</span>, Timeout.Infinite); <span class="comment">// 返回前让Timer在2秒后再次触发</span></span><br><span class="line">    <span class="comment">// 这个方法返回后，线程回归池中，等待下一个工作项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:32 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:35 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:38 4</span></span><br></pre></td></tr></table></figure><p>然后书中用了await/async写一个等效的实现。我这里打印了线程号，可以观察出来其实两者并不同。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Status(<span class="literal">null</span>);</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; main &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Status</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now + <span class="string">&quot; &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟做2秒的事</span></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 2秒之后，某个线程池的线程会在await之后介入并继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:33 1</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:34 main 1</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:36 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:39 4</span></span><br></pre></td></tr></table></figure><p>观察输出理解await做了什么：</p><p>画面线程走到await之前都是正常顺序执行的，但是遇到了await之后立刻退出了方法并继续执行了；而<strong>Status方法借由线程池线程来继续执行</strong>。</p><p>所以画面既没卡死，也在不断更新UI。我估计await这里的做法就是起了个Task把回调包进去，然后传递了同步上下文给它让他可以更新UI。</p><h1 id="大章28：I-O限制的异步操作⭐"><a href="#大章28：I-O限制的异步操作⭐" class="headerlink" title="大章28：I/O限制的异步操作⭐"></a><center>大章28：I/O限制的异步操作⭐</center></h1><p>讲述如何异步执行I/O限制的操作，允许将任务交由硬件设备处理，期间完全不占用线程和CPU资源。当然这还是离不开线程池得处理。</p><h2 id="Windows如何执行I-O操作"><a href="#Windows如何执行I-O操作" class="headerlink" title="Windows如何执行I/O操作"></a>Windows如何执行I/O操作</h2><h3 id="从硬件开始理解"><a href="#从硬件开始理解" class="headerlink" title="从硬件开始理解"></a>从硬件开始理解</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220114151554.png"></p><p>图中展示的是连接了几个硬件设备的OS。</p><p>其实每个硬件都有自己的电路板，知道如何驱动自己的设备（寻道、读写数据、与计算机内存交换数据），所以其实不需要计算机线程来处理这些事。</p><h3 id="程序请求I-O流程⭐"><a href="#程序请求I-O流程⭐" class="headerlink" title="程序请求I/O流程⭐"></a>程序请求I/O流程⭐</h3><p>当你使用<code>FileStream fs = new FileStream(...); var bytes = fs.Read();</code>之后发生了这些事：</p><p>① 线程从托管代码转变为本机代码，Read内部<strong>调用Win32 ReadFile函数</strong>。</p><p>② ReadFile分配一个小数据结构，称作<strong>I/O请求包也就是IRP</strong> (I/O Request Packet)。</p><p>③ <strong>IRP结构初始化</strong>后包括：文件句柄，文件中的偏移量（字节读取开始位置）、一个Byte[]数组地址（用于写入读取的字节）等等。</p><p>④ 之后ReadFile将线程从 本机/用户模式代码=&gt;本机/内核模式代码，从而<strong>调用Windows内核并向其传递IRP数据包</strong>。Windows内核根据IRP中得设备句柄，传递给对应硬件设备的驱动程序的<strong>IRP队列</strong>。</p><p>⑤ 对应设备驱动软件在自己的IRP队列拿到IRP数据包，将信息传给物理硬件设备得电路板，执行I/O操作。</p><p>⑥ 设备执行I/O期间，发出请求的线程将无事可做，所以Windows将其变成<strong>睡眠</strong>状态。</p><p>⑦ 最终，硬件完成I/O操作。Windows会唤醒你的线程，并调度给一个CPU使它从内核模式返回用户模式，再<strong>返回至托管代码</strong>。</p><h3 id="异步请求I-O流程⭐"><a href="#异步请求I-O流程⭐" class="headerlink" title="异步请求I/O流程⭐"></a>异步请求I/O流程⭐</h3><p>上面演示了正常(同步)请求I/O流程，可以看⑥中你的线程在等待I/O期间是无所事事的。这是极大的浪费。</p><p>当你以异步方式发送I/O请求（用<strong>ReadAsync</strong>而不是Read） <code>FileStream fs = new FileStream(...,FileOptions.Asynchronous); Task&lt;int&gt; task = fs.ReadAsync();</code> 时发生了这些事：</p><p>① ReadAsync内部分配一个<code>Task&lt;int&gt;</code>对象来代表用于完成读取操作的代码。</p><p>② 和同步一样的方式，初始化IRP并发送到对应驱动软件IRP队列。</p><p>③ 驱动软件根据IRP数据包让硬件执行I/O，此刻，你的线程并<strong>不再睡眠</strong>，而是直接<strong>返回你的代码</strong>。</p><p>④ 从代码上看，你的线程会从ReadAsync的调用中很快返回，但是IRP可能还未处理好，所以不能在ReadAsync之后的代码中访问获取的Byte[]。</p><p>那么什么时候可以访问结果Byte[]呢？答案是为①中返回的<code>Task&lt;int&gt;</code>对象添加延续任务<strong>ContinueWith</strong>来执行回调方法。C#的<strong>异步函数</strong>可以简化这部分代码，从而以顺序方式写代码让你感觉像写同步I/O代码一样。</p><h3 id="I-O异步对比同步优势"><a href="#I-O异步对比同步优势" class="headerlink" title="I/O异步对比同步优势"></a>I/O异步对比同步优势</h3><p>资源上来说，同步阻塞线程，会导致CLR线程池不得不开辟更多线程来继续操作，<strong>增大开销</strong>；当I/O结束时线程又会回到线程池，导致<strong>过饱和</strong>，下场就是CPU同步上下文轮询花费更久。</p><p>效率上来说，一个线程去同步执行10个下载任务，每个5秒就得50秒；异步执行就只需要5秒。</p><h2 id="C-的异步函数⭐"><a href="#C-的异步函数⭐" class="headerlink" title="C#的异步函数⭐"></a>C#的异步函数⭐</h2><p>前面聊过了使用 <strong>ReadAsync + Task.ContinueWith</strong> 来实现异步，但是那么写代码比较复杂，于是微软推出了 <strong>异步函数 + Task</strong> 的方案，使开发者能够以同步顺序写代码实现异步。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; before &quot;</span> + <span class="string">&quot;tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Test(<span class="number">3</span>);</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; after &quot;</span> + <span class="string">&quot;tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">var</span> result = i * i;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; body &quot;</span> + result + <span class="string">&quot; tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">//  17:16:35 before tid:1</span></span><br><span class="line"><span class="comment">//  17:16:35 after tid:1</span></span><br><span class="line"><span class="comment">//  17:16:38 body 9 tid:4</span></span><br></pre></td></tr></table></figure><p>照这个示例来一步一步说明。</p><h3 id="async-gt-状态机"><a href="#async-gt-状态机" class="headerlink" title="async =&gt; 状态机"></a>async =&gt; 状态机</h3><p>我们很容易分辨Test是异步函数，因为他用async来修饰。</p><p>一旦方法被标记为async，编译器就会将方法的代码转换成实现了<strong>状态机</strong>的一个类型。具体下节讨论。</p><h3 id="await-gt-Task-ContinueWith"><a href="#await-gt-Task-ContinueWith" class="headerlink" title="await =&gt;Task.ContinueWith"></a>await =&gt;Task.ContinueWith</h3><p><code>await Task.Delay(3000);</code>这一句，Delay方法会在内部分配一个Task并实现<code>task.ContinueWith(await之后所有的代码);</code>等价的效果。</p><h3 id="最后，状态机恢复"><a href="#最后，状态机恢复" class="headerlink" title="最后，状态机恢复"></a>最后，状态机恢复</h3><p>当把后续代码包到Task的延续任务之后，线程不再等待Task的执行完毕，而是直接回到调用方法的地方<code>Test(3);</code>执行它之后的代码…</p><p>等到Task内部方法运行结束后，一个线程池线程会通知Task对象，开始激活ContinueWith回调方法（线程恢复状态机）。</p><h2 id="编译器如何将异步函数转换成状态机⭐"><a href="#编译器如何将异步函数转换成状态机⭐" class="headerlink" title="编译器如何将异步函数转换成状态机⭐"></a>编译器如何将异步函数转换成状态机⭐</h2><p>通过实现一个简单的异步函数使用案例，然后将IL代码反编译成C#代码来理解编译器到底做了些什么。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type1</span> &#123; &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type2</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Type1&gt; <span class="title">Method1Async</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 异步执行一些操作，最后返回一个Type1对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Type2&gt; <span class="title">Method2Async</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 异步执行一些操作，最后返回一个Type2对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">MyMethodAsync</span>(<span class="params"><span class="built_in">int</span> arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> local = arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Type1 result1 = <span class="keyword">await</span> Method1Async();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">Type2 result2 = <span class="keyword">await</span> Method2Async();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Catch&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>IL反编译成C#并精简后的代码：</p><p>要点是观察状态机的状态<strong>m_state</strong>在什么地方变化。</p><p>然后再观察<strong>m_x</strong>怎么实现的await循环<code>for()&#123; await ...&#125;;</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AsyncStateMachine特性指出这是一个异步方法（对使用反射的工具有用）</span></span><br><span class="line"><span class="comment">// 类型指出实现状态机的是哪个结构</span></span><br><span class="line">[<span class="meta">DebuggerStepThrough, AsyncStateMachine(typeof(StateMachine))</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">MyMethodAsync</span>(<span class="params">Int32 arg</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建状态机实例并初始化它</span></span><br><span class="line">    StateMachine stateMachine = <span class="keyword">new</span> StateMachine() &#123;</span><br><span class="line">        <span class="comment">// 创建 builder,从这个存根方法返回Task&lt;String&gt;</span></span><br><span class="line">        <span class="comment">// 状态机访问builder来设置Task完成/异常</span></span><br><span class="line">        m_builder = AsyncTaskMethodBuilder&lt;<span class="built_in">string</span>&gt;.Create(),</span><br><span class="line">        </span><br><span class="line">        m_state = <span class="number">-1</span>, <span class="comment">// 初始化状态机位置</span></span><br><span class="line">        m_arg = arg, <span class="comment">// 将实参拷贝到状态机字段</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行状态机</span></span><br><span class="line">    stateMachine.m_builder.Start(<span class="keyword">ref</span> statemachine):</span><br><span class="line">    <span class="keyword">return</span> stateMachine.m_builder.Task; <span class="comment">// 返回状态机的Task</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是状态机结构</span></span><br><span class="line">[<span class="meta">CompilerGenerated, StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> StateMachine : IAsyncStateMachine &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表状态机 builder(Task)及其位置的字段</span></span><br><span class="line">    <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="built_in">string</span>&gt; m_builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> m_state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实参和局部变量现在成了字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> m_argument, m_local, m_x;</span><br><span class="line">    <span class="keyword">public</span> Type1 m_resultType1;</span><br><span class="line">    <span class="keyword">public</span> Type2 m_resultType2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个 awaiter 类型一个字段</span></span><br><span class="line">    <span class="comment">// 任何时候这些字段只有一个是重要的，那个字段引用最近执行的、以异步方式完成的 await</span></span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter&lt;Type1&gt; m_awaiterType1;</span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter&lt;Type2&gt; m_awaiterType2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是状态机方法本身</span></span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.MoveNext() &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="literal">null</span>; <span class="comment">// Task的结果值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 编译器插入txy块来确保状态机的任务完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">bool</span> executeFinally = <span class="literal">true</span>; <span class="comment">// 先假定逻辑上离开try块</span></span><br><span class="line">            <span class="keyword">if</span>(m_state == <span class="number">-1</span>) &#123;         <span class="comment">// 如果第一次在状态机方法中，</span></span><br><span class="line">                m_ local = m_argument;  <span class="comment">// 原始方法就从头开始执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 原始代码中的try块</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                TaskAwaiter&lt;Type1&gt; awaiterType1;</span><br><span class="line">                TaskAwaiter&lt;Type2&gt; awaiterType2;</span><br><span class="line">                </span><br><span class="line">                 <span class="keyword">switch</span>(m_state) &#123;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// 开始执行源代码中try块中的代码</span></span><br><span class="line">                         <span class="comment">// 调用 Method1Async并获得它的 awaiter</span></span><br><span class="line">                         awaiterType1 = Method1Async().GetAwaiter();</span><br><span class="line">                         <span class="keyword">if</span>(!awaiterType1.IsCompleted)&#123;</span><br><span class="line">                             m_state = <span class="number">0</span>; <span class="comment">// Method1Async要以异步方式完成</span></span><br><span class="line">                             m_awaiterType1 = awaiterType1; <span class="comment">// 保存awaiter以便将来返回</span></span><br><span class="line">                </span><br><span class="line">                             <span class="comment">// 告诉awaiter在操作完成时调用MoveNext</span></span><br><span class="line">                             m_builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiterType1, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                             <span class="comment">// 上述代码调用 awaiterType1 的 OnCompleted,它会在被等待的任务上调用 ContinueWith(t=&gt; MoveNext())</span></span><br><span class="line">                             <span class="comment">// 任务完成后ContinueWith调用MoveNext</span></span><br><span class="line">                             </span><br><span class="line">                             executeFinally = <span class="literal">false</span>; <span class="comment">// 逻辑上不离开try块</span></span><br><span class="line">                             <span class="keyword">return</span>; <span class="comment">// 线程返回至调用者</span></span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// Method1Async以同步方式完成了</span></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                         </span><br><span class="line">                     <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// Method1Async 以异步方式完成了</span></span><br><span class="line">                         awaiterType1 = m_awaiterType1; <span class="comment">// 恢复最新的awaiter</span></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Method2Async 以异步方式完成了</span></span><br><span class="line">                         awaiterType2 = m_awaiterType2; <span class="comment">// 恢复最新的awaiter</span></span><br><span class="line">                         <span class="keyword">goto</span> ForLoopEpilog;</span><br><span class="line">                 &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在第一个await后，我们捕捉结果并启动for循环</span></span><br><span class="line">                m_resultType1 = awaiterType1.GetResult(); <span class="comment">// 获取awaiter的结果</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//序幕</span></span><br><span class="line">                ForLoopPrologue:</span><br><span class="line">                m_x = <span class="number">0</span>; <span class="comment">// for循环初始化</span></span><br><span class="line">                <span class="keyword">goto</span> ForLoopBody;</span><br><span class="line">                <span class="comment">//收场</span></span><br><span class="line">                ForLoopEpilog:</span><br><span class="line">                m_resultType2 = awaiterType2.GetResult();</span><br><span class="line">                m_x ++;</span><br><span class="line">                <span class="comment">// 循环主体</span></span><br><span class="line">                ForLoopBody:</span><br><span class="line">                <span class="keyword">if</span>(m_x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="comment">// 调用 Method2Async并获取它的 awaiter</span></span><br><span class="line">                        awaiterType2 = Method2Async().GetAwaiter();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(!awaiterType2.IsCompleted)&#123;</span><br><span class="line">                            m_state = <span class="number">1</span>; <span class="comment">// Method2Async要以异步方式完成</span></span><br><span class="line">                            m_awaiterType2 = awaiterType2; <span class="comment">// 保存 awaiter以使将来返回</span></span><br><span class="line">                            </span><br><span class="line">                              <span class="comment">// 告诉 awaiter在操作完成时调用 MoveNext</span></span><br><span class="line">                        m_builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiterType2, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                        executeFinally = <span class="literal">false</span>; <span class="comment">// 逻辑上不离开try块</span></span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 线程返回至调用者</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Method2Async以同步方式完成了</span></span><br><span class="line">                        <span class="keyword">goto</span> ForLoopEpilog; <span class="comment">// 如果走这个goto,意味着以同步方式完成就再次循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">             </span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Catch&quot;</span>); <span class="comment">// 源代码的catch块</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 本来,只要线程物理上离开try就会执行finally,</span></span><br><span class="line">                <span class="comment">// 但我们希望在线程逻辑上离开try时才执行这些代码</span></span><br><span class="line">                <span class="keyword">if</span>(executeFinally)&#123;</span><br><span class="line">                    Console.WriteLIne(<span class="string">&quot;Finally&quot;</span>); <span class="comment">// 源代码的finally块</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="string">&quot;Done&quot;</span>; <span class="comment">// 源代码最后一句</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 未处理的异常：通过设置异常来完成状态机的Task</span></span><br><span class="line">            m_builder.SetException(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常：通过返回结果来完成状态机的Task</span></span><br><span class="line">        m_builder.SetResult(result):</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="梳理一下"><a href="#梳理一下" class="headerlink" title="梳理一下"></a>梳理一下</h3><p>当编译器遇到<strong>async</strong>时，会尝试将方法编译成一个<strong>new状态机</strong>。</p><p>当编译器遇到<strong>await</strong>时，编译器会在它上面调用<strong>GetAwaiter</strong>方法。调用该方法所返回的对象为awaiter，正是它将被等待的对象与状态机粘合起来。</p><p>状态机获得awaiter后会查询其<strong>IsCompleted</strong>属性：如果操作以同步方式执行就返回true，如果以异步方式完成就返回false。如果为false，状态机调用awaiter的<strong>OnCompleted</strong>方法并传递一个委托（内含原任务和MoveNext）。此刻，状态机允许它的线程回到原地以执行其他代码。</p><p>将来某个时候，awaiter会在完成任务时调用委托以执行<strong>MoveNext</strong>，状态机往下运行，从而使得方法也回到当初离开的位置继续执行。之后，方法内其他的awaiter得以以同样的方式执行。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220117144608.png"></p><h2 id="异步函数扩展性"><a href="#异步函数扩展性" class="headerlink" title="异步函数扩展性"></a>异步函数扩展性</h2><p>在扩展性方面，只要是能用Task对象包装的操作，都可以用await来等待。</p><h3 id="TaskLogger"><a href="#TaskLogger" class="headerlink" title="TaskLogger"></a>TaskLogger</h3><p>clr作者自制的类，可用它打印尚未完成的异步操作。会影响性能，可以只在调试的时候启用。</p><p>// TODO</p><h2 id="await支持void"><a href="#await支持void" class="headerlink" title="await支持void"></a>await支持void</h2><p>异步函数的返回类型一般是<code>Task</code>或<code>Task&lt;Result&gt;</code>，它们代表函数的状态机完成。</p><p>但是异步函数是支持<strong>返回void</strong>的，毕竟所有事件签名几乎都是这么写的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventHandlerCallback</span>(<span class="params">Object sender, EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><p>C#编译器仍然会给返回void的异步函数创建状态机，但不再创建Task对象（因为创建了也没法使用）。<strong>所以你无法知道返回void的异步函数状态机在什么时候运行完毕。</strong></p><p>但这一般不致命，因为一般不需要知道它什么时候结束，只要可以在它执行结束完再执行后续代码就行了。</p><h2 id="异步函数和异常处理"><a href="#异步函数和异常处理" class="headerlink" title="异步函数和异常处理"></a>异步函数和异常处理</h2><p>如果硬件驱动收到IRP后，在进行I/O时虽然完成了但是内部出现错误，他就会向CLR的线程池post已完成的IRP。一个线程池线程会完成Task对象并设置异常，当你的状态机恢复后，await操作符会发现操作失败并引发该异常。</p><p>前面提过，当你用<code>Task.Start()</code>这种方式时，通常抛出一个<strong>AggregateException</strong>；但是如果你用<code>await someTask</code>的方式，编译器会优化体验，直接抛出<strong>第一个内部异常</strong>。</p><h2 id="线程处理模型：GUI线程⭐"><a href="#线程处理模型：GUI线程⭐" class="headerlink" title="线程处理模型：GUI线程⭐"></a>线程处理模型：GUI线程⭐</h2><p>简单聊下<strong>线程处理模型</strong>，.NET framework 支持很多种不同的应用程序模型，每种模型有自己的线程处理模型。比如说控制台应用程序没有任何线程处理模型。</p><h3 id="GUI线程"><a href="#GUI线程" class="headerlink" title="GUI线程"></a>GUI线程</h3><p>而GUI应用程序比如wpf引入了一个线程处理模型，<strong>这个模型中UI元素只能由创建它的线程更新</strong>，而这个线程我们叫做<strong>GUI线程</strong>。</p><p>如果通过线程池线程来更新UI元素，就会抛出异常。</p><h3 id="await优化-恢复上下文"><a href="#await优化-恢复上下文" class="headerlink" title="await优化 = 恢复上下文"></a>await优化 = 恢复上下文</h3><p><code>System.Threading.SynchronizationContext</code> 类的派生对象将应用程序模型连接到它的线程处理模型。<br>我们不和这个类打交道，只要知道它可以让你获得正确的<strong>同步上下文</strong>就行了。</p><p><code>await someTask;</code>的await关键字发生等待前，它会传递一个SynchronizationContext对象过去。之后，异步发生，会抽一个线程池线程来执行Task。<strong>当线程池线程完成Task后，会使用该SynchronizationContext对象</strong>，确保为应用程序模型使用正确的线程处理模型，换成人话就是<strong>会调用wpf的GUI线程来做事</strong>。</p><p>这就是await做的优化：<code>await someTask;</code>之后的代码如果有更新UI元素也能正常实现。但是注意，Task是由线程池线程来执行的，所以你在Task里面更新UI元素仍然会抛错。</p><p>来个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    Test();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GUI thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> t =  Task.Run(() =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;task thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    <span class="keyword">await</span> t;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;after task thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    myTextBox.Text = <span class="string">&quot;123&quot;</span>; <span class="comment">// 3秒后成功更新UI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// GUI thread id: 1</span></span><br><span class="line"><span class="comment">// task thread id: 3</span></span><br><span class="line"><span class="comment">// after task thread id: 1</span></span><br></pre></td></tr></table></figure><h2 id="I-O请求优先级"><a href="#I-O请求优先级" class="headerlink" title="I/O请求优先级"></a>I/O请求优先级</h2><p>Windows允许线程在发出I/O请求时指定优先级。但是只允许指定本进程的，不允许指定其他进程的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> (ThreadIO.BeginBackgroundProcessing())&#123;</span><br><span class="line">        <span class="comment">// 在这里执行低优先级I/O请求(例如：调用 ReadAsync/ WriteAsync)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大章29：基元线程同步构造"><a href="#大章29：基元线程同步构造" class="headerlink" title="大章29：基元线程同步构造"></a><center>大章29：基元线程同步构造</center></h1><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁的存在是为了实现线程同步、避免多个线程同时修改一个数据源从而造成数据损坏。锁的存在意义是一次只允许一个线程访问资源。什么时候不需要锁？多个线程如果只访问不修改一个数据源，是不需要锁的。</p><p>锁的缺点很多，</p><p>即便是最快的锁，也会损害性能，需要时间开销；</p><p>一次只允许一个线程访问资源是锁的存在意义，但是也就意味着某个线程会被锁阻塞，导致线程池不得不创建更多的线程来处理其他问题。</p><h2 id="类库和线程安全"><a href="#类库和线程安全" class="headerlink" title="类库和线程安全"></a>类库和线程安全</h2><p><strong>FCL(Framework Class Library)确保其所有静态方法都是线程安全的</strong>。比如Console类就有一个静态字段，类的许多方法都要释放获取这个字段上的锁，从而保证一次只有一个线程访问控制台。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果你的代码在进程中有<strong>多个线程同时运行</strong>一段代码，如果每次执行的结果都和单线程运行时的<strong>结果一致</strong>， 那么就是线程安全的。</p><p>线程安全方法并不意味着一定需要线程同步锁。</p><p>比如System.Math的静态Max方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Max</span>(<span class="params"><span class="built_in">int</span> val1, <span class="built_in">int</span> val2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (val1 &lt; val2) ? val2 : val1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是线程安全的，它没有获取任何锁。多个线程可以同时调用Max方法，每个线程都处理的是自己的栈上数据，互不干扰。</p><h3 id="使所有实例方法非线程安全，使静态方法线程安全"><a href="#使所有实例方法非线程安全，使静态方法线程安全" class="headerlink" title="使所有实例方法非线程安全，使静态方法线程安全"></a>使所有实例方法非线程安全，使静态方法线程安全</h3><p>FCL并不保证实例方法是线程安全的。并不是不保证，而是没必要。正如标题，FCL是遵守这个原则的。</p><p>为什么说不保证实例方法线程安全？首先是<strong>没必要</strong>，线程在构造对象时，只有这个线程才拥有对象引用，其他线程都不能访问那个对象。其次是<strong>要了不好</strong>，线程同步锁会严重影响性能。</p><p>然而这句话也<strong>不是绝对的</strong>，如果线程随后公开了这个对象引用（比如把它放到一个静态字段中），传给了一个ThreadPool或Task的线程，那么<strong>在多个线程可能同时进行非只读访问的前提下，就需要线程同步</strong>。</p><h2 id="基元用户模式和内核模式构造"><a href="#基元用户模式和内核模式构造" class="headerlink" title="基元用户模式和内核模式构造"></a>基元用户模式和内核模式构造</h2><h3 id="基元-primitive"><a href="#基元-primitive" class="headerlink" title="基元 (primitive)"></a>基元 (primitive)</h3><p>基元，是指可以在代码中使用的最简单的构造。有两种基元构造：<strong>用户模式</strong>(user-mode)和<strong>内核模式</strong>( kernel-mode)。</p><p>用户模式的速度显著快于内核模式，但是这个速度的优势是由于<strong>协调是在硬件中发生的</strong>，这也同样意味着Windows操作系统永远检测不到一个线程在基元用户模式的构造上阻塞了。</p><p>而内核模式是<strong>由Windows操作系统自身提供</strong>的，所以它们在获取其他线程资源时，Windows会阻塞线程以避免它浪费CPU时间，直到资源可用才恢复线程。</p><p>线程在 用户模式 和 内核模式 之间转换，是一个巨大的开销。</p><h3 id="死锁活锁"><a href="#死锁活锁" class="headerlink" title="死锁活锁"></a>死锁活锁</h3><p>当一个线程遇到资源等待的问题时，</p><p>如果它是用户模式的，那么线程就会一直在一个CPU上运行，称为 <strong>活锁</strong>(livelock)；</p><p>如果它是内核模式的，那么线程就会一直阻塞，称为 <strong>死锁</strong>(deadlock)。</p><p><strong>死锁永远优于活锁</strong>，要知道，死锁只是卡死一个线程那也只是浪费了内存，而活锁线程除了内存，还一直在占用CPU的时间片。</p><h2 id="用户模式构造"><a href="#用户模式构造" class="headerlink" title="用户模式构造"></a>用户模式构造</h2><h3 id="原子性⭐"><a href="#原子性⭐" class="headerlink" title="原子性⭐"></a>原子性⭐</h3><p>CLR保证对以下数据类型变量的读写是原子性的：bool、char、(S)Byte、Int16、Int32、IntPtr、Single以及引用类型。这意味着<strong>变量中的所有字节都一次性读取或写入</strong>。</p><p>什么意思呢，比如执行以下代码时，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">0x01234567</span>;</span><br><span class="line"></span><br><span class="line">Int64 y;</span><br><span class="line">y = <span class="number">0x0123456789abcdef</span>;</span><br></pre></td></tr></table></figure><p>x变量会<strong>一次性（原子性）</strong>地从0x00000000变成0x01234567。另一个线程不可能看到处于中间状态的值。</p><p>y变量就不同了，其他线程查询到它的值可能是0x0000000000000000 到 0x0123456789abcdef的值，因为读取和写入操作不是原子性的。这称为一次 <strong>torn read</strong>（撕裂读取：一次读取被撕成两半，或者在机器级别上要2个MOV指令才能读完）。</p><p>有两种基元<strong>用户模式</strong>线程同步构造：易变构造和互锁构造。</p><p>易变构造：在特定的时间，它在包含一个简单数据类型的变量上执行原子性的<strong>读或写</strong>操作。</p><p>互锁构造：在特定的时间，它在包含一个简单数据类型的变量上执行原子性的<strong>读和写</strong>操作。</p><h3 id="易变构造-volatile-construct"><a href="#易变构造-volatile-construct" class="headerlink" title="易变构造 (volatile construct)"></a>易变构造 (volatile construct)</h3><p>说的就是由于代码是由 C#编译器转换为IL语言、再由JIT将IL语言转换成本机CPU指令，最后再执行的，所以其中包括很多的<strong>编译器优化</strong>，导致你最终生成的代码运行顺序与你书写的不同。</p><p>可以使用两个<code>System.Threading.Volatile</code>类（<strong>易变构造</strong>）的静态方法来确保代码顺序执行而不被优化得偏离你的意图：</p><p><strong>Volatile.Write</strong> 方法执行一次原子性的写入操作。强迫location中的值在调用时写入。按照编码顺序，之前的加载和存储操作必须在调用Volatile.Write之前发生。</p><p><strong>Volatile.Read</strong> 方法执行一次原子性的读取操作。强迫location中的值在调用时读取。按照编码顺序，之后的加载和存储操作必须在调用Volatile.Read之后发生。</p><h4 id="易变构造volatile-例子"><a href="#易变构造volatile-例子" class="headerlink" title="易变构造volatile 例子"></a>易变构造volatile 例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序可能被优化到偏离意图的执行案例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Before</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法由一个线程执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        val = <span class="number">5</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法由另一个线程执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意：value可能先于flag读取</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span><br><span class="line">            Console.WriteLine(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后,确保按照意图执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">After</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// flag的写入 必然在所有前面代码之前</span></span><br><span class="line">        val = <span class="number">5</span>;</span><br><span class="line">        Volatile.Write(<span class="keyword">ref</span> flag, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// flag的读取 必然在所有后续代码之前</span></span><br><span class="line">        <span class="keyword">if</span>(Volatile.Read(<span class="keyword">ref</span> flag) == <span class="number">1</span>) &#123;</span><br><span class="line">            Console.WriteLine(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互锁构造"><a href="#互锁构造" class="headerlink" title="互锁构造"></a>互锁构造</h3><p>互锁，说的是<code>System.Threading.Interlocked</code>类提供的方法，Interlocked类中的每个方法都执行一次原子读取以及写入操作。Interlocked的所有方法都建立了完整的<strong>内存栅栏</strong>(memory fence)：调用某个Interlocked方法之前的任何变量写入都在这个Interlocked方法之前执行；这个调用之后的任何变量读取都在这个调用之后读取。</p><h4 id="Interlocked类"><a href="#Interlocked类" class="headerlink" title="Interlocked类"></a>Interlocked类</h4><p>展示对int处理的接口，来理解他能做哪些事。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Interlocked</span> &#123;</span><br><span class="line">    <span class="comment">// return (++location)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Increment</span> (<span class="params"><span class="keyword">ref</span> Int32 location</span>)</span>;</span><br><span class="line">    <span class="comment">// return (--location)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Decrement</span> (<span class="params"><span class="keyword">ref</span> Int32 location</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Add</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Exchange</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">CompareExchange</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span>, Int32 comparand</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// TODO 后面的都略了，太需要实战应用，光看不够</p><h1 id="大章30：混合线程同步构造"><a href="#大章30：混合线程同步构造" class="headerlink" title="大章30：混合线程同步构造"></a><center>大章30：混合线程同步构造</center></h1><h2 id="双检锁技术"><a href="#双检锁技术" class="headerlink" title="双检锁技术"></a>双检锁技术</h2><p>双检锁(Double- Check Locking)是一个非常著名的技术，开发人员用它将单实例(singleton)对象的构造推退到应用程序首次请求该对象时进行。也就是<strong>懒加载（也叫延迟初始化 lazy init）</strong>。</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// s_lock对象是实现线程安全所需要的。定义这个对象时，我们假设创建单实例对象的</span></span><br><span class="line">    <span class="comment">// 代价高于创建一个System.Object对象，并假设可能根本不需要创建单实例对象</span></span><br><span class="line">    <span class="comment">// 否则，更经济、更简单的做法是在一个类构造器中创建单实例对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> s_lock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">        </span><br><span class="line">        Monitor.Enter(s_lock); <span class="comment">// Monitor.Enter: 获取指定对象上的排他锁</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            Singleton temp = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="comment">// 将引用保存到instance中(参见正文的详细讨论)</span></span><br><span class="line">            Volatile.Write(<span class="keyword">ref</span> instance, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Monitor.Exit(s_lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存栅栏"><a href="#内存栅栏" class="headerlink" title="内存栅栏"></a>内存栅栏</h4><p>由于CLR对任何锁方法的调用都构成了一个<strong>完整的内存栅栏</strong>，在柵栏之前写入的任何变量都必须在栅栏之前完成；在栅栏之后的任何变量读取都必须在栅栏之后开始。所以第二个if中instance的值必须等待锁结束后，其他线程才能获取到，而不是什么缓存到寄存器中的东西。</p><p>放到JAVA就不一样了，它因为不保证完整的内存栅栏，导致第二个if可能读取到缓存到寄存器中的instance数值，从而返回true。</p><h4 id="发布-publishing"><a href="#发布-publishing" class="headerlink" title="发布(publishing)"></a>发布(publishing)</h4><p>而<code>Volatile.Write(ref instance, temp);</code>是解决了什么问题呢？</p><p>使一个值对其他线程可见称为<strong>发布</strong>。如果按照常规思路写<code>instance = new Singleton();</code>，编译器可能并不会按照你顺序写的代码来执行。它可能会先为Singleton分配内存，将引用发布到instance，然后再调用构造器，这导致了其他线程看到的instance不为null也不为正确的构造好的Singleton对象，而是一个<strong>正在构造的Singleton对象</strong>。</p><h3 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本与前面的效果是一样的！即使它没用“双检锁”也能保证<strong>线程安全</strong>。具体原因看下面。</p><p>在首次有线程访问这个Singleton的时候，CLR就会自动调用类构造器，创建并返回一个对象实例。</p><h4 id="线程安全⭐"><a href="#线程安全⭐" class="headerlink" title="线程安全⭐"></a>线程安全⭐</h4><p>关于线程安全需要特別说明一下，由于程序可能在多线程环境下运行，也就是可能出现同时多个线程准备执行静态构造函数的情況。<strong>CLR确保这个过程是安全的</strong>，实际上调用静态构造函数的线程需要先获得一个<strong>互斥线程同步锁</strong>，如果有多个线程试图执行类型的静态构造函数，只有一个线程能获得该锁；获得锁的线程完成初始类型初始化操作，<strong>其它线程只能等待</strong>；当初始化完成，等待的线程被唤醒，然后发现静态构造函数已经被执行过，就不会再执行，此时获得的字段也是初始化完成后的状态。</p><p>下面献上我自己的测试代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task1 Started&quot;</span>);</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task1 &quot;</span> + Singleton.Instance().counter.ToString());</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task1 End&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Utils.WriteLine( <span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task2 Started&quot;</span>);</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task2 &quot;</span> + Singleton.Instance().counter.ToString());</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task2 End&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">counter++;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; ctor bf&quot;</span> + counter);</span><br><span class="line">Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">counter += <span class="number">10</span>;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; ctor af&quot;</span> + counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">Instance</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Utils</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteLine</span>(<span class="params"><span class="built_in">string</span> txt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(Thread.CurrentThread.ManagedThreadId + txt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态构造、实例构造、内联执行顺序"><a href="#静态构造、实例构造、内联执行顺序" class="headerlink" title="静态构造、实例构造、内联执行顺序"></a>静态构造、实例构造、内联执行顺序</h4><p>引用：<a href="https://www.cnblogs.com/xiaoxiaotank/p/11155886.html">https://www.cnblogs.com/xiaoxiaotank/p/11155886.html</a></p><p>一般情况下是 <strong>静态字段内联 &gt; 静态构造 &gt; 实例字段内联 &gt; 实例构造</strong>。</p><p>如果加上基类就是：</p><p>Child静态字段内联 &gt; Child静态构造 &gt; Child实例字段内联 &gt; Base静态字段内联 &gt; Base静态构造 &gt; Base实例字段内联 &gt; Base实例构造 &gt; Child实例构造</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;---------------一般初始化顺序---------------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child1();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n---------------子类静态字段初始化需要使用父类静态字段时初始化顺序---------------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child2();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n---------------子类静态构造函数中使用父类静态字段时初始化顺序---------------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> child3 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child1</span> : <span class="title">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 静态构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"><span class="comment">// 静态构造器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Child1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line"><span class="comment">// 实例构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Child1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child2</span> : <span class="title">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 子类静态字段初始化需要使用父类静态字段</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>, () =&gt; BaseStatic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Child2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Child2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child3</span> : <span class="title">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 子类静态构造函数中使用父类静态字段</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Child3</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> baseStatic = BaseStatic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Child3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 3个Base类相同，这里是为了演示静态成员的初始化</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 静态字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"><span class="comment">// 静态构造器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Base1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"><span class="comment">// 实例构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Base1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Base2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Base2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Base3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Base3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Display</span>(<span class="params"><span class="built_in">string</span> msg, Func&lt;Display&gt; displayFunc = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(msg);</span><br><span class="line"><span class="keyword">var</span> display = displayFunc?.Invoke();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">---------------一般初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br><span class="line"></span><br><span class="line">---------------子?静?字段初始化需要使用父?静?字段?初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br><span class="line"></span><br><span class="line">---------------子?静??造函数中使用父?静?字段?初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br></pre></td></tr></table></figure><h3 id="Lazy模式"><a href="#Lazy模式" class="headerlink" title="Lazy模式"></a>Lazy模式</h3><p>FCL有两个类型封装了上面描述的模式，也就是<strong>懒汉模式</strong>。</p><p>下面是泛型System.Lazy类(方法未列完)：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lazy</span>&lt;<span class="title">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lazy</span>(<span class="params">Func&lt;T&gt; valueFactory, LazyThreadSafetyMode mode</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> Boolean IsValueCreated &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> T Value &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line">LazyThreadSafetyMode &#123;</span><br><span class="line">    None, <span class="comment">// 完全没有线程安全支持(适合GUI应用程序)</span></span><br><span class="line">    ExecutionAndPublication, <span class="comment">// 使用双检锁技术</span></span><br><span class="line">    PublicationOnly, <span class="comment">// 使用Interlocked.CompareExchange技术</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个“延迟初始化”包装器，它将Datetime的获取包装起来</span></span><br><span class="line">    Lazy&lt;<span class="built_in">string</span>&gt; s = <span class="keyword">new</span> Lazy&lt;<span class="built_in">string</span>&gt;(() =&gt; DateTime.Now.ToLongTimeString(), <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(s.IsValueCreated); <span class="comment">// 还没查询Value，返回false</span></span><br><span class="line">    Console.WriteLine(s.Value); <span class="comment">// 开始调用委托</span></span><br><span class="line">    Console.WriteLine(s.IsValueCreated); <span class="comment">// 已经查询了Value，返回true</span></span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">    Console.WriteLine(s.Value); <span class="comment">// 委托没有被重复调用，显示相同结果是正常的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo output:</span></span><br><span class="line"><span class="comment">// False</span></span><br><span class="line"><span class="comment">// 2:40:42 PM</span></span><br><span class="line"><span class="comment">// True</span></span><br><span class="line"><span class="comment">// 2:40:42 PM</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> CLR via C# </category>
          
          <category> 第五章 线程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/Tech/Game/01knapsack/"/>
      <url>/Tech/Game/01knapsack/</url>
      
        <content type="html"><![CDATA[<h1 id="基础01背包"><a href="#基础01背包" class="headerlink" title="基础01背包"></a><center>基础01背包</center></h1><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>n种物品每种只有1个。</p><p>每个物品有自己的weight和value，求解一个MAX_Weight的容量的背包尽可能多装value的解法。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>背包MAX重量为4。</p><p>每个物品只有2个状态（0或1），直接用回溯算法进行<strong>枚举</strong>。解决本题的时间复杂度为<strong>O(2^n) = 8</strong>。</p><h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><h3 id="dp数组"><a href="#dp数组" class="headerlink" title="dp数组"></a>dp数组</h3><p>一个二维数组，</p><p>下标i 对应条件0~i 的物品任取，下标j 对应背包重量。</p><p><code>dp[i][j]</code> 的值 对应 当0~i的物品任取、一个容量为j的背包所放物品的最大value。</p><h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><p>考虑一个<code>dp[i][j]</code>的前后。</p><p>首先<code>dp[i][j]</code>前面说过，代表i、j情况下的最大value，</p><p>那么<strong>不放物品i的最大价值</strong>：<code>dp[i-1][j]</code>（不考虑放入物品i但保持j背包重量的情况下的最大价值）</p><p>从而推出<strong>放物品i的最大价值</strong>：<code>dp[i-1][j-weight[i]] + value[i]</code>（一定放物品i的背包的最大价值）</p><p>从上面的递进关系可以推出公式，<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) ;</code></p><h3 id="dp数组初始化"><a href="#dp数组初始化" class="headerlink" title="dp数组初始化"></a>dp数组初始化</h3><p>利用推出的公式<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) ;</code></p><p>![image-20220112140432011](E:\My Github\hexo\blog\source_posts\Tech\Game\01knapsack.assets\image-20220112140432011.png)</p><p>因为所有的数据都是 max(正上方数据，左上角某一个数据 + value[i])。所以初始化只要把<strong>第一行和第一列正确初始化</strong>，其他的都可以靠递推公式推出。</p><p>第一列因为背包容量为0所以固定全是0，而第一行很容易计算。</p><p>最后初始化完成结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112141044.png"></p><h3 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h3><p>二维dp数组其实都可以（因为确定数值时左上方的数值都已确定），但是常规选择：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(物品)</span><br><span class="line">    <span class="keyword">for</span>(背包)</span><br><span class="line">        递推公式 dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]] + <span class="keyword">value</span>[i]);</span><br></pre></td></tr></table></figure><h3 id="解题案例"><a href="#解题案例" class="headerlink" title="解题案例"></a>解题案例</h3><p>题目还是前面的那个题目。手写一遍，再代码实现一遍。</p><h4 id="动态规划手写"><a href="#动态规划手写" class="headerlink" title="动态规划手写"></a>动态规划手写</h4><p>不说了…图画了我半小时…</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112144431.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112144446.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><center>完全背包</center></h1><h2 id="问题概述-1"><a href="#问题概述-1" class="headerlink" title="问题概述"></a>问题概述</h2><p>n种物品每种有无限个。</p><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><center>多重背包</center></h1><h2 id="问题概述-2"><a href="#问题概述-2" class="headerlink" title="问题概述"></a>问题概述</h2><p>n种物品每种物品个数各不相同。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 技术 </tag>
            
            <tag> 01背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#传入方法中的是一个指针</title>
      <link href="/Tech/CSharp/experience/20211222_1/"/>
      <url>/Tech/CSharp/experience/20211222_1/</url>
      
        <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>起因是工作中，在一个方法中对一个List进行了重赋值大概是，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rezeptTekiyouUiList是参数</span></span><br><span class="line">rezeptTekiyouUiList = rezeptTekiyouUiList.OrderBy(o =&gt; o.SubSeq).ThenBy(o =&gt; o.KomokuSeq).ToList();</span><br><span class="line"><span class="comment">// ...后续对rezeptTekiyouUiList继续操作</span></span><br></pre></td></tr></table></figure><p>然后发现退出方法后，后续对list的操作不起效了…查了一会之后发现，不止是ToList，这样的也会失效：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReSort</span>(<span class="params">List&lt;Test&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">list = <span class="keyword">new</span> List&lt;Test&gt;();</span><br><span class="line">list.Add(<span class="keyword">new</span> Test()&#123;val = <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//甚至下面的也不行，val修改失败</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReSort</span>(<span class="params">Test test</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">test = <span class="keyword">new</span> Test();</span><br><span class="line">test.val = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>那到这里问题就很明显了，是指针问题，不难得出一个结论：</p><ol><li>  进入方法后，参数会被分配空间并压在栈上。这个参数与调用处传入的变量不是一个东西，它只是调用处传入变量的一个浅拷贝，<strong>两者内容相等但不是同一个物体</strong>。</li><li>  执行<code>test = new Test();</code>，是在堆上新分配了一个实例并赋值其地址给参数，这时候这个参数和调用处传入变量已经一点关系也没有了。后续操作<code>test.val = 2;</code>也只是对堆上新实例操作。</li><li>  方法体结束，栈帧unwind恢复，方法体内那个指着新堆中对象的参数凉了，而调用处传入得变量毫无变化。</li></ol><p>至于<code>.ToList()</code>和new一样的，因为List不可变性。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>解决比较简单，就是ref or out传参。但如果内部用了lambda操作这个参数，那就没法用ref，所以最保险的是别用void了，直接return。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> 一些坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 一些坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR Via C#个人笔记6 - 核心机制</title>
      <link href="/Tech/CSharp/CLR-Via-CSharp/cp6/"/>
      <url>/Tech/CSharp/CLR-Via-CSharp/cp6/</url>
      
        <content type="html"><![CDATA[<h1 id="大章20：异常和状态管理"><a href="#大章20：异常和状态管理" class="headerlink" title="大章20：异常和状态管理"></a><center>大章20：异常和状态管理</center></h1><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p><strong>什么是“异常”</strong></p><p>首先对异常有一个基本理解，对于一些预想外的情况（比如中途转换失败），需要对既有代码进行进一步的安全性保证，就需要由对异常的处理。</p><p>平时代码throw抛出就会<strong>结束后续代码的执行，终止进程</strong>，<font color="pink">但是如果在try里throw就会被catch接住，执行catch内代码；如果catch也抛出但被更上层的catch抓住了，抛出地点的后续代码就不会执行了，但仍然会执行对应finally内的代码，之后finally结束后的代码不会执行。</font></p><p><strong>异常处理标准流程</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do method</span></span><br><span class="line">&#125;</span><br><span class="line">    catch (InvalidOperationException)&#123;</span><br><span class="line">        <span class="comment">// 异常预想情况1，从InvalidOperationException恢复的代码放在这</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException)&#123;</span><br><span class="line">        <span class="comment">//  异常预想情况2，从IOException恢复的代码放在这</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123;</span><br><span class="line">        <span class="comment">// 上述异常以外的其他异常恢复代码放在这</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 因为是未预想到的异常，恢复代码不可靠，所以一般抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 对try块代码的操作，进行后处理</span></span><br><span class="line">        <span class="comment">// finally总是执行，无论是否抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有在catch中抛出异常，就继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try块</strong></p><p>介绍略了。</p><p>对于程序设计时，多少代码放到try块中是很难把控的，应该根据catch和finally的对应处理来思考这个问题：</p><ol><li>  一段代码，catch后的挽回处理如果各不相同，那就该考虑多分几块<code>try&#123;&#125;catch()&#123;&#125;</code>了</li><li>  一段代码，他们的finally清理代码如果都不相同，那就不应该放在一起</li></ol><p><strong>catch块⭐</strong></p><p>先说下<strong>捕捉类型</strong>，就是<code>catch()</code>括号里的玩意。C#要求捕捉类型必须是<code>System.Exception</code>以及它的派生类。当你括号里不指定时，就相当于捕捉<code>System.Exception</code>这个类型了，不过这样也没法在后续代码块里访问到异常信息了。</p><p>再说下关键，<strong>catch抓取错误的机制</strong>，也就是整个异常处理的机制。</p><ol><li>  try中代码抛出异常后，CLR将搜索捕捉类型与抛出异常相同(或是其基类)的catch块。</li><li>  如果catch没有任何捕捉类型与抛出的异常匹配，CLR会去回溯查找调用堆栈更高的一层的catch捕捉类型。</li><li>  直到找到调用堆栈的顶部，仍然没有找到匹配的catch块，就会发生未处理的异常，这个后面讨论。</li><li>  一旦CLR找到匹配的catch块，就会执行内层所有finally块中的代码，也就是 <font color="brown">从抛出异常的try块-到匹配到异常的catch块之间</font> 所有的finally块。顺序是：内层finally块 =&gt; 抓取到异常的catch块 =&gt; 抓取到异常的catch块的finally块 =&gt; …。</li></ol><p>然后再说下catch到后，常用的<strong>catch块末尾处理选择</strong>，提供3种：</p><ol><li>  重新抛出相同的异常，向调用栈高一层的代码通知异常的发生。</li><li>  抛出一个不同的异常，向调用栈高一层的代码通知异常的发生。</li><li>  啥也不抛，正常从线程底部退出。</li></ol><p>当选择3，线程从catch块的底部退出后，它将立即执行包含在finally块中的代码。如果没有，就执行catch块结束的后续代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Test1(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Test2();</span><br><span class="line">&#125;</span><br><span class="line">catch</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test1 catched&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Test3();</span><br><span class="line">&#125;</span><br><span class="line">catch</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test2 catched&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentOutOfRangeException(<span class="string">&quot;test!!!&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Test2 catched</span></span><br><span class="line"><span class="comment">// Test2</span></span><br><span class="line"><span class="comment">// Test1</span></span><br></pre></td></tr></table></figure><p>最后，再说一下捕捉到异常时，会有一个变量将引用抛出的System.Exception对象：<code>catch (Exception e)</code>。可以用这个变量打印出<strong>堆栈调用</strong>。</p><p><strong>finally块</strong></p><p>包裹的是确保会执行的代码。</p><p>前面粉字里也说过，即使catch里也抛出了错误，仍然会执行finally内的代码。</p><p>除了Win32的TerminateThread杀死线程，或者TerminateProcess或System.Environment的FailFast方法杀死进程，finally块就不会执行。</p><h2 id="非CLS异常"><a href="#非CLS异常" class="headerlink" title="非CLS异常"></a>非CLS异常</h2><p><strong>RuntimeWrappedException类</strong></p><p>上面说的都是<strong>CLS标准的异常</strong>（也就是继承于<strong>Exception类</strong>的），但是也存在C#调用了其他编程语言写的方法，而且那个方法抛出了一个非CLS相容的异常，那么C#代码根本不能捕捉这个异常，从而造成安全隐患。</p><p>于是微软引入了全新的<code>System.Runtime.CompilerServices</code>的<strong>RuntimeWrappedException类</strong>，该类派生自Exception，所以他本身与CLR相容。当非CLS相容的异常被抛出时，CLR会自动构造这个类，并初始化+引用实际抛出的异常。也就是完成了 非CLS标准异常 =&gt; CLS标准异常。</p><h2 id="Exception-StackTrace属性"><a href="#Exception-StackTrace属性" class="headerlink" title="Exception.StackTrace属性"></a>Exception.StackTrace属性</h2><p><strong>异常抛出</strong></p><p>其实CLR可以让异常抛出任何类型的实例，String、Int32都行。但是为了能够简化使用，协定为统一使用System.Exception类。</p><p><strong>Exception.StackTrace属性</strong></p><p>Exception包含几个公共属性：String Message、IDictionary Data、String Source、String StackTrace、MethodBase TargetSite、String HelpLink、Exception InnerException、Int32 HResult。</p><p>讲一下其只读的StackTrace属性，它指出异常发生前调用了哪些方法。</p><p>新构造Exception类时，StackTrace是null。</p><p><strong>StackTrace的捕捉范围</strong></p><p>抛出异常时，CLR会重置异常起点，所以CLR只能记录最新的异常对象的抛出位置。</p><p>比如catch中又抛出了异常<code>throw e;</code>，那么StackTrace捕捉的起始点就又更新了，前面抛出的堆栈抓不到了，只能抓到最底一层的。</p><p>最后生成一个字符串来指出从异常抛出位置到异常捕捉位置的所有方法。</p><p><strong>System.Diagnostics.StackTrace类型</strong></p><p>该类型定义了一些属性和方法，允许开发人员程序化地处理堆栈跟踪以及构成堆栈跟踪的栈帧。</p><p>用这个类型来自己定制一套堆栈记录机制，实现抓取到多层抛错的堆栈记录。</p><h2 id="定义自己的异常类"><a href="#定义自己的异常类" class="headerlink" title="定义自己的异常类"></a>定义自己的异常类</h2><p><strong>设计原则</strong></p><p>创建自定义异常类应严格遵循几个原则</p><ol><li>声明可序列化（用于进行序列化写入，当然如果你不需要序列化。那么可以不声明为可序列化的）</li><li>添加一个默认的构造函数</li><li>添加包含message的构造函数</li><li>添加一个包含message,及内部异常类型参数的构造函数</li><li>添加一个序列化信息相关参数的构造函数.</li><li>可以把序列化重新继承ISerializable接口，重写序列化反序列化的方法</li></ol><p><strong>简单实践</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>] <span class="comment">//声明为可序列化的 因为要写入文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PayOverflowException</span> : <span class="title">Exception</span> <span class="comment">// 如有需求，可以继承ISerializable接口，重写序列化反序列化的方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"><span class="built_in">string</span> message</span>): <span class="title">base</span>(<span class="params">message</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"><span class="built_in">string</span> message, Exception inner</span>): <span class="title">base</span>(<span class="params">message, inner</span>)</span> &#123; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">10000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ex = <span class="keyword">new</span> PayOverflowException(<span class="string">&quot;The employee&#x27;s max pay should be no more than 10000.&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DoSth(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (PayOverflowException ex)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">var</span> file = <span class="keyword">new</span> FileStream(<span class="string">@&quot;c:\customerexception.txt&quot;</span>, FileMode.Create);</span><br><span class="line">         <span class="comment">//以序列化方式写入</span></span><br><span class="line">         BinaryFormatter bf = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">         bf.Serialize(file, ex);</span><br><span class="line">         file.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>书中的泛型Exception示例</strong></p><p>比较复杂，就贴上图看一下。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211217161743.png"></p><h2 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h2><p><strong>善用finally</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">@&quot;C:\Data.bin&quot;</span>, FileMode.Open);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do sth to fs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO  清理代码放这，这样哪怕抛错也会把fs正确关闭</span></span><br><span class="line">fs.Close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C#自动实现finally</strong></p><p>为了方便程序员，只要使用了lock、using、foreach语句和析构器时，C#编译器就会<strong>自动生成try/finally块代码</strong>，如下：</p><ul><li>  使用lock语句时，锁在finally块中释放。</li><li>  使用using语句时，在finally块中调用对象的Dispose方法。</li><li>  使用foreach语句时，在finally块中调用IEnumerator对象的Dispose方法。</li><li>  定义析构器方法时，在finally块中调用基类的Finalize方法。</li></ul><p>比如下面这个方法的实现，和上面的代码编译结果一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法的实现和上面的代码编译结果一样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">@&quot;C:\Data.bin&quot;</span>, FileMode.Open)) &#123;</span><br><span class="line">        <span class="comment">// do sth to fs</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备份、回滚状态</strong></p><p>对于一些目前无法掌控到的异常，想要修复会无从下手。可以考虑一下下面的状态回滚：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> beforeDoing = num; <span class="comment">// 1.备份数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DoSth(num); <span class="comment">// 执行处理num的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch&#123;</span><br><span class="line">        num = beforeDoing; <span class="comment">// 2.回滚状态</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 抛出错误，让程序员知道发生了什么</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>包装抛错</strong></p><p>有的时候接受到了抛错，提前协定好，可以向外抛出不一样的错误类型。</p><p>因为直接让别人用你自己的包装类方法，如果抛错了，可能预料不到，抓不到错；如果提前协定好某些情况固定抛什么Exception，那么其他开发者就能提前预知要去抓这些错了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">PhoneBook</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> m_pathname; <span class="comment">// 地址簿文件的路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部调用的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPhoneNumber</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">string</span> phoneNum;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fs = <span class="keyword">new</span> FileStream(m_pathname, FileMode.Open);</span><br><span class="line">            ... phoneNum = ... <span class="comment">// 这里是查找代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 协定好的Exception类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e) &#123;</span><br><span class="line">            <span class="comment">// 协定好的Exception类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fs != <span class="literal">null</span>) fs.Close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未处理的异常"><a href="#未处理的异常" class="headerlink" title="未处理的异常"></a>未处理的异常</h2><p><strong>未处理异常的处理</strong></p><p>异常抛出时，CLR在调用栈中向上查找与抛出的异常对象的类型匹配的catch块。如果没有任何catch块匹配抛出的异常类型，就发生一个<strong>未处理的异常</strong>，CLR一旦检测到有未处理的异常的存在，就会终止进程。</p><p>CLR的默认策略时将未处理的异常，写进Windows事件日志。</p><p><strong>Windows事件日志</strong></p><p>上述的未处理异常，在“事件查看器&gt;Windows日志&gt;应用程序”中可以看到，我个人推荐直接WIN+R运行<code>eventvwr.msc</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211217182146.png"></p><h2 id="对异常进行调试"><a href="#对异常进行调试" class="headerlink" title="对异常进行调试"></a>对异常进行调试</h2><p><strong>VS 调试&gt;异常</strong></p><p>讲的是VS的菜单 “调试”&gt;“异常”，能打开CLR和自己定义的所有能被识别的Exception类型，并可以选择在抛出某Exception时中断（本来的话要异常未处理才会中断）。</p><p>这个用到了直接百度吧，知道有这个功能就行。</p><h2 id="约束执行区域-CER"><a href="#约束执行区域-CER" class="headerlink" title="约束执行区域 CER"></a>约束执行区域 CER</h2><p><strong>PrepareConstrainedRegions</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In try&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        Type1.M();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Type1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这里抛出错误，M就得不到调用</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Type1&#x27;s static ctor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// In try</span></span><br><span class="line"><span class="comment">// Type1&#x27;s static ctor called</span></span><br></pre></td></tr></table></figure><p>像上述这样的代码执行顺序，不难看出，finally里的错误就抓不住了，而且中间出错影响finally块代码执行。</p><p>我们想实现<font color="brown">除非保证catch和finally块内的代码得到执行，否则就不执行try块中的代码</font>。可以使用<strong>PrepareConstrainedRegions</strong>方法，JIT编译器如果发现在一个try块之前调用了这个方法，就会提前编译与try块关联的catch和finally块中的代码。JIT编译器会加载任何程序集，创建任何类型对象，调用任何静态构造器，并对任何方法进行JIT编译。如果其中任何操作造成异常，这个异常会在线程进入try块之前发生。</p><p>此外，JIT编译器提前准备方法时，还会遍历整个调用图，寻找应用了<strong>ReliabilityConstractAttribute</strong>特性的方法，提前准备这些被调用的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    RuntimeHelpers.PrepareConstrainedRegions(); <span class="comment">// System.Runtime.CompilerServices命名空间</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In try&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        Type2.M();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Type2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Type2&#x27;s static ctor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ReliabilityConstractAttribute(Consistency.WillNotCorruptState. Cer.Success)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Type2&#x27;s static ctor called</span></span><br><span class="line"><span class="comment">// In try</span></span><br></pre></td></tr></table></figure><p><strong>ReliabilityConstractAttribute</strong></p><p>聊一下这个属性，前面提到了，这个属性要配合PrepareConstrainedRegions方法使用。这样JIT编译器提前准备方法时，会遍历整个调用图，寻找应用了<strong>ReliabilityConstractAttribute</strong>特性的方法，提前准备这些被调用的方法。</p><p>首先会对这个属性实例传递一个枚举成员 Consistency：</p><table><thead><tr><th>枚举成员</th><th>value</th><th>详细</th></tr></thead><tbody><tr><td>MayCorruptAppDomain</td><td>1</td><td>在遇到异常情况时，公共语言运行时 (CLR) 对当前应用程序域中的状态一致性不做任何保证。</td></tr><tr><td>MayCorruptInstance</td><td>2</td><td>在遇到异常情况时，此方法保证将状态损坏限制到当前实例。</td></tr><tr><td>MayCorruptProcess</td><td>0</td><td>在遇到异常情况时，CLR 对状态一致性不做任何保证；即这种情况可能损坏进程。</td></tr><tr><td>WillNotCorruptState</td><td>3</td><td>在遇到异常情况时，此方法保证不损坏状态。 （不保证此方法永远不会失效；但确实可以保证此类故障将永远不损坏状态。）</td></tr></tbody></table><p>以及枚举成员 Cer：</p><table><thead><tr><th>枚举成员</th><th>value</th><th>详细</th></tr></thead><tbody><tr><td>MayFail</td><td>1</td><td>在遇到异常情况时，此方法可能会失败。 在这种情况下，此方法将向调用方法报告它是否成功。 该方法的方法体周围必须有 CER 以确保它可以报告返回值。</td></tr><tr><td>None</td><td>0</td><td>方法、类型或程序集没有 CER 的概念。 它不利用 CER 保证。</td></tr><tr><td>Success</td><td>2</td><td>在遇到异常情况时，保证此方法获得成功。 应始终在调用的方法周围构造 CER，即使是在非 CER 区域内调用该方法。 如果方法完成了其任务，则该方法成功。 例如，用 ReliabilityContractAttribute(Cer.Success)意味着当它在 CER 下运行时，它始终返回 ArrayList 中的元素的数目计数，并且它永远不能将内部的字段保留为不确定状态。</td></tr></tbody></table><p><strong>TODO</strong></p><p>我说实话这节没有看懂，主要问题是不理解AppDomain的“状态”到底指的是什么，书中说22章会讲。以后在这里补吧。</p><h2 id="代码协定"><a href="#代码协定" class="headerlink" title="代码协定"></a>代码协定</h2><p><strong>是什么</strong></p><p>代码协定的核心是静态类System.Diagnostics.Contracts.Contract。</p><p>协定采取的形式：</p><ul><li>  前条件：一般用于对实参进行验证。</li><li>  后条件：方法因为一次普通的返回或抛出异常而终止时，对状态进行验证。</li><li>  对象不变性(Object Invariant)：在对象的整个生命期内，确保对象的字段的良好状态。</li></ul><p><strong>怎么用</strong></p><p>下面举个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Item</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Item</span>&gt; m_cart</span> = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line">    <span class="keyword">private</span> Decimal m_totalCost = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShoppingCart</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params">Item item</span>)</span> &#123;</span><br><span class="line">        AddItemHelper(m_cart, item, <span class="keyword">ref</span> m_totalCost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddItemHelper</span>(<span class="params">List&lt;Item&gt; m_cart, Item newItem, <span class="keyword">ref</span> Decimal totalCost</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 前条件</span></span><br><span class="line">        Contract.Requires(newItem != <span class="literal">null</span>);</span><br><span class="line">        Contract.Requires(Contract.ForAll(m_cart, s =&gt; s!= newItem));</span><br><span class="line">        <span class="comment">// 后条件</span></span><br><span class="line">        Contract.Ensures(Contract.Exists(m_cart, s=&gt; s == newItem));</span><br><span class="line">        Contract.Ensures(totalCost &gt;= Contract.OldValue(totalCost));</span><br><span class="line">        Contract.EnsureOnThrow&lt;IOException&gt;(totalCost == Contract.OldValue(totalCost));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做一些事，可能抛出IOException</span></span><br><span class="line">        m_cart.Add(newItem);</span><br><span class="line">        totalCost += <span class="number">1.00</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象不变性</span></span><br><span class="line">    [<span class="meta">ContractInvariantMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ObjectInvariant</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Contract.Invariant(m_totalCost &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>有空看看吧，这个技术太老了，工作中没见过。</p><h1 id="大章21：托管堆和垃圾回收"><a href="#大章21：托管堆和垃圾回收" class="headerlink" title="大章21：托管堆和垃圾回收"></a><center>大章21：托管堆和垃圾回收</center></h1><h2 id="托管堆⭐"><a href="#托管堆⭐" class="headerlink" title="托管堆⭐"></a>托管堆⭐</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>访问一个资源所需的步骤：</p><ol><li>  调用IL指令newobj，为代表资源的类型分配内存（C#中用new操作符完成）。</li><li>  初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。</li><li>  访问类型的成员来使用资源（有必要可以重复）。</li><li>  摧毁资源的状态以进行清理。</li><li>  释放内存。垃圾回收器独自负责这一步。</li></ol><p>C#为了简化编程，将大多数类的4这一步略去了，也就是不需要资源清理，由垃圾回收器来自动释放内存。遇到需要特殊清理不等待GC的类时，不推荐写unsafe代码，而是在类中调用额外的<strong>方法Dispose</strong>以按照自己的节奏清理资源。</p><h3 id="1-从托管堆分配资源"><a href="#1-从托管堆分配资源" class="headerlink" title="1.从托管堆分配资源"></a>1.从托管堆分配资源</h3><p><strong>NextObjPtr</strong></p><p>CLR要求所有对象从托管堆分配源。进程初始化时，CLR划出一个连续的地址空间区域作为托管堆。CLR还会维护一个指针NextObjPtr，它指向下一个对象在堆中的分配位置。</p><p>一个区域被非垃圾对象填满后，CLR会分配更多的区域。这个过程一直重复直至整个进程地址空间都被填满。所以，你的应用程序的内存受进程的虚拟地址空间的限制，32位进程最多能分配1.5GB，64位进程最多能分配8TB。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211221105618.png"></p><p><strong>new操作符执行流程</strong></p><p>new操作符导致CLR执行以下步骤：</p><ol><li>  计算类型（包括基类继承的字段）的<strong>字段</strong>所需的字节数。</li><li>  加上对象的<strong>overhead开销字段</strong>所需的字节数。每个对象都有2个开销字段：类型都西昂指针和同步块索引。对于32位应用程序，这2个字段各需32位，所以每个对象要+<strong>8字节</strong>；对于64位，各需要64位，所以每个对象要+<strong>16字节</strong>。</li><li>  CLR检查区域中是否有分配对象所需的字节数。如果托管堆空间足够，就在NextObjPtr指针指向的地址放入对象，为对象分配的字节会被清零。接着调用类型构造器(为this参数传递NextObjPtr)返回初始化好的对象的引用，并让NextObjPtr移动到新地址：原地址+这个类占用的内存字节数。</li></ol><p><strong>堆性能很强</strong></p><p>正如上述所说，对于托管堆，分配对象只需要在指针上加一个值；寻找对象时，因为同时分配的对象内存是连续的（比如FileStream）且往往有业务联系，所以因为**局部化(locality)**会获得性能提升。</p><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><p><strong>垃圾回收的起因</strong></p><p>托管堆性能并不是无敌的，前面说的有一个大前提——内存无限，CLR总能分配新对象。如果托管堆没有大小限制，那C#的执行速度要优于c了(托管堆的结构让它有比c运行时堆更快的对象分配速度)。但是内存不可能是无限的，所以CLR有“垃圾回收”GC。</p><p><strong>垃圾回收的基本原理</strong></p><p>回收分为两个阶段： <strong>标记 –&gt; 压缩</strong></p><p>标记的过程，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含可达(已标记)与不可达(未标记)对象。</p><p>标记完成后，进入压缩阶段。在这个阶段中，垃圾回收器线性的遍历堆，以寻找不可达对象的连续内存块。并把可达对象移动到这里以压缩堆。这个过程有点类似于磁盘空间的碎片整理。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211221112506.png"></p><p>如上图所示，绿色框表示可达对象，黄色框为不可达对象。不可达对象清除后，移动可达对象实现内存压缩(变得更紧凑)。</p><p>压缩之后，“指向这些对象的指针”的变量和CPU寄存器现在都会失效，垃圾回收器必须重新访问所有根，并修改它们来指向对象的新内存位置。这会造成显著的性能损失。这个损失也是托管堆的主要缺点。</p><p><strong>GC不是用引用计数</strong></p><p>引用计数是COM(Component Object Model)使用的办法，GC并不是用这个，而是用的从根遍历。了解即可。说的是堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一“部分”到达代码某个不再需要对象的地方，就递减这个计数，直到0就可以删除了。</p><p><strong>根（Root）</strong></p><p>我们将所有引用类型的变量都成为<strong>根</strong>，类中定义的任何静态字段，方法的参数，局部变量(仅限引用类型变量)等都是根，另外cpu寄存器中的对象指针也是根。根是CLR在堆之外可以找到的各种入口点。</p><p><strong>可达和不可达</strong></p><p>对象可达与不可达(Objects reachable and unreachable)：</p><p>如果一个根引用了堆中的一个对象，则该对象为“可达”，否则即是“不可达”。</p><p><strong>引用跟踪 GC算法详解</strong></p><p>CLR针对无法处理循环引用的情况，推出了引用跟踪算法，它只关心引用类型的变量，因为只有这种变量能引用堆上的对象。</p><p>GC时，</p><ol><li><p>  CLR先<strong>暂停进程中的所有线程</strong>，避免检查时对象状态被更改。</p></li><li><p>  CLR进入GC的<strong>标记阶段</strong>。这个阶段中，CLR先遍历堆中所有对象，将<font color="brown">同步块索引中的一位</font>设为0：这一位是0代表着对象未被引用要删除，是1代表对象被引用着。</p></li><li><p>  然后检查所有活动根，查看它们引用的对象，如果对象是null就跳过；否则就进行标记(就是上面说的一位改为1)。一个对象A第一次被标记后，CLR会检查这个对象A中的根(也就是这个对象A中自己的字段啥的)，查看是否也引用了其他对象BCD，有就标记。当下次有根标记这个对象A的时候，就不再检查内部字段了。这样能解决循环引用：根引用了A，A中有B导致B被标记，B中有A发现A已经被标记就不标记了。</p></li><li><p>  标记阶段结束，进入<strong>压缩</strong>阶段。这个阶段中CLR让堆中的所有幸存对象都紧挨在一起，使内存的地址空间得到释放。操作完内存后，将所有引用幸存对象的根减去所引用的对象在内存中偏移的字节数，从而保证每个根引用与以前一样的对象。</p></li></ol><p>结束GC后，如果GC并没有分出足够的内存给新的new操作，就会抛出OutOfMemoryException异常。</p><h3 id="根的作用域"><a href="#根的作用域" class="headerlink" title="根的作用域"></a>根的作用域</h3><p>根一旦离开作用域，它引用的对象就会变得“不可达”。</p><p>下面演示一个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object o</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now);</span><br><span class="line">    <span class="comment">// 执行一次强制垃圾回收</span></span><br><span class="line">    GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行会发现，程序只输出了一次，而不是每2秒一次。</p><p>原因是<code>GC.Collect();</code>这句，回收开始时，会假设堆中所有都对象不可达，而CLR发现Main方法再也没有继续用过变量t，所以会回收它的内存。</p><p>然而神奇的是，这么写也是不对的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">    <span class="comment">// 想在Read之后引用t但是失败了，因为编译器优化了这一段</span></span><br><span class="line">    t  = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方法应该这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">    <span class="comment">// 在Read之后引用t（在Dispose方法返回之前，t会在GC中存活）</span></span><br><span class="line">    t.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分代-Generation-算法"><a href="#分代-Generation-算法" class="headerlink" title="分代(Generation)算法"></a>分代(Generation)算法</h2><p><strong>假设原则</strong></p><p>CLR的GC对代码做出了以下几点假设：</p><ul><li>  对象越新，生存期越短。</li><li>  对象越老，生存期越长。</li><li>  回收堆的一部分，速度快于回收整个堆。</li></ul><p>以此为方针，制定GC的机制。</p><p><strong>回收机制</strong></p><p>简单来说就是回收时，不可达的直接销毁，可达的压缩并放到下一代中，称作“存活对象”。</p><p>CLR托管堆支持3代：第0代，第1代，第2代。便于理解，可以将第0代的空间理解为256KB，第1代理解为2M，第2代理解为10M。新构造的对象会被分配到第0代。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211228093933.png"></p><p>如上图所示，当第0代的空间满时，垃圾回收器启动回收，不可达对象(上图C、E)会被回收，存活的对象被归为第1代。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211228093946.png"></p><p>当第0代空间已满，第1代也开始有很多不可达对象以至空间将满时，这时两代垃圾都将被处理：存活下来的对象(可达对象)，第0代升为第1代，第1代升为第2代。</p><p><strong>“预算”机制</strong></p><p>如果说GC时，第1代中有一些“不可达”的存在，但是第1代已用的内存开销小于<strong>预算</strong>，那么就不用担心不够用，此时去扫描一遍第1代整体进行GC处理是非常多余的。所以这个时候，CLR就会选择<strong>忽略</strong>第1代的GC，直到某一次GC发现第1代的开销到达了预算。</p><p>实际CLR的代回收机制更加“智能”，如果新创建的对象生存周期很短，第0代垃圾也会立刻被垃圾回收器回收(不用等空间分配满)。另外，如果回收了第0代，发现还有很多对象“可达”，并没有释放多少内存，就会增大第0代的预算至512KB，回收效果就会转变为：垃圾回收的次数将减少，但每次都会回收大量的内存。如果还没有释放多少内存，垃圾回收器将执行完全回收(3代)，如果还是不够，则会抛出“内存溢出”异常。</p><p>也就是说，垃圾回收器会根据回收内存的大小，动态的调整每一代的分配空间预算！达到自动优化。</p><p><strong>GCNotification</strong></p><p>该类在 第0代 or 第2代 回收时引发一个事件，可用来计算2次回收的间隔时间、分配了多少内存。</p><h2 id="强制垃圾回收"><a href="#强制垃圾回收" class="headerlink" title="强制垃圾回收"></a>强制垃圾回收</h2><h3 id="垃圾回收触发方式"><a href="#垃圾回收触发方式" class="headerlink" title="垃圾回收触发方式"></a>垃圾回收触发方式</h3><ul><li>  0代超过预算时自动触发GC</li><li>  代码显式调用<strong>System.GC的静态Collect</strong>方法</li><li>  Windows报告低内存情况</li><li>  CLR正在卸载AppDomain、CLR正在关闭</li></ul><h3 id="System-GC"><a href="#System-GC" class="headerlink" title="System.GC"></a>System.GC</h3><p>GC.Collect最复杂的重载签名也就这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span>(<span class="params">Int32 generation, GCCollectionMode mode, Boolean blocking</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>  generation：最多回收到x代（最高2）。</li><li>  blocking：阻塞（非并发）或后台（并发）回收的一个Boolean值。</li><li>  mode：如下表。</li></ul><table><thead><tr><th>符号名称</th><th>说明 GCCollectionMode枚举类</th></tr></thead><tbody><tr><td>Default</td><td>等同于不传递任何符号名称。目前还等同于传递 Forced,但CLR未来的版本可能对此进行修改</td></tr><tr><td>Forced</td><td>强制回收指定的代（以及低于它的所有代）</td></tr><tr><td>Optimized</td><td>只有在能释放大量内存或者能减少碎片化的前提下，才执行回收。如果垃圾回收没有什么效率，当前调用就没有任何效果</td></tr></tbody></table><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>前面讨论的都是小对象，对于大对象（出书时是85000字节以上），CLR会区分对待：</p><p>内存不是在小对象的地址空间分配，而是进程地址空间的其他地方分配；总是第2代；目前不支持压缩。</p><h3 id="垃圾回收模式"><a href="#垃圾回收模式" class="headerlink" title="垃圾回收模式"></a>垃圾回收模式</h3><p>默认使用工作站GC模式，可以在配置文件中修改。</p><p><strong>工作站</strong></p><p>针对客户端的GC模式，假设其他应用程序不占用太多CPU资源。GC造成的延时很低，程序挂起时间很短。</p><p><strong>服务器</strong></p><p>针对服务端的GC模式，假设没有其他应用程序，所有的CPU都可用来辅助完成GC。优化了吞吐量和资源利用。每个CPU都跑一个特殊线程，它和其他线程并发回收自己的区域。</p><h2 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h2><h3 id="Finalize方法对GC过程的影响"><a href="#Finalize方法对GC过程的影响" class="headerlink" title="Finalize方法对GC过程的影响"></a>Finalize方法对GC过程的影响</h3><p>写代码时，理解的是GC时Finalize方法会被得到调用。实际上CLR是用了2个专门的列表来操作的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115018.png"></p><p>**一个是终结列表(finalization list)**，</p><p>对象创建(new)时，CLR检测到他们的Finalize方法被重写，就会把这些对象的指针扔进终结列表。</p><p>**另一个是F-reachable队列(finalization reachable Arrary)**，</p><p>一个无情的只顾执行对象Finalize方法然后将其移除的队列。</p><p>它们之间的协作：</p><p>终结列表中的对象在得知需要被回收后，会从终结列表转移到F-reachable队列中。此时，对象变得不在被认为是垃圾，还不能回收他的内存，被标记为垃圾但是不被认为是垃圾，叫<strong>复活</strong>了。垃圾回收器会递归该对象中所有的引用，让它们也不被内存回收，但是会被GC到更老的一代。<strong>下次GC时</strong>早已经执行完Finalize方法，会发现之前复活的对象们已经不可达，然后会回收。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115028.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115038.png"></p><h3 id="有一些特殊的类，需要清理本机资源"><a href="#有一些特殊的类，需要清理本机资源" class="headerlink" title="有一些特殊的类，需要清理本机资源"></a>有一些特殊的类，需要清理本机资源</h3><p>上面说的类都是只需要内存资源就行，但是有些类比如FileStream类型需要占用本机资源(打开文件保存句柄)。</p><p>GC清理不了这些本机资源。</p><p>这里就可以使用Finalize方法来<strong>清理本机资源</strong>。</p><h3 id="Finalize-1"><a href="#Finalize-1" class="headerlink" title="Finalize"></a>Finalize</h3><p>GC判定对象是垃圾后，会调用其Finalize方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeType</span>&#123;</span><br><span class="line">    ~SomeType() &#123; Finalize方法体 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; C#实际生成代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeType</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="title">Finalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           Finalize方法体 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">base</span>.Finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLR用一个特殊的高优先级的<strong>专用线程</strong>调用Finalize方法来避免死锁。Finalize方法如果阻塞(比如死循环)，会导致该线程瘫痪，致使整个程序内存不停泄露并无法捕捉到此异常。</p><h3 id="SafeHandle-CriticalFinalizerObject"><a href="#SafeHandle-CriticalFinalizerObject" class="headerlink" title="SafeHandle : CriticalFinalizerObject"></a>SafeHandle : CriticalFinalizerObject</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Safehandle</span> : <span class="title">CriticalFinalizerObject</span>, <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这是本机资源的句柄</span></span><br><span class="line"><span class="keyword">protected</span> IntPtr handle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Safehandle</span>(<span class="params">IntPtr invalidhandlevalue, Boolean ownsHandle</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.handle = invalidhandlevalue;</span><br><span class="line"><span class="comment">// 如果ownsHandle为true,那么这个从 Safehandle派生的对象被回收时，</span></span><br><span class="line"><span class="comment">//本机资源会被关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Sethandle</span>(<span class="params">IntPtr handle</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.handle = handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这个默认实现会忽略 disposing参数</span></span><br><span class="line"><span class="comment">// 如果资源已经释放，那么返回</span></span><br><span class="line"><span class="comment">// 如果 ownsHandle为false,那么返回</span></span><br><span class="line"><span class="comment">// 设置一个标志来指明该资源已经释放</span></span><br><span class="line"><span class="comment">// 调用虚方法 ReleaseHandle</span></span><br><span class="line"><span class="comment">// 调用GC, SuppressFinalize(this)方法来阻止调用Finalize方法</span></span><br><span class="line"><span class="comment">// 如果 ReleaseHandle返回true,那么返回</span></span><br><span class="line"><span class="comment">// 如果走到这一步，就激活 releaseHandleFailed托管调试助手（MDA)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的 Finalize实现（如下所示）正是我们希望的。强烈建议不要重写这个方法</span></span><br><span class="line">~Safehandle() &#123; Dispose(<span class="literal">false</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.需要重写以实现释放资源的代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">ReleaseHandle</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetHandleAsInvalid</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 设置标志来指出这个资源已经释放</span></span><br><span class="line"><span class="comment">// 调用GC, SuppressFinalize(this)方法来阻止调用Finalize方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> IsClosed</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 返回指出资源是否释放的一个标志</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.派生类要重写这个属性</span></span><br><span class="line"><span class="comment">// 如果句柄的值不代表资源(通常意味着句柄为0或-1),实现应返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> IsInvalid</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进一步深入了解SafeHandle类，上下都介绍一下：</p><p><strong>父类，CriticalFinalizerObject</strong></p><p>CLR特殊对待的类，它的行为：</p><ol><li>  首次构造时就进行此类Finalize方法JIT编译，保证不会出现内存满后无法编译Finalize导致无法执行的情况。</li><li>  在所有非CriticalFinalizerObject派生类的Finalize执行完后才开始执行它们的Finalize，这样非CriticalFinalizerObject派生类可以在Finalize中安全调用它们。</li><li>  AppDomain被宿主应用程序强行中断，也会调用CriticalFinalizerObject类的Finalize方法。</li></ol><p><strong>子类1，SafeFileHandle</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SafeFileHandle</span>: <span class="title">SafeHandleZeroOrMinusOneIsInvalid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeFileHandle</span>(<span class="params">Intptr preexistingHandle, Boolean ownsHandle</span>) : <span class="title">base</span>(<span class="params">ownshandle</span>)</span></span><br><span class="line">    &#123;     </span><br><span class="line"><span class="keyword">base</span>. Sethandle(preexistinghandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Boolean <span class="title">Releasehandle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 告诉 Windows我们希望本机资源关闭</span></span><br><span class="line">        <span class="keyword">return</span> Win32Native.CloseHandle(<span class="keyword">base</span>.handle);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GC句柄表"><a href="#GC句柄表" class="headerlink" title="GC句柄表"></a>GC句柄表</h3><p>是说CLR为每个AppDomain都提供了一个**GC句柄表(GC Handle table)<strong>，允许程序监视or手动控制对象的生存期。句柄表启动时是空白的，每个记录项都包含了</strong>对托管堆中的一个对象的引用，以及指出如何监视或控制对象的标志(flag)**。</p><p>使用<code>System.Runtime.InteropServices.GCHandle</code>类型在表中添加或删除记录项。在表中创建一个记录项调用该类的<code>public static GCHandle Alloc(object value, GCHandleType type);</code>，对象+标志。</p><p><strong>GCHandleType</strong>有下面4种枚举类：</p><p><strong>Weak</strong><br>该标志允许监视对象的生存期。具体地说，可检测垃圾回收器在什么时候判定该对象<br>在应用程序代码中不可达。注意，此时对象的 Finalize方法可能执行，也可能没有执<br>行，对象可能还在内存中。</p><p><strong>Weaktrackresurrection</strong><br>该标志允许监视对象的生存期。具体地说，可检测垃圾回收器在什么时候判定该对象<br>在应用程序的代码中不可达。注意，此时对象的 Finalize方法（如果有的话）已经执行，<br>对象的内存已经回收。</p><p><strong>Normal</strong><br>该标志允许控制对象的生存期。具体地说，是告诉垃圾回收器：即使应用程序中没有<br>变量（根）引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存可<br>以压缩（移动）。不向Ale方法传递任何 Gchandle Type标志，就默认使用<br>Gchandle T’ype Normal</p><p><strong>Pinned</strong><br>该标志允许控制对象的生存期。具体地说，是告诉垃圾回收器：即使应用程序中没有<br>变量（根）引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存不<br>能压缩（移动）。需要将内存地址交给本机代码时，这个功能很好用。本机代码知道GC<br>不会移动对象，所以能放心地向托管堆的这个内存写入。</p><h1 id="大章22：CLR寄宿和AppDomain"><a href="#大章22：CLR寄宿和AppDomain" class="headerlink" title="大章22：CLR寄宿和AppDomain"></a><center>大章22：CLR寄宿和AppDomain</center></h1><h2 id="CLR寄宿"><a href="#CLR寄宿" class="headerlink" title="CLR寄宿"></a>CLR寄宿</h2><p>**寄宿(hosting)**使任何应用程序都能使用CLR的功能。</p><p>所有托管模块和程序集文件都必须使用 Windows PE文件格式，而且要么是 Windows EXE文件，要么是DLL文件。</p><p><strong>开发CLR时， Microsoft实际是把它实现成包含在一个DLL中的COM服务器。</strong>很遗憾，这一句对于目前的我来说还无法深入理解，放着吧。</p><p>**垫片(slim)**，MSCorEE.dll。</p><p>CLRCreateInstance函数在MSCorEE.dll文件中实现。“垫片”的工作是决定创建哪个版本的CLR（1.0、2.0、3.0的CLR代码在MSCorWks.dll文件中；版本4则在Clr.dll文件中）。CLRCreateInstance函数可返回一个ICLRMetaHost接口。宿主应用程序可调用这个接口的GetRuntime函数，指定宿主要创建的CLR版本。然后，垫片将所需版本的CLR加载到宿主的进程中。</p><h2 id="初识AppDomain"><a href="#初识AppDomain" class="headerlink" title="初识AppDomain"></a>初识AppDomain</h2><p><strong>AppDomain是什么</strong></p><p>CLR COM服务器初始化时会创建一个AppDomain。<strong>AppDomain是一组程序集的逻辑容器，它存在的目的是为了隔离。</strong>CLR初始化时创建的第一个AppDomain称为“默认AppDomain”，这个默认的AppDomain只有在Windows进程终止时才会被销毁。</p><p>在 Windows中，线程总是在一个进程的上下文中创建，而且线程的整个生存期都在该进程的生存期内。<strong>但线程和Appdomain没有一对一关系。</strong>一个Windows进程可包含多个Appdomain，所以线程能执行一个Appdomain中的代码，再执行另一个AppDomain中的代码。从CLR的角度看，<strong>线程一次只能执行一个Appdomain中的代码。</strong></p><p><strong>AppDomain长这样</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230160015.png"></p><p>AppDomain #1和AppDomain #2完全不共享信息，以至于他们都用了System.dll却不共用。虽然有些浪费内存资源，但是这就是AppDomain的本质，“隔离”。</p><p>另外针对这种浪费，CLR也提供了一种<strong>AppDoamin中立</strong>加载方式的程序集。CLR会为它们维护一个特殊的Loader堆，该Loader堆中的所有资源都会共享给同一个进程中的其他AppDomain。省下资源的代价是这样的程序集永远不能卸载，只能终止Windows进程让Windows回收资源。</p><p><strong>AppDomain特点</strong></p><p><strong>①一个AppDomain的代码不能直接访问另一个AppDomain的代码创建的对象。</strong><br>一个AppDomain中的代码创建了一个对象后，该对象便被该AppDomain“拥有”。换言之，它的生存期不能超过创建它的代码所有的AppDomain。一个AppDomain中的代码要访问另一个AppDomain的对象，只能使用“按引用封送”或者“按值封送”的予以。这就强制建立了清晰的分割和边界，因为一个AppDomain中的代码不能直接引用另一个AppDomain中的代码创建的对象。这种隔离使AppDomain能很容易地从进程中卸载，不会影响其他AppDomain正在运行的代码<br><strong>②AppDomain可以卸载</strong><br>CLR不支持从AppDomain中卸载特定的程序集，但可以告诉CLR卸载一个AppDomain，从而卸载该AppDomain当前包含的所有程序集<br><strong>③AppDomain可以单独保护</strong><br>AppDomain创建后会应用一个权限集，它决定了想这个AppDomain中运行的程序集授予最大权限，正是由于存在这样的权限，所以当宿主加载一些代码后，可以保证这些代码不会破坏（或读取）宿主本身使用的一些重要数据结构<br><strong>④AppDomain可以单独配置</strong><br>AppDomain创建后会关联一组配置设置。这些设置主要影响CLR在AppDomain中加载程序集的方式，设计搜索路径、版本绑定重定向、卷影复制以及加载器优化</p><p><strong>跨越AppDomain边界访问对象</strong></p><p>一个AppDomain中的代码可以和另一个AppDomain中的类型和对象通信，但只能通过良好定义的机制执行。</p><p>抄个网上的可运行demo，做了解吧，以后深入ILRuntime之后再补一些理解：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication7</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Marshalling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Marshalling</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取AppDomain引用（“调用线程”当前正在该AppDomain中执行）</span></span><br><span class="line">AppDomain adCallingThreadDomain = Thread.GetDomain();</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个AppDomain都分配了友好字符串名称（以便调试）</span></span><br><span class="line"><span class="comment">//获取这个AppDomain的友好名称并显示它</span></span><br><span class="line">String CallingDomainName = adCallingThreadDomain.FriendlyName;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;默认AppDomain友好的名称=&#123;0&#125;&quot;</span>, adCallingThreadDomain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并显示我们的AppDomain中包含了“Main”方法的程序集</span></span><br><span class="line">String exeAssembly = Assembly.GetEntryAssembly().FullName;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;包含“Main”方法的程序集=&#123;0&#125;&quot;</span>, exeAssembly);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义局部变量来引用一个AppDomain</span></span><br><span class="line">AppDomain ad2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line"><span class="comment">//************************************************************ DEMO 1：使用“按引用封送”进行跨AppDomain通信 ***</span></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; Demo1 按引用封送&quot;</span>, Environment.NewLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个AppDomain（从当前AppDomain继承安全性和配置）</span></span><br><span class="line">ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">MarshalByRefType mbrt = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将我们的程序集加载到新AppDomain,构造一个对象，把它封送回我们的AppDomain（实际得到对一个代理的引用）</span></span><br><span class="line">mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Type=&#123;0&#125;&quot;</span>, mbrt.GetType());<span class="comment">//CLR在类型上撒谎了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//证明得到的是对一个代理对象的引用</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Is proxy=&#123;0&#125;&quot;</span>, RemotingServices.IsTransparentProxy(mbrt));</span><br><span class="line"></span><br><span class="line"><span class="comment">//看起来像是在MarshalByRefType上调用了一个方法，实则不然。</span></span><br><span class="line"><span class="comment">//我们是在代理类型上调用了一个方法，代理是线程切换到拥有对象的那个</span></span><br><span class="line"><span class="comment">//AppDomain,并在真实的对象上调用这个方法</span></span><br><span class="line">mbrt.SomeMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载新的AppDomain</span></span><br><span class="line">AppDomain.Unload(ad2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时，mbrt引用了一个有效的代理对象；代理对象引用一个无效的AppDomain</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">mbrt.SomeMethod();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch (AppDomainUnloadedException)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用失败，AppDomain被卸载了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line"><span class="comment">//************************************************************ DEMO 2：使用“按值封送”进行跨AppDomain通信 ***</span></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; Demo2 按值封送&quot;</span>, Environment.NewLine);</span><br><span class="line">ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的方法返回所返回对象的副本</span></span><br><span class="line"><span class="comment">//对象按值（而非按引用）封送</span></span><br><span class="line">MarshalByValType mbvt = mbrt.MethodWithReturn();</span><br><span class="line"><span class="comment">//证明得到的是对一个代理对象的引用</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Is proxy=&#123;0&#125;&quot;</span>, RemotingServices.IsTransparentProxy(mbvt));</span><br><span class="line"><span class="comment">//看起来在MarshalByValType上调用一个方法，实际也是如此</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Return object created &quot;</span> + mbvt.ToString());</span><br><span class="line"><span class="comment">//卸载新的AppDomain</span></span><br><span class="line">AppDomain.Unload(ad2);</span><br><span class="line"><span class="comment">//此时，mbrt引用了一个有效的x代理对象；代理对象引用一个无效的AppDomain</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//卸载AppDomain之后调用mbvt方法不会抛出异常</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Return object created &quot;</span> + mbvt.ToString());</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch (AppDomainUnloadedException)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用失败，AppDomain被卸载了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line"><span class="comment">//************************************************************ DEMO 3：使用不可封送的类型进行跨AppDomain通信 ***</span></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line">ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">NonMarshalableType nmt = mbrt.MethodArgAndReturn(CallingDomainName);<span class="comment">//抛出异常:未标记为可序列化</span></span><br><span class="line">&#125;</span><br><span class="line">catch (SerializationException)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;抛出异常:未标记为可序列化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该类型的实例可跨越AppDomain的边界“按引用封送”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByRefType</span> : <span class="title">MarshalByRefObject</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MarshalByRefType</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; ctor running in &#123;1&#125;&quot;</span>, GetType(), Thread.GetDomain().FriendlyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Executing in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MarshalByValType <span class="title">MethodWithReturn</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Execute in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">MarshalByValType t = <span class="keyword">new</span> MarshalByValType();</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> NonMarshalableType <span class="title">MethodArgAndReturn</span>(<span class="params"><span class="built_in">string</span> callingDomainName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意：callingDomainName是可序列化的</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Calling from &#x27;&#123;0&#125;&#x27; to &#x27;&#123;1&#125;&#x27;.&quot;</span>, callingDomainName, Thread.GetDomain().FriendlyName);</span><br><span class="line">NonMarshalableType t = <span class="keyword">new</span> NonMarshalableType();</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该类的实例可跨越AppDomain的边界“按值封送”</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByValType</span> : <span class="title">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> DateTime m_creationTime = DateTime.Now;<span class="comment">//注意：DateTime是可序列化的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MarshalByValType</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; ctor running in &#123;1&#125;, Created no &#123;2:D&#125;&quot;</span>, GetType(), Thread.GetDomain().FriendlyName,</span><br><span class="line">m_creationTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_creationTime.ToLongDateString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该类的实例不能跨AppDomain边界进行封送</span></span><br><span class="line"><span class="comment">//[Serializable]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">NonMarshalableType</span> : <span class="title">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NonMarshalableType</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Execute in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作AppDomain"><a href="#操作AppDomain" class="headerlink" title="操作AppDomain"></a>操作AppDomain</h2><h3 id="卸载AppDomain"><a href="#卸载AppDomain" class="headerlink" title="卸载AppDomain"></a>卸载AppDomain</h3><p>调用<strong>AppDomain的静态Unload方法</strong>可以实现卸载，CLR会按顺序执行以下操作：</p><ol><li>  挂起进程中的所有线程。</li><li>  检查每一个线程栈，如果线程在执行即将卸载的AppDomain中的代码，就抛出一个ThreadAbortException，并执行所有遇到的finally块。线程终止，进程可继续运行。</li><li>  所有线程离开目标AppDomain后，CLR遍历堆，为所有引用了目标AppDomain中的对象设置一个标志，告诉它们引用的真实对象已经不在了，再调用它们会抛出AppDomainUnloadedException异常。</li><li>  强制垃圾回收目标AppDomain的对象。</li><li>  Unload执行完毕，恢复剩余所有线程运行，此刻调用了AppDomain.Unload方法的线程才会继续运行。</li></ol><h3 id="监视AppDomain"><a href="#监视AppDomain" class="headerlink" title="监视AppDomain"></a>监视AppDomain</h3><p>// TODO 本章后续的内容等实际工作用到再看吧。</p><h1 id="大章23：程序集加载和反射"><a href="#大章23：程序集加载和反射" class="headerlink" title="大章23：程序集加载和反射"></a><center>大章23：程序集加载和反射</center></h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><h3 id="程序集可以用Load加载"><a href="#程序集可以用Load加载" class="headerlink" title="程序集可以用Load加载"></a>程序集可以用Load加载</h3><p>使用System.Reflection.Assembly类的静态Load方法可以在运行时加载程序集。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">publiv <span class="keyword">class</span> <span class="title">Assembly</span>&#123;</span><br><span class="line">    <span class="comment">// 2种常用重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">Load</span>(<span class="params">AssemblyName assemblyRef</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">Load</span>(<span class="params">String assemblyString</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据路径加载，内部只是找到AssemblyName作为参数传给Load方法</span></span><br><span class="line">    <span class="comment">// ex: Assembly a  = Assembly.LoadFrom(@&quot;http://Wintellect.com/SomeAssembly.dll&quot;);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">LoadFrom</span>(<span class="params">String assemblyString</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和Load不同的是，不会用版本策略，指定哪个版本就用那个版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">ReflectionOnlyLoadFrom</span>(<span class="params">String assemblyFile</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Load内部，CLR会应用绑定重定向"><a href="#在Load内部，CLR会应用绑定重定向" class="headerlink" title="在Load内部，CLR会应用绑定重定向"></a>在Load内部，CLR会应用绑定重定向</h3><p>在GAC(全局程序集缓存）中查找程序集。如果没找到就接着去应用程序的基目录、私有路径子目录和 codebase位置查找。如果调用Load时传递的是<a href="https://www.cnblogs.com/w6w6/p/10592356.html">弱命名程序集</a>，Load就不会向程序集应用版本绑定重定向策略，CLR也不会去GAC査找程序集。</p><p>找到指定程序集后，会返回对代表已加载程序集的一个Assembly对象的引用，否则会抛出IO异常。</p><h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><h3 id="使用反射构建动态可扩展应用程序"><a href="#使用反射构建动态可扩展应用程序" class="headerlink" title="使用反射构建动态可扩展应用程序"></a>使用反射构建动态可扩展应用程序</h3><p>通过反射的运行时序列化，使得应用程序在运行时可显式加载程序集构造类型的实例，再调用类型中定义的方法，这种绑定方法叫做<strong>晚期绑定</strong>。</p><h3 id="反射的性能"><a href="#反射的性能" class="headerlink" title="反射的性能"></a>反射的性能</h3><ol><li>  反射造成编译时无法保证类型安全性，严重依赖字符串。搜索”int”是没法找到”System.Int32”的。</li><li>  反射速度慢。</li></ol><p>针对第2点，提一些具体情况来理解慢在哪里：</p><ul><li>  类型及其成员的名称在编译时未知，需要用字符串名称标识每个类型以及成员。<strong>反射机制会不停的对字符串进行搜索。</strong></li><li>  用反射调用方法时，必须将实参打包(pack)成数组；在内部，反射必须将这些实参解包(unpack)到线程栈上。导致CLR必须检查实参的数据类型是否正确、以及访问权限。</li></ul><p>那么针对反射速度慢，有一些常见构造方案来实现类的动态行为，避免反射：</p><ul><li>  <strong>继承+重载</strong>。用父类变量接子类实例(转型)，再调用基类虚方法。</li><li>  <strong>接口</strong>。用接口变量接实例(转型)，再调用接口定义的方法。</li></ul><h3 id="来点反射代码"><a href="#来点反射代码" class="headerlink" title="来点反射代码"></a>来点反射代码</h3><h4 id="程序集-反射"><a href="#程序集-反射" class="headerlink" title="程序集+反射"></a>程序集+反射</h4><p>通过反射获取一个程序集定义了哪些类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        String dataAssembly =<span class="string">&quot;System, Data, veraionm4,0.0.0, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;culture-neutral, Publickeytoken=b77a5c561934e089&quot;</span>;</span><br><span class="line">        LoadAssemAndShowPublicTypes(dataAssembly);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadAssemAndShowPublicTypes</span>(<span class="params">String assemId</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 显式地将程序集加载到这个Appdomain中</span></span><br><span class="line">        Assembly a =  Assembly.Load(assemId);</span><br><span class="line">        <span class="comment">// 在一个循环中显示已加载程序集中每个公开导出Type的全名</span></span><br><span class="line">        <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> a.Exportedtypes)&#123;</span><br><span class="line">            <span class="comment">//显示类型全名</span></span><br><span class="line">            Console.Writeline(t.Fullname):</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h4><p>Type只是轻量级的对象引用，想要更多类型信息，可用TypeInfo对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type someType = <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line">TypeInfo info = someType.GetTypeInfo(); <span class="comment">// Extensions:System.Reflection.Introspections.GetTypeInfo </span></span><br></pre></td></tr></table></figure><h4 id="批量加载"><a href="#批量加载" class="headerlink" title="批量加载"></a>批量加载</h4><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106144143.png"></p><h3 id="反射构造类型实例"><a href="#反射构造类型实例" class="headerlink" title="反射构造类型实例"></a>反射构造类型实例</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol><li>  System.Activator 的 CreateInstance 方法。</li><li>  System.Activator 的 CreateInstanceFrom 方法。</li><li>  System.AppDomain 的方法。4种实例方法，可以指定在哪个AppDomain中构造对象。</li><li>  System.Reflection.ConstructorInfo 的 Invoke 实例方法。绑定到特定的构造器到ConstructorInfo 中。</li></ol><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>System.Array 的 静态CreateInstance方法。</p><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>MethodInfo 的 静态CreateDelegate方法。</p><h4 id="开放类型"><a href="#开放类型" class="headerlink" title="开放类型"></a>开放类型</h4><p>MakeGenericType方法。</p><p>![image-20220106145501671](E:\My Github\hexo\blog\source_posts\Tech\CSharp\CLR-Via-CSharp\cp6.assets\image-20220106145501671.png)</p><h2 id="反射-程序集加载-设计支持加载项的应用程序⭐"><a href="#反射-程序集加载-设计支持加载项的应用程序⭐" class="headerlink" title="反射+程序集加载 = 设计支持加载项的应用程序⭐"></a>反射+程序集加载 = 设计支持加载项的应用程序⭐</h2><p><strong>接口是中心。</strong>假设要写一个应用程序来无缝地加载和使用别人创建的类型，</p><ol><li>  创建“宿主SDK (Host SDK)”程序集，<strong>接口的方法</strong>作为宿主应用程序与加载项之间的通信机制使用。</li><li>  创建单独的“宿主应用程序”程序集，引用“宿主SDK”程序集，随意开发。</li></ol><p><strong>来看一个上述的例子</strong>：</p><p>首先是<strong>宿主SDK</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostSDK.dll 程序集</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Wintellect.HostSDK</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAddIn</span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">DoSomething</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次是引用了HostSDK.dll的<strong>AddInTypes.dll程序集</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddInTypes.dll 程序集</span></span><br><span class="line"><span class="keyword">using</span> Wintellect.HostSDK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AddIn_A</span> : <span class="title">IAddIn</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddIn_A</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddIn_A:&quot;</span> + x.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AddIn_B</span> : <span class="title">IAddIn</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddIn_B</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddIn_B:&quot;</span> + (x * <span class="number">2</span>).ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们写一个简单的Host.exe程序集的代码，也就是<strong>宿主应用程序</strong>。它必须引用HostSDK.dll程序集。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Host.exe 程序集</span></span><br><span class="line"><span class="keyword">using</span> Wintellect.HostSDK;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找宿主EXE文件所在的目标</span></span><br><span class="line">        String AddInDir = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);</span><br><span class="line">        <span class="comment">// 假定加载项程序集和宿主EXE文件在一个目录</span></span><br><span class="line">        <span class="keyword">var</span> AddInAssemblies = Directory.EnumerateFiles(AddInDir, <span class="string">&quot;*.dll&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建可由宿主使用的所有加载Type的一个集合</span></span><br><span class="line">        <span class="keyword">var</span> AddInTypes = </span><br><span class="line">            <span class="keyword">from</span> file <span class="keyword">in</span> AddInAssemblies</span><br><span class="line">            <span class="keyword">let</span> assembly = Assembly.Load(file)</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> assembly.ExportedTypes <span class="comment">// 公开导出的类型</span></span><br><span class="line">            <span class="comment">// 如果类型实现了IAddIn接口，该类型就可由宿主使用。A.IsAssignableFrom(B) 查看B是否实现or继承了A。</span></span><br><span class="line">            <span class="keyword">where</span> t.IsClass &amp;&amp; <span class="keyword">typeof</span>(IAddIn).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo())</span><br><span class="line">            <span class="keyword">select</span> t;</span><br><span class="line">        <span class="comment">// 初始化完成:宿主已发现了所有可用的加载项</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面示范宿主如何构造加载项对象并使用它们</span></span><br><span class="line">        <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> AddInTypes)&#123;</span><br><span class="line">            IAddIn ai = (IAddIn) Activator.CreateInstance(t);</span><br><span class="line">            Console.WriteLine(ai.DoSth(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用反射发现类型的成员"><a href="#使用反射发现类型的成员" class="headerlink" title="使用反射发现类型的成员"></a>使用反射发现类型的成员</h2><p>揭示WPF、ILDasm等的窗体设计器是如何利用反射实现需求的。</p><h3 id="反射获取类型成员"><a href="#反射获取类型成员" class="headerlink" title="反射获取类型成员"></a>反射获取类型成员</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106164233.png"></p><p>可以先用<code>System.Reflection.MemberInfo</code>抽象基类来接对象，然后再具体判别是什么：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();</span><br><span class="line">    <span class="keyword">foreach</span>(Assembly a <span class="keyword">in</span> assemblies) &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(Type t <span class="keyword">in</span> a.ExportedTypes) &#123;</span><br><span class="line">            <span class="keyword">foreach</span>(MemberInfo mi <span class="keyword">in</span> t.GetTypeInfo().DeclaredMembers) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> Type) &#123; 嵌套类型 &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> FieldInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> MethodInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> ConstructorInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> PropertyInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> EventInfo) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聊下MemberInfo"><a href="#聊下MemberInfo" class="headerlink" title="聊下MemberInfo"></a>聊下MemberInfo</h3><p>上面看到了MemberInfo类是成员层次结构的根，它的实现意味着所有派生成员的实现。下面解析下它：</p><h4 id="MemberInfo属性和方法"><a href="#MemberInfo属性和方法" class="headerlink" title="MemberInfo属性和方法"></a>MemberInfo属性和方法</h4><ul><li>  Name。成员名称</li><li>  DeclaringType。成员类型。</li><li>  Module。</li><li>  CustomAttributes。返回一个<code>IEnumerable&lt;CustomAttributeData&gt;</code>，特性实例。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106172200.png"></p><h4 id="MemberInfo调用"><a href="#MemberInfo调用" class="headerlink" title="MemberInfo调用"></a>MemberInfo调用</h4><p><strong>FieldInfo</strong><br>调用 Getvalue获取字段的值<br>调用 Setvalue设置字段的值</p><p><strong>Constructorlnfo</strong><br>调用 Invoke构造类型的实例并调用构造器</p><p><strong>MethodInfo</strong><br>调用 Invoke来调用类型的方法</p><p><strong>PropertyInfo</strong><br>调用 Getvalue来调用的属性的get访问器方法<br>调用 Setvalue来调用属性的set访问器方法</p><p><strong>Eventlnfo</strong><br>调用 Addeventhandler来调用事件的add访问器方法<br>调用 Removeeventhandler来调用事件的 remove访问器方法</p><h4 id="使用绑定句柄减少进程的内存消耗"><a href="#使用绑定句柄减少进程的内存消耗" class="headerlink" title="使用绑定句柄减少进程的内存消耗"></a>使用绑定句柄减少进程的内存消耗</h4><p>很多情况下会这么写代码：绑定了一组类型(Type)或类型成员(MemberInfo派生)，并将这些对象保存在某种形式的集合中。然后只需要搜索这个集合就可以找到特定对象，并调用(比如Invoke)它。</p><p>这样写很方便，但是会导致一个问题，Type和MemberInfo派生对象需要大量内存，如果只是偶尔调用会造成严重浪费。</p><p>可以使用**运行时句柄(runtime handle)**代替对象以减小该Assembly的内存占用。使用System下的<code>RuntimeTypeHandle</code>、<code>RuntimeFieldHandle</code>、<code>RuntimeMethodHandle</code>。三个类型都是值类型，只包含了一个IntPtr，也就是一个句柄，指向AppDomain的Loader堆中的一个类型/方法/字段。可以使用<code>Type.GetTypeFromHandle</code>和<code>Type.GetTypeHandle</code>方法实现Type和IntPtr的相互转换。</p><h1 id="大章24：运行时序列化"><a href="#大章24：运行时序列化" class="headerlink" title="大章24：运行时序列化"></a><center>大章24：运行时序列化</center></h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>序列化是将<strong>对象or对象图(比如数组)<strong>转换成</strong>字节流</strong>的过程，反序列化是将字节流转换回对象图的过程。</p><p>再举一些例子：</p><ul><li>  ASP.NET利用序列化反序列化来保存和还原会话状态。</li><li>  WPF的对象剪切板由序列化反序列化实现。</li><li>  深拷贝/备份 对象</li><li>  不同端末之间的交互（pc与服务器）</li></ul><h3 id="序列化反序列化API"><a href="#序列化反序列化API" class="headerlink" title="序列化反序列化API"></a>序列化反序列化API</h3><p>微软提供 BinaryFormatter 和 SoapFormatter 两个格式化器，他们都是实现了<code>System.Runtime.Serialization.IFormatter</code>这个序列化专用的接口。</p><p>SoapFormatter在.net3.5废了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectGraph = <span class="keyword">new</span> List&lt;String&gt; &#123; <span class="string">&quot;Jeff&quot;</span>, <span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Grant&quot;</span> &#125;;</span><br><span class="line">MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 to stream</span></span><br><span class="line">formatter.Serialize(stream, objectGraph);</span><br><span class="line"><span class="comment">// 反序列化 to obj</span></span><br><span class="line">stream.Position = <span class="number">0</span>; <span class="comment">// 流的当前位置归零!否则在末尾</span></span><br><span class="line">Object obj = formatter.Deserialize(stream);</span><br></pre></td></tr></table></figure><p>序列化对象之后，会将类型的全名和字段都写入流中，甚至还会将程序集的信息写入进去。</p><p>我们尝试一下，发现直接转字符串是不行的，也是毕竟是流，要先转Byte，再转成人能看的懂的字节：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> readBuffer = <span class="keyword">new</span> <span class="built_in">byte</span>[stream.Length];</span><br><span class="line"><span class="built_in">int</span> count = stream.CanRead ? stream.Read(readBuffer, <span class="number">0</span>, readBuffer.Length) : <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> charCount = Encoding.Default.GetCharCount(readBuffer, <span class="number">0</span>, count);</span><br><span class="line"><span class="keyword">var</span> readCharArray = <span class="keyword">new</span> <span class="built_in">char</span>[charCount];</span><br><span class="line"></span><br><span class="line">Encoding.Default.GetDecoder().GetChars(readBuffer, <span class="number">0</span>, count, readCharArray, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; readCharArray.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    test += readCharArray[i];</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(test);</span><br></pre></td></tr></table></figure><p>最后输出这么个东西，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">&quot;\0\u0001\0\0\0\u0001\0\0\0\0\0\0\0\u0004\u0001\0\0\0\u007fSystem.Collections.Generic.List`1[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\u0003\0\0\0\u0006_items\u0005_size\b_version\u0006\0\0\b\b\t\u0002\0\0\0\u0003\0\0\0\u0003\0\0\0\u0011\u0002\0\0\0\u0004\0\0\0\u0006\u0003\0\0\0\u0004Jeff\u0006\u0004\0\0\0\u0005Aidan\u0006\u0005\0\0\0\u0005Grant\n\v&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理一下上面</span></span><br><span class="line">System.Collections.Generic.List`<span class="number">1</span>[[System.String, mscorlib, Version=<span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>, Culture=neutral, PublicKeyToken=b77a5c561934e089]]</span><br><span class="line">_items</span><br><span class="line">_siz_versio</span><br><span class="line">Jeff Aidan Grant</span><br></pre></td></tr></table></figure><p>转义符很多，程序集信息、字段信息确实都在里面。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>可以看到上面的那一串东西，</p><p>反序列化时，格式化器先获取程序集标识信息，并通过调用System.Reflection.Assembly的Load方法确保程序集已加载到正在执行的 Appdomain中。</p><p>然后在程序集中查找对应的类型，找不到就抛出异常。</p><p>找到类型就创建类型实例，并用流中的值对其字段初始化。如果字段名不完全匹配，就抛出SerializationException异常。</p><h2 id="使类型可序列化"><a href="#使类型可序列化" class="headerlink" title="使类型可序列化"></a>使类型可序列化</h2><h3 id="SerializebleAttribute"><a href="#SerializebleAttribute" class="headerlink" title="SerializebleAttribute"></a>SerializebleAttribute</h3><p>直接序列化一个类，会抛出SerializationException异常。因为你没有使用定制特性**[SerializebleAttribute]**。</p><p>该定制特性只能应用于<strong>引用类型(class)、值类型(struct)、枚举类型(enum)和委托类型(delegate)<strong>。其中，</strong>枚举类型和委托类型</strong>不必申明，他们总是可序列化的；对于<strong>类</strong>，可序列化特性不能被子类继承，但基类型如果不被申明可序列化那么子类无法可序列化，毕竟父类是子类的一部分。</p><h3 id="控制序列化和反序列化"><a href="#控制序列化和反序列化" class="headerlink" title="控制序列化和反序列化"></a>控制序列化和反序列化</h3><p>使用**[NonSerialized]**特性来使部分字段不参与序列化。</p><p>使用**[OnDeserialized]**特性来控制反序列化。它是用来修饰方法的，当实例所有字段被反序列化完后，方法才会被执行。你可以在里面给忽略的字段赋值或者标准化数据。</p><p>同样的还有特性**[OnDeserializing] (反序列化前)<strong>、</strong>[OnSerializing] (序列化前)<strong>、</strong>[OnSerialized]  (序列化后)**。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面4个特性时，必须获取一个StreamingContext参数并返回void：</span></span><br><span class="line">[<span class="meta">OnSerialized</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSerialized</span>(<span class="params">StreamingContext context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 举例：在序列化后，恢复任何需要恢复的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格式化器序列化流程"><a href="#格式化器序列化流程" class="headerlink" title="格式化器序列化流程"></a>格式化器序列化流程</h3><p>微软提供了FormatterServices类型，里面只有静态方法，下面刨析一下流程。</p><p>序列化：</p><ol><li>格式化器调用 Formatterservices的 GetSerializableMembers方法，<strong>反射获取类型的字段</strong>。<br>  <code>public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context)</code></li><li>  格式化器调用 Formatterservices的 GetObjectData方法，该方法<strong>输入一个MemberInfo[]输出一个Object[]，而输出的Object[]是MemberInfo[]对应字段的值</strong>，两者一一对应。<code>public static Object[] GetObjectData(Object obj, MemberInfo[] members)</code></li><li>  格式化器将程序集标识和类型的完整名称写入流中。</li><li>  格式化器然后遍历两个数组中的元素，将每个成员的名称和值写入流中。</li></ol><p>反序列化：</p><ol><li>  格式化器从流中读取程序集标识和完整类型名称，如果程序集没加载到AppDomain中，就会加载它。确保程序集被加载后，格式化器将程序集标识信息和类型全名传给 FormatterServices的静态方法 GetTypeFromAssembly来<strong>获取反序列化对象的Type</strong>。<code>public static Type GetTypeFromAssembly(Assembly assem, String name)</code></li><li>  格式化器调用 FormatterServices的静态方法 GetUninitializedObject，<strong>为对象分配内存并初始化字段</strong>为null、0，但不调用构造器。<code>public static Object GetUninitializedObject(Type type)</code></li><li>  格式化器调用 Formatterservices的 GetSerializableMembers方法，<strong>构造并初始化一个MemberInfo[] 数组</strong>，等待着对应的字段值。</li><li>  格式化器根据流中包含的数据<strong>创建并初始化一个 Object数组</strong>，是与3中一一对应的字段值。</li><li>将新分配对象、 MemberInfo[] 数组以及并行 Object数组（其中包含字段值）的引用传给<br>  FormatterServices的静态方法 PopulateObjectMembers：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">PopulateObjectMembers</span>(<span class="params">Object obj, MemberInfo[] members, Object[] data</span>)</span>;</span><br></pre></td></tr></table></figure><p>这个方法遍历数组，将每个字段初始化成对应的值。</p><h2 id="完全控制序列化-反序列化"><a href="#完全控制序列化-反序列化" class="headerlink" title="完全控制序列化/反序列化"></a>完全控制序列化/反序列化</h2><p>可以自己定义序列化和序列化的方法，来实现完全控制，具体是用<strong>ISerializable和IDeserializationCallback</strong>来实现。</p><h3 id="ISerializable-接口"><a href="#ISerializable-接口" class="headerlink" title="ISerializable 接口"></a>ISerializable 接口</h3><p>只有GetObjectData一个方法，但是同时需要提供一个特殊签名的构造器，反序列化的时候会调用那个构造器，一般拿来暂存 SerializationInfo。</p><h3 id="IDeserializationCallback接口"><a href="#IDeserializationCallback接口" class="headerlink" title="IDeserializationCallback接口"></a>IDeserializationCallback接口</h3><p>只有OnDeserialization一个方法。当然你可以不把赋值逻辑写在这里，可以直接写在构造器里，就不必实现本接口。</p><h3 id="看个例子"><a href="#看个例子" class="headerlink" title="看个例子"></a>看个例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ISerializable</span>,<span class="title">IDeserializationCallback</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> A;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> B;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存序列化用的字段</span></span><br><span class="line">    <span class="keyword">private</span> SerializationInfo _info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ISerializable 接口要求实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">info.AddValue(<span class="string">&quot;A&quot;</span>,A);</span><br><span class="line">info.AddValue(<span class="string">&quot;B&quot;</span>,B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特别签名的构造器，接口不要求实现，但是反序列化Deserialize的时候会被调用，没有会抛错，且不保存后续调不到SerializationInfo的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Test</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_info = info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDeserializationCallback 接口要求实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDeserialization</span>(<span class="params"><span class="built_in">object</span> sender</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">A = (<span class="built_in">string</span>)_info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">B = (<span class="built_in">string</span>)_info.GetValue(<span class="string">&quot;B&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动为父类实现-ISerializable"><a href="#手动为父类实现-ISerializable" class="headerlink" title="手动为父类实现 ISerializable"></a>手动为父类实现 ISerializable</h3><p>有时候父类没实现ISerializable，子类却想实现ISerializable来完全控制序列化，那么可以手动为父类实现 ISerializable。</p><p>观察下面代码，关键在于<code>info.GetValue(baseType.FullName + &quot;+&quot; + fi.Name, fi.FieldType)</code>和<code>info.AddValue(baseType.FullName + &quot;+&quot; + mi[i].Name, ((FieldInfo) mi[i]).GetValue(this));</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISerializable 接口要求的特殊构造器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Test</span> (<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 手动为父类实现序列化</span></span><br><span class="line">Type baseType = <span class="keyword">this</span>.GetType().BaseType;</span><br><span class="line">MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;mi.Length; i++)&#123;</span><br><span class="line">        FieldInfo fi = (FieldInfo) mi[i];</span><br><span class="line">        fi.SetValue(<span class="keyword">this</span>, info.GetValue(baseType.FullName + <span class="string">&quot;+&quot;</span> + fi.Name, fi.FieldType)); <span class="comment">// 这一句很关键</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后实现本类的序列化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span>&#123;</span><br><span class="line">    Type baseType = <span class="keyword">this</span>.GetType().BaseType;</span><br><span class="line">    MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;mi.Length; i++)&#123;</span><br><span class="line">        info.AddValue(baseType.FullName + <span class="string">&quot;+&quot;</span> + mi[i].Name, ((FieldInfo) mi[i]).GetValue(<span class="keyword">this</span>)); <span class="comment">// 这一句对应上面关键的那句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看下 FormatterServices.GetSerializableMembers方法获取出来的东西：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220110153044.png"></p><h3 id="为单例序列化的技巧"><a href="#为单例序列化的技巧" class="headerlink" title="为单例序列化的技巧"></a>为单例序列化的技巧</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例序列化Helper</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SingletonSerializationHelper</span>: <span class="title">IObjectReference</span>&#123;</span><br><span class="line">    <span class="comment">//这个方法在对象（它没有字段）反序列化之后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">GetRealObject</span>(<span class="params">streaming</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.GetSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例类</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> : <span class="title">ISerializable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> Instance; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)&#123;</span><br><span class="line">        info.SetType(<span class="keyword">typeof</span>(SingletonSerializationHelper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流上下文-StreamingContext"><a href="#流上下文-StreamingContext" class="headerlink" title="流上下文 StreamingContext"></a>流上下文 StreamingContext</h2><p>前面的 ISerializable接口也好 FormatterServices.GetSerializableMembers方法也好，都用到了 StreamingContext这个类，<strong>它存储着关于程序集的上下文</strong>。</p><p>这个类内一共2个字段：</p><ul><li>  Context：Object类型，一个对象引用，对象中包含用户希望的任何上下文信息。</li><li>  State：StreamingContextStates枚举类型，一组位标志( bit flag)，指定要序列化/反序列化的对象的来源或目的地。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220110153439.png"></p><p>State就不多举例了，只说这个All：来源或目的地可能是上述任何一个上下文。这是默认设定。</p><h2 id="序列化代理"><a href="#序列化代理" class="headerlink" title="序列化代理"></a>序列化代理</h2><p>自定义一个序列化器。看了一遍，感觉XLua的Loader是参照了这里的解决方案。</p><h3 id="ISerializationSurrogate-接口"><a href="#ISerializationSurrogate-接口" class="headerlink" title="ISerializationSurrogate 接口"></a>ISerializationSurrogate 接口</h3><p>实现序列化代理项选择器，此选择器允许一个对象对另一个对象执行序列化和反序列化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISerializationSurrogate</span> &#123;</span><br><span class="line">    <span class="comment">// 使用序列化对象所需的数据填充所提供的 SerializationInfo。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">Object, SerializationInfo, StreamingContext</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SerializationInfo 中的信息填充对象。</span></span><br><span class="line"><span class="function">Object <span class="title">SetObjectData</span>(<span class="params">Object, SerializationInfo, StreamingContext, ISurrogateSelector</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现之后怎么用？</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    IFormatter formatter = <span class="keyword">new</span> SoapFormatter();</span><br><span class="line">    SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">    <span class="comment">// 告诉代理选择器为 Datetime对象使用我们的代理MyProxy</span></span><br><span class="line">    ss.AddSurrogate(<span class="keyword">typeof</span>(DateTime), formatter.Context, <span class="keyword">new</span> MyProxy());</span><br><span class="line">    formatter.SurrogateSelector = ss;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至此，上面已经实现了一个formatter可以通过代理来 序列化/反序列化 DateTime类型。</span></span><br><span class="line">    formatter.Serialize(stream, someTime);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> test = (DateTime)formatter.Deserialize(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当格式化器准备好已登记的代理类型（如上述），调用格式化器的 Serialize方法时，会在<strong>SurrogateSelector维护的集合（一个哈希表）</strong>中查找每个对象的类型。如果发现一个匹配，就调用 ISerializationSurrogate.GetObjectData方法来获取写入流的信息。Deserialize方法同理。</p><p>上面提到的SurrogateSelector维护的集合是一个私有哈希表，调用AddSurrogate时，Type和StreamingContext构成了哈希表的key，对应的value就是ISerializationSurrogate对象。</p><h3 id="代理选择器链"><a href="#代理选择器链" class="headerlink" title="代理选择器链"></a>代理选择器链</h3><p>多个SurrogateSelector对象可链接到一起。</p><p>看一下 ISurrogateSelector怎么实现的，有点类似迭代器（不是真的实现了迭代器）：</p><p><strong>ChainSelector</strong>方法负责将参数插入到当前Selector后面。</p><p><strong>GetNextSelector</strong>方法返回对链表中的下一个 IsurrogateSelector对象的引用（如果当前操作的对象是链尾，就返回null）。经过测试发现，GetNextSelector并不会像迭代器的 GetEnumerator方法一样调用一次就改变一次Current，单纯只是返回值罢了。</p><p><strong>GetSurrogate</strong>方法返回对应Type的 ISurrogateSelector实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISurrogateSelector</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChainSelector</span>(<span class="params">ISurrogateSelector selector</span>)</span>;</span><br><span class="line">    <span class="function">ISurrogateSelector <span class="title">GetNextSelector</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">ISerializationSurrogate <span class="title">GetSurrogate</span>(<span class="params">Type, StreamingContext, <span class="keyword">out</span> ISurrogateSelector</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意了，格式化器在里面找对应的Type，如果到了第一个就直接调用对应方法，不会再找第二个了。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> objectGraph = <span class="keyword">new</span> Test &#123;A=<span class="string">&quot;3&quot;</span>, B=<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"></span><br><span class="line">BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">SurrogateSelector ss2 = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">ss.AddSurrogate(<span class="keyword">typeof</span>(<span class="built_in">string</span>), formatter.Context, <span class="keyword">new</span> StringProxy());</span><br><span class="line">ss2.AddSurrogate(<span class="keyword">typeof</span>(Test), formatter.Context, <span class="keyword">new</span> TestProxy());</span><br><span class="line">ss.ChainSelector(ss2);</span><br><span class="line">formatter.SurrogateSelector = ss;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至此，上面已经实现了一个formatter可以通过代理来 序列化/反序列化 String和Test类型。只会调用链中第一个找到的Test类型。</span></span><br><span class="line">formatter.Serialize(stream, objectGraph);</span><br><span class="line">stream.Position = <span class="number">0</span>;</span><br><span class="line">Test obj = (Test)formatter.Deserialize(stream);</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">        <span class="comment">// 最后，obj.isMoreThanFive 值为true;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestProxy</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> datas = (Test) obj;</span><br><span class="line">info.AddValue(<span class="string">&quot;A&quot;</span>, datas.A);</span><br><span class="line">info.AddValue(<span class="string">&quot;B&quot;</span>, datas.B);</span><br><span class="line">info.AddValue(<span class="string">&quot;A_Int&quot;</span>, <span class="built_in">int</span>.Parse(datas.A));</span><br><span class="line">info.AddValue(<span class="string">&quot;B_Int&quot;</span>, <span class="built_in">int</span>.Parse(datas.B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> datas = <span class="keyword">new</span> Test();</span><br><span class="line">datas.A = (<span class="built_in">string</span>)info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">datas.B = (<span class="built_in">string</span>)info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">datas.A_Int = (<span class="built_in">int</span>)info.GetValue(<span class="string">&quot;A_Int&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">datas.B_Int = (<span class="built_in">int</span>)info.GetValue(<span class="string">&quot;B_Int&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">datas.isMoreThanFive = datas.A_Int + datas.B_Int &gt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">return</span> datas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StringProxy</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// do sth</span></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> A;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> B;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> A_Int;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> B_Int;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isMoreThanFive;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与之类似的SerializationBinder：反序列化对象时重写程序集-类型"><a href="#与之类似的SerializationBinder：反序列化对象时重写程序集-类型" class="headerlink" title="与之类似的SerializationBinder：反序列化对象时重写程序集/类型"></a>与之类似的SerializationBinder：反序列化对象时重写程序集/类型</h3><p>讲的是 SerializationBinder类，<code>格式化器.Binder</code>可以指定，也就是也可以自定义。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Ver1ToVer2SerializationBinder</span> : <span class="title">SerializationBinder</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Type <span class="title">BindToType</span>(<span class="params"><span class="built_in">string</span> assemblyName, <span class="built_in">string</span> typeName</span>)</span> &#123;</span><br><span class="line">        AssemblyName assemVer1 = Assembly.GetExecutingAssembly().GetName();</span><br><span class="line">        assemVer1.Version = <span class="keyword">new</span> Version(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果是1.0.0.0版本的程序集,就返回 Ver2类</span></span><br><span class="line">        <span class="keyword">if</span>(assemblyName == assemVer1.ToString() &amp;&amp; typeName == <span class="string">&quot;Ver1&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span>(Ver2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就返回参数指定程序集的Type(默认实现)</span></span><br><span class="line">        <span class="keyword">return</span> Type.GetType(String.Format(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, typeName, assemblyName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大章25：与-WinRT组件互操作"><a href="#大章25：与-WinRT组件互操作" class="headerlink" title="大章25：与 WinRT组件互操作"></a><center>大章25：与 WinRT组件互操作</center></h1><h2 id="WinRT-is-what？"><a href="#WinRT-is-what？" class="headerlink" title="WinRT is what？"></a>WinRT is what？</h2><p>**WinRT (Window Runtime, Windows运行时)**，是windows8带来的新类库。</p><p>WinRT 组件内部作为“组件对象模型”(COM)组件来实现。</p><p>WinRT 的特点是，他是异步的。</p><p>// TODO 本章只做基本了解，日后有需求补齐。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>WinRT与CLR是隐式映射的，通过各种解决方案来讲两者机制默默帮你处理成一致。</p><p>WinRT与.Net之间是显式映射的，写代码的时候调的是WinRT的API。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> CLR via C# </category>
          
          <category> 第四章 核心机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
            <tag> 可访问性 </tag>
            
            <tag> 核心机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*算法</title>
      <link href="/Tech/Game/AStar/"/>
      <url>/Tech/Game/AStar/</url>
      
        <content type="html"><![CDATA[<h1 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a><center>A*算法</center></h1><h3 id="A-算法是什么"><a href="#A-算法是什么" class="headerlink" title="A*算法是什么"></a>A*算法是什么</h3><p><strong>原理</strong></p><p>主要利用到3个数值，</p><ul><li>  <strong>G Cost</strong>：从出发点到该点已花费的距离。</li><li>  <strong>H Cost</strong>：从该点到终点的最乐观距离（不考虑障碍等因素）。</li><li>  <strong>F Cost = G Cost + H Cost</strong>，它越低，作为寻径选择就越有吸引力。</li></ul><p>目标是简单选择最低的F Cost，一步一步往后踩，每一步都记录附近没踩过的格子的F Cost到列表里。每踩下去一步后，如果发现周围邻近的格子F Cost都比过去的某个列表里的格子的F Cost大，就用那个列表里的格子继续踩。</p><p>不断重复，直到我们到达目标节点。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211208131158.png"></p><p><strong>NodeBase</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Nodebase</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> G &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> H &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> F =&gt; G+H</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> Nodebase Connection &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span> &#125; </span><br><span class="line">    <span class="keyword">public</span> List&lt;NodeBase&gt; Neighbors &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setconnection</span>(<span class="params">Nodebase nodebase</span>)</span> =&gt; &#123; Connection = nodebase; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetDistance</span>(<span class="params">NodeBase other</span>)</span> =&gt; Coords.GetDistance(other.Coords); <span class="comment">// reduce noise,优化的话主要就优化这里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetG</span>(<span class="params"><span class="built_in">float</span> g</span>)</span> =&gt; G=<span class="function">g</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetH</span>(<span class="params"><span class="built_in">float</span> h</span>)</span> =&gt; H=h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;NodeBase&gt; <span class="title">FindPath</span>(<span class="params">NodeBase startNode, NodeBase targetNode</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 接下来需要探索的结点。又名“开放列表”。</span></span><br><span class="line"><span class="keyword">var</span> toSearch = <span class="keyword">new</span> List&lt;NodeBase&gt;() &#123; startNode &#125;;</span><br><span class="line"><span class="comment">// 已处理过的结点：一旦进入该队列，就再也不会更新结点值、探索了。又名“关闭列表”。</span></span><br><span class="line"><span class="keyword">var</span> processed = <span class="keyword">new</span> List&lt;NodeBase&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (toSearch.Any())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> current = toSearch[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> toSearch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 0.获取一个【乐观总长F】最好的结点，或者F相同但是【乐观H】最好的结点</span></span><br><span class="line">            <span class="keyword">if</span> (t.F &lt; current.F || t.F == current.F &amp;&amp; t.H &lt; current.H) current = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.将此结点作为探测完毕的结点</span></span><br><span class="line">processed.Add(current);</span><br><span class="line">toSearch.Remove(current);</span><br><span class="line">current.SetColor(ClosedColor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.探测是否是终点结点</span></span><br><span class="line"><span class="keyword">if</span> (current == targetNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> currentPathTile = targetNode;</span><br><span class="line"><span class="keyword">var</span> path = <span class="keyword">new</span> List&lt;NodeBase&gt;();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (currentPathTile != startNode)</span><br><span class="line">&#123;</span><br><span class="line">path.Add(currentPathTile);</span><br><span class="line">currentPathTile = currentPathTile.Connection;</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">Debug.Log(<span class="string">&quot;sdfsdf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> tile <span class="keyword">in</span> path) tile.SetColor(PathColor);</span><br><span class="line">startNode.SetColor(PathColor);</span><br><span class="line">Debug.Log(path.Count);</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将该结点的所有邻居结点进行更新(只更新未被加入已处理队列的)</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> neighbor <span class="keyword">in</span> current.Neighbors.Where(t =&gt; t.Walkable &amp;&amp; !processed.Contains(t)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ① 如果该邻居不在未来需要探索的结点队列中</span></span><br><span class="line"><span class="keyword">var</span> inSearch = toSearch.Contains(neighbor);</span><br><span class="line"><span class="comment">// ② 如果该邻居的开销G &gt; 本结点开销G + 本结点到该邻居距离</span></span><br><span class="line"><span class="keyword">var</span> costToNeighbor = current.G + current.GetDistance(neighbor);</span><br><span class="line"><span class="comment">// ① || ②</span></span><br><span class="line"><span class="keyword">if</span> (!inSearch || costToNeighbor &lt; neighbor.G)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ③ 根据当前结点的【开销G】，更新所有邻居的G和路线为目前最优解。</span></span><br><span class="line">neighbor.SetG(costToNeighbor);</span><br><span class="line">neighbor.SetConnection(current);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inSearch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ④ 如果更新了的数据结点不在探索队列，就更新它的【乐观H】，并将其加入探索队列</span></span><br><span class="line">neighbor.SetH(neighbor.GetDistance(targetNode));</span><br><span class="line">toSearch.Add(neighbor);</span><br><span class="line">neighbor.SetColor(OpenColor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们确定这个新邻居G Cost的值，然后如果它不在搜索列表中，或者这个G值比现在的G值好，那就设置它的Connection，并更新它的G值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CacheNeighbors</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Neighbors = GridManager.Instance.Tiles.Where(t =&gt; Coords.GetDistance(t.Value.Coords) == <span class="number">1</span>).Select(t=&gt;t.Value).ToList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考</strong></p><ol><li>  GetDistance是优化的重点，想减少噪音，如何根据具体业务选择最好的算法是值得思考的。</li><li>  算法核心就是上面代码的<code>3.</code>这一块：每走一步当前最优时需要更新所有的未探索邻居结点，从中找出更优解作为继续探索的起点。</li></ol><h1 id="多种寻路对比"><a href="#多种寻路对比" class="headerlink" title="多种寻路对比"></a><center>多种寻路对比</center></h1><h2 id="方格版本"><a href="#方格版本" class="headerlink" title="方格版本"></a>方格版本</h2><p>1.先做一个地图生成器，每个方格都带坐标，提前生成好地图和每个结点的邻居list；</p><p>2.规定横竖都是1长度，斜向是1.4长度(1/cos45°)；</p><p>3.有2个列表，一个是【已探索的结点】列表，一个是【即将探索的结点】队列。每一步探索，就是去遍历第二个队列，把里面的结点移到第一个列表里，同时把这个结点的邻居list全部扔到第二个队列里（如果已经在第一个、第二个列表中有，就不扔）。// 这一步是优化点</p><h2 id="可以优化的寻路算法"><a href="#可以优化的寻路算法" class="headerlink" title="可以优化的寻路算法"></a>可以优化的寻路算法</h2><p>1.宽度优先算法：这个是最简单直白的版本，总体是绕圈方式一点点遍历全图，个体之间是找找到可达就确定一个路径，不进行任何大小比较。这种寻路算法并没有什么意义，效率低且<strong>无法找到最短路径</strong>，找到的第一个解不一定是最短距离。</p><p>2.迪杰斯特拉算法：基于宽度优先算法，总体是绕圈方式，但是个体之间不再是可达就确定，而是不停更新比较、更新成最小值。可以找到最短路径，但是<strong>计算量极大</strong>，因为需要遍历完整个地图结点才能确定出最短解，不然。</p><p>3.贪心算法：追求局部最优解，总体是几乎直线的形式。但是因为走的是局部最优，获得的解在有障碍物的情况下不一定是最优解。速度极快，<strong>只能用于中途无障碍的寻路</strong>，比如mmo广场。</p><p>4.A星算法：结合迪杰斯特拉往后看、贪心往前看，一种综合评估的算法。也会和贪心算法一样选错路，但是<strong>很快会调转回头，最终一定能得到一个最短解</strong>。</p><h2 id="引入优先队列优化"><a href="#引入优先队列优化" class="headerlink" title="引入优先队列优化"></a>引入优先队列优化</h2><p>通过引入优先队列，可以解决<strong>迪杰斯特拉算法</strong>因为无法确定退出时间点，所以需要遍历完全图才能确定获得最短解，导致效率低下的问题。</p><p><strong>迪杰斯特拉算法</strong>：具体引入就是修改【即将探索的结点】队列，对于每一个<code>priority = 到当前点的最短距离 G Cost</code>，优先去探索最小的sumDistance的点，这样第一个找到的路径就是最短路径。</p><p><strong>贪心算法</strong>：把上面的priority改为<code>priority = 当前点的乐观最短距离 H Cost</code>。不过这不一定能得到最短解。</p><p><strong>A星算法</strong>：把上面的priority改为<code>priority = 到当前点的最短距离 G Cost + 当前点的乐观最短距离 H Cost</code>。一定能找到最短解，且性能适中。</p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 技术 </tag>
            
            <tag> A* </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR Via C#个人笔记5 - 基本类型</title>
      <link href="/Tech/CSharp/CLR-Via-CSharp/cp5/"/>
      <url>/Tech/CSharp/CLR-Via-CSharp/cp5/</url>
      
        <content type="html"><![CDATA[<h1 id="大章14：字符、字符串和文本处理"><a href="#大章14：字符、字符串和文本处理" class="headerlink" title="大章14：字符、字符串和文本处理"></a><center>大章14：字符、字符串和文本处理</center></h1><h3 id="字符Char类型"><a href="#字符Char类型" class="headerlink" title="字符Char类型"></a>字符Char类型</h3><p><strong>System.Char</strong></p><ol><li>Char类型，在.NET中总是表示成16位Unicode代码值。</li><li>Char类型，提供2个静态只读字段：<code>MinValue = \0</code> 和 <code>MaxValue = \uffff</code>。</li><li>Char类型，提供GetUnicodeCategory方法，它返回枚举类，表明该字符是Unicode标准定义的控制字符、货币符号、小写字母、大写字母、标点符号、数学符号还是其它字符。</li><li>Char类型，在使用ToLower和ToUpper方法时，会需要使用到语言文化来转换，语言文化通过<code>System.Threading.Thread.CurrentCulture静态方法</code>获取。</li></ol><p><strong>Char转换数值类型</strong></p><ol><li>强转，效率最高。</li><li>用Convert类的静态方法。</li><li>用IConvertible接口，效率最低，因为要装箱。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Main()&#123;</span><br><span class="line"><span class="built_in">char</span> c;</span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.强转</span></span><br><span class="line">c = (Char) <span class="number">65</span>;</span><br><span class="line">n = (<span class="built_in">int</span>) c;</span><br><span class="line">Console.WriteLine(c);<span class="comment">// output:&quot;A&quot;</span></span><br><span class="line">Console.WriteLine(n);<span class="comment">// output:&quot;65&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Convert类</span></span><br><span class="line">c = Convert.ToChar(<span class="number">65</span>);</span><br><span class="line">n = Convert.ToInt32(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.IConvertible</span></span><br><span class="line">c = ((IConvertible) <span class="number">65</span>).ToChar(<span class="literal">null</span>);</span><br><span class="line">n = ((IConvertible) c).ToInt32(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringInfo处理字符</strong></p><p>可以用StringInfo类提供的方法来实现处理字符、获取字符长度与文本元素等，具体不说了。</p><p>值得了解的是一个概念：Char实际代表一个16位Unicode码值，但是该值不一定就等于一个抽象Unicode字符。比如有的抽象Unicode字符是2个码值的组合，U+0625和U+0650字符组合起来构成一个抽象字符或者文本元素。</p><p>上述提到的一些Unicode抽象字符或者文本元素要求用2个16位值表示，第一个叫“高位代理项(high surrogate)”，第一个叫“低位代理项(low surrogate)”。两个代理项，Unicode可以表示100万以上不同的字符。</p><h3 id="字符串String类型⭐"><a href="#字符串String类型⭐" class="headerlink" title="字符串String类型⭐"></a>字符串String类型⭐</h3><p><strong>System.String</strong></p><ol><li>String代表一个不可变(immutable)的顺序字符集。</li><li>String直接继承自Object，所以是引用类型、总在堆上。</li></ol><p><strong>构造String</strong></p><p>string虽然是引用类型，却不可以用new、只能用简化过的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hi there.&quot;</span>;</span><br><span class="line"><span class="comment">// =&gt;IL Code</span></span><br><span class="line">IL_0000: ldstr <span class="string">&quot;Hi there.&quot;</span></span><br><span class="line">IL_0005: stloc<span class="number">.0</span></span><br><span class="line">IL_0006: ldloc<span class="number">.0</span></span><br></pre></td></tr></table></figure><p>可见，String构造新实例用的是ldstr(load string)指令 而不是类通用的newobj指令，来处理从元数据获得的字面值(literal) “Hi there.”字符串。</p><p><strong>逐字字符串@</strong></p><p>推出这个是因为C#编译器会对String的实例实行转义机制，在使用比如输出时，会把诸如<code>\r \n</code>进行语义转换。</p><p>逐字字符串(verbatim string)，用<code>@关键字</code>。抛弃转义，所有字符都被视为字符串的一部分。</p><p><strong>字符串是不可变的⭐</strong></p><p>字符串是不可变(immutable)的，也就是说一经创建就不能更改任何字符。</p><ol><li>对字符串的变更操作（比如<code>Substring()</code>）会返回新的字符串。因为它们都在堆上，所以频繁对字符串进行处理会影响GC。执行大量字符串操作更推荐用<code>StringBuilder类</code>。</li><li>不可变所以不会发生线程同步问题。</li><li>CLR会将”字符串留用“，多个String实例共享一个String内容。</li></ol><p><strong>字符串留用⭐</strong></p><p>字符串一经创建不可变更，所以CLR为了提升性能推出了字符串留用(string interning)机制。</p><p>CLR在初始时会创建一个空的内部哈希表，key是字符串，value是对托管堆中String对象的引用。String类提供了2个方法来访问这个内部哈希表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把入参str作为哈希值去找内部哈希表，如果存在则返回引用，如果不存在则创建入哈希表并返回引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Intern</span>(<span class="params">String str</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把入参str作为哈希值去找内部哈希表，如果存在则返回引用，如果不存在则返回null,不会添加到哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">IsInterned</span>(<span class="params">String str</span>)</span>;</span><br></pre></td></tr></table></figure><p>注意了，这种字符串留用机制录入的字符串，因为哈希表引用着String，所以永远不会被GC；一般的新建字符串方法，会被GC。</p><p><strong>重点来了，那么，对于我们日常的字符串写法<code>var s = &quot;Hello&quot;;</code>会进入留用哈希表吗？答案是不一定，但大概率会。</strong></p><p>书中说了，如果<font color="red">元数据中</font>存在“字面值”字符串定义，C#编译器会在加载AppDomain时对这些字面值进行留用。</p><p>在CLR4.5以前的版本中，由于<code>System.Runtime.CompilerServices.CompilationRelaxationsArrtibute</code>和<code>System.Runtime.CompilerServices.NoStringInterning</code>两个标志的标记，CLR会不留用。</p><p>目前的CLR版本中，我测试了，默认是留用的。但是注意了，留用只限于元数据中存在的、编译时就可确定的那些字面值。运行时确定的是不行的。下面展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 1.元数据内能确定的字面值，目前CLR版本留用</span></span><br><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;Hell&quot;</span> + <span class="string">&quot;o&quot;</span>;</span><br><span class="line">String b1 = String.IsInterned(s1); <span class="comment">// 返回&quot;Hello&quot;！目前版本留用！</span></span><br><span class="line"><span class="keyword">var</span> eq1 = Object.ReferenceEquals(s1, s2); <span class="comment">// 返回true！堆中目标只有一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.元数据内不能确定的字面值，比如需要运行时决定，一定不留用</span></span><br><span class="line">String s3 = <span class="string">&quot;Hell&quot;</span> + <span class="string">&quot;O&quot;</span>.ToLower();</span><br><span class="line"><span class="keyword">var</span> eq2 = Object.ReferenceEquals(s1, s3); <span class="comment">// 返回false！堆中目标一定不同！</span></span><br><span class="line">String s4 = s3.Substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> chaos = String.IsInterned(s4); <span class="comment">// 返回null！一定不留用！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.正确可靠的留用机制使用方式：显式调用Intern</span></span><br><span class="line">String s5 = String.Intern(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String s6 = String.Intern(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> eq3 = Object.ReferenceEquals(s5, s6); <span class="comment">// 返回true！一定留用！堆中目标只有一个。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，怎么说呢，这块概念很重要，便于去理解C#留用机制的实现。但是真写代码是不会用这么麻烦的<code>String.Intern</code>写法的。</p><p><strong>字符串池</strong></p><p>字符串留用机制之外的另一个优化。</p><p>CLR处理字面值字符串并嵌入元数据，同一个字符串在源代码中多次出现，把它们都嵌入元数据会使生成的文件无谓地增大。</p><p>所以只在元数据中嵌入一次该字符串，剩下的全部是持有那个字符串的实例。</p><p><strong>比较字符串（语言文化）</strong></p><p>了解即可。</p><p>用来比较的<code>String.Equals();String.Compare()</code>等的重载，一般都有一个<font color="red">StringComparison枚举类型</font>或者<font color="red">CompareOptions枚举类型</font>参数，这2个枚举类型跟语言文化有关，可以改变比较的思路。下面进行展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringComparison枚举类型</span></span><br><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StringComparison &#123;</span><br><span class="line">CurrentCulture = <span class="number">0</span>, <span class="comment">// 使用语言文化</span></span><br><span class="line">CurrentCultureIgnoreCase = <span class="number">1</span>, <span class="comment">// 使用语言文化</span></span><br><span class="line">InvariantCulture = <span class="number">2</span>,</span><br><span class="line">InvariantCultureIgnoreCase = <span class="number">3</span>,</span><br><span class="line">Ordinal = <span class="number">4</span>, <span class="comment">// 忽略语言文化</span></span><br><span class="line">OrdinalIgnoreCase = <span class="number">5</span>, <span class="comment">// 忽略语言文化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareOptions枚举类型</span></span><br><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CompareOptions &#123;</span><br><span class="line">None = <span class="number">0</span>,</span><br><span class="line">IgnoreCase = <span class="number">1</span>,</span><br><span class="line">IgnoreNonSpace = <span class="number">2</span>,</span><br><span class="line">IgnoreSymbols = <span class="number">4</span>,</span><br><span class="line">IgnoreKanaType = <span class="number">8</span>,</span><br><span class="line">Ordinal = <span class="number">0x40000000</span>, <span class="comment">// 忽略指定语言文化</span></span><br><span class="line">OrdinalIgnoreCase = <span class="number">0x10000000</span>, <span class="comment">// 忽略指定语言文化</span></span><br><span class="line">StringSort = <span class="number">0x20000000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果进行一些url、值得比较，不需要语言文化，那就选择忽略语言文化。</p><p>下面讲一下语言文化，.NET把语言文化放在<code>System.Globalization.CultureInfo类</code>表示一个”语言/国家“对，例如”en-US“。</p><p>在CLR中，每个线程都关联了2个特殊属性，每个属性都引用一个<font color="red">CultureInfo对象</font>。它们是：</p><ul><li>CurrentUICulture属性：在GUI或者Web窗体等等程序中，UI元素的显示资源用的就是它。</li><li>CurrentCulture属性：不适合CurrentUICulture属性的场合就用它，例如数字和日期格式化、字符串比较。</li></ul><p>在许多计算机上，线程的<font color="red">CurrentUICulture属性</font> 与 <font color="red">CurrentCulture属性</font>都被设为同一个CultureInfo对象。但是也可以不同。</p><p>下面根据语言文化进行比较的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;Strasse&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;Straβe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eq1 = false</span></span><br><span class="line"><span class="built_in">bool</span> eq1 = String.Compare(s1, s2, StringComparison.Ordinal) == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// StringComparison 一个枚举值，用于指定比较中要使用的规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eq2 = true</span></span><br><span class="line">CultureInfo ci = <span class="keyword">new</span> CultureInfo(<span class="string">&quot;de-DE&quot;</span>);</span><br><span class="line"><span class="built_in">bool</span> eq2 = String.Compare(s1, s2, <span class="literal">true</span>, ci) == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Compare(String, String, Boolean, CultureInfo)</span></span><br><span class="line"><span class="comment">// Boolean 是否在比较过程中忽略大小写</span></span><br><span class="line"><span class="comment">// CultureInfo 一个对象，提供区域性特定的比较信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高效率构造字符串StringBuilder类型"><a href="#高效率构造字符串StringBuilder类型" class="headerlink" title="高效率构造字符串StringBuilder类型"></a>高效率构造字符串StringBuilder类型</h3><p><strong>StringBuilder是什么</strong></p><p>StringBuilder代表可变(mutable)字符串。也就是说StringBuilder的大多数成员都能更改字符数组的内容，同时不会造成在托管堆上分配新对象。<br>只有以下2种情况会分配新对象：</p><ul><li>动态构造字符串，其长度超过了设置的“容量”。</li><li>调用StringBuilder的ToString方法。</li></ul><p><strong>StringBuilder是怎么做的</strong></p><ol><li><p>StringBuilder对象包含一个字段，这个字段引用了由Char结构构成的数组。可以利用StringBuilder的各个成员来操纵该字符数组，高效缩短字符串或更改字符串中的字符，而不是和String一样只能新建。</p></li><li><p>如果字符串变大，超过了事先分配的字符数组大小，StringBuilder会自动分配一个新的、更大的数组，复制字符并开始使用新数组。前一个数组被GC。</p></li><li><p>使用ToString转换为String对象。</p></li></ol><p><strong>StringBuilder构造概念</strong></p><p>StringBuilder就是个普通的类，不会把他当作基元类型。</p><p>下面介绍一些StringBuilder的核心元素：</p><p>1.<strong>最大容量</strong>：一个Int32值，指定了能放到字符串中的最大字符数。默认值是Int.MaxValue（约20亿）。<br>创建完之后，这个最大容量就不能修改了。</p><p>2.<strong>容量</strong>：一个Int32值，指定了由StringBuilder维护的字符数组的长度。默认为16，可以在构造时自己设置。<br><font color="red">向字符数组追加字符时，StringBuilder会检测数组会不会超过设定的容量。如果会，StringBuilder会自动倍增容量字段，用新容量来分配新数组，并将原始数组的字符复制到新数组中。随后，原始数组可以被GC。</font>尽量避免分配不合适导致的动态扩容，会影响性能。</p><p>3.<strong>字符数组</strong>：一个由Char结构构成的数组，负责维护“字符串”的字符内容。字符数可用StringBuilder的Length属性来获取，它总是 &lt;= “容量”、“最大容量”。</p><p>4.<strong>构造器</strong>：可以在构造StringBuilder时传递一个String来初始化字符数组。不传递字符串，数组刚开始就不会包含任何字符，Length=0。</p><p><strong>StringBuilder构造实际</strong></p><p>上面介绍了核心概念，下面讲一下StringBuilder核心、常用的成员：</p><table><thead><tr><th>成员名称</th><th>成员类型</th><th>说明</th></tr></thead><tbody><tr><td>MaxCapacity</td><td>只读属性</td><td>返回字符数组能容纳的最大字符数(最大容量)。</td></tr><tr><td>Capacity</td><td>可读可写属性</td><td>字符数组的长度(容量)。比MaxCapacity大会抛错。</td></tr><tr><td>EnsureCapacity(Int32)</td><td>方法</td><td>如果传给方法的值大于当前容量，当前容量就会自动增大；如果小于当前容量，就不做。</td></tr><tr><td>Length</td><td>可读可写属性</td><td>存储着的字符数组的实际长度(使用)。设置为0就会重置StringBuilder为空字符串。</td></tr><tr><td>Chars[]</td><td>可读可写索引器属性</td><td>用于操作指定索引位置的字符。</td></tr><tr><td>ToString</td><td>方法</td><td>返回代表StringBuilder的字符数组的一个String。</td></tr><tr><td>Equals</td><td>方法</td><td>只有2个StringBuilder对象具有相同的 最大容量、字符数组容量和字符内容才返回true。</td></tr><tr><td>CopyTo</td><td>方法</td><td>将StringBuilder的字符内容的一个子集复制到一个Char数组中。</td></tr><tr><td>Append、Insert等插入方法</td><td>方法</td><td>向字符数组中插入一个对象。如由必要，数组会进行扩容。</td></tr></tbody></table><p>个人觉得，主要就是看MaxCapacity、Capacity、Length这三个容量相关的核心属性，以及EnsureCapacity(Int32)方法的机制。</p><h3 id="ToString方法"><a href="#ToString方法" class="headerlink" title="ToString方法"></a>ToString方法</h3><p><strong>默认实现</strong></p><p>面对对象理念下，所有类型都有责任提供转换为字符串表示的方法。</p><p>System.Object提供了一个public、virtual的ToString默认实现，它只返回对象所属类型的全名。</p><p>C#的许多核心类型（Byte、int、uint、double等）都进行了ToString方法重写。</p><p><strong>IFormattable接口</strong></p><p>用于指定 格式(比如x进制、日期) 和 语言文化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFormattable</span> &#123;</span><br><span class="line"><span class="function">String <span class="title">ToString</span>(<span class="params">String format, System.IFormatProvider formatProvider</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有基元类型、所有枚举类型都定义或自动实现了IFormattable接口。</p><p>介绍下这个签名的2个参数，</p><ol><li>format，告诉方法如何格式化对象。比如DateTime类型支持用“d”表示短日期、“Y”表示年等。</li><li>formatProvider，提供具体文化信息。可以传null，默认调用线程关联的语言文化信息。System.IFormatProvider实现的类型不多，CultureInfo算一个。</li></ol><p><strong>String.Format方法</strong></p><p>就是常用的format方法，在内部Format方法会调用每个对象的ToString方法来获取对象的字符串表示，再依次拼接。<br>StringBuilder.AppendFormat方法也差不多。</p><p>当然，每个对象都要调用ToString意味着他们都要使用他们的常规格式和调用线程的语言文化来格式化，但是你可以像下面这样指定：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = String.Format(<span class="string">&quot;On &#123;0:D&#125;,&#123;1&#125; is &#123;2:E&#125; years old.&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> DateTime(<span class="number">2012</span>,<span class="number">4</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">35</span>,<span class="number">5</span>), <span class="string">&quot;Aidan&quot;</span>, <span class="number">9</span>);</span><br><span class="line">Console.WriteLine(e);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// On SUnday,April 22,2012,Aidan is 9.000000E+000 years old.</span></span><br></pre></td></tr></table></figure><p><strong>定制格式化器</strong></p><p>可以通过实现<code>ICustomFormatter接口</code>和<code>IFormatProvider接口</code>实现自定义StringBuilder的AppendFormat方法的行为。它将不再为每个对象调用ToString，而是调用定制的方法。</p><p>具体看书，提供一下调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Main &#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.AppendFormat(<span class="keyword">new</span> BoldInt32s(), <span class="string">&quot;&#123;0&#125; &#123;1&#125; &#123;2:M&#125;&quot;</span>, <span class="string">&quot;Jeff&quot;</span>, <span class="number">123</span>, DateTime.Now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BoldInt32s</span> : <span class="title">IFormatProvider</span>, <span class="title">ICustomFormatter</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析字符串获取对象：Parse</strong></p><p>能解析字符串的任何类型都提供了公共静态方法Parse。它们如下形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String解析为Int32</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Parse</span>(<span class="params">String s, NumberStyle style, IFormatProvider provider</span>)；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 列举几个解析方法</span></span></span><br><span class="line"><span class="function">NumberStyle</span> &#123;</span><br><span class="line">None, <span class="comment">// 无特殊</span></span><br><span class="line">AllowLeadingWhite, <span class="comment">// 解析时跳过最靠前的空行</span></span><br><span class="line">HexNumber, <span class="comment">// 解析十六进制数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编码解码：字符和字节的互转"><a href="#编码解码：字符和字节的互转" class="headerlink" title="编码解码：字符和字节的互转"></a>编码解码：字符和字节的互转</h3><p><strong>不同的字节码</strong></p><p>只说CLR常见的2个：</p><ul><li>UTF-16：每个16位字符编码成2个字节，又称作“Unicode编码”。</li><li>UTF-8：将部分字符编码成1 or 2 or 3 or 4个字节。值在0x0080下用1个字节，适合美国语言；值在0x0080~0x07FF用2个字节，适合中东语言；值在0x07FF以用3个字节，适合东亚语言；代理项对(surrogate pair)表示4个字节。</li></ul><p>其他的诸如UTF-7、UTF-32、ASCII之类的就不展开了。</p><p><strong>编码解码</strong></p><p>用<code>System.IO.BinaryWriter 或者 System.IO.StreamWriter类型</code>将字符串发送给文件或网络流时，通常要进行编码；<br>用<code>System.IO.BinaryReader 或者 System.IO.StreamReader类型</code>从文件或网络流读取字符串时，通常要进行解码。<br>不显式指定一种编码方案，所有这些类型都默认使用UTF-8。</p><p><strong>Sytem.Text.Encoding</strong></p><p>要编码或解码一组字符时，应获取从Sytem.Text.Encoding派生的一个类的实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;Hi there.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.应获取从Sytem.Text.Encoding派生的一个类的实例</span></span><br><span class="line">Encoding encodingUTF8 = Encoding.UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将字符串 编码 成字节数组</span></span><br><span class="line">Byte[] encodedBytes = encodingUTF8.GetBytes(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将字节数组 解码 回字符串</span></span><br><span class="line"><span class="built_in">string</span> decodedString = encodingUTF8.GetString(encodedBytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出看结果</span></span><br><span class="line">Console.WriteLine(encodedBytes);</span><br><span class="line">Console.WriteLine(decodedString);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 48-69-20-74-68-65-72-65-2E</span></span><br><span class="line"><span class="comment">// Hi there.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节流</strong></p><p>字节流通常以<strong>数据块(data chunk)</strong>的形式传输。</p><p>不能以常规方法解码，假设要通过<code>System.Net.Sockets.NetworkStream</code>来读取UTF-16字符串，可能从流中先读取5个字节，再读取7个字节。如果使用UTF-16的Encoding来解码，那么第一次GetString就只能正确解码2个字，第二次GetString就只能正确解码3个字，那样数据就损坏了。</p><p>字节块正确的解码方法是：</p><ol><li>获取一个Encoding派生对象，再调用其GetDecoder方法</li><li>方法返回对一个新构造对象的引用，该对象的类型从System.Text.Decoder类派生。</li><li>执行Decoder对象的<strong>GetChars</strong>或者<strong>GetCharCount</strong>方法：它会尽可能多地解码字节数组，假如字节数组包含的字节不足以完成一个字符，剩余的字节会保存到Decoder对象内部。下次再调用其中一个方法时，Decoder对象会利用之前剩余的字节再加上传给它地新字节数组进行解码。</li></ol><p>上面提到的，<br>GetChars：将一个字节序列解码为一组字符。<br>GetCharCount：计算对一个字节序列进行解码所产生的字符数，不实际进行解码。</p><h3 id="安全字符串SecureString"><a href="#安全字符串SecureString" class="headerlink" title="安全字符串SecureString"></a>安全字符串SecureString</h3><p><strong>System.Security.SecureString</strong></p><p>就是说String对象可能在GC之前，被非托管代码操作或者执行unsafe方法，导致String对象的使用内存无法被重用，导致String一直在进程内存里逗留着。万一这个String式机密数据，那就会泄露。</p><p>为了解决上述问题，推出了<code>System.String,System.Security.SecureString类型</code>。</p><p>SecureString类型的字符串是加密的。会为它分配一块非托管内存块，为了逃避GC。<br>它也有AppendChar、InsertAt、RemoveAt这几个方法，便于增删改查，但是它们都是通过解密后处理再加密实现的。</p><p>访问它的话，需要用unsafe方法，因为要访问到非托管内存。</p><h1 id="大章15：枚举类型和位标志"><a href="#大章15：枚举类型和位标志" class="headerlink" title="大章15：枚举类型和位标志"></a><center>大章15：枚举类型和位标志</center></h1><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p><strong>枚举类型(enumerated type)是值类型</strong></p><p>枚举类型都从System.Enum派生，System.Enum从System.ValueType派生，所以枚举类型是值类型，会有装箱拆箱发生，但是不能定义定义任何方法、属性或事件。</p><p>另外，枚举类型也是基元类型。</p><p><strong>枚举类型内部构造</strong></p><p>比如我们这么定义一个枚举类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Color &#123;</span><br><span class="line">White,</span><br><span class="line">Red,</span><br><span class="line">Blue,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#编译器会这么看待它（不是真的生成这样的代码，不过效果相同）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Color : System.Enum &#123;</span><br><span class="line"><span class="comment">// 内部的枚举就是一些public常量字段，可被反射调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> Color White = (Color)<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> Color Red = (Color)<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> Color Blue = (Color)<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共实例字段，无法通过代码引用引用，包含Color变量的值</span></span><br><span class="line"><span class="keyword">public</span> Int32 value__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举类型的值</strong></p><p>C#枚举类型的值默认是int类型的。它还可以是byte、sbyte、short、ushort、int、uint、long、ulong。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值定义成byte类型</span></span><br><span class="line"><span class="built_in">enum</span> Color : <span class="built_in">byte</span> &#123;</span><br><span class="line">White,</span><br><span class="line">Red,</span><br><span class="line">Blue,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过Enum类型的静态方法GetUnderlyingType方法获取到基础类型</span></span><br><span class="line">Console.WriteLine(Enum.GetUnderlyingType(<span class="keyword">typeof</span>(Color)));</span><br><span class="line"><span class="comment">// output: System.Byte</span></span><br></pre></td></tr></table></figure><p><strong>枚举类型常用方法</strong></p><p>简单说下<strong>枚举类型名称&lt;=&gt;值</strong>之间得转换。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> nameArr = (Color[])Enum.GetValues(<span class="keyword">typeof</span>(Color));</span><br><span class="line"><span class="comment">// String =&gt; 枚举类型名称</span></span><br><span class="line"><span class="keyword">var</span> someName = (Color)Enum.Parse(<span class="keyword">typeof</span>(Color), <span class="string">&quot;White&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型名称 =&gt; 值</span></span><br><span class="line"><span class="keyword">var</span> val1 = (<span class="built_in">int</span>)nameArr[<span class="number">0</span>];<span class="comment">// val1 = 1</span></span><br><span class="line"><span class="keyword">var</span> val2 = (<span class="built_in">int</span>)someName;<span class="comment">// val2 = 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//枚举类型名称</span></span><br><span class="line">White = <span class="number">1</span>,</span><br><span class="line">Red = <span class="number">2</span>,</span><br><span class="line">Blue = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位标志"><a href="#位标志" class="headerlink" title="位标志"></a>位标志</h3><p><a href="#jump">注：如果前面的理解了直接从“位运算”看起。</a></p><p><strong>什么是位标志(bit flag)</strong></p><p>比如要解决这么一个问题：</p><p>假如我从早上到晚上一天有12节课，我希望用一串数来记录每节课我有没有去。</p><p>首先会想到定制规则，1是去0是不去：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211209103726.png"></p><p>会变成如上一串数字，解决了问题，但这不就是一个二进制数吗？转换成十进制数902。</p><p>这串数字就是一种位标志。</p><p>下面也会提到“0x0001”这样的位标志，“0x”指的是16进制，“0001”是16进制数。</p><p><strong>什么是位运算</strong></p><p>现在，我有新的需求：我发现1、2节课漏记了去上课了，需要补上。</p><p>那只需要用 <code>001110000110 | 110000000000</code> 得运算结果就完成了，转换成十进制它看上去就是 <strong>“902 | 3072”</strong>，计算得出的结果更新就行了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">902</span> | <span class="number">3072</span>;</span><br><span class="line">Console.WriteLine(Convert.ToString(x,<span class="number">2</span>));<span class="comment">// x = 3974(10进制) 输出为 111110000110(2进制)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我想检查1、2节课我去上课了没，那也很容易：</p><p>用 <code>001110000110 &amp; 110000000000</code> ，也就是 <strong>“902 &amp; 3072”</strong> 判断计算得到十进制结果的是不是0，如果是0那就意味着并不重复，可以去。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">902</span> &amp; <span class="number">3072</span>;</span><br><span class="line">Console.WriteLine(x);<span class="comment">// x = 0(10进制)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump"><strong>C#位运算</strong></span></p><p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p><p>A = 0011 1100<br>B = 0000 1101</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td align="left">(A | B) 将得到 61，即为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td align="left">~</td><td align="left">按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><p><strong>C#位标记：[Flags]特性</strong></p><p>C#的位标记离不开[Flags]特性，<br>这个特性的作用就是<code>someEnum.ToString()</code>是”ReadOnly, Hidden”这个枚举名称的字符串。<br>如果没有[Flags]特性，就会为具体的数值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>] <span class="comment">//增加Flags标记便可申明一个位标记</span></span><br><span class="line"><span class="built_in">enum</span> Action</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Walk = <span class="number">0x0001</span>,</span><br><span class="line">    Run = <span class="number">0x0002</span>,</span><br><span class="line">    Speak = <span class="number">0x0004</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位标记的实例应用</span></span><br><span class="line"><span class="function">vod <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//申明一个行为</span></span><br><span class="line"><span class="keyword">var</span> action = Action.None;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询目前拥有行为</span></span><br><span class="line">Console.WriteLine(action.ToString()); <span class="comment">// output:None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加行走和奔跑行为</span></span><br><span class="line">action = action | Action.Walk | Action.Run;</span><br><span class="line">Console.WriteLine(action.ToString()); <span class="comment">// output:Walk,Run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数值转换为标志字符串</strong></p><p>存在<strong>[Flags]特性</strong>时<code>枚举实例.ToString()</code>的工作流程：</p><ol><li>获取枚举类型定义的数值集，并按降序排列。</li><li>每个数值将会与枚举实例的值进行“按位与&amp;”计算，假如结果等于该数值，与该数值关联的字符串便会追加到输入字符串中，对应的位会被认为考虑过了(设置为0)。反复到每一个数值都计算完。</li><li>如果2中计算出的数值结果仍然不为0，说明枚举实例的一些“1”状态的位，在枚举类里压根没定义过，那么ToString<font color="brown">直接返回枚举实例原始值的字符串</font>。</li><li>如果2中计算出的数值结果为0，那么再检查枚举实例原始值：</li><li>如果枚举实例原始值不为0，那么ToString<font color="brown">返回符号名称之间以逗号分隔的字符串</font>。</li><li>如果枚举实例原始值为0，那么再检查枚举类型定义的符号中有没有值为0的，有的话ToString<font color="brown">返回值为0的符号名称</font>；没有的话ToString<font color="brown">返回值“0”</font>。</li></ol><p>为什么能这么做？因为确保过枚举类型中定义的每一个枚举的值，都只代表一位的开关。就是<code>0001</code>、<code>0010</code>、<code>0100</code>这样下去，转换成十进制的话，全是2的整数次方。</p><p>但是也有唯一一个例外不是2的整数次方，比如可以添加一个枚举类<code>Action.All = Action.Walk | Action.Run | Action.Speak</code>，它的值是<code>0x0007</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="built_in">enum</span> Action</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Walk = <span class="number">0x0001</span>,</span><br><span class="line">    Run = <span class="number">0x0002</span>,</span><br><span class="line">    Speak = <span class="number">0x0004</span>,</span><br><span class="line">    All = <span class="number">0x0007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标志字符串转换为数值</strong></p><p>将逗号分割的符号字符串转换为数值，这是通过Enum的静态方法Parse和TryParse来实现的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Action a = (Action) Enum.Parse(<span class="keyword">typeof</span>(Action),<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Console.WriteLine(a);</span><br><span class="line"><span class="comment">// output: Walk , Run</span></span><br><span class="line"><span class="comment">// &quot;3&quot;对应16位的&quot;0x0003&quot;，转换二进制是&quot;0000000000000011&quot;，所以是Walk、Run</span></span><br></pre></td></tr></table></figure><p>Enum的静态方法Parse和TryParse的工作流程：</p><ol><li>删除字符串头尾所有的空白字符。</li><li>如果字符串第一个字符是数字、+、-，该字符串会被认为是一个数字，方法返回会一个枚举类型实例，数值为字符串转换后的数值。</li><li>将2得到的数值转换为2进制，再将每一位的”1”都单独分割成一个2进制数，用<code>,</code>分隔，比如0110 =&gt; 0100,0010。</li><li>把3中得到的每一个数都去枚举类型中匹配，如果有匹配不到的就<font color="brown">抛错ArgumentExpection</font>；如果匹配的到就与动态结果进行“按位或|”计算（动态结果初始值是0），再查找下一个符号。</li><li>查找并找到所有标识后，<font color="brown">以Object形式返回这个动态结果值所表示的枚举类型名称们</font>，格式是“名称1 , 名称2”。</li></ol><p>上面的3-4我是猜的，因为书里写的token我不明白，搜也没搜到。<br>但是像这么做的确可以实现，4的目的，是记录已经找到的枚举类型名称罢了。</p><p><strong>向枚举类型添加方法</strong></p><p>枚举类型中不能定义方法，但是可以通过<strong>拓展方法</strong>来实现模拟向枚举类型添加方法。</p><h1 id="大章16：数组"><a href="#大章16：数组" class="headerlink" title="大章16：数组"></a><center>大章16：数组</center></h1><h3 id="数组是什么"><a href="#数组是什么" class="headerlink" title="数组是什么"></a>数组是什么</h3><p><strong>数组 is a Array</strong></p><p>所有数组类型都隐式从<strong>System.Array抽象类</strong>派生，System.Array又从Object派生，所以数组都是<strong>引用类型</strong>。</p><p>所有数组同时隐式实现IEnumerable、ICollection、IList接口。</p><p><strong>多维数组 ≠ 交错数组</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 1.申明、new构造器不同</span></span><br><span class="line"><span class="built_in">int</span>[,] test1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span>[][] test2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>][];<span class="comment">// 不可指定第二个[]内的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.交错数组存着的每个数组可以不等长，多维数组的每个数组必须等长</span></span><br><span class="line"><span class="comment">// 且交错数组存着的每个数组必须new</span></span><br><span class="line">test2[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">test2[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.存储结构不同，赋值写法不同</span></span><br><span class="line">test1[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">test2[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><p><strong>new一个数组⭐</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Int32[] myIntegers = new Int32[100];// 包含100个Int32的数组</span><br><span class="line"></span><br><span class="line">Control[] myControls = new Control[50];// 包含50个Control引用的数组</span><br></pre></td></tr></table></figure><p>像上面这样new，</p><ol><li>首先，数组是引用类型，所以数组都是在堆里的，分配内存也是在堆里分配。</li><li>其次，数组单个元素的类型，<br>如果是值类型比如上面的Int32，就会在托管堆上分配100个未装箱Int32所需的内存块，并给每个Int32实例都附上default值0；<br>如果是引用类型比如上面的Control，就会在托管堆上分配50个Control引用的内存块，并给每个引用都附上null。</li><li>最后，给一个类型对象指针、一个同步块索引和一些overhead字段(开销字段)分配内存。</li><li>返回上面分配完的内存块地址，保存到array变量中。</li></ol><p>堆上的图大概可以这么理解（这里给myControls数组提前new了几个实例）：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211209155727.png"></p><p><strong>初始化数组元素 语法糖</strong></p><p>C#提供了语法糖方便初始化数组，由编译器帮你推断最佳类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建+初始化数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span>[] &#123;<span class="string">&quot;Sim&quot;</span>, <span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Grant&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这么写会编译不过：error 找不到隐式类型数组的最佳类型</span></span><br><span class="line"><span class="keyword">var</span> namesError!!!! = <span class="keyword">new</span>[] &#123;<span class="string">&quot;Sim&quot;</span>, <span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Grant&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建+初始化匿名数组</span></span><br><span class="line"><span class="keyword">var</span> kids = <span class="keyword">new</span>[] &#123; <span class="keyword">new</span> &#123;Name=<span class="string">&quot;Aidan&quot;</span>&#125;, <span class="keyword">new</span> &#123;Name=<span class="string">&quot;Grant&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p><strong>数组转型</strong></p><p>两种方法：</p><p>1.显式或隐式转型：要求数组维数相同、且必须存在从元素源类型到目标类型的显式或隐式转换。所有的值类型都不允许用这个方式转。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileStream[,] fsArr = <span class="keyword">new</span> FileStream[<span class="number">5</span>,<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 隐式、显式 可以</span></span><br><span class="line">Object[,] o2Arr_1 = fsArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型不能 隐式、显式转</span></span><br><span class="line"><span class="built_in">int</span>[,] intArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>,<span class="number">10</span>];</span><br><span class="line">Object[,] o2Arr_2 = intArr;<span class="comment">// 编译无法通过!</span></span><br></pre></td></tr></table></figure><p>2.Array.Copy(fromArr, toArr, length)：浅拷贝，可以拆箱装箱所以能接受值类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line">Object[] objArr = <span class="keyword">new</span> Object[intArr.Length];</span><br><span class="line"><span class="comment">// 值类型数组 装箱转换到 引用类型数组</span></span><br><span class="line">Array.Copy(intArr, objArr, intArr.Length);</span><br></pre></td></tr></table></figure><h3 id="所有数组都会偷偷…"><a href="#所有数组都会偷偷…" class="headerlink" title="所有数组都会偷偷…"></a>所有数组都会偷偷…</h3><p><strong>所有数组都隐式派生自System.Array</strong></p><p>随意声明一个数组，它都隐式派生自System.Array类型，</p><p>System.Array类型定义了很多常用的实例方法、静态方法和属性，比如Clone、CopyTo、GetLength、IndexOf等。</p><p><strong>所有数组都隐式实现IEnumerable、ICollection、IList接口</strong></p><p>System.Array类型也实现了IEnumerable、ICollection、IList这几个接口，但是它是把他们都当作Object类型来处理的。</p><p>全当作Object类来处理会很不方便，影响性能，甚至可能患有类型不安全，所以数组重新实现了这几个接口，用泛型：</p><p>当你新创建 一维数组 时，会将其类型传入并实现<code>IEnumerable&lt;T&gt;、ICollection&lt;T&gt;、IList&lt;T&gt;</code>这几个泛型接口。同时为会传入类型的父类也实现这3个接口，直到Array的默认实现。可以看结构展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">FileStream[] fsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码会自动实现大量的IEnumerable&lt;T&gt;、ICollection&lt;T&gt;、IList&lt;T&gt;接口，结构如下：</span></span><br><span class="line"><span class="function">Object</span></span><br><span class="line"><span class="function"><span class="title">Arrary</span> (<span class="params">非泛型IEnumerable, ICollection, IList</span>)</span></span><br><span class="line"><span class="function">Object[] (<span class="params">IEnumerable&lt;Object&gt;, ICollection&lt;Object&gt;, IList&lt;Object&gt;</span>)</span></span><br><span class="line"><span class="function">String[] (<span class="params">IEnumerable&lt;String&gt;, ICollection&lt;String&gt;, IList&lt;String&gt;</span>)</span></span><br><span class="line"><span class="function">Stream[] (<span class="params">IEnumerable&lt;Stream&gt;, ICollection&lt;Stream&gt;, IList&lt;Stream&gt;</span>)</span></span><br><span class="line"><span class="function">FileStream[] (<span class="params">IEnumerable&lt;FileStream&gt;, ICollection&lt;FileStream&gt;, IList&lt;FileStream&gt;</span>)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">.</span></span><br><span class="line"><span class="function">.(<span class="params">其他引用类型数组</span>)</span></span><br><span class="line"><span class="function">.</span></span><br></pre></td></tr></table></figure><p>另外，如果是值类型数组，就只会为值类型数组本身实现这3个泛型接口，其父类不会再自动实现了，和引用类型数组是不一样的。</p><h3 id="数组的传递和返回"><a href="#数组的传递和返回" class="headerlink" title="数组的传递和返回"></a>数组的传递和返回</h3><p>要理清楚，数组是引用类型，数组的元素类型可能是堆上分配的值/引用类型。</p><p>所以，数组作为参数，传的一定是地址。<br>但是数组元素作为参数，传的可能是地址可能是逐位复制的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">int</span>[] b = a;<span class="comment">// 传数组</span></span><br><span class="line"><span class="built_in">int</span>[] c = <span class="keyword">new</span> <span class="built_in">int</span>[a.Length];</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">333</span>;</span><br><span class="line">Array.Copy(a, c, a.Length);<span class="comment">//传元素</span></span><br><span class="line">c[<span class="number">2</span>] = <span class="number">444</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行完打印, a[2]=333,b[2]=333,c[2]=444</span></span><br></pre></td></tr></table></figure><h3 id="创建下限非0的数组"><a href="#创建下限非0的数组" class="headerlink" title="创建下限非0的数组"></a>创建下限非0的数组</h3><p>用静态方法 Array.CreatInstance(Type type, int[] lengths, int[] lowerBounds) 来实现。</p><p>该方法为数组分配内存，将参数信息保存到数组的内存块开销(overhead)部分。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下实现了创建二维数组：Decimal[2005...2009][1...4]</span></span><br><span class="line"><span class="built_in">int</span>[] lowerBounds = &#123;<span class="number">2005</span>, <span class="number">1</span>&#125;;<span class="comment">// 指定下标下限</span></span><br><span class="line"><span class="built_in">int</span>[] lengths = &#123;<span class="number">5</span>, <span class="number">4</span>&#125;;<span class="comment">// 指定数组长度</span></span><br><span class="line">Decimal[,] decimalArr = (Decimal[,]) Array.CreatInstance(<span class="keyword">typeof</span>(Decimal), lengths, lowerBounds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下用于获取数组x维下标的上限下限值</span></span><br><span class="line"><span class="built_in">int</span> firstYear = decimalArr.GetLowerBound(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">int</span> lastYear = decimalArr.GetUpperBound(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">int</span> firstNum = decimalArr.GetLowerBound(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">int</span> lastNum = decimalArr.GetUpperBound(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="数组循环的内部检查"><a href="#数组循环的内部检查" class="headerlink" title="数组循环的内部检查"></a>数组循环的内部检查</h3><p><strong>数组循环</strong></p><p>用例子解释，执行以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> index=<span class="number">0</span>; index&lt;a.Length; index++)&#123;</span><br><span class="line"><span class="comment">// 对a[index]操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>a.Length检查：只做一次</strong></p><p>对于上述循环操作，只会执行一次a.Length属性获取到数组的实际长度，再将其放到一个临时变量中，后续的循环迭代检查都是用这个临时变量了。</p><p><strong>index检查：为什么0基一维更快？</strong></p><p>对于索引值index，JIT也会进行检查。</p><p>JIT编译器知道for循环要访问0到Length-1的数组元素，所以它会生成代码在运行时测试所有数组元素的访问都在数组有效范围内：<strong>检查是否 <code>(0 &gt;= Get.LowerBound(0)) &amp;&amp; ((Length-1) &gt;= a.GetUpperBound(0))</code></strong>，这个检查在循环之前发生。如果在数组有效范围内，JIT不会再循环内部生成代码验证每一次数组访问是否有效。</p><p>但是对于非0基一维数组（多维数组和非0基一维数组）的循环迭代，JIT就没法这么信任，它必须在循环内部进行越界检查，并且它还需要从指定索引中减去数组下限，所以很影响性能。</p><p>对于这种情况，推荐用0基一维数组构成的多维数组，也就是交错数组<code>int[][]</code>代替矩形数组。</p><p><strong>unsafe访问数组：关闭检查</strong></p><p>使用unsafe关键字，可以关闭索引上下限检查，但是要慎用：它直接访问内存，越界不会抛出异常，但是会损坏内存中的数据，破坏类型安全性制造安全漏洞。</p><p>写法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> my_length = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">SafeArrAccess</span>(<span class="params"><span class="built_in">int</span>[,] a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; my_length; x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; my_length; y++)&#123;</span><br><span class="line">sum += a[x,y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;转换为unsafe版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">unsafe</span> <span class="built_in">int</span> <span class="title">SafeArrAccess</span>(<span class="params"><span class="built_in">int</span>[,] a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">fixed</span> (<span class="built_in">int</span>* pi = a)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; my_length; x++)&#123;</span><br><span class="line"><span class="built_in">int</span> baseOfDim = x * my_length;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; my_length; y++)&#123;</span><br><span class="line">sum += pi[baseOfDim + y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不安全的数组访问和固定大小的数组"><a href="#不安全的数组访问和固定大小的数组" class="headerlink" title="不安全的数组访问和固定大小的数组"></a>不安全的数组访问和固定大小的数组</h3><p><strong>unsafe数组</strong></p><p>unsafe数组访问非常强大，它允许访问：</p><ul><li>托管堆上的数组中的元素（上面的就是）。</li><li>非托管堆上的数组中的元素（比如用Marshal.SecureStringToCoTaskMemUnicode方法返回一个数组，并用不安全的数组访问）。</li><li>线程栈上的数组中的元素，利用stackalloc，下面介绍。</li></ul><p><strong>线程栈上的数组</strong></p><p>通常结构体内写数组也只是持有数组的引用，但是可以如下将数组嵌入结构实现在栈上分配数组的内存。</p><p>在结构体中嵌入数组需要满足以下条件：</p><ul><li>类型必须是结构（值类型），不能在类（引用类型）中嵌入固定大小缓冲区字段（栈上数组）。</li><li>字段或其定义结构必须用unsafe关键字标记。</li><li>数组字段必须用fixed关键字标记。</li><li>数组必须是一维0基数组。</li><li>数组的元素类型必须是：Boolen，Char，SByte，Byte，Int16，Int32，Int64，UInt16，UInt32，UInt64，Single，Double。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">StackallocDemo();</span><br><span class="line">InlineArrayDemo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StackallocDemo</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> width = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">char</span>* pc = <span class="keyword">stackalloc</span> <span class="built_in">char</span>[width];<span class="comment">// 栈上分配数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;Jeffrey Richter&quot;</span>;<span class="comment">// 15个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">&#123;</span><br><span class="line">pc[width - i - <span class="number">1</span>] = (i &lt; s.Length) ? s[i] : <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="keyword">new</span> <span class="built_in">string</span>(pc, <span class="number">0</span>, width));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InlineArrayDemo</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line">CharArray ca;<span class="comment">// 栈上分配数组</span></span><br><span class="line"><span class="built_in">int</span> widthInBytes = <span class="keyword">sizeof</span>(CharArray);</span><br><span class="line"><span class="built_in">int</span> width = widthInBytes / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;Jeffrey Richter&quot;</span>;<span class="comment">// 15个字符 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">&#123;</span><br><span class="line">ca.Characters[width - i - <span class="number">1</span>] = (i &lt; s.Length) ? s[i] : <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="keyword">new</span> <span class="built_in">string</span>(ca.Characters, <span class="number">0</span>, width));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">//.....rethciR yerffeJ</span></span><br><span class="line"><span class="comment">//.....rethciR yerffeJ</span></span><br></pre></td></tr></table></figure><h1 id="大章17：委托"><a href="#大章17：委托" class="headerlink" title="大章17：委托"></a><center>大章17：委托</center></h1><h3 id="初识委托"><a href="#初识委托" class="headerlink" title="初识委托"></a>初识委托</h3><p><strong>委托是什么？</strong></p><p>得先提到<strong>回调函数</strong>，回调函数是一个非常重要的机制，在C/C++中通过qsort函数获取指向一个回调函数的指针，而在.NET中，使用委托来实现回调函数。</p><p>委托比C/C++的回调函数强在它能确保<strong>类型安全</strong>、且提供更多更强大的功能。</p><p><strong>如何使用委托</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.声明委托，它的实例引用一个方法。该方法签名：获取一个int参数，返回void</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.实例方法可以委托</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method_A</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.静态方法也可以委托</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method_B</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用委托</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// a.声明委托，其实给null后可以直接 += method()，也不会报错空引用，可能是编译器重写了委托的+=</span></span><br><span class="line">    FeedBack delegateList = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// b.给与委托变量一个实例</span></span><br><span class="line">delegateList = <span class="keyword">new</span> FeedBack(Method_A);</span><br><span class="line">    <span class="comment">// c.下面3个行为结果相同</span></span><br><span class="line">delegateList += Method_B;</span><br><span class="line">delegateList += <span class="keyword">new</span> FeedBack(Method_B);<span class="comment">// FeedBack是委托的方法包装器(wapper)</span></span><br><span class="line">delegateList = (FeedBack)Delegate.Combine(delegateList, <span class="keyword">new</span> FeedBack(Method_B));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="委托类型揭秘"><a href="#委托类型揭秘" class="headerlink" title="委托类型揭秘"></a>委托类型揭秘</h3><p><strong>委托就是类</strong></p><p>声明一个委托，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Feedback</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br></pre></td></tr></table></figure><p>这一行代码，C#编译器会这么定义一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Feedback</span> : <span class="title">System.MulticastDelegate</span> &#123;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Feedback</span>(<span class="params">Object @<span class="built_in">object</span>, IntPtr method</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IAsyncResult <span class="title">BeginInvoke</span>(<span class="params"><span class="built_in">int</span> val, AsyncCallback callback, Object @<span class="built_in">object</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndInvoke</span>(<span class="params">IAsyncResult result</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可见委托其实就是个类，所以委托能定义到类中，也能定义到类外。只要能定义类的地方就能定义委托，可见性随声明委托时用的可见性一样。</li><li>所有的委托都继承自System.MulticastDelegate。</li></ol><p><strong>委托构造器</strong></p><p>上面已经知道委托都继承自System.MulticastDelegate类，那么要构造一个委托肯定离不开这个类，先展示一下这个类内的<strong>重要成员</strong>：</p><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_target</td><td>System.Object</td><td>这个字段引用的是回调方法要操作的对象。当委托对象包装静态方法时，这个字段返回null；当委托对象包装实例方法时，这个字段引用回调方法要操作的对象。</td></tr><tr><td>_methodPtr</td><td>System.IntPtr</td><td>一个内部的整数值，CLR用它标识要回调的方法</td></tr><tr><td>_invocationList</td><td>System.Object</td><td>通常为null。构造委托链时它引用一个委托数组（详见下节）</td></tr></tbody></table><p>再聊<strong>构造器</strong>，所有委托都有一个构造器，它获取2个参数：一个是对象引用，另一个是引用了回调方法的整数。</p><ol><li><p>  C#编译器知道要构造的是委托，在传入诸如<code>new FeedBack(Method_B) </code>这样的参数时，会分析源代码来确定引用的是哪个对象和方法。</p></li><li><p>  对象引用被传给构造器的object参数，标识了方法的一个特殊IntPtr值被传给构造器的method参数。对于静态方法，会给object参数传递null值。构造器方法体内部将这两个实参分别存在_target、_methodPtr这两个私有字段里。</p></li><li><p>  最后将_invocationList字段设置为null，这个字段后面讨论。</p></li></ol><p>所以，每个委托对象实际都是一个**包装器(wapper)**，其中包装了一个方法和调用该方法时要操作的对象。结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211210173655.png"></p><h3 id="委托使用揭秘"><a href="#委托使用揭秘" class="headerlink" title="委托使用揭秘"></a>委托使用揭秘</h3><p><strong>委托调用</strong></p><p>C#编译器会自动将委托的调用转换为Invoke：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FeedBack fb = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">fb(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 在C#编译器眼里，上面的调用自动转换为：</span></span><br><span class="line">fb.Invoke(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>可以查看IL代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IL_0009:callvirt instance void Feedback::Invoke(int32)</span><br></pre></td></tr></table></figure><p><strong>委托链</strong></p><p>委托链，也就是用委托回调多个方法。<br>下面制造一个委托链并调用，堆流程刨析：</p><p>1.初始化委托链(委托)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line">...</span><br><span class="line">FeedBack fbChain = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>2.将委托添加到链中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbChain = (Feedback) Delegate.Combine(fbChain, fb1);</span><br></pre></td></tr></table></figure><p>此时Combine方法内部，发现fbChain是null，所以直接返回fb1中的值。</p><p>3.再将委托添加到链中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbChain = (Feedback) Delegate.Combine(fbChain, fb2);</span><br></pre></td></tr></table></figure><p>此时Combine方法内部，发现fbChain内部已经包含了一个委托(fb1)，所以会构造一个新的委托对象。初始化这个新委托对象时，**_invocationList字段**被初始化为引用一个委托对象数组。</p><p>数组的第一个元素(索引0)被初始化为重包装了fbChain内部方法的委托，数组的第二个元素(索引1)被初始化为重包装了fb2内部方法的委。</p><p>最后，fbChain被设为引用新建的委托对象。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211213095622.png"></p><p>后续如果继续向委托链+=新委托，每次都会新建一个委托数组放入**_invocationList字段<strong>中，让原先的数组进入GC，我称之为</strong>委托链的不可变性**。至于为什么要新建而不是扩容，我估计是因为数组长度不可变，比起扩容，new比较省事安全吧。</p><p>4.对委托链进行调用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbChain(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>首先知道，fbChain会被转换为 fbChain.Invoke。</p><p>Invoke时发现内部字段_invocationList不为null，就能判断为一个委托链，对其进行循环遍历数组并依次调用各个委托中的方法。</p><p>5.对委托链进行Remove</p><p>倒序循环遍历_invocationList数组，匹配_target和_methodPtr字段相同的元素进行删除，只删除一个元素。</p><p><strong>显式调用委托链</strong></p><p>起因是委托链遍历调用，返回值只能有一个，且某一元素出错会导致后续的委托都出错，就很不健壮。</p><p>所以MulticastDelegate类提供了<strong>实例方法GetInvocationList</strong>，用于显式调用链中的每一个委托：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstarct clas MulticastDelegate : Delegate &#123;</span><br><span class="line">    <span class="comment">// 创建一个委托数组，其中每个元素都指向委托链的一个委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> Delegate[] <span class="title">GetInvocationList</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个方法，就可以自己显式调用每一个委托，加上诸如 try catch 的定制化处理。</p><h3 id="C-泛型委托"><a href="#C-泛型委托" class="headerlink" title="C#泛型委托"></a>C#泛型委托</h3><p><strong>尽量少定义委托</strong></p><p>主要是就定义的太多了，比如微软定义的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TryCode</span>(<span class="params">Object userData</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">WaitCallback</span>(<span class="params">Object state</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object state</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>压根就是重复的签名，根本没必要定义的这么杂乱，所以推荐用泛型委托。</p><p><strong>Action和Func</strong></p><p>微软定义好的泛型委托就是Action和Func，Action有16个Func有17个。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span>;<span class="comment">// 这个不是泛型，所以不算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">TResult</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">TResult</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>, <span class="title">TResult</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br></pre></td></tr></table></figure><h3 id="C-委托语法糖"><a href="#C-委托语法糖" class="headerlink" title="C#委托语法糖"></a>C#委托语法糖</h3><p><strong>不必新建委托对象</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义签名以及调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params">FeedBack fb</span>)</span> &#123; &#125;</span><br><span class="line">...</span><br><span class="line">SomeMethod(<span class="keyword">new</span> FeedBack(Method_A));</span><br><span class="line"><span class="comment">// 可以简化为直接传方法名</span></span><br><span class="line">SomeMethod(Method_A);</span><br></pre></td></tr></table></figure><p>省去new，当然IL代码还是会一样生成的。</p><p><strong>不必定义方法(lambda)</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SomeMethod(num =&gt; &#123;</span><br><span class="line">    <span class="comment">//do sth </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实就是匿名函数，IL代码也一样会生成一个同签名的方法，不过方法名不确定(编译时才知道)且为private。</p><p><strong>直接使用局部变量(lambda)</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OtherMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    FeedBack fb = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">3</span>;</span><br><span class="line">    fb += (num =&gt; &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在IL的生成代码里看，这个匿名方法之所以能直接用局部变量、实例变量，是因为它定义为一个方法内的嵌套类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OtherMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    FeedBack fb = <span class="literal">null</span>;<span class="comment">// 伪代码</span></span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">3</span>;<span class="comment">// 伪代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造辅助类实例并初始化</span></span><br><span class="line">    &lt;&gt;c__DisplayClass1 class1 = <span class="keyword">new</span> c__DisplayClass1();</span><br><span class="line">    class1.x = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定委托</span></span><br><span class="line">    fb = <span class="keyword">new</span> FeedBack(class1.&lt;OtherMethod&gt;b__0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IL代码</span></span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span>&lt;&gt;<span class="title">c__DisplayClass1</span> : <span class="title">Object</span>&#123;</span><br><span class="line"><span class="comment">// 回调函数要使用的每个局部变量都有一个对应的公共字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line"><span class="comment">// 公共无参构造器</span></span><br><span class="line"><span class="keyword">public</span> &lt;&gt;c__DisplayClass1 &#123; &#125;</span><br><span class="line"><span class="comment">// 公共实例方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> &lt;OtherMethod&gt;b__0(<span class="built_in">int</span> num)&#123;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>+=和-=操作符</strong></p><p>被重载了，分别是Delegate.Combine、Delegate.Remove。IL代码完全一致。</p><h3 id="委托和反射"><a href="#委托和反射" class="headerlink" title="委托和反射"></a>委托和反射</h3><ol><li>  获取委托，使用<code>MethodInfo.CreateDelegate(委托Type, 实例对象Object)</code>方法。</li><li>  调用委托，使用<code>Delegate.DynamicInvoke</code>方法。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MethodInfo mi = <span class="keyword">typeof</span>(Person).GetMethod(<span class="string">&quot;TellAge&quot;</span>, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line"><span class="keyword">var</span> instance = Activator.CreateInstance(<span class="keyword">typeof</span>(Person)) <span class="keyword">as</span> Person;</span><br><span class="line">Delegate d = mi.CreateDelegate(<span class="keyword">typeof</span>(FeedBack), instance);</span><br><span class="line">d.DynamicInvoke(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">TellAge</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;我&#123;0&#125;岁了&quot;</span>,age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="大章18：定制特性"><a href="#大章18：定制特性" class="headerlink" title="大章18：定制特性"></a><center>大章18：定制特性</center></h1><h3 id="定制特性-custom-attribute"><a href="#定制特性-custom-attribute" class="headerlink" title="定制特性(custom attribute)"></a>定制特性(custom attribute)</h3><p><strong>什么是特性</strong></p><p>比如public、private、static这些就算是特性。</p><p>但是如果能定义自己的特性，比如定义一个类型，指出该类型能够通过序列化来进行远程处理。</p><p><strong>什么是定制特性</strong></p><p>定制特性其实是一个类型的实例。它必须从类<strong>System.Attribute</strong>派生。</p><p><strong>如何使用特性</strong></p><p>1.使用特性的语法和构造方法非常相似，是因为其实就是对Attribute类进行实例化。但也有点不同，构造器用到的参数叫**定位参数(positional parameter)<strong>，用于设置字段或属性的参数成为</strong>命名参数(named parameter)**。</p><p>比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;Kernel32&quot;</span>, CharSet = CharSet.Auto, SetLastError = true)</span>]</span><br></pre></td></tr></table></figure><p>这一句里，”Kernel32”是构造器需要的参数，也就是定位参数，它是必要的；“CharSet”和“SetLastError”是设置内部属性的，也就是命名参数，是非必要的。</p><p>2.此外，特性写法也很多种，Attribute后缀可以写可以不写，以下4条是等效的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>][Flags]</span><br><span class="line">[<span class="meta">Serializable, Flags</span>]</span><br><span class="line">[<span class="meta">FlagsAttribute, SerializableAttribute</span>]</span><br><span class="line">[<span class="meta">Serializable()</span>][FlagsAttribute()]</span><br></pre></td></tr></table></figure><p><strong>定制特性例子</strong></p><p>.NET类库定义了几百个定制特性，可将他们应用于自己源代码中：</p><ul><li>DllImport特性应用于方法，告诉CLR该方法的实现位于指定dll的非托管代码中。</li><li>Serializable特性应用于类型，告诉序列化格式化器一个实例的字段可以序列化和反序列化。</li><li>AssemblyVersion特性应用于程序集，设置程序集的版本号。</li><li>Flags特性应用于枚举类型，枚举类型就成了位标志(bit flag)集合。</li></ul><p><strong>特性应用范围</strong></p><p>CLR允许将特性应用于可在文件的元数据中表示的几乎任何东西。比如：</p><ul><li>  TypeDef 类、结构、枚举、接口和委托</li><li>  MethodDef 构造器、方法</li><li>  ParamDef 参数</li><li>  …</li></ul><h3 id="定义自己的特性类"><a href="#定义自己的特性类" class="headerlink" title="定义自己的特性类"></a>定义自己的特性类</h3><p><strong>1.定义一个Attribute类</strong></p><p>模仿写一个FlagsAttribute位标识特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlagsAttribute</span> : <span class="title">System.Attribute</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlagsAttribute</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.限制特性的应用范围</strong></p><p>希望特性只能用于枚举类型，需要用到System.AttributeUsage类的实例，该类是微软定义的用于限制特性定义范围的特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeUsage.Enum, Inherited = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlagsAttribute</span> : <span class="title">System.Attribute</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlagsAttribute</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.5.了解一下System.AttributeUsage</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类大致定义</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class, Inherited = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AttributeUsageAttribute</span> : <span class="title">Attribute</span> &#123;</span><br><span class="line">    <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> AttributeUsageAttribute Default = <span class="keyword">new</span> AttributeUsageAttribute(AttrubuteTargets.All);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 属性(这里简写为字段了)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">bool</span> AllowMultiple = <span class="literal">false</span>;<span class="comment">// 是否可以让该特性实例多次应用于同一个目标</span></span><br><span class="line">    <span class="keyword">internal</span> AttributeTargets AttributeTarget = AttributeTargets.All;<span class="comment">// 特性应用范围</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">bool</span> Inherited = <span class="literal">true</span>;<span class="comment">// 特性是否可被继承</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AttributeUsageAttribute</span>(<span class="params">AttributeTargets validOn</span>)</span> &#123;</span><br><span class="line">        AttributeTarget = validOn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AttributeUsageAttribute</span>(<span class="params">AttributeTargets validOn, <span class="built_in">bool</span> allowMulit, <span class="built_in">bool</span> inherited</span>)</span> &#123;</span><br><span class="line">        AttributeTarget = validOn;</span><br><span class="line">        AllowMultiple = allowMulit;</span><br><span class="line">        Inherited = inherited;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AttributeTargets枚举类</span></span><br><span class="line">[<span class="meta">Flags, Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AttributeTargets &#123;</span><br><span class="line">    Assembly,</span><br><span class="line">    Module,</span><br><span class="line">    Class,</span><br><span class="line">    Struct,</span><br><span class="line">    Enum,</span><br><span class="line">    Construector,</span><br><span class="line">    Method,</span><br><span class="line">    Property,</span><br><span class="line">    Field,</span><br><span class="line">    Event,</span><br><span class="line">    Interface,</span><br><span class="line">    Parameter,</span><br><span class="line">    Delegate,</span><br><span class="line">    ReturnValue,</span><br><span class="line">    GenericParamter,<span class="comment">// 泛型参数</span></span><br><span class="line">    All</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = true)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">TastyAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Tasty</span>][Serializable]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">BaseType</span> &#123;</span><br><span class="line">    [<span class="meta">Tasty</span>] <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DerivedType</span> : <span class="title">BaseType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用例，稍微讲一下：</p><p>DerivedType类 和它的 DoSomething方法 都被视为 [Tasty]，因为他们都在应用范围内且<code>Inherited = true</code>，意味着可被继承。但是Serializable设置为不可被继承，所以DerivedType没有继承到父类的[Serializable]。</p><p><strong>3.构造器</strong></p><p>一般来说特性类就当正常类定义就行了，不过构造器比较特殊：</p><p>a.特性类<strong>构造器的入参</strong>可供选择的数据类型并不多：bool，char，byte，SByte，Int16，UInt16，Int32，UInt32，Int64，UInt64，Single，Double，String，Type，Object或枚举类型。以及上述类型的一维0基数组。如果不遵守，是通不过编译的 “不是有效的特性参数类型”。</p><p>b.特性类构造器有2种参数，一种是构造方法定义的指定参数，还有一种是<strong>增强型构造器语法</strong>所指定的值。当然无论哪种都得遵守1中的要求，演示如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">TastyAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line"><span class="keyword">public</span> Test Z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TastyAttribute</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">X = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Tasty(10, Y = 100)</span>] <span class="comment">// 可见可以直接指定Y，但是Z无法指定！会报错 “不是有效的特性参数类型”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>c.我们怎么理解定制特性？它是类的实例，被序列化成驻留在元数据中的字节流。运行时可对元数据中的字节进行反序列化，从而构造出类的实例。真实情况中的元数据会稍微复杂点，构造器的参数会序列化成 “字段1 字段1类型ID 字段2 字段2类型ID…” 这样的字符串。</p><h3 id="运用自己的特性类"><a href="#运用自己的特性类" class="headerlink" title="运用自己的特性类"></a>运用自己的特性类</h3><p><strong>光应用特性类没用</strong></p><p>仅仅定义+应用自制的特性类没有用，只能在元数据中生成一堆额外数据罢了。</p><p>那怎么有用呢？比如特性[Flags]用于枚举类型，之所以能让ToString的方法产生行为变化，是因为ToString方法会在运行时检查自己操作的枚举类型是否关联了[Flags]特性元数据。</p><p>所以，方法会在运行时检查操作的数据是否关联了特性元数据，至于检测用的是<strong>反射</strong>技术。</p><p><strong>检测定制特性</strong></p><p>微软在反射插件<code>System.Reflection.CustomAttributeExtensions</code>提供了3个静态拓展方法来<strong>扫描</strong>托管模块的元数据，执行字符串比较来定位指定的定制特性类的位置：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>IsDefined</td><td>如果至少有一个指定的Attribute派生类的实例与目标关联就返回true。效率很高因为不需要反序列化构造特性类的实例。</td></tr><tr><td>GetCustomAttributes</td><td>返回应用于目标的指定特性实例的集合；如果没有，就返回null。一般该方法用于AllowMultiple为true的特性。</td></tr><tr><td>GetCustomAttribute</td><td>返回应用于目标的指定特性的实例。实例使用编译时指定的参数、字段和属性，反序列化元数据获得并构造；如果没有，就返回null；如果有目标应用指定特性的多个实例，就抛出System.Reflection.AmbiguousMatchException异常。一般该方法用于AllowMultiple为false的特性。</td></tr></tbody></table><p>在<code>System.Reflection</code>命名空间提供了很多类允许检查模块的元数据（也就是上述方法），包括Assembly、Module、ParameterInfo、MemberInfo、Type、MethodInfo、ConstructorInfo、FieldInfo、EventInfo、PropertyInfo及其各自的*Builder类。</p><p><strong>用起特性类</strong></p><p>了解前面理论之后，特性[Flags]的用法大概就会这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum的ToString实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> String <span class="title">ToString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.GetType().IsDefined(<span class="keyword">typeof</span>(FlagAttribute), <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果是，就当作一个位标志枚举类型</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果不是，就当作一个普通枚举类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比较特性类</strong></p><p>特性类之间的比较通过<strong>Equals和Match两个虚方法</strong>。</p><p>System.Attribute重写了Object的Equals方法，Match默认实现就是直接调用Equals，具体比较逻辑如下：</p><ol><li>  先比较两个实例的类型，不一致返回false。</li><li>  再用反射比较两个特性实例中的字段值（为每个字段都调用Equals），所有字段匹配返回true；否则false。</li></ol><p>但是既然是虚方法，自然可以重写自定义，这里重写一个Match的实现为判断是否是子集。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特性用标志位枚举类</span></span><br><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="built_in">enum</span> Accounts &#123;</span><br><span class="line">    Saving = <span class="number">0x0001</span>,</span><br><span class="line">    Checking = <span class="number">0x0002</span>,</span><br><span class="line">    Brokerage = <span class="number">0x0004</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义特性</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AccountsAttribute</span> : <span class="title">Attribute</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Accounts accounts;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountsAttribute</span>(<span class="params">Accounts accounts</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Boolean <span class="title">Match</span>(<span class="params">Object obj</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果父类实现了Match if(!base.Match(obj)) return false</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 确保不为null</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.GetType() != obj.GetType()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 确保类型一致</span></span><br><span class="line">        AccountsAttribute other = (AccountsAttribute)obj; <span class="comment">// 既然类型一致转型必成功</span></span><br><span class="line">        <span class="keyword">if</span>((other.accounts &amp; accounts) != accounts)&#123;</span><br><span class="line">            <span class="comment">// 如果不是子集</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">[<span class="meta">Accounts(Accounts.Saving)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ChildAccount</span> &#123; &#125;</span><br><span class="line">[<span class="meta">Accounts(Accounts.Saving | Accounts.Checking | Accounts.Brokerage)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AdultAccount</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> child = <span class="keyword">new</span> ChildAccount();</span><br><span class="line"><span class="keyword">var</span> adult = <span class="keyword">new</span> AdultAccount();</span><br><span class="line">    Attribute checking = <span class="keyword">new</span> AccountsAttribute(Accounts.Checking); <span class="comment">// 指定Accounts.Checking来测试Match方法</span></span><br><span class="line">    </span><br><span class="line">    Attribute validChildAccounts = Attribute.GetCustomAttribute(child.GetType(),<span class="keyword">typeof</span>(AccountsAttribute),<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (validChildAccounts != <span class="literal">null</span> &amp;&amp; checking.Match(validChildAccounts))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;child matched!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Attribute validAdultAccounts = Attribute.GetCustomAttribute(adult.GetType(), <span class="keyword">typeof</span>(AccountsAttribute), <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (validAdultAccounts != <span class="literal">null</span> &amp;&amp; checking.Match(validAdultAccounts))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;adult matched!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: adult matched!</span></span><br></pre></td></tr></table></figure><h3 id="不创建实例的检测定制特性方法"><a href="#不创建实例的检测定制特性方法" class="headerlink" title="不创建实例的检测定制特性方法"></a>不创建实例的检测定制特性方法</h3><p>前面是调用了<code>Attribute.GetCustomAttributes</code>方法，这些方法会在内部调用特性类的构造器并set属性。</p><p>利用CustomAttributeData类，比如<code>CustomAttributeData.GetCustomAttributes</code>方法，可以不实际调用构造器与set属性，来安全获得预想状态的实例属性等，而实际上并没有真的创建实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Accounts(Accounts.Saving | Accounts.Checking | Accounts.Brokerage, age=33)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AdultAccount</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> adult = <span class="keyword">new</span> AdultAccount();</span><br><span class="line"><span class="keyword">var</span> attributeDatas = CustomAttributeData.GetCustomAttributes(adult.GetType());</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> attributeData <span class="keyword">in</span> attributeDatas)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// AttributeType 属性的类型, Constructor 表示应已初始化自定义属性的构造函数</span></span><br><span class="line">Console.WriteLine(attributeData.AttributeType);</span><br><span class="line">Console.WriteLine(attributeData.Constructor.DeclaringType);</span><br><span class="line"><span class="comment">// output1: ConsoleApp5.AccountsAttribute</span></span><br><span class="line"><span class="comment">// output2: ConsoleApp5.AccountsAttribute</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// attributeData.ConstructorArguments 表示特性实例指定的位置参数列表</span></span><br><span class="line">         <span class="comment">// output3: constructorArgs:ConsoleApp5.Accounts 7</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> conArg <span class="keyword">in</span> attributeData.ConstructorArguments)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;constructorArgs:&quot;</span> + conArg.ArgumentType + <span class="string">&quot; &quot;</span> + conArg.Value);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// attributeData.NamedArguments 表示的特性实例指定的命名参数列表</span></span><br><span class="line">         <span class="comment">// output4: namedArgs:Int32 age age (Int32)33 True</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> conArg <span class="keyword">in</span> attributeData.NamedArguments)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;namedArgs:&quot;</span> + conArg.MemberInfo + <span class="string">&quot; &quot;</span> + conArg.MemberName + <span class="string">&quot; &quot;</span> + conArg.TypedValue +<span class="string">&quot; &quot;</span>+ conArg.IsField);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍一下<code>GetCustomAttributes</code>方法，它返回包裹了所有特性数据的列表，特性用类<code>CustomAttributeData</code>来包裹，它的属性：</p><ul><li>  AttributeType：该特性的类型</li><li>  Constructor：已初始化过的自定义属性的构造函数</li><li>  ConstructorArguments：所使用 构造器 中的参数们（注意无法获取参数名字）</li><li>  NamedArguments：所使用 特性增强构造器 的参数们（就是命名指定的那些参数，可以获取到参数名字）</li></ul><h3 id="条件特性类"><a href="#条件特性类" class="headerlink" title="条件特性类"></a>条件特性类</h3><p><strong>ConditionalAttribute</strong></p><p>条件特性类，说的就是特性<code>System.Disgnostics.ConditionalAttribute</code>。将此特性应用于自定义的定制特性，该定制特性就能根据环境宏来判断是否真正应用特性类并生成其元数据。当然不止是运用于定制特性，应用于方法等也是一样有效的。使用起来有点类似于**#if**。</p><p>调用方法是，<strong>宏定义 或者 #define</strong>，两者是一样的含义，都是在定义编译时常量。</p><p>#define方法展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CodingCodingK</span></span><br><span class="line"><span class="comment">// 上面启用了Test()和Test2()两个方法，当然宏定义也是一样的</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    Test();</span><br><span class="line">    Test2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;CodingCodingK&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;I can do that !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上作用类似于</span></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;CodingCodingK&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CodingCodingK</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;I can do that !&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏定义方法展示：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211215154042.png"></p><p>最后，网上有篇文章说ConditionalAttribute和#if方法使用只是类似而不是完全一致，是因为方法定义和方法调用如果在2个不同的程序集内，那么就点不同了：ConditionalAttribute是根据调用地点的程序集内有没有定义宏来选择生成代码的，而#if像上面这样写是根据方法定义地点的程序集内有没有定义宏来判断的。</p><p>我个人是觉得…其实也可以把#if写到调用方法的地方，那样两者使用的效果可以说一样了。嘛…</p><h1 id="大章19：可null值类型"><a href="#大章19：可null值类型" class="headerlink" title="大章19：可null值类型"></a><center>大章19：可null值类型</center></h1><h3 id="可null值类型-结构"><a href="#可null值类型-结构" class="headerlink" title="可null值类型 结构"></a>可null值类型 结构</h3><p><strong>问题由来</strong></p><p>由于各类系统或软件之间定义的类型并不能一一配对，比如java中的java.util.Date类是引用类型，所以该类型的变量能为null；但CLR的System.DateTime是值类型，永远不能为null。</p><p>为了解决这个问题，微软在CLR中引入了可空值类型的概念，先看一下<code>System.Nullable&lt;T&gt;</code>结构来理解。</p><p><strong>System.Nullable<T></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable, StructLayout(LayoutKind.Sequential)</span>]</span><br><span class="line"><span class="comment">// Nullable约束为struct，T也约束为struct，所以实例仍然是在栈上的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Nullable&lt;T&gt; <span class="keyword">where</span> T : <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这两个字段表示状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> hasValue; <span class="comment">// 假定null</span></span><br><span class="line"><span class="keyword">internal</span> T <span class="keyword">value</span>; <span class="comment">// 假定所有位都为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Nullable</span>(<span class="params">T val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">value</span> = val;</span><br><span class="line"><span class="keyword">this</span>.hasValue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> HasValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> hasValue; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T Value</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!hasValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Nullable object must have a value.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetValueOrDefault</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="keyword">value</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetValueOrDefault</span>(<span class="params">T defaultValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> defaultValue;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面重写 Equals、GetHashCode、ToString，避免报值类型的错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> (other == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (other == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>.Equals(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>.GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 值类型=&gt;可null值类型 隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Nullable</span>&lt;<span class="title">T</span>&gt;(<span class="params">T val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Nullable&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 可null值类型=&gt;值类型 隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">T</span>(<span class="params">Nullable&lt;T&gt; val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> val.Value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">main <span class="title">void</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Nullable&lt;<span class="built_in">int</span>&gt; a = <span class="number">1</span>; <span class="comment">// 模仿 int? a = 1;</span></span><br><span class="line">    <span class="comment">// 最尴尬的来了，按照书里的敲，下面的这个是编译不过的：无法将null转换为“Nullable&lt;int&gt;”，因为后者是不可以为null的值类型</span></span><br><span class="line">Nullable&lt;<span class="built_in">int</span>&gt; b = <span class="literal">null</span>; <span class="comment">// 模仿 int? b = null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段用来理解是够了，看.NET源码也确实是这么写的，自己实例化却发现null不了，很尴尬。TODO 估计是哪里漏了理解，以后再补上。</p><h3 id="C-对可空值类型的支持"><a href="#C-对可空值类型的支持" class="headerlink" title="C#对可空值类型的支持"></a>C#对可空值类型的支持</h3><p><strong>语法简化</strong></p><p>C#允许使用<code>T?</code>来等价替代<code>Nullable&lt;T&gt;</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? x = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 完全等价于</span></span><br><span class="line">Nullable&lt;<span class="built_in">int</span>&gt; y = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><strong>操作符</strong></p><p>基本上有一个操作数是null，就直接返回null。如果操作数都不为null，那操作符计算方式与非null值类型相同。</p><h3 id="CLR对可null类型的特殊处理"><a href="#CLR对可null类型的特殊处理" class="headerlink" title="CLR对可null类型的特殊处理"></a>CLR对可null类型的特殊处理</h3><p><strong>可null类型的装箱</strong></p><p><code>Nullable&lt;T&gt;</code>毕竟还是值类型，所以将其传给一个接收Object的方法时就得为其装箱。但是其为null时为一个null装箱很奇怪。所以CLR对可null类型的装箱多作了些手段：</p><ol><li>  判断是否是null，如果是，就不装箱直接返回null。</li><li>  如果不是null，就取出值，并装箱返回。</li></ol><p><strong>可null类型的拆箱</strong></p><p>如果已装箱值类型的引用是null，那么CLR会将<code>Nullable&lt;T&gt;</code>的值设为null。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="number">5</span>; <span class="comment">// 创建已装箱的int</span></span><br><span class="line">o = <span class="literal">null</span>;</span><br><span class="line">int32? a = (int32?) o; <span class="comment">// 拆箱，a = null</span></span><br></pre></td></tr></table></figure><p><strong>Nullable.GetType</strong></p><p>对<code>Nullable&lt;T&gt;</code>执行<code>GetType()</code>，CLR会“撒谎”说类型是T，而不是<code>Nullable&lt;T&gt;</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int32? x = <span class="number">6</span>;</span><br><span class="line">Console.WriteLine(x.GetType()); <span class="comment">// output:&quot;System.Int32&quot;</span></span><br></pre></td></tr></table></figure><p><strong>调用接口方法</strong></p><p>编译器提供了更简洁的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果CLR没有提供，写起来很繁琐</span></span><br><span class="line"><span class="built_in">int</span> result1 = ((IComparable) (<span class="built_in">int</span>) n).CompareTo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLR提供特殊支持后的简便写法</span></span><br><span class="line"><span class="built_in">int</span> result2 = ((IComparable) n).CompareTo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="其他：空接合操作符"><a href="#其他：空接合操作符" class="headerlink" title="其他：空接合操作符"></a>其他：空接合操作符</h3><p><strong>null-coalescing operator</strong></p><p>空接合操作符(null-coalescing operator)，即**??操作符**。它要获取两个操作数，如果左边的操作数不为null，就返回左，否则就返回右。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> CLR via C# </category>
          
          <category> 第三章 基本类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
            <tag> 可访问性 </tag>
            
            <tag> 基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 技能篇</title>
      <link href="/Project/Unity/Moba/HOK/skill/"/>
      <url>/Project/Unity/Moba/HOK/skill/</url>
      
        <content type="html"><![CDATA[<h1 id="技能系统"><a href="#技能系统" class="headerlink" title="技能系统"></a>技能系统</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211206214406.png"></p><h2 id="Skill"><a href="#Skill" class="headerlink" title="Skill"></a>Skill</h2><p>数据类 SkillCfg：</p><p>​        拥有伤害值、动画切片名等等基础信息。</p><p>​        拥有技能类型、碰撞关系的技能逻辑体需要用到的枚举信息。</p><p>​        拥有BuffList、BulletCfg用于动态创建Buff和Bullet。</p><p>逻辑类 Skill：</p><h2 id="Buff"><a href="#Buff" class="headerlink" title="Buff"></a>Buff</h2><ul><li>数据类 BuffCfg。给策划配表用，只有数值（碰撞关系、伤害数值）。</li><li>逻辑类 Buff。本身用状态机实现。</li></ul><p>复杂的Buff自己派生BuffCfg、Buff来实现数据、逻辑。</p><h2 id="Bullet"><a href="#Bullet" class="headerlink" title="Bullet"></a>Bullet</h2><ul><li>目标追踪型：如果Skill是指向型的、且存在BulletCfg，就会被当作指向型弹道技能。</li><li>位置确定型：如果Skill是非指向型的、且存在BulletCfg，就会被当作非指向型弹道技能。</li></ul><p>Bullet结构自身并不附带任何Buff。</p><p>子弹伤害、效果在Bullet的命中回调中通过读取Skill伤害、Skill的BuffList实现。</p><h1 id="技能实现"><a href="#技能实现" class="headerlink" title="技能实现"></a>技能实现</h1><p>// TODO 梳理一整个战斗网络包（位移、技能）Send-Rsp-Tick过程：所有的本地设备（包括操纵者自己）其实就是同步演算+播放器</p><h2 id="技能前摇、后摇"><a href="#技能前摇、后摇" class="headerlink" title="技能前摇、后摇"></a>技能前摇、后摇</h2><h2 id="指向技能实现"><a href="#指向技能实现" class="headerlink" title="指向技能实现"></a>指向技能实现</h2><h3 id="查找目标"><a href="#查找目标" class="headerlink" title="查找目标"></a>查找目标</h3><p>指向 = 有目标的、追踪的。需要额外的查找目标代码。</p><h3 id="非弹道型"><a href="#非弹道型" class="headerlink" title="非弹道型"></a>非弹道型</h3><p>前摇结束时目标仍在技能范围内，就判定释放成功。比如亚瑟这类近战的普攻。</p><h3 id="弹道型"><a href="#弹道型" class="headerlink" title="弹道型"></a>弹道型</h3><p>追踪子弹。比如后裔这类射手的普攻。</p><h2 id="非指向技能实现"><a href="#非指向技能实现" class="headerlink" title="非指向技能实现"></a>非指向技能实现</h2><h3 id="非弹道型-1"><a href="#非弹道型-1" class="headerlink" title="非弹道型"></a>非弹道型</h3><p>通过buff动态确定目标，其实大部分属于纯buff型技能。比如亚瑟2技能。</p><h3 id="弹道型-1"><a href="#弹道型-1" class="headerlink" title="弹道型"></a>弹道型</h3><p>自判定子弹，通过<strong>SweepVolume算法</strong>确定是否命中。比如后裔的大招。</p><h2 id="纯buff型技能"><a href="#纯buff型技能" class="headerlink" title="纯buff型技能"></a>纯buff型技能</h2><p>很多，比如替换普攻的技能、亚瑟的2技能、亚瑟的被动都属于这一类。</p><p>不需要通过技能逻辑代码来执行，直接通过buff逻辑（比如Buff.Tick、Buff对Skill添加回调等）。</p><h1 id="金克斯技能拆解"><a href="#金克斯技能拆解" class="headerlink" title="金克斯技能拆解"></a>金克斯技能拆解</h1><h2 id="被动"><a href="#被动" class="headerlink" title="被动"></a>被动</h2><p>击杀防御塔、英雄就进行加速175%，持续3秒。</p><h2 id="技能一"><a href="#技能一" class="headerlink" title="技能一"></a>技能一</h2><blockquote><p>枪炮交响曲·Q：金克丝切换武器 　　</p><p>鱼骨头——火箭发射器：普通攻击会对目标和目标身边的所有敌人造成110%的伤害，攻击距离提升75/100/125/150/175，并且耗费法力值。 　　</p><p>砰砰枪——轻机枪：普通攻击会获得攻击速度加成，持续2.5秒。攻速加成可叠加3次，总攻速加成为30/55/80/105/130%。叠加效果在同一时间只会消耗一层，并且在金克丝切换至火箭发射器后，只有第一次攻击会享受加速效果。</p></blockquote><p>金克斯最复杂的一个技能。</p><p><strong>普攻、技能一自身替换</strong>，通过技能替换buff实现。</p><p>持续2.5秒的可叠加被动，是作为英雄被动技能实现的：buff初期化时给英雄的技能释放成功添加回调来刷新计时、叠加层数，在buff状态机内不断迭代时间是否满足2.5秒。但是普攻回调中会检测目前的普攻ID，如果是替换了的火箭发射器ID，就会把攻速加成提前取消。这样同时实现了“只有第一次攻击会享受加速效果”。</p><p><strong>火箭发射器形态普攻</strong>，当作指向性弹道技能实现。爆炸是通过给技能添加一个 静态范围伤害buff 来实现的爆炸效果。在子弹命中回调中创建buff，传入子弹及时Pos，形成一个检测碰撞区来获取被命中的敌人。</p><h2 id="技能二"><a href="#技能二" class="headerlink" title="技能二"></a>技能二</h2><blockquote><p>振荡电磁波·W：金克丝0.6-0.4秒后发射一束震荡波，对命中的第一个目标造成10/60/110/160/210物理伤害，让非潜行的目标暴露在视野内，并让目标减速30/40/50/60/70%，减速效果持续2秒。</p></blockquote><p>由于demo还没有实现战争迷雾系统，暴露视野暂不实现。</p><p>非指向弹道技能 + 减速buff。</p><h2 id="技能三"><a href="#技能三" class="headerlink" title="技能三"></a>技能三</h2><blockquote><p>金克丝扔出3颗陷阱手雷。手雷一旦布置完毕，就会在接触到敌方英雄时爆炸，将敌方英雄束缚1.5秒并阻止在该位置上的进行中的移动技能，立刻对周围的敌人造成共80/135/190/245/300魔法伤害。手雷持续5秒。</p></blockquote><p>可以通过非指向非弹道技能实现。通过轮盘确定投放位置后，对位置生成3个静态范围寻找目标buff实现。给buff添加buffEffect实现夹子特效。</p><h2 id="技能四"><a href="#技能四" class="headerlink" title="技能四"></a>技能四</h2><blockquote><p>超究极死神飞弹·R：金克丝发射一枚飞弹。在发射后的一秒里，飞弹的伤害会根据飞行的距离而持续增加。飞弹会在首次命中敌方英雄后爆炸，对目标造成25/35/45到250/350/450物理伤害，并附带相当于目标已损失生命值的25/30/35%的额外伤害。附近的敌人也会受到80%伤害。</p></blockquote><p>非指向弹道技能 + 静态计算碰撞范围+记录距离计算伤害+损失生命计算百分比伤害buff。因为比较特殊3个buff的数据是存在依赖（后2个buff的伤害计算 -&gt;.前1个buff的伤害基准值）的，所以直接放到一个新buff里实现。</p><h1 id="技能机制"><a href="#技能机制" class="headerlink" title="技能机制"></a>技能机制</h1><h2 id="技能分析"><a href="#技能分析" class="headerlink" title="技能分析"></a>技能分析</h2><p>目标 = 指向；弹道 = 借助bullet；无前摇 = 瞬发型。</p><table><thead><tr><th>英雄</th><th>亚瑟</th><th>后羿</th></tr></thead><tbody><tr><td>普攻</td><td>目标技能 + 非弹道、有前摇</td><td>目标技能 + 弹道、延迟</td></tr><tr><td>技能1</td><td>非目标技能  buff替换普攻Cfg + 非弹道、无前摇</td><td></td></tr><tr><td>技能2</td><td>非目标技能 + 非弹道、无前摇</td><td></td></tr><tr><td>技能3</td><td>目标技能 + 非弹道、有前摇</td><td></td></tr></tbody></table><h2 id="非目标技能（非指向）"><a href="#非目标技能（非指向）" class="headerlink" title="非目标技能（非指向）"></a>非目标技能（非指向）</h2><h3 id="1-buff替换普攻Cfg技能实现（亚瑟一技能）"><a href="#1-buff替换普攻Cfg技能实现（亚瑟一技能）" class="headerlink" title="1.buff替换普攻Cfg技能实现（亚瑟一技能）"></a>1.buff替换普攻Cfg技能实现（亚瑟一技能）</h3><p>亚瑟技能1有许多buff附加到下一个普攻上，直接修改普攻得buffArr使其变更数据会让代码复杂，所以直接采用技能替换普攻的方法，将其作为一个技能。</p><p>之后每1次普攻，其实就相当于在释放1次技能了，所以技能的buff 也会随着每一次普攻而重新Create。</p><p>直到时间结束或者攻击次数用完，技能被替换回原先的普攻。</p><h3 id="2-后裔三技能实现"><a href="#2-后裔三技能实现" class="headerlink" title="2.后裔三技能实现"></a>2.后裔三技能实现</h3><h2 id="目标技能（指向）"><a href="#目标技能（指向）" class="headerlink" title="目标技能（指向）"></a>目标技能（指向）</h2><h3 id="通用的寻找目标实现"><a href="#通用的寻找目标实现" class="headerlink" title="通用的寻找目标实现"></a>通用的寻找目标实现</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211206220958.png"></p><ol><li>根据配置，查找到所有活着的可作为目标的单位(比如红队的英雄)</li><li>根据技能配置规则，确定最终目标单位(比如最近的单个英雄)</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------1.中的配置规则----------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 施法目标阵营</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> TargetTeamEnum</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于动态选择目标，通常是方向指向或位置指向技能，在施法成功后通过buff选择目标</span></span><br><span class="line">    Dynamic,</span><br><span class="line">    Friend,</span><br><span class="line">    Enemy</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> 施法目标类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UnitTypeEnum</span><br><span class="line">&#123;</span><br><span class="line">    Hero,</span><br><span class="line">    Soldier,</span><br><span class="line">    Tower,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------2.中的技能配置规则----------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SelectRuleEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单个目标选择规则</span></span><br><span class="line">    </span><br><span class="line">    MinHpValue,<span class="comment">// 血量最小</span></span><br><span class="line">    MinHpPercent,<span class="comment">// 血量百分比最小</span></span><br><span class="line">    TargetClosestSingle,<span class="comment">// 最近的单个</span></span><br><span class="line">    PositionClosestSingle,<span class="comment">// 靠近某个位置的单个选择</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多个目标选择规则</span></span><br><span class="line">    </span><br><span class="line">    TargetClosestMulti,<span class="comment">// 最近的多个（范围选择）</span></span><br><span class="line">    PositionClosestMulti,<span class="comment">// 靠近某个位置的多个选择（范围选择）</span></span><br><span class="line">    </span><br><span class="line">    Hero,<span class="comment">// 所有英雄单位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让我们看一下2中实现目标查找的关键部分代码，找最近单体目标的核心代码。其他的实现比如查找符合目标的群体算法，核心部分逻辑也是一样的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------核心，查找规则----------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> MainLogicUnit <span class="title">FindMinDisTarget</span>(<span class="params">MainLogicUnit self,List&lt;MainLogicUnit&gt; targetList, PEInt range</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetList == <span class="literal">null</span> || targetList.Count &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MainLogicUnit target = <span class="literal">null</span>;</span><br><span class="line">    CodingKVector3 selfPos = self.LogicPos;</span><br><span class="line">    PEInt len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; targetList.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PEInt sumRaius = targetList[i].ud.unitCfg.colliCfg.mRadius + self.ud.unitCfg.colliCfg.mRadius;</span><br><span class="line">        <span class="comment">// 要剔除掉半径，因为某单位半径可能因为体型变大而变得非常大，结果就看上去更近了，应该打这个看上去更近的</span></span><br><span class="line">        <span class="comment">// 可以优化一下 =&gt; 模magnitude 用 平方根sqrMagnitude替代，比较的时候与(range + sumRaius)*(range + sumRaius)比较即可，不等式是一样的，但可以省去一次开根号。</span></span><br><span class="line">        PEInt tmpLen = (targetList[i].LogicPos - selfPos).magnitude - sumRaius;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span> || tmpLen &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            len = tmpLen;</span><br><span class="line">            target = targetList[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将上面找到的最近目标与range比较，如果还是超过range就返回null</span></span><br><span class="line">    <span class="keyword">return</span> len &lt; range ? target : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-亚瑟普攻实现"><a href="#1-亚瑟普攻实现" class="headerlink" title="1.亚瑟普攻实现"></a>1.亚瑟普攻实现</h3><ol><li>寻找目标</li><li>切换技能状态到<code>SKillState.SpellStart</code></li><li>播放音效</li><li>修改朝向：修改为<code>lockTarget.LogicPos - owner.LogicPos</code>的CodingKVector3向量。</li><li>播放动画：先取消移动，再播放攻击动画。</li></ol><h3 id="2-后裔普攻实现"><a href="#2-后裔普攻实现" class="headerlink" title="2.后裔普攻实现"></a>2.后裔普攻实现</h3><h1 id="技能构造"><a href="#技能构造" class="headerlink" title="技能构造"></a><Center>技能构造<Center/></h1><h2 id="技能Config"><a href="#技能Config" class="headerlink" title="技能Config"></a>技能Config</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="血条和伤害UI"><a href="#血条和伤害UI" class="headerlink" title="血条和伤害UI"></a><Center>血条和伤害UI<Center/></h1><h2 id="血条-数据结构"><a href="#血条-数据结构" class="headerlink" title="血条 数据结构"></a>血条 数据结构</h2><p><strong>个体状态枚举类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 血条上显示的状态</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StateEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Silenced,<span class="comment">//沉默</span></span><br><span class="line">    Knockup,<span class="comment">//击飞</span></span><br><span class="line">    Stunned,<span class="comment">//眩晕</span></span><br><span class="line">    </span><br><span class="line">    Invincible,<span class="comment">//无敌</span></span><br><span class="line">    Restricted,<span class="comment">//禁锢</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象血条类结构</strong></p><p>继承关系：公用抽象血条类 =&gt; 塔 ； 公用抽象血条类 =&gt; 小兵 =&gt; 英雄 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RectTransform rect;</span><br><span class="line"><span class="keyword">public</span> Image imgPrg;<span class="comment">// 进度</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">bool</span> isFriend;<span class="comment">//是否是友军，用来显示不同颜色的血条UI</span></span><br><span class="line"><span class="keyword">protected</span> Transform rootTrans;<span class="comment">//目标血条，即需要映射的物体的位置，比如英雄头顶上的位置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">int</span> hpVal;</span><br></pre></td></tr></table></figure><h2 id="UI映射"><a href="#UI映射" class="headerlink" title="UI映射"></a>UI映射</h2><p><strong>血条</strong></p><p><strong>血条映射</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (rootTrans)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 标准高度：自适应高度，取出比例</span></span><br><span class="line">         <span class="built_in">float</span> scaleRate = <span class="number">1.0f</span> * ClientConfig.ScreenStandardHeight / Screen.height;</span><br><span class="line">         <span class="keyword">var</span> screenPos = Camera.main.WorldToScreenPoint(rootTrans.position);</span><br><span class="line">         rect.anchoredPosition = screenPos * scaleRate;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="伤害飘字-数据结构"><a href="#伤害飘字-数据结构" class="headerlink" title="伤害飘字 数据结构"></a>伤害飘字 数据结构</h2><p><strong>缓存池</strong></p><p>需要用到伤害飘字的单位比较多，频繁销毁创建会消耗性能，所以首先建立一个缓存池，限制个数为50，用到的时候从池中取出播放动画。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**跳字类型枚举类**</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> JumpTypeEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    SkillDamage,</span><br><span class="line">    BuffDamage,</span><br><span class="line">    Cure,<span class="comment">// 治疗</span></span><br><span class="line">    SlowSpeed,<span class="comment">// 减速</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>跳字动画枚举类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> JumpAniEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    LeftCurve,<span class="comment">// 左曲线飘出</span></span><br><span class="line">    RightCurve,<span class="comment">// 右曲线飘出</span></span><br><span class="line">    CenterUp,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>飘字预制体脚本 结构</strong></p><p>全部公开，方便在unity面板内调参</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JumpNum</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> RectTransform rect;</span><br><span class="line">    <span class="keyword">public</span> Animator ani;</span><br><span class="line">    <span class="keyword">public</span> Text txt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxFont;<span class="comment">// 最大字体，比如60</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MinFont;<span class="comment">// 最小字体，比如40</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxFontValue;<span class="comment">// 将伤害转化为字体大小的计算值x，举例：伤害刚好=x，字体大小就取50</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Color skillDamageColor;</span><br><span class="line">    <span class="keyword">public</span> Color buffDamageColor;</span><br><span class="line">    <span class="keyword">public</span> Color cureDamageColor;</span><br><span class="line">    <span class="keyword">public</span> Color slowDamageColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通用技能定时器"><a href="#通用技能定时器" class="headerlink" title="通用技能定时器"></a><Center>通用技能定时器<Center/></h1><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>用于CD计时器。一共分3个部分：延迟、回调函数(循环)执行、结束回调(1次or不)执行。</p><h2 id="定时器代码"><a href="#定时器代码" class="headerlink" title="定时器代码"></a>定时器代码</h2><p>只展示<strong>重要成员</strong>和使用的<strong>接口</strong>，内部直接看代码（在github开源了）。</p><p>回调函数和3个部分的回调签名：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.回调函数，用于显示次数进度。参数：loopCounter</span></span><br><span class="line"><span class="keyword">private</span> Action&lt;<span class="built_in">int</span>&gt; cbAction;</span><br><span class="line"><span class="comment">// 循环累计次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> loopCounter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.回调函数，用于显示百分比进度。参数：是不是延迟的部分,prgLoopRate,prgAllRate</span></span><br><span class="line"><span class="keyword">private</span> Action&lt;<span class="built_in">bool</span>, <span class="built_in">float</span>, <span class="built_in">float</span>&gt; prgAction;</span><br><span class="line"><span class="comment">// 当前阶段(延迟or回调执行)进度</span></span><br><span class="line"><span class="built_in">float</span> prgLoopRate = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计时器总体进度</span></span><br><span class="line"><span class="built_in">float</span> prgAllRate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.结束后回调函数</span></span><br><span class="line"><span class="keyword">private</span> Action endAction;</span><br></pre></td></tr></table></figure><p>对外接口（构造器）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MonoTimer</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    Action&lt;<span class="built_in">int</span>&gt; cbAction,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">float</span> intervalTime,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> loopCount = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    Action&lt;<span class="built_in">bool</span>, <span class="built_in">float</span>, <span class="built_in">float</span>&gt; prgAction = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    Action endAction = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">float</span> delayTime = <span class="number">0</span></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.IsActive = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.prgAllTime = delayTime + intervalTime * loopCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时器测试示例"><a href="#定时器测试示例" class="headerlink" title="定时器测试示例"></a>定时器测试示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClickTestBtn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    SetText(txtTime, <span class="number">5</span>);</span><br><span class="line">    testTimer?.DisableTimer();</span><br><span class="line">    testTimer = CreateMonoTimer(</span><br><span class="line">        (loopCount) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.ColorLog(LogColor.Green, <span class="string">&quot;Loop:&quot;</span> + loopCount);</span><br><span class="line">            SetText(txtTime, <span class="number">5</span> - loopCount);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="number">1000</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        (isDelay, loopPrg, allPrg) =&gt; &#123;</span><br><span class="line">            SetActive(imgPrgLoop);</span><br><span class="line">            <span class="keyword">if</span>(isDelay) &#123;</span><br><span class="line">                SetActive(txtTime, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                SetActive(txtTime);</span><br><span class="line">            &#125;</span><br><span class="line">            imgPrgLoop.fillAmount = <span class="number">1</span> - loopPrg;</span><br><span class="line">            imgPrgAll.fillAmount = allPrg;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            SetActive(imgPrgLoop, <span class="literal">false</span>);</span><br><span class="line">            imgPrgAll.fillAmount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.ColorLog(LogColor.Green, <span class="string">&quot;Loop End&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="number">3000</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211229204847.png"></p><p>延迟圈转完后进行倒计时轮转，下面的进度条prg= 已过时长 / (延迟时长+回调时长)。</p><h2 id="逻辑定时器"><a href="#逻辑定时器" class="headerlink" title="逻辑定时器"></a>逻辑定时器</h2><p>逻辑定时器(基于定点数)，可以跑在服务器上，不依赖于Mono。</p><p>在本项目中，由 NetSvc.GetServiceMessageAndHandle(GameMsg msg) &gt; BattleSys.NotifyOpKey(GameMsg msg) &gt; FightMgr.Tick() &gt; MainLogicUnit.LogicTick() &gt; MainLogicUnit.TickSkill() &gt; <strong>LogicTimer.Tick()</strong> 驱动。</p><p>下面贴<strong>重要成员</strong>和使用的<strong>接口</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对外接口(构造器)：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LogicTimer</span>(<span class="params">Action cb, PEInt delayTime, <span class="built_in">int</span> loopTime = <span class="number">0</span></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    delta = Configs.ServerLogicFrameIntervelMs;</span><br><span class="line">    IsActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要成员：</span></span><br><span class="line"><span class="comment">// 服务端每一帧的时间(66ms)</span></span><br><span class="line">PEInt delta;</span><br><span class="line"><span class="comment">// 延迟时长</span></span><br><span class="line">PEInt delayTime;</span><br><span class="line"><span class="comment">// 循环周期时长</span></span><br><span class="line">PEInt loopTime;</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line">Action cb;</span><br></pre></td></tr></table></figure><h1 id="Buff-1"><a href="#Buff-1" class="headerlink" title="Buff"></a><Center>Buff<Center/></h1><p>贴一下核心属性和对应的Enum类。</p><h2 id="SubLogicUnit类：辅助类逻辑单元基类"><a href="#SubLogicUnit类：辅助类逻辑单元基类" class="headerlink" title="SubLogicUnit类：辅助类逻辑单元基类"></a>SubLogicUnit类：辅助类逻辑单元基类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 状态阶段</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SubUnitState</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Delay,</span><br><span class="line">    Start,</span><br><span class="line">    Tick,</span><br><span class="line">    End</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 辅助类逻辑单元基类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Buff and Bullet</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">SubLogicUnit</span> : <span class="title">LogicUnit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//---------------1.核心属性：---------------</span></span><br><span class="line">    <span class="comment">// 来源角色</span></span><br><span class="line">    <span class="keyword">public</span> MainLogicUnit source;</span><br><span class="line">    <span class="comment">// 所属技能</span></span><br><span class="line">    <span class="keyword">protected</span> Skill skill;</span><br><span class="line">    <span class="comment">// 延迟生效时间</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> delayTime;</span><br><span class="line">    <span class="comment">// 辅助单元状态</span></span><br><span class="line">    <span class="keyword">public</span> SubUnitState unitState;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//---------------2.核心事件：---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if delayTime == 0 切换状态为Start</span></span><br><span class="line">        <span class="comment">// else 切换状态为Delay</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicTick</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (unitState)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.Delay:</span><br><span class="line">                <span class="comment">// Delay完切换状态为Start</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.End:</span><br><span class="line">                End();</span><br><span class="line">                unitState = SubUnitState.None;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.None:</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUnInit</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Tick</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BuffCfg类"><a href="#BuffCfg类" class="headerlink" title="BuffCfg类"></a>BuffCfg类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buff类型，用来创建不同类型的buff</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BuffTypeEnum &#123;</span><br><span class="line">    None,</span><br><span class="line">    ModifySkill,</span><br><span class="line">    MoveSpeed_Single,<span class="comment">//单体加速buff</span></span><br><span class="line">    Silense,<span class="comment">//沉默</span></span><br><span class="line">    ArthurMark,<span class="comment">//Arthur1技能的标记伤害Buff</span></span><br><span class="line">    HPCure,<span class="comment">//治疗</span></span><br><span class="line">    MoveSpeed_DynamicGroup,<span class="comment">//Arthur1技能的动态群体移速Buff</span></span><br><span class="line">    MoveAttack,<span class="comment">//移动攻击</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buff位置确定方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StaticPosTypeEnum &#123;</span><br><span class="line">    None,</span><br><span class="line">    SkillCasterPos,<span class="comment">//Buff所属技能施放者的位置</span></span><br><span class="line">    SkillLockTargetPos,<span class="comment">//Buff所属技能锁定目标的位置</span></span><br><span class="line">    BulletHitTargetPos,<span class="comment">//子弹命中目标的位置</span></span><br><span class="line">    UIInputPos,<span class="comment">//UI输入位置信息，比如后裔2技能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buff附着目标</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AttachTypeEnum &#123;</span><br><span class="line">    None,</span><br><span class="line">    Caster,<span class="comment">//由施术者自己确定：给自己，Arthur的1技能加速buff</span></span><br><span class="line">    Indie,<span class="comment">//由施术者自己确定：区域，Arthur大招(位置固定)产生的持续范围伤害</span></span><br><span class="line">    </span><br><span class="line">    Target,<span class="comment">//由受击者确定：给目标，Arthur的1技能沉默buff</span></span><br><span class="line">    Bullet,<span class="comment">//由受击者确定：Houyi大招命中(位置动态)目标时产生的范围伤害</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BuffCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ------------属性------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffId;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐buff类型，用来创建不同类型的buff</span></span><br><span class="line">    <span class="keyword">public</span> BuffTypeEnum buffType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐buff附着目标</span></span><br><span class="line">    <span class="keyword">public</span> AttachTypeEnum attacher;</span><br><span class="line">    <span class="keyword">public</span> StaticPosTypeEnum staticPosType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buff作用目标，如果为null默认影响附着对象</span></span><br><span class="line">    <span class="keyword">public</span> TargetCfg impacter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------效果相关------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffDelay;</span><br><span class="line">    <span class="comment">// ⭐buff效果触发频率(比如持续1秒1次) </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffInterval;</span><br><span class="line">    <span class="comment">// ⭐buff持续时间（不包含delay）0：生效1次，-1：永久生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffDuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------配置------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffAudio;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffEffect;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> hitTickAudio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buff类"><a href="#Buff类" class="headerlink" title="Buff类"></a>Buff类</h2><p>使用关系：</p><p>正常一种类得buff有 <code>xxBuff类 and xxBuffCfg类</code>，xxBuffCfg拥有该buff特有的属性，xxBuff会包含xxBuffCfg在初期化通过ResSvc加载获取它。</p><p>继承关系：</p><ul><li>xxBuff &lt; Buff &lt; SubLogicUnit &lt; LogicUnit</li><li>xxBuffCfg &lt; BuffCfg</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Buff</span> : <span class="title">SubLogicUnit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff附着单位</span></span><br><span class="line">    <span class="keyword">public</span> MainLogicUnit owner;</span><br><span class="line">    <span class="keyword">public</span> BuffCfg cfg;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> buffId;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">object</span>[] args;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 群体buff作用目标列表</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;MainLogicUnit&gt; targetList;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        cfg = ResSvc.Instance().GetBuffConfigById(buffId);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">base</span>.LogicInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicTick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.LogicTick();</span><br><span class="line">        <span class="keyword">switch</span>(unitState) &#123;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.Start:</span><br><span class="line">                Start();</span><br><span class="line">                <span class="comment">// buffDuration: buff持续时间（不包含delay）0：生效1次，-1：永久生效</span></span><br><span class="line">                <span class="comment">// 根据buffDuration来切换状态，永久or循环的切换到Tick，生效1次得直接进入End状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.Tick:</span><br><span class="line">                <span class="comment">// 频率触发型buff需要按照频率来Tick，比如点燃</span></span><br><span class="line">                <span class="keyword">if</span>(cfg.buffInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tickCount += Configs.ServerLogicFrameIntervelMs;</span><br><span class="line">                    <span class="keyword">if</span>(tickCount &gt;= cfg.buffInterval) &#123;</span><br><span class="line">                        tickCount -= cfg.buffInterval;</span><br><span class="line">                        Tick();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// 根据服务器所规定得逻辑帧得时长，来进行每一次循环得时长计算</span></span><br><span class="line">                durationCount += Configs.ServerLogicFrameIntervelMs;</span><br><span class="line">                <span class="keyword">if</span>(durationCount &gt;= buffDuration &amp;&amp; buffDuration != <span class="number">-1</span>) &#123;</span><br><span class="line">                    unitState = SubUnitState.End;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Tick</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用于替换技能的特别buff"><a href="#用于替换技能的特别buff" class="headerlink" title="用于替换技能的特别buff"></a>用于替换技能的特别buff</h2><p>前面提到的亚瑟技能1实现得具体buff，进行技能之间的替换</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommonModifySkillBuffCfg</span> : <span class="title">BuffCfg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> originalID;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> replaceID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommonModifySkillBuff</span> : <span class="title">Buff</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> originalID;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> replaceID;</span><br><span class="line">    <span class="keyword">private</span> Skill modifySkill;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.LogicInit();</span><br><span class="line">        <span class="comment">// Cfg给originalID、replaceID赋值，owner.SkillArr找到对应技能给modifySkill赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        <span class="comment">// 开始时替换</span></span><br><span class="line">        modifySkill.ReplaceSkillCfg(replaceID);</span><br><span class="line">        modifySkill.SpellSuccCallback += ReplaceSkillReleaseDone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReplaceSkillReleaseDone</span>(<span class="params">Skill skillReleased</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(skillReleased.cfg.isNormalAttack) &#123;</span><br><span class="line">            unitState = SubUnitState.End;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1.如果上次成功释放普攻就会被Skill.SpellSuccCallback()调用到这里</span></span><br><span class="line">    <span class="comment">// 情况2.如果buff时间过了，会在Buff.LogicTick()中得计时结束进入End状态被调用到这里</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.End();</span><br><span class="line">        <span class="comment">// 结束时替换回来</span></span><br><span class="line">        modifySkill.ReplaceSkillCfg(originalID);</span><br><span class="line">        modifySkill.SpellSuccCallback -= ReplaceSkillReleaseDone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技能替换得接口：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skill</span>&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 技能替换，其实就是把Skill构造时做的事重做一遍</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReplaceSkillCfg</span>(<span class="params"><span class="built_in">int</span> replaceId</span>)</span> &#123;</span><br><span class="line">        skillCfg = ResSvc.Instance().GetSkillConfigById(replaceId);</span><br><span class="line">        spellTime = skillCfg.spellTime;</span><br><span class="line">        skillTime = skillCfg.skillTime;</span><br><span class="line">        <span class="keyword">if</span>(skillCfg.isNormalAttack) &#123;</span><br><span class="line">            owner.InitAttackSpeedRate(<span class="number">1000</span> / skillTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="人物状态：沉默、眩晕、击飞"><a href="#人物状态：沉默、眩晕、击飞" class="headerlink" title="人物状态：沉默、眩晕、击飞"></a>人物状态：沉默、眩晕、击飞</h2><p>比如亚瑟1技能的沉默，技能是附加了沉默buff，buff那块只要对 英雄/小兵 脚本的对应字段进行改变就行了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单体沉默buff：亚瑟技能1附带的buff</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SilenseBuff_Single</span>: <span class="title">Buff</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        owner.SilenceCount += <span class="number">1</span>;<span class="comment">//1秒沉默</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.End();</span><br><span class="line">        owner.SilenceCount -= <span class="number">1</span>;<span class="comment">//buff.duration字段设置了为1秒，所以1秒后会执行这句，沉默期结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 英雄/小兵 的接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> MainLogicAttributes</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainLogicUnit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -------------沉默：沉默时无法施放技能-------------</span></span><br><span class="line">    <span class="built_in">int</span> silenceCount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SilenceCount &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> silenceCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            silenceCount = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">if</span>(IsSilenced()) &#123;</span><br><span class="line">                <span class="comment">// 1.进入沉默状态并触发OnStateChange</span></span><br><span class="line">                OnStateChange?.Invoke(StateEnum.Silenced, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                OnStateChange?.Invoke(StateEnum.Silenced, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">IsSilenced</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> silenceCount != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的接口是 OnStateChange += UpdateState，看下UpdateState代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainViewUnit</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateState</span>(<span class="params">StateEnum state, <span class="built_in">bool</span> show</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(state == StateEnum.Knockup</span><br><span class="line">           || state == StateEnum.Silenced</span><br><span class="line">           || state == StateEnum.Silenced) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mainLogicUnit.IsPlayerSelf() &amp;&amp; show) &#123;</span><br><span class="line">                playWindow.SetAllSkillForbidState();<span class="comment">// 禁止所有技能的点击</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hpWindow.SetStateInfo(mainLogicUnit, state, show);<span class="comment">// 在ui血条上显示状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为目标标记上受击标记"><a href="#为目标标记上受击标记" class="headerlink" title="为目标标记上受击标记"></a>为目标标记上受击标记</h2><p>其实就是MarkBuff，类似于亚瑟技能1的标记buff：标记目标，持续5秒，技能和普攻会对标记目标可额外造成目标最大生命1%的伤害。</p><p>使用对<strong>Onhurt事件</strong>委托链添加委托实现。</p><p>调用回溯：from serive &gt; InputKey() &gt; MainLogicSkill.InputSkillKey() &gt;Skill.ReleaseSkill() &gt; Skill.CalcSkillAttack() &gt; Skill.HitTarget() &gt;target.CreateSkillBuff() &gt; ArthurMarkBuff new()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArthurMarkBuffCfg</span> : <span class="title">BuffCfg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damagePct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArthurMarkBuff</span> : <span class="title">Buff</span></span><br><span class="line">&#123;</span><br><span class="line">    PEInt damagePct;</span><br><span class="line">    MainLogicUnit target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.LogicInit();</span><br><span class="line"></span><br><span class="line">        ArthurMarkBuffCfg ambc = cfg <span class="keyword">as</span> ArthurMarkBuffCfg;</span><br><span class="line">        damagePct = ambc.damagePct;</span><br><span class="line">        target = skill.lockTarget; <span class="comment">// 为target赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        target.OnHurt += GetHurt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetHurt</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        target.GetDamageByBuff(damagePct / <span class="number">100</span> * target.ud.unitCfg.hp, <span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.End();</span><br><span class="line">        target.OnHurt -= GetHurt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为目标标记一个立场标记，友军群体加速"><a href="#为目标标记一个立场标记，友军群体加速" class="headerlink" title="为目标标记一个立场标记，友军群体加速"></a>为目标标记一个立场标记，友军群体加速</h2><p>亚瑟技能1标记，会让附近 range&lt;5f 的友军会增加10%的移速。这像是一个立场，需要按照服务端的逻辑帧逐帧计算敌人是否在范围内从而为其加速。</p><p>核心是维护一个targetList：使用类似于前面写的<strong>通用的寻找目标实现</strong>查找算法，逐帧计算附近 range&lt;5f 的对象，将其加入到targetList队列中。</p><p>下面对Buff整体生命流程中，仅对于核心targetList的处理与使用进行展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveSpeedBuff_DynamicGroup</span>: <span class="title">Buff</span> &#123;</span><br><span class="line">    <span class="comment">// 设定的buff加速量，亚瑟技能1标记buff为10%</span></span><br><span class="line">    <span class="keyword">private</span> PEInt speedOffset;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        targetList = <span class="keyword">new</span> List&lt;MainLogicUnit&gt;();</span><br><span class="line">        targetList.AddRange(CalcRule.FindMulipleTargetByRule(owner, cfg.impacter, skill.skillArgs)); <span class="comment">// 开始时计算目标队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ModifyTargetsMoveSpeed(speedOffset, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ModifyTargetsMoveSpeed(-speedOffset);</span><br><span class="line"></span><br><span class="line">        targetList.Clear();</span><br><span class="line">        targetList.AddRange(CalcRule.FindMulipleTargetByRule(owner, cfg.impacter, CodingKVector3.zero)); <span class="comment">// 逐帧计算目标队列</span></span><br><span class="line">        ModifyTargetsMoveSpeed(speedOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ModifyTargetsMoveSpeed(-speedOffset);</span><br><span class="line">        targetList.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyTargetsMoveSpeed</span>(<span class="params">PEInt <span class="keyword">value</span>, <span class="built_in">bool</span> showJump = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// targetList =&gt; Move speed up</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动寻找目标攻击的通用buff"><a href="#自动寻找目标攻击的通用buff" class="headerlink" title="自动寻找目标攻击的通用buff"></a>自动寻找目标攻击的通用buff</h2><p>实现功能示意图：</p><p><img src="C:\Users\YAN\AppData\Roaming\Typora\typora-user-images\image-20220104233959056.png" alt="image-20220104233959056"></p><p>部分代码演示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buff配置</span></span><br><span class="line"><span class="keyword">var</span> MoveAttackBuff = <span class="keyword">new</span> BuffCfg()  &#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通用buff属性</span></span><br><span class="line">    buffId = <span class="number">999999</span>,</span><br><span class="line">    buffName = <span class="string">&quot;移动攻击&quot;</span>,</span><br><span class="line">    buffType = BuffTypeEnum.MoveAttack,</span><br><span class="line"></span><br><span class="line">    attacher = AttachTypeEnum.Caster,<span class="comment">// buff附着给自己</span></span><br><span class="line">    impacter = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    buffDelay = <span class="number">0</span>,</span><br><span class="line">    buffInterval = <span class="number">66</span>,<span class="comment">// 1帧检测1次</span></span><br><span class="line">    buffDuration = <span class="number">5000</span>,<span class="comment">// 单次持续时间</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Buff逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveAttackBuff</span>: <span class="title">Buff</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找算法示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220104231802.png"></p><h2 id="后裔的被动技能"><a href="#后裔的被动技能" class="headerlink" title="后裔的被动技能"></a>后裔的被动技能</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112225127.png"></p><h3 id="普攻成功后增加攻速"><a href="#普攻成功后增加攻速" class="headerlink" title="普攻成功后增加攻速"></a>普攻成功后增加攻速</h3><p>后裔被动，每次平砍增加5%攻速，最高3次，持续3秒。如果释放2、3技能（1技能强化普攻可以）就直接失效。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HouyiPasvAttackSpeedBuffCfg</span> : <span class="title">BuffCfg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> overCount;<span class="comment">// 叠加层数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> speedAddtion;<span class="comment">// 加成百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> resetTime;<span class="comment">// 重置周期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buff代码就不贴了，具体逻辑是 buff类 给技能释放成功的回调注册一个事件，事件实现技能效果。</p><h3 id="普攻3次后变成3连击"><a href="#普攻3次后变成3连击" class="headerlink" title="普攻3次后变成3连击"></a>普攻3次后变成3连击</h3><p>由于技能会跳转（如图），所以不能使用前面制作的替换技能buff，那个太简单了。</p><h1 id="Bullet-1"><a href="#Bullet-1" class="headerlink" title="Bullet"></a><Center>Bullet<Center/></h1><h2 id="SweepVolume-体积扫描检测"><a href="#SweepVolume-体积扫描检测" class="headerlink" title="SweepVolume 体积扫描检测"></a>SweepVolume 体积扫描检测</h2><p>用于逻辑帧计算子弹是否命中用的。记录上一帧的位置，与这一帧的位置连线，它的轨迹是一个矩形（粉色），查看矩形是否穿过目标碰撞体（蓝色），也就是矩形与圆形求相交的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220111220103.png"></p><ol><li>计算 AB中点位置 = (LogicPos + lastPos) / 2</li><li>计算 向量A-&gt;B = LogicPos - lastPos</li><li>由1与2模拟出 矩形碰撞体CodingKBoxCollider</li><li>由3创建出的矩形，与目标的 圆形碰撞体CodingKCylinderCollider 进行</li></ol><p>具体怎么创建碰撞体，是自制的定点数物理碰撞计算库，在其他文章中详解。</p><h3 id="Debug-弹道显示方案"><a href="#Debug-弹道显示方案" class="headerlink" title="Debug 弹道显示方案"></a>Debug 弹道显示方案</h3><p>想要debug看到弹道规矩，可以在每一个Tick里创建一个Cube模拟矩形，也就是子弹轨迹。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112000119.png"></p><h2 id="子弹Config"><a href="#子弹Config" class="headerlink" title="子弹Config"></a>子弹Config</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BulletCfg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> BulletTypeEnum bulletType;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> bulletName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> resPath;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletSpeed;<span class="comment">//运算时转换为PEInt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletHeight;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletOffset;<span class="comment">//画面表现用的偏移值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> bulletDelay;<span class="comment">//释放延迟 ms</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> canBlock;<span class="comment">//技能是否不能穿透</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TargetCfg impacter;<span class="comment">//目标类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> bulletDuration;<span class="comment">//持续时间(不含bulletDelay)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BulletTypeEnum &#123;</span><br><span class="line">    UIDirection,<span class="comment">//ui指定方向</span></span><br><span class="line">    UIPosition,<span class="comment">//ui指定位置</span></span><br><span class="line">    SkillTarget,<span class="comment">//当前技能目标(锁定目标技能)</span></span><br><span class="line">    BuffSearch,<span class="comment">//靠近物体自动寻找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现子弹曲线"><a href="#实现子弹曲线" class="headerlink" title="实现子弹曲线"></a><Center>实现子弹曲线<Center/></h1><h2 id="图像分解"><a href="#图像分解" class="headerlink" title="图像分解"></a>图像分解</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220115100853.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220115101025.png"></p><p>![image-20220115105710617](C:\Users\YAN JUNJIE\AppData\Roaming\Typora\typora-user-images\image-20220115105710617.png)</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>我 -&gt; 目标 连线的向量，是最初的弹道向量，也就是一开始的红色向量。</p><p>对 最初的弹道向量 + 我的中心点，可以取出一个唯一的<strong>垂直平面</strong>，对这个垂直平面上，以我的中心点为起始点，任取一个<strong>模（偏移量）</strong>数值随机的向量，作为偏移向量，也就是绿箭头。</p><p>绿箭头的模确定后就不再改变，持续施加，称作<strong>固定值影响向量</strong>。</p><p>而红色向量始终指向目标，所以会不停改变方向，称作<strong>方向矫正向量</strong>。</p><p>最终，使用 固定值影响向量、方向矫正向量 的向量之和，也就是某个时间点下<strong>子弹的方向向量</strong>了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实际就并不取用这么复杂过程了。</p><h3 id="①-固定值影响向量"><a href="#①-固定值影响向量" class="headerlink" title="① 固定值影响向量"></a>① 固定值影响向量</h3><p>取 我-&gt;目标 的向量 + 我的up方向向量 的叉乘<strong>Cross</strong>向量，然后规格化，就得到了准确的方向向量。</p><p>想要往上，只要对结果添加up方向上的向量就可以。当然，这需要一个随机数。</p><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>因为同步问题，不能只使用随机，所以通过<strong>传播随机种子</strong>来确定性地随机，让多个端末都能正确计算出同样的效果。</p><p>然后再偷个懒，种子也不传播了，固定666。</p><h1 id="Bug-amp-QA"><a href="#Bug-amp-QA" class="headerlink" title="Bug &amp; QA"></a><Center>Bug &amp; QA<Center/></h1><h2 id="移动攻击Bugs"><a href="#移动攻击Bugs" class="headerlink" title="移动攻击Bugs"></a>移动攻击Bugs</h2><p>1.<strong>攻击动画没播放</strong>是因为移动攻击时方向变更，导致动画状态立即恢复“free”从而导致攻击动画被跳过了。</p><p>解决方案是方向变更时，将<strong>是否在技能前摇</strong>flag一起加入判定条件，来决定是否变化动画。</p><p>2.<strong>人物朝向没变化</strong>也是因为方向被UI输入朝向重制了，关键是看ViewUnit.viewTargetDir属性。</p><p>解决方案一样，将<strong>是否在技能前摇</strong>flag作为判定条件来决定是否根据UI改变朝向。</p><p>3.<strong>移动攻击时会滑动</strong>是因为UI输入方向被服务端传来的最新UI移动请求给覆盖了，关键看MainLogic.InputDir属性。</p><p>解决方案是在接收到服务端传来的最新UI移动请求时，进行<strong>是否在技能前摇、是否被控制</strong>flag作为判定条件来决定是否改变InputDir。</p><p>4.<strong>移动攻击完会僵直平移一段距离</strong>是因为技能前摇时有一个定时器，根据技能总时长来将角色设回“free”动画。</p><p>解决方案是在收到服务器逻辑方向改变请求改变LogicUnit.LogicDir属性时，将过去的定时器动画Callback都清除掉。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#精要 - 堆栈篇</title>
      <link href="/Tech/CSharp/Essence/stack/"/>
      <url>/Tech/CSharp/Essence/stack/</url>
      
        <content type="html"><![CDATA[<h1 id="先说一下什么是栈？"><a href="#先说一下什么是栈？" class="headerlink" title="先说一下什么是栈？"></a>先说一下什么是栈？</h1><p>数据结构中的栈是一种先进后出的数据结构。</p><p>在C#的内存中有用到栈结构，一个线程拥有一个大概<strong>1mb的线程栈</strong>。一般拿来存放引用指针、值类型、方法的局部变量和实参等。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>栈是一种内存自我管理的结构，压栈自动分配内存，出栈自动清空所占内存。</p><p>但因此栈只能在一端对数据进行操作，也就是栈顶端进行操作。</p><h2 id="方法调用与线程栈"><a href="#方法调用与线程栈" class="headerlink" title="方法调用与线程栈"></a>方法调用与线程栈</h2><p>方法的调用追踪就是在栈上完成的。比如我们有一个main方法（程序入口）， 在main方法中会调用一个GetPoint的方法。在线程执行时，会将main方法压入栈底（包括编译好的方法指令，参数，和方法内部变量），然后再将GetPoint的方法压入栈底，GetPoint中没有调用其它方法，压栈完毕。出栈顺序是先进后出，也就是后进先出，栈顶的方法GetPoint先执行完毕，然后出栈，所占内存清空，接着main方法执行后出栈，所占内存清空。</p><h1 id="再说一下什么是堆？"><a href="#再说一下什么是堆？" class="headerlink" title="再说一下什么是堆？"></a>再说一下什么是堆？</h1><p>数据结构中的堆，是用数组实现的二叉树，所以它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。</p><p>CLR的堆是和栈对立的内存概念，而不是二叉树。一个程序用一个<strong>托管堆</strong>。托管堆一般拿来存放实例对象。</p><h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><p>相比栈只能在一端操作，堆中的数据可以随意存取。</p><p>因此堆的内存回收不是自我管理的，所以.NET推出了GC来管理堆内存。这里不展开GC。</p><h1 id="说一下堆栈的协作？"><a href="#说一下堆栈的协作？" class="headerlink" title="说一下堆栈的协作？"></a>说一下堆栈的协作？</h1><p>1.当创建一个值类型时，CLR直接为其分配一个空间，这个空间<strong>分配在变量创建的地方</strong>：</p><ul><li>  如果值类型是在方法内部创建，则跟随方法入栈，分配到栈上存储。</li><li>  如果值类型是引用类型的成员变量，则跟随引用类型，存储在堆上。</li></ul><p>2.当创建一个引用类型时，CLR会<strong>在堆上分配对象，在栈上分配指针</strong>。</p><h1 id="方法运行流程与堆栈？"><a href="#方法运行流程与堆栈？" class="headerlink" title="方法运行流程与堆栈？"></a>方法运行流程与堆栈？</h1><p>执行一个方法比如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">     Test(x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> y</span>)</span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.id = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.进来这个方法的时候会将 方法的返回地址、方法体内的局部变量 都压入栈。</p><p>2.在方法内再遇到方法的时候，同样会做1一样的事：将此方法的返回地址、方法体内的局部变量压入栈。</p><p>3.执行完内部方法（return）后，CPU指令指针返回到记录的返回地址上，继续执行外部代码。</p><p>4.如果方法内遇到new对象的情况，会在堆中申请对象，然后栈上会有一个指向对象的指针。</p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>简单点说就是一个栈的暂时状态，它反映着进入方法前的栈内状态。进入某方法前会执行上面说的一系列操作，退出这个方法后，会展开栈帧，回到进来前的运行状态 和 代码执行位置（CPU指向）。</p><h2 id="序幕代码"><a href="#序幕代码" class="headerlink" title="序幕代码"></a>序幕代码</h2><p>也就是步骤1、2做的事，将方法内部的局部变量、参数、和返回地址压入栈。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> C#精要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 模型控制篇</title>
      <link href="/Project/Unity/Moba/HOK/chara/"/>
      <url>/Project/Unity/Moba/HOK/chara/</url>
      
        <content type="html"><![CDATA[<h1 id="模型预处理"><a href="#模型预处理" class="headerlink" title="模型预处理"></a>模型预处理</h1><p>淘宝、网上资源搞到的人物FBX，全都是一个FBX对应一个动作或者集成在一起。所以需要预先处理一下，这里记录过程。</p><p>最终的目的是一个model里带有所有的animation clip动作。因为直接用代码调用播放动画，所以也不需要动画状态机。</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>导入之后，先把动画模式改成Legacy。</p><h2 id="动作未切片"><a href="#动作未切片" class="headerlink" title="动作未切片"></a>动作未切片</h2><p>如果动画clip没有处理，那就自己在Animation里给动作切片就行。</p><h2 id="一个fbx对应一个切片"><a href="#一个fbx对应一个切片" class="headerlink" title="一个fbx对应一个切片"></a>一个fbx对应一个切片</h2><p>这类资源其实蛮麻烦的，需要在场景里拖拽任意一个带动作的model，然后把他作为新的prefab，才能对它的fbx进行编辑。</p><p>之后先把其他<strong>FBX动画模式改成Legacy</strong>！！！这点很重要，否则后面动作用不了的。</p><p>最后把其他fbx文件的animation clip用 ctrl+d 拷贝出来，拖到前面做的prefab的animation里，就可以了。</p><h2 id="切片规范"><a href="#切片规范" class="headerlink" title="切片规范"></a>切片规范</h2><p>切片时长最好是要统一的，比如普攻随机动画总时长必须统一。还有诸如死亡动画。技能动画则不用。</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/CCWSK%7BYP%7B84GU$HY1FF1VVM.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220313110354.png"></p><h1 id="人物模型"><a href="#人物模型" class="headerlink" title="人物模型"></a>人物模型</h1><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211124221502.png"></p><p><strong>主要内容</strong></p><ul><li>Arthur： 主节点，用来控制角色的位置移动。</li><li>arthur： Model，内附人物骨骼等，用来控制角色的旋转。</li><li>hitpoint： 受伤动画弹出点。</li><li>point： 用来显示各种动画的中心点，比如亚瑟的盾buff围绕这个点旋转而不是arthur的某点，因为arthur旋转，buff的动画也会跟着转！</li><li>HPRoot： 血条显示位置。</li><li>skillRange： 攻击范围。</li></ul><h3 id="玩家UI面板控制"><a href="#玩家UI面板控制" class="headerlink" title="玩家UI面板控制"></a>玩家UI面板控制</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211128225437.png"></p><p><strong>InfoRoot</strong></p><ul><li>取消技能。</li></ul><p><strong>SkillRoot</strong></p><ul><li>imgSka：普攻按钮。</li><li>imgSk1：技能1按钮，只举例一个技能。</li><li>imgInfoRoot：被动技能图标（也许是个buff），无点击事件，只有cd。</li><li>imgSk1-frame：技能背景盘。</li><li>imgSk1-imgPoint：控制技能释放方向的拖拽点。</li><li>imgSk1-imgForbid：技能暂时无法使用，比如被晕眩状态。</li><li>imgSk1-imgCD、txtCD：技能cd显示。</li><li>imgSk1-ClickEffect：技能点击特效</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR Via C#个人笔记4 - 类型和成员基础</title>
      <link href="/Tech/CSharp/CLR-Via-CSharp/cp4/"/>
      <url>/Tech/CSharp/CLR-Via-CSharp/cp4/</url>
      
        <content type="html"><![CDATA[<h1 id="大章6：类型和成员基础"><a href="#大章6：类型和成员基础" class="headerlink" title="大章6：类型和成员基础"></a><center>大章6：类型和成员基础</center></h1><h3 id="类型的各种成员"><a href="#类型的各种成员" class="headerlink" title="类型的各种成员"></a>类型的各种成员</h3><ul><li>常量（大章7）  数据值恒定不变的符号。<code>public const bool isBoy = true;</code></li><li>字段（大章7）  </li><li>实例构造器（大章8）</li><li>类型构造器（大章8）  是将类型的静态字段初始化为良好初始状态的特殊方法。<code>static ClassName() &#123;&#125;</code></li><li>方法（大章8）  更改或查询类型或对象状态的函数。分静态方法和实例方法。</li><li>操作符重载（大章8）  实际是方法，由于不是所有编程语言都支持操作符重载，所以它不是CLS(公共语言规范) 的一部分。</li><li>转换操作符（大章8）  是定义如何隐式或显式将对象从一种类型转型为另一种类型的方法。同操作符重载，由于不是所有编程语言都支持，所以它不是CLS(公共语言规范) 的一部分。</li><li>属性（大章10）  可以无参，也可以多参。<code>public Int32 this[String s]&#123;get;set;&#125; // 实例有参属性(索引器)</code></li><li>事件（大章11）  <code>public event EventHandler SomeEvent; // 实例事件</code></li><li>类型  可以定义其他嵌套类型。通常用这个办法将大的类型分解成更小的构建单元（building block）以实现简化。</li></ul><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>无论什么编程语言，编译器都必须能处理源代码，为上述成员生成元数据和IL代码，所有编程语言的生成的元数据格式完全一致。<font color="#dd0000">元数据</font>是所有语言都生成和使用的公共信息，是它使不同基于CLR的语言的代码无缝访问。</p><p>下面看一下元数据到底是怎么定义的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SomeType</span>&#123;<span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 嵌套类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">SomeNestedType</span>&#123;&#125;<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量、只读和静态可读/可写字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> Int32 c_SomeConstant = <span class="number">1</span>;<span class="comment">// 3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> String m_SomeReadOnlyField = <span class="string">&quot;2&quot;</span>;<span class="comment">// 4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Int32 s_SomeReadWriteField = <span class="number">3</span>;<span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型构造器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">SomeType</span>(<span class="params"></span>)</span> &#123;&#125;<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params">Int32 x</span>)</span> &#123;&#125;  <span class="comment">// 7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"></span>)</span> &#123;&#125;<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法和静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">InstanceMethod</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;<span class="comment">// 9</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;&#125;<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例属性</span></span><br><span class="line"><span class="keyword">public</span> Int32 SomeProp&#123;<span class="comment">// 11</span></span><br><span class="line"><span class="keyword">get</span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;<span class="comment">// 12</span></span><br><span class="line"><span class="keyword">set</span>&#123;&#125;<span class="comment">// 13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例有参属性（索引器）</span></span><br><span class="line"><span class="keyword">public</span> Int32 <span class="keyword">this</span>[String s]&#123;<span class="comment">// 14</span></span><br><span class="line"><span class="keyword">get</span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;<span class="comment">// 15</span></span><br><span class="line"><span class="keyword">set</span>&#123;&#125;<span class="comment">// 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler SomeEvent;<span class="comment">// 17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>希望能回头看看这个例子，体会成员是如何定义的，他们对编译器生成的元数据有何影响。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211118184048.png"></p><h3 id="类型的可见性"><a href="#类型的可见性" class="headerlink" title="类型的可见性"></a>类型的可见性</h3><p>可见性，只是针对类说的，而不是字段。</p><ul><li><p>public class  全部可见</p></li><li><p>internal class  程序集内可见，如果不定义可见性，默认就是internal</p></li></ul><p><strong>友元程序集(friend assembly)</strong><br>是为了让两个不同程序集之间能相互公开，而对外不公开的一种技术支持。利用<code>InternalsVisibleTo</code>特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;<span class="comment">// 为了InternalsVisibleTo特性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥为“12345678...90abcdef”的友元程序集“AssemblyMySchool”</span></span><br><span class="line">[<span class="meta">assembly:InternalsVisibleTo(<span class="meta-string">&quot;AssemblyMySchool,PublicKey=12345678...90abcdef&quot;</span>)</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元集访问下类时，会如同访问public一样</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Student</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="成员的可访问性"><a href="#成员的可访问性" class="headerlink" title="成员的可访问性"></a>成员的可访问性</h3><p>可访问性，是针对字段说的，但是如果类不可见，哪怕是可访问的也访问不到。</p><ul><li>private  =&gt;  CLR:Private</li><li>protected  =&gt;  CLR:Family</li><li>不支持  =&gt;  CLR:Family Ana Assembly</li><li>internal  =&gt;  CLR:Assembly</li><li>protected internal  =&gt;  CLR:Family or Assembly</li><li>public  =&gt;  CLR:Public</li></ul><p>派生类重写基类型定义的成员时，<font color="#dd0000">C#要求必须是相同的可访问性</font>。比如父类protected，子类也必须是protected。但是CLR并没有这么严格，它要求重写方法可以放宽限制，比如从protected到public，但不可以缩紧比如从protected到private。之所以这样因为CLR承诺派生类总能转型为基类，并获取对基类方法的访问权。</p><h3 id="静态类-static"><a href="#静态类-static" class="headerlink" title="静态类 static"></a>静态类 static</h3><ul><li>是指永远不需要实例化的类，比如Console、Math。</li><li>静态类只有static成员，且static关键字只能修饰类、不能修饰值类型，因为CLR总是允许值类型实例化。</li><li>静态类必须从基类System.Object派生。</li><li>静态类不能实现任何接口。这是因为只有使用类的实例时，才可调用类的接口方法。</li></ul><p>在IL代码中，会把static类标记为abstract和sealed，且不会为其生成实例构造器方法。</p><h3 id="分布类-partial"><a href="#分布类-partial" class="headerlink" title="分布类 partial"></a>分布类 partial</h3><p><strong>partial关键字</strong></p><p>partial关键字告诉C#编译器，类、结构或接口的定义源代码可能要分散到一个或多个源代码文件中。</p><ul><li>多人协作。可以将类型的代码分散到多个源代码文件中，每个文件都可单独check out 或 merge。</li><li>结构清晰。在同一个文件中将类或结构分解成不同的逻辑单元，比如一部分写需求A一部分写需求B，这样注释修改会更容易。</li><li>代码生成。通过工具新生成的代码，不需要去原有类里写，新起一个文件类名相同新增即可。更符合开放-封闭原则。</li></ul><h3 id="组件化开发和版本控制（虚实调用、virtual、new）"><a href="#组件化开发和版本控制（虚实调用、virtual、new）" class="headerlink" title="组件化开发和版本控制（虚实调用、virtual、new）"></a>组件化开发和版本控制（虚实调用、virtual、new）</h3><p><strong>组件化开发</strong></p><p>组件软件编程（Component Software Programming）正是面向对象编程发展到极致的成果。</p><ul><li>组件（程序集）是独立的，且有自己的标识，比如名称和版本号。</li><li>组件必须指定它需要的安全权限。</li><li>组件要对外公布接口，这些接口不应随着版本迭代而导致外部的用法改变。</li></ul><p>如果无法想象，就直接想象第三方dll。</p><p><strong>CLR调用方法虚方法</strong></p><p>IL提供2种指令去调用方法</p><p>call </p><ul><li>可用于调用实例方法、虚方法和静态方法。</li><li>假定该变量不为null，如果变量的类型没有定义该方法，就检查基类型来查找匹配方法。</li><li>call指令常用于以非虚方式调用虚方法。</li><li>对于代码来说，<code>Object o = new Point()</code>会根据<font color="#dd0000">申明类型</font>Object来确定。</li></ul><p>callvirt</p><ul><li>可用于调用实例方法和虚方法。</li><li>一定会进行null检查，因为会check null，所以callvirt的执行速度会比call慢一些。</li><li>callvirt调用虚实例方法，CLR调查发出调用的对象的实际类型，然后以多态方式调用方法。</li><li>对于代码来说，<code>Object o = new Point()</code>会根据<font color="#dd0000">实际类型</font>Point来确定。</li></ul><p>看一个调用例子</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">Console.WriteLine();    <span class="comment">//IL_1:call void System.Console::WriteLine()</span></span><br><span class="line">Object o = <span class="keyword">new</span> Object();<span class="comment">//IL:newobj instance void System.Object::.ctor()</span></span><br><span class="line">o.GetHashCode();        <span class="comment">//IL_2:callvirt instance int32 System.Object::GetHashCode()</span></span><br><span class="line">o.GetType();            <span class="comment">//IL_3:callvirt class System.Object::GetType()</span></span><br></pre></td></tr></table></figure><p>IL_1 是call，很好理解，静态方法调用。<br>IL_2 是callvirt，不难想，因为GetHashCode是虚方法。<br>IL_3 是callvirt，这个比较难，因为定义是<code>public Type GetType()</code>根本不是虚方法。</p><p>但这是可行的，因为对代码进行JIT编译时，CLR知道GetType不是虚方法，所以JIT编译好的代码中，会直接以非虚方式（就是直接找申明类型，不找对象指针了）调用GetType。<br>那么，为什么C#不干脆直接生成call指令呢？<br>C#团队认为，JIT编译器应生成代码来验证发出调用的对象不为null。</p><p>// TODO 为什么必须用callvirt调用 p147</p><p>综上所属，设计类的时候，最好减少虚方法的数量：</p><ul><li>上面说过了，调用虚方法的速度比非虚方法慢</li><li>JIT编译器不能内嵌（inline）虚方法，这进一步影响性能</li><li>虚方法使组件版本控制变得更脆弱</li></ul><p>正确的做法是：</p><blockquote><p>将最复杂的方法作为虚方法，使所有重载的简便方法成为非虚方法。</p></blockquote><p>具体如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Set</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个简便的重载方法是非虚的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params">Object val</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Find(val,<span class="number">0</span>,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个简便的重载方法是非虚的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params">Object val,<span class="built_in">int</span> startIndex</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Find(val,<span class="number">0</span>,length - startIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能最丰富的方法是虚方法，可被重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params">Object val,<span class="built_in">int</span> startIndex,<span class="built_in">int</span> endIndex</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 可被重写的实现...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用可见性和可访问性</strong></p><p>一般实际应用的情况来说，开发人员使用第三方程序集的时候是看不到源码的，所以做程序集的时候就需要好好利用 可见性和可访问性 ，避免使用者开发人员出错。</p><ul><li>对于不需要特化或无法确定的新类型，要定义成密封类。1.因为更安全：不存在派生类修改其内部逻辑；2.更易于版本控制：密封类可以保持密封，非密封类无法改为密封，因为用户可能已经继承过这个类了。</li><li>对于确定需要特化、需要派生的类型，定义成public类对外暴露。</li><li>类的内部的数据字段，尽可能定义成private，不让外界中途修改。</li><li>类的内部的方法、属性、事件，定义成private和非虚。</li><li>类的内部的嵌套类型，要用private，不要对外公布而应该只在该类里使用。</li></ul><p><strong>new与override</strong></p><p>如果基类型和其派生类型有同名同参方法，但是想要指明新方法与基类型的同名方法无关，那么需要用到<font color="#dd0000">new关键字</font>。new关键字可以告诉编译器生成元数据，这同样CLR就知道到底调用的是哪个了。</p><p>比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span>:<span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Talk</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;A Talk&quot;</span>);</span><br><span class="line">OpenMouth();</span><br><span class="line"><span class="keyword">base</span>.Talk();<span class="comment">// 用了基类的同名方法！基类的Talk方法里调用了基类自己的OpenMouth方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">new</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OpenMouth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;A Open the Mouse&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行A.Talk();</span></span><br><span class="line"><span class="comment">// output line 1:A Talk</span></span><br><span class="line"><span class="comment">// output line 2:A Open the Mouse</span></span><br><span class="line"><span class="comment">// output line 3:B Talk</span></span><br><span class="line"><span class="comment">// output line 4:B Open the Mouse</span></span><br></pre></td></tr></table></figure><p>但如果想要替换、影响基类方法，那么就该使用<font color="#dd0000">override关键字</font>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span>:<span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OpenMouth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;A Open the Mouse&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行A.Talk();</span></span><br><span class="line"><span class="comment">// output line 1:B Talk</span></span><br><span class="line"><span class="comment">// output line 2:A Open the Mouse</span></span><br></pre></td></tr></table></figure><h1 id="大章7：常量和字段"><a href="#大章7：常量和字段" class="headerlink" title="大章7：常量和字段"></a><center>大章7：常量和字段</center></h1><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量，是指值从不变化的符号，它的值必须能在编译时确定。<br>确定后，编译器将常量值保存到程序集元数据中，这意味着常量只能定义成编译器识别的基元类型。<br>我们把<font color="#dd0000">const关键字</font>拿来写常量，且它不能和static关键字连用，因为常量总是隐式为static。<br>常量符号会直接嵌入应用程序的IL代码，如下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> Int32 MyNumMaxLength = <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 以下为对应调用的IL代码，可以看到直接是50而不是读取变量</span></span><br><span class="line">IL_0006: ldc.i4.s<span class="number">50</span></span><br></pre></td></tr></table></figure><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul><li><p>字段，是一种数据成员，其中容纳了一个值类型的实例或者对一个引用类型的引用。</p></li><li><p>字段存储于动态内存中，所以他们的值在运行时才能获取。</p></li><li><p>字段的内联（inline）是指 <code>public string x = &quot;A&quot; ;</code> 这种声明后紧跟赋值的用法。内联语法简化的只是语法，仍然是在构造器中赋值的。</p><p>​    </p></li></ul><table><thead><tr><th>C#术语</th><th>CLR术语</th><th>说明</th></tr></thead><tbody><tr><td>默认</td><td>Instance</td><td>该字段只与对象的一个实例关联，而不是与类型本身关联</td></tr><tr><td>static</td><td>Static</td><td>该字段是类型状态的一部分，而不是对象状态的一部分</td></tr><tr><td>readonly</td><td>InitOnly</td><td>该字段只能由一个构造器方法中的代码写入（但是可以通过反射修改）</td></tr><tr><td>volatile</td><td>Volatile</td><td>编译器、CLR和硬件不会对该字段执行“线程不安全”的优化措施</td></tr></tbody></table><p>readonly标记，限制的是让字段的引用不可改变，而其引用的对象是可以修改的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="title">List</span>&lt;<span class="title">int</span>&gt; readonlyList</span> = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;()&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Test.readonlyList.Add(<span class="number">4</span>);<span class="comment">// 修改引用的字段</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> line <span class="keyword">in</span> Test.readonlyList)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 1 2 3 4</span></span><br></pre></td></tr></table></figure><h1 id="大章8：方法"><a href="#大章8：方法" class="headerlink" title="大章8：方法"></a><center>大章8：方法</center></h1><h3 id="实例构造器-引用类型"><a href="#实例构造器-引用类型" class="headerlink" title="实例构造器(引用类型)"></a>实例构造器(引用类型)</h3><ul><li>构造器是将类型的实例初始化为良好状态的特殊方法。</li><li>构造器在“方法定义元数据表”种始终叫做 <code>.ctor</code>。</li><li>未被构造器构造的引用类型对象，其实例字段都是0或null。</li><li>构造器不可被继承，所以不能使用以下修饰符：virtual、new、override、sealed、abstract。</li></ul><p><strong>类自动实现的默认构造器</strong></p><ul><li>如果不写构造器的话，会默认生成：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeType</span>&#123; &#125;</span><br><span class="line"><span class="comment">/*--------等价于---------*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeType</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"></span>) : <span class="title">base</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果派生类没有显式调用基类的构造器，C#编译器会在自动生成对默认的基类构造器的调用。</p><p>自动生成的基类构造器，会在派生类构造器内部执行完所有字段初始化（如果你不给它们赋值，就会赋值default）后，再调用。下面贴的代码进一步理解。</p><p>有两种情况不会调用构造器而创建类型的实例，1是MemberwiseClone方法，2是序列化器反序列化对象。</p><p>以下纪录构造器的特殊写法，这样写可以让IL只自动生成一次代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeType</span>()&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> m_x;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">double</span> m_d;</span><br><span class="line"><span class="comment">// 通用构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">m_x = <span class="number">5</span>;</span><br><span class="line">m_d = <span class="number">3.11</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承通用构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"><span class="built_in">int</span> input</span>) : <span class="title">this</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">m_x = input;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"><span class="built_in">double</span> input</span>) : <span class="title">this</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">m_d = input;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例构造器-值类型"><a href="#实例构造器-值类型" class="headerlink" title="实例构造器(值类型)"></a>实例构造器(值类型)</h3><p>上面说了：<br>自动生成的基类构造器，会在派生类构造器内部执行完所有字段初始化（如果你不给它们赋值，就会赋值default）后，再调用。<br>意思比如你有个int，就会赋值0。</p><p>那么如果像这么改写呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> x,y;</span><br><span class="line"><span class="comment">// 注意，实际上不可能写出构造器Point，因为C#规定不允许struct结构体内部定义 无参构造器 或者给内联赋初始值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">x = y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Point topLeft,bottomRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述代码通过不了C#编译，但是如果执行，Rectangle也不会隐式调用Point的构造器，而是会赋默认值0给Point内的x、y。</p><h3 id="类型构造器"><a href="#类型构造器" class="headerlink" title="类型构造器"></a>类型构造器</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> a = <span class="number">2</span>;<span class="comment">//先执行</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">a = <span class="number">1</span>;<span class="comment">//后执行，最后a=1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是类型构造器。</p><ul><li>它不允许有入参。</li><li>它本身静态，也只能操作静态字段。</li><li>它有一个<font color="#dd0000">线程互斥同步锁</font>，C#希望AppDomain中每个类型只执行一次类型构造器，所以线程1拿到该锁后开始构造类型，期间其他线程想调用会被阻塞，知道线程1构造结束放开锁后，其他线程恢复正常发现类已经造好了。</li></ul><p>此外，如果你想在类型销毁时做点什么，虽然CLR不支持静态Finalize方法，但是可以在AppDomain卸载时的DomainUnload事件登记一个回调。</p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>对于CLR而言，对操作符一无所知，所谓操作符重载只是方法而已。</p><h3 id="转换操作符方法"><a href="#转换操作符方法" class="headerlink" title="转换操作符方法"></a>转换操作符方法</h3><p>说的是自定义类型之间的 显式转换 和 隐式转换 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Rational</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义转换方法 x.ToInt32();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Int32 <span class="title">ToInt32</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式转换重写 Rational x = 5;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Rational</span>(<span class="params">Int32 num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Rational(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式转换重写 (int)x;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Int32</span>(<span class="params">Rational r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> r.ToInt32();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在IL中，对应op_Implicit(Int32 num)</span></span><br><span class="line">    <span class="comment">// 在IL中，对应op_Explicit(Rational r)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SomeExtensions</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">IndexOf</span>(<span class="params"><span class="keyword">this</span> SomeType st,<span class="built_in">char</span> val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.Find(val).index;<span class="comment">// 假设有这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong></p><p>简化代码用，添加后会在智能感知中提示。</p><p><strong>this关键字</strong></p><p>其核心是<code>this</code>关键字，需要在静态类中声明。</p><p><strong>调用</strong></p><p>编译器遇到这个会先找类内的实例方法，找不到才继续会找静态方法，最终生成IL。</p><p>因为本质是对静态方法的调用，所以CLR不会生成代码对调用方法的值进行null-check。即不保证非空。</p><p><strong>技巧</strong></p><p>诸如 <code>public static void ShowItems&lt;T&gt; (this IEnumerable&lt;T&gt; collection)</code> ，通过泛型+接口实现泛用。</p><p><strong>可被接作委托</strong></p><p>拓展方法可以被当作委托接住，并在后续执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action a = <span class="string">&quot;Jeff&quot;</span>.ShowItems;</span><br><span class="line">a();<span class="comment">// 本质是Invoke委托并传入&quot;Jeff&quot;的引用</span></span><br></pre></td></tr></table></figure><h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p><strong>partial关键字</strong></p><p>分部方法用起来和委托很像，书里没提，我猜是委托+注入委托实现的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">OnNameChanged</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;<span class="comment">// 分部方法写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OnNameChanged(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 如果OnNameChanged没被提供实现，那么这一段调用在IL代码里不会出现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">OnNameChanged</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do sth or just not</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法</strong></p><ul><li>分部方法只能在 分部类 或者 分部结构 中声明。</li><li>分部方法可以是 静态 或者 泛型方法 。</li><li>分部方法返回类型必须是 void ，且不能用 out 。</li></ul><p><strong>它更有优势</strong></p><p>比起把基类某方法设置为virtual调用，然后子类继承去重写的方法，它更有以下2点优势：</p><ul><li>类的要求更低，不需要继承且可以密封。</li><li>编译器会对其进行优化，如果没有提供分部方法的实现，IL就不会生成调用这个方法的代码。</li></ul><h1 id="大章9：参数"><a href="#大章9：参数" class="headerlink" title="大章9：参数"></a><center>大章9：参数</center></h1><h3 id="可选参数和命名参数"><a href="#可选参数和命名参数" class="headerlink" title="可选参数和命名参数"></a>可选参数和命名参数</h3><p><strong>可选参数</strong></p><p>就是给参数设定默认值，这样可以不输。</p><p><strong>命名参数</strong></p><p>就是调用的时候给参数显式赋值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DoSth(name:<span class="string">&quot;Sim&quot;</span>,thing:<span class="string">&quot;talk&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>ref and out</strong></p><ul><li>ref和out不能作为默认参数，因为它们无法传递有意义的默认值。</li><li>ref和out在IL以及CLR看来是一码事，它们都是传参数实例的指针。</li><li>ref和out在方法元数据中的签名是一摸一样的，以为着无法把一个方法的out参数改为ref就作为新方法，编译器会报错。</li></ul><p><strong>IL代码</strong></p><p>C#中分配了默认参数，编译器会在内部向该参数应用定制特性 System.Runtime.InteropServices.OptionalAttribute 和 System.Runtime.InteropServices.DefaultParameterValueAttribute。<br>生成的代码会存在文件的元数据中。然后，会向DefaultParameterValueAttribute的构造器传递在源代码中指定的常量值。</p><h3 id="向参数传引用"><a href="#向参数传引用" class="headerlink" title="向参数传引用"></a>向参数传引用</h3><p><strong>引用和值参数</strong></p><ul><li>如果是引用类型，会传引用，意味着值可以被改变。</li><li>如果是值类型，会传实例的一个副本。</li></ul><p><strong>ref vs out</strong></p><p>C#编译器会区分 <font Color ="red">out和ref</font> ，但CLR不区分，他们的IL代码相同，元数据几乎相同只有一个bit不同用来区分。</p><ul><li>out假设调用者在调用方法之前可能没初始化对象，所以方法体内不能读取参数的值，而且必须在返回前写入这个值。</li><li>ref与之相反，方法体内能读写参数的值，但是必须在调用方法前初始化参数。</li></ul><p><strong>优化点</strong></p><p>为大的参数值类型使用out，可以避免在调用方法时复制值类型实例的字段。</p><p><strong>签名一致</strong></p><p>如果方法使用ref和out，要求参数必须完全吻合签名的类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">String s1 = <span class="string">&quot;Jeffrey&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;Richter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap(ref s1,ref s2)编译器会直接报错，必须像下面这样写</span></span><br><span class="line">Swap(<span class="function"><span class="keyword">ref</span> <span class="title">object</span>(<span class="params">s1</span>),<span class="keyword">ref</span> <span class="title">object</span>(<span class="params">s2</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">object</span> a,<span class="keyword">ref</span> <span class="built_in">object</span> b</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=&gt; 因此，签名处建议改成泛型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">String s1 = <span class="string">&quot;Jeffrey&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;Richter&quot;</span>;</span><br><span class="line">    </span><br><span class="line">Swap(<span class="keyword">ref</span> s1,<span class="keyword">ref</span> s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T a,<span class="keyword">ref</span> T b</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让参数的数量可变"><a href="#让参数的数量可变" class="headerlink" title="让参数的数量可变"></a>让参数的数量可变</h3><p><strong>params关键字 怎么用</strong></p><p>使用params关键字可以让方法接受可变数量的参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"><span class="keyword">params</span> Int32 values</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>params关键字 实现</strong></p><p>params关键字告诉编译器向参数应用定制特性System.ParamArrayAttribute的一个实例。</p><p>编译器在方法调用时，会先检查所有参数没有应用ParamArray特性的方法；如果没有找到匹配的方法，再去寻找参数应用了ParamArray特性的方法。</p><p><strong>params关键字 少用</strong></p><p>因为params肯定跟着数组型参数，数组型参数必须在堆上分配且参与垃圾回收，比帧栈上丢参数的方式耗费性能的多。关于这一块改善，可以参考<code>String.Concat</code>方法，对方法进行尽可能地重载而不是用params，params只用在极端情况下。</p><h3 id="参数和返回类型的设计规范-⭐"><a href="#参数和返回类型的设计规范-⭐" class="headerlink" title="参数和返回类型的设计规范 ⭐"></a>参数和返回类型的设计规范 ⭐</h3><p><strong>参数类型尽可能弱</strong></p><p>声明方法的参数，类型越弱越好，宁愿要接口也不要基类。这样适用范围更大。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeMethod</span>&lt;<span class="title">T</span>&gt; (<span class="params">IEnumerable&lt;T&gt; collection</span>)</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// is better than</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeMethod</span>&lt;<span class="title">T</span>&gt; (<span class="params">List&lt;T&gt; collection</span>)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>返回类型尽可能强</strong></p><p>相反，声明方法的返回值类型越强越好，代码就不演示了。这样做返回值能做的事更多，也可以转换成基类。</p><p><strong>适当调整提高灵活性</strong></p><p>上面2点虽然是原则，但是最后要根据实际情况来。比如说返回类型更强，会导致方法内部的变量要求更为严格，导致灵活性下降更难改动方法。</p><h3 id="常量性"><a href="#常量性" class="headerlink" title="常量性"></a>常量性</h3><p>有的语言（比如C++）允许将方法或参数声明为常量，但是CLR并不提供这个功能。</p><h1 id="大章10：属性"><a href="#大章10：属性" class="headerlink" title="大章10：属性"></a><center>大章10：属性</center></h1><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>CLR支持两种属性：无参与有参。它们之间的区分就是get、set访问器接不接受参数。</p><ul><li>无参属性，就是平时说的属性</li><li>有参属性，C#又称它为索引器。</li></ul><h3 id="无参属性"><a href="#无参属性" class="headerlink" title="无参属性"></a>无参属性</h3><p><strong>是什么</strong></p><p>无参属性，就是平时说的属性。</p><p><strong>数据封装</strong></p><p>建议将字段设置为private，为其设置访问器（accessor）方法。属性进行读/写操作的本质是通过访问器，也就是方法。</p><p><strong>数据封装的目的</strong></p><ul><li>为了实现一些side effect，就是在<code>get;set;</code>里写逻辑。比如数据检查。</li><li>可以以线程安全的方式访问字段。</li></ul><p><strong>编译器处理</strong></p><ul><li>  如果对属性写了<code>get;set;</code>访问器方法，那么在编译器会生成对应的方法，类似于<code>get_Name();set_Name();</code>。如果没写就不生成。</li><li>  托管程序集元数据中的属性定义。这一项必然生成。</li></ul><p><strong>用于反射</strong></p><p>上面说了，编译器会为属性生成一个属性定义项，里面有一些flag、属性类型、属性对应的get、set访问器方法的引用。这种元数据可以被<code>System.Reflection.PropertyInfo类</code>获取，但是CLR不用这些元数据，只需要访问器方法。</p><p><strong>属性自动实现</strong></p><p>C#提供的语法糖：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String Name &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br></pre></td></tr></table></figure><p>像上述这么实现，C#编译器会自动声明一个私有字段，并自动实现get_Name、set_Name方法。</p><p><strong>属性vs字段</strong></p><ul><li>  属性可以只读只写，而字段总是可读可写（除了readonly）。</li><li>  属性不能作为out或ref参数传给方法，而字段可以。</li><li>  属性方法可能造成副作用，而字段不会。</li><li>  属性方法可能抛出异常，而字段访问永远不会。</li></ul><p><strong>对象初始化器</strong></p><p>C#提供的语法糖：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man() &#123; Name = <span class="string">&quot;Sam&quot;</span>, Age = <span class="number">25</span>&#125;;</span><br><span class="line"><span class="comment">// 上述语法糖等价于</span></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line">man.Name = <span class="string">&quot;Sam&quot;</span>;</span><br><span class="line">man.Age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p><strong>集合初始化器</strong></p><p>如果属性类型实现了<code>IEnumerable</code>或者<code>IEnumerable&lt;T&gt;</code>接口，属性就被认为是集合。</p><p>而编译器面对集合的初始化，会假设类实现了Add方法并为其执行Add方法；如果集合没有实现Add方法却使用集合初始化器，会报错。</p><p>比如，C#提供的语法糖：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Classroom</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">String</span>&gt; Students</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法糖</span></span><br><span class="line">Classroom <span class="keyword">class</span> = <span class="keyword">new</span> Classroom&#123;</span><br><span class="line">    Students = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上述语法糖等价于</span></span><br><span class="line">Classroom <span class="keyword">class</span> = <span class="keyword">new</span> Classroom();</span><br><span class="line"><span class="keyword">class</span>.Students.Add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">class</span>.Students.Add(<span class="string">&quot;B&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>匿名类型</strong></p><p>如下方式定义类型，编译器的操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> &#123;Name = <span class="string">&quot;Jeff&quot;</span>, Year = <span class="number">1964</span>&#125;;</span><br><span class="line"><span class="comment">// equal to ， 2种匿名类型定义方式</span></span><br><span class="line">String Name = <span class="string">&quot;Jeff&quot;</span>;Int Year = <span class="number">1964</span>;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> &#123;Name, Year&#125;;</span><br><span class="line"><span class="comment">// 他们属于一个结构的匿名类，C#就只创造一个类</span></span><br><span class="line">o2 = o1;</span><br><span class="line"><span class="comment">// 匿名类结构，编译器生成代码如下</span></span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;&gt;<span class="title">f__AnonymousType0</span>&lt;...&gt; : <span class="title">Object</span> &#123;</span><br><span class="line">    <span class="comment">// 1.属性，会作为只读字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> String Name;</span><br><span class="line">    <span class="keyword">public</span> String Name &#123;<span class="keyword">get</span>&#123;<span class="keyword">return</span> Name;&#125;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.构造器，按照声明处顺序来</span></span><br><span class="line">    <span class="keyword">public</span> &lt;&gt;f__AnonymousType0&lt;...&gt;(String a1,Int a2)&#123;</span><br><span class="line">        Name = a1;Year = a2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.重写Object.Equals</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Boolean <span class="title">Equals</span>(<span class="params">Object val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 任何字段不匹配就返回false，否则true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.重写Object.GetHashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Int32 <span class="title">GetHashCode</span>(<span class="params">Object val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回根据每个字段的哈希码生成的一个哈希码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.重写Object.ToString</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> String <span class="title">ToString</span>(<span class="params">Object val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回 “属性名=值”对 的逗号分隔列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  如代码段描述，生成的匿名类型继承自Object，所有字段readonly且不提供set所以不可修改。</li><li>  如代码段描述，会重写Equals、GetHashCode、ToString三个方法。</li><li>  如代码段描述，完全同样结构的匿名类型，C#编译器会复用同一个类，所以可以<code>o1 = o2</code>甚至<code>o1.Equals(o2)</code>。</li><li>  匿名类型经常与LINQ配合使用，比如<code>var query = from ... select new&#123;Name = ...,Year = ...&#125;; </code></li></ul><p><strong>System.Tuple类型</strong></p><p>Tuple，组元。一组微软定义的泛型组成的类型，目的是简化类的定义，有需求时可以使用。</p><ul><li>  这个类型提供了CompareTo、Equals、GetHashCode、ToString方法 以及 Size属性。</li><li>  这一系列类型都和下面一样结构，只是入参数量不同，最复杂的是8个入参！</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tuple</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>,<span class="title">TRest</span>&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> T1 m_Item1;</span><br><span class="line"><span class="keyword">public</span> T1 Item1 &#123; <span class="keyword">get</span>&#123;<span class="keyword">return</span> m_Item1;&#125; &#125;</span><br><span class="line">...other props...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tuple</span>(<span class="params">T1 t1,T2 t2,TRest rest</span>)</span>&#123;</span><br><span class="line">m_Item1 = t1; m_Item2 = t2; m_Rest = rest;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------使用------</span></span><br><span class="line"><span class="comment">// 常规用法</span></span><br><span class="line">Tuple&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; test = Tuple.Create&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 拓展用法，创建多于8个元素的Tuple，可为Rest参数传递另一个Tuple</span></span><br><span class="line"><span class="keyword">var</span> t = Tuple.Create(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,Tuple.Create(<span class="number">7</span>,<span class="number">8</span>));</span><br></pre></td></tr></table></figure><h3 id="有参属性"><a href="#有参属性" class="headerlink" title="有参属性"></a>有参属性</h3><p><strong>是什么</strong></p><p>get、set访问器接受一个或多个参数的属性，C#称为索引器。</p><p><strong>数组风格</strong></p><p>C#使用数组风格的语法来公开有参属性（索引器），其实也就是对<code>[]</code>操作符的重载。</p><p>必须在this里写重载，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] name = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//索引器必须以this关键字定义，其实这个this就是类实例化之后的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            name[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">...</span><br><span class="line">Students sts = <span class="keyword">new</span> Students();</span><br><span class="line"><span class="comment">// “=”号右边对索引器赋值，其实就是调用其set方法</span></span><br><span class="line">Students[<span class="number">0</span>] = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">Students[<span class="number">1</span>] = <span class="string">&quot;Sam&quot;</span>;</span><br><span class="line"><span class="comment">// 输出索引器的值，其实就是调用其get方法</span></span><br><span class="line">Console.WriteLine(Students[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p><strong>编译器处理</strong></p><ul><li>  如果对属性写了<code>get;set;</code>访问器方法，那么在编译器会生成对应的方法，类似于<code>get_Item();set_Item();</code>。如果没写就不生成。</li><li>  托管程序集元数据中的属性定义。这一项必然生成。</li></ul><p><strong>IndexerName特性</strong></p><p>上面提到了编译器会默认给有参属性生成<code>get_Item();set_Item();</code>名字默认方法，但是也可以使用 IndexerName特性 修改默认的名字：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BitArray</span> &#123;</span><br><span class="line">[<span class="meta">IndexerName(<span class="meta-string">&quot;Bit&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> Boolean <span class="keyword">this</span>[Int32 bitPos]&#123;</span><br><span class="line"><span class="comment">// 这里至少要定义一个访问器方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上述代码后，编译器将生成<code>get_Bit();set_Bit();</code>的方法，而不是默认方法名。</p><p>因为C#编译器的索引器实现，本质是重写<code>[]</code>，所以不支持 命名不同、签名相同的 索引器，但是支持 命名相同、签名不同的 索引器。</p><h3 id="另外，关于属性访问器"><a href="#另外，关于属性访问器" class="headerlink" title="另外，关于属性访问器"></a>另外，关于属性访问器</h3><p><strong>调用属性访问器时的性能</strong></p><ol><li>对于简单的get、set访问器，JIT编译器会将代码内联，这样使用属性就不会有性能上的缺失。</li><li>此处内联（inline）是指将方法的代码直接编译到调用它的方法中。</li><li>这么做，坏处是会使编译好的方法变得更大，好处是避免了在运行时发出调用产生的开销。</li></ol><p><strong>属性访问器的可访问性</strong></p><p>就是set、get访问器分别设置不同的保护级别，实现不同目的。</p><h1 id="大章11：事件"><a href="#大章11：事件" class="headerlink" title="大章11：事件"></a><center>大章11：事件</center></h1><h3 id="事件是什么"><a href="#事件是什么" class="headerlink" title="事件是什么"></a>事件是什么</h3><p><strong>概念</strong></p><p>事件，用于通知其他对象发生了特定的事情。</p><p>CLR事件以 <font color="red">委托</font> 为基础。</p><p><strong>功能</strong></p><ul><li>方法能登记它对事件的关注。</li><li>方法能注销它对事件的关注。</li><li>事件发生时，登记了的方法将收到通知。</li></ul><p><strong>例子</strong></p><ol><li>一个<code>Phone实例</code>和一个<code>Computer实例</code>，两者各有一个方法，在<code>MailManager实例</code>里登记了对<code>NewMail事件</code>的关注。</li><li>一封新邮件到达<code>MailManager实例</code>。</li><li><code>MailManager实例</code>将事件通知发送给所有已登记的方法，他们各自的方法以自己的方式处理邮件。</li></ol><h3 id="设计公开事件"><a href="#设计公开事件" class="headerlink" title="设计公开事件"></a>设计公开事件</h3><p><strong>0.序言</strong></p><p>进行上述模型的完整设计。</p><p><strong>1.定义传递信息：EventArgs</strong></p><p>定义一个类型，来容纳所有应该发送给事件通知接收者的附加信息。</p><p>根据约定，这种类，这种类应该从<code>System.EventArgs</code>派生，类名由EventArgs结束。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMailEventArgs</span> : <span class="title">EventArgs</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String From &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125; <span class="comment">// 发件人</span></span><br><span class="line"><span class="keyword">public</span> String To &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125; <span class="comment">// 收件人</span></span><br><span class="line"><span class="keyword">public</span> String Subject &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125; <span class="comment">// 主题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NewMailEventArgs</span>(<span class="params">String <span class="keyword">from</span>,String to,String subject</span>)</span>&#123;</span><br><span class="line">From = <span class="keyword">from</span>;</span><br><span class="line">To = to;</span><br><span class="line">Subject = subject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.定义事件成员：EventHandler</strong></p><p>事件成员使用关键字event定义。</p><p>根据约定，这种类，这种类应该从<code>System.EventArgs</code>派生，类名由EventArgs结束。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MailManager</span> &#123;</span><br><span class="line"><span class="comment">// 事件成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;NewMailEventArgs&gt; NewMail;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用的泛型委托EventHandler：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>&lt;<span class="title">TEventArgs</span>&gt; (<span class="params">Object sender,TEventArgs e</span>)</span>;</span><br><span class="line"><span class="comment">// 所有登录的方法原型必须满足以下签名：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MethodName</span>(<span class="params">Object sender,NewMailEventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>3.定义引发事件的方法：OnEvent</strong></p><p>根据约定，类要定义一个受保护的虚方法。引发事件时，方法会被调用，获取到<code>NewMailEventArgs</code>对象并传递对象信息给接收者们。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MailManager</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNewMail</span> (<span class="params">NewMailEventArgs e</span>)</span>&#123;</span><br><span class="line">EventHandler&lt;NewMailEventArgs&gt; tmp = NewMail;</span><br><span class="line">tmp?.Invoke(<span class="keyword">this</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.定义引发事件的方法：Publish</strong></p><p>相当于对外暴露的接口，按照指定格式输入入参，再将入参转化为配置好的事件进行调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MailManager</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SimulateNewMail</span>(<span class="params">String <span class="keyword">from</span>,String to,String subject</span>)</span>&#123;</span><br><span class="line">NewMailEventArgs e = <span class="keyword">new</span> NewMailEventArgs(<span class="keyword">from</span>,to,subject);</span><br><span class="line"><span class="comment">// 调用虚方法通知对象事件已发生</span></span><br><span class="line">OnNewMail(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.简单使用：Subscribe &amp; Use</strong></p><p>书里没有，我补一下最简单的使用方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Main</span>() &#123;</span><br><span class="line"><span class="keyword">var</span> manager = <span class="keyword">new</span> MailManager();</span><br><span class="line">manager.NewMail += (sender, eventArgs) =&gt; &#123; </span><br><span class="line">Console.WriteLine(<span class="string">&quot;Phone got it.&quot;</span>);</span><br><span class="line">Console.WriteLine(eventArgs.From,eventArgs.To,eventArgs.Subject);</span><br><span class="line">&#125;;</span><br><span class="line">manager.NewMail += (sender, eventArgs) =&gt; &#123; </span><br><span class="line">Console.WriteLine(<span class="string">&quot;Computer got it.&quot;</span>);</span><br><span class="line">Console.WriteLine(eventArgs.From,eventArgs.To,eventArgs.Subject);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译器如何实现事件"><a href="#编译器如何实现事件" class="headerlink" title="编译器如何实现事件"></a>编译器如何实现事件</h3><p><strong>事件成员</strong></p><p>前面代码中，事件成员，用一行代码就完成了定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;NewMailEventArgs&gt; NewMail;</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><p>C#编译器编译时把它转换为以下3个构造：</p><p><strong>1.具有恰当委托类型的字段</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EventHandler&lt;NewMailEventArgs&gt; NewMail = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>第一个构造是一个具有恰当委托类型(<code>EventHandler&lt;NewMailEventArgs&gt;</code>)的<font color="red">字段</font>。</p><p>把<code>NewMail</code>理解成一个委托实例列表，事件发生时会通知这个列表中的所有委托实例，目前为<code>null</code>意味着没有监听者(listener)。<br>登记监听该事件，就相当于对委托列表添加一个实例；反之，注销意味着从列表中移除委托。</p><p><em>注意了，上面代码也提到过，EventHandler就是委托！委托类似于签名定义，下面说的委托实例是说遵照签名定义的方法。</em></p><p><strong>~.插播一下</strong></p><p>下面用到很多<code>Interlocked.CompareExchange</code>方法，先了解一下，摘自微软官方文档。</p><ul><li><code>System.Threading.Interlocked</code>类：为多个线程共享的变量提供原子操作。</li><li><code>Interlocked.CompareExchange(ref A, B, C)</code>静态方法：比较BC两个值是否相等，如果相等，则替换第一个值A。</li></ul><p><strong>2.为事件构造add方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许方法登记对事件的关注</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_NewMail</span>(<span class="params">EventHandler&lt;NewMailEventArgs&gt; <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">EventHandler&lt;NewMailEventArgs&gt; prevHandler;</span><br><span class="line">EventHandler&lt;NewMailEventArgs&gt; newMail = <span class="keyword">this</span>.NewMail;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 通过循环和对CompareExchange的调用，可以以一种线程安全的方式向事件添加委托</span></span><br><span class="line">prevHandler = newMail;</span><br><span class="line">EventHandler&lt;NewMailEventArgs&gt; newHandler =</span><br><span class="line">(EventHandler&lt;NewMailEventArgs&gt;) Delegate.Combine(prevHandler,<span class="keyword">value</span>);</span><br><span class="line">newMail = Interlocked.CompareExchange&lt;EventHandler&lt;NewMailEventArgs&gt;&gt;(<span class="keyword">ref</span> <span class="keyword">this</span>.NewMial,newHandler,prevHandler)</span><br><span class="line">&#125; <span class="keyword">while</span> (newMial != prevHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#编译器在事件名(NewMail)前加add_前缀，并自动生成代码。<br>添加委托是通过调用<code>Delegate.Combine</code>方法，它将委托实例添加到委托实例列表中，返回新的列表头(地址)，并将这个地址存回字段。</p><p><strong>3.为事件构造remove方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许方法注销对事件的关注</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove_NewMail</span>(<span class="params">EventHandler&lt;NewMailEventArgs&gt; <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">EventHandler&lt;NewMailEventArgs&gt; prevHandler;</span><br><span class="line">EventHandler&lt;NewMailEventArgs&gt; newMail = <span class="keyword">this</span>.NewMail;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 通过循环和对CompareExchange的调用，可以以一种线程安全的方式向事件移除委托</span></span><br><span class="line">prevHandler = newMail;</span><br><span class="line">EventHandler&lt;NewMailEventArgs&gt; newHandler =</span><br><span class="line">(EventHandler&lt;NewMailEventArgs&gt;) Delegate.Remove(prevHandler,<span class="keyword">value</span>);</span><br><span class="line">newMail = Interlocked.CompareExchange&lt;EventHandler&lt;NewMailEventArgs&gt;&gt;(<span class="keyword">ref</span> <span class="keyword">this</span>.NewMial,newHandler,prevHandler)</span><br><span class="line">&#125; <span class="keyword">while</span> (newMial != prevHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#编译器在事件名(NewMail)前加remove_前缀，并自动生成代码。<br>添加委托是通过调用<code>Delegate.Remove</code>方法，它将委托实例从委托实例列表中移除，返回新的列表头(地址)，并将这个地址存回字段。</p><p><strong>ps.关于add和remove</strong></p><p>上述由编译器自动生成的add和remove方法的可访问性，都是根据event申明的可访问性来的，也就是都是public。</p><p>编译器除了上述3块，还会在元数据中生成一个事件定义记录项，它引用了add和remove访问其方法。它们用来建立“事件”和访问其方法之间的联系，可以通过反射<code>System.Reflection.EventInfo</code>获取调用。</p><h3 id="设计监听者的类型"><a href="#设计监听者的类型" class="headerlink" title="设计监听者的类型"></a>设计监听者的类型</h3><p><strong>我分割为3要素</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Phone</span> &#123;</span><br><span class="line"><span class="comment">// 实例化必须给一个MailManager。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phone</span>(<span class="params">MailManager manager</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 1.登记方法到事件</span></span><br><span class="line">manager.NewMail += PhoneMsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.登记到事件的方法</span></span><br><span class="line"><span class="comment">// sender:表示MailManager对象，便于将信息传回给它</span></span><br><span class="line"><span class="comment">// e:表示MailManager对象向传给我们的附加事件信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PhoneMsg</span>(<span class="params">Object sender,NewMailEventArgs e</span>)</span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Phone mail message:&quot;</span>);</span><br><span class="line">Console.WriteLine(e.From + e.To + e.Subject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.公开的注销关注方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unregister</span>(<span class="params">MailManager manager</span>)</span>&#123;</span><br><span class="line">manager.NewMail -= PhoneMsg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>+=操作符</strong></p><p>C#编译器内部对+=的操作符由特殊处理，会翻译成以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">manager.NewMail += PhoneMsg;</span><br><span class="line"><span class="comment">// C#编译</span></span><br><span class="line">manager.add_NewMail(<span class="keyword">new</span> EventHandler&lt;NewMailEventArgs&gt;(PhoneMsg));</span><br></pre></td></tr></table></figure><p><strong>-=操作符</strong></p><p>代码和上面一样，就不多写了。</p><p>值得一提的是，-=是扫描委托列表，找到匹配再删除的，没有找到也不会报错。</p><p><strong>登记方法属于引用</strong></p><p>实例的方法被登记到了某事件，那么该实例就无法被垃圾回收了。</p><h3 id="显式实现事件"><a href="#显式实现事件" class="headerlink" title="显式实现事件"></a>显式实现事件</h3><p>下面自己使用Dictionary来实现一个维护委托实例列表的事件类。</p><p><strong>调用</strong></p><p>先看做完后怎么调用的。使用标准语法即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">TypeWithLotsOfEvents twle = <span class="keyword">new</span> TypeWithLotsOfEvents();</span><br><span class="line"><span class="comment">// 添加回调</span></span><br><span class="line">twle.myDelegateList += SomeMyEvent;</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">twle.Simulate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeMyEvent</span>(<span class="params"><span class="built_in">object</span> sender,MyEventArgs e</span>)</span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Nice!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现委托列表</strong></p><p>映射EventKey -&gt; Delegate，且对外提供Add、Remove、Raise方法。书中用了很多线程安全方法诸如<code>Monitor.Enter</code>，由于在将事件，这块简化掉：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">EventKey</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">EventSet</span> &#123;</span><br><span class="line"><span class="comment">// 委托列表，设置为只读是可以add、remove的，但是不可以再被 &quot;= new Dictionary&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="title">Dictionary</span>&lt;<span class="title">EventKey</span>,<span class="title">Delegate</span>&gt; eventList</span> = <span class="keyword">new</span> Dictionary&lt;EventKey,Delegate&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">EventKey key,Delegate handler</span>)</span>&#123;</span><br><span class="line">Delegate d;</span><br><span class="line">eventList.TryGetValue(key,<span class="keyword">out</span> d);</span><br><span class="line">        <span class="comment">// Delegate.Combine，像+=操作符一样连接委托</span></span><br><span class="line">eventList[key] = Delegate.Combine(d,handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">EventKey key,Delegate handler</span>)</span>&#123;</span><br><span class="line">Delegate d;</span><br><span class="line"><span class="keyword">if</span>(eventList.TryGetValue(key,<span class="keyword">out</span> d))&#123;</span><br><span class="line">d = Delegate.Remove(d,handler);</span><br><span class="line"><span class="comment">// 如果还有委托，就设置新的头部(地址)，否则删除EventKey</span></span><br><span class="line"><span class="keyword">if</span> (d != <span class="literal">null</span>)</span><br><span class="line">eventList[key] = d;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">eventList.Remove(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Raise</span>(<span class="params">EventKey key,Object sender,EventArgs e</span>)</span>&#123;</span><br><span class="line">Delegate d;</span><br><span class="line">eventList.TryGetValue(key,<span class="keyword">out</span> d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于字典包含不同的委托类型，所以无法再编译时构造一个类型安全的委托调用。</span></span><br><span class="line"><span class="comment">// DynamicInvoke会向调用的回调方法查证参数类型安全性，并调用方法。</span></span><br><span class="line"><span class="keyword">if</span> (d != <span class="literal">null</span>) d.DynamicInvoke(<span class="keyword">new</span> Object[] &#123; sender,e &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用委托列表的类</strong></p><p>接着定义一个类来使用EventSet类。在这个类中，一个字段引用了一个EventSet对象，且显式实现了事件的add/remove。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件类型，可以在里面加想要的附加信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventArgs</span> : <span class="title">EventArgs</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeWithLotsOfEvents</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> EventSet eventSet = <span class="keyword">new</span> EventSet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> EventSet EventSet &#123; <span class="keyword">get</span> &#123;<span class="keyword">return</span> eventSet;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义本类的key</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">readonly</span> EventKey eventKey = <span class="keyword">new</span> EventKey();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;MyEventArgs&gt; myDelegateList &#123;</span><br><span class="line"><span class="keyword">add</span> &#123; eventSet.Add(eventKey,<span class="keyword">value</span>); &#125;</span><br><span class="line"><span class="keyword">remove</span> &#123; eventSet.Remove(eventKey,<span class="keyword">value</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDelegate</span>(<span class="params">MyEventArgs e</span>)</span>&#123;</span><br><span class="line">eventSet.Raise(eventKey,<span class="keyword">this</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Simulate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">OnDelegate(<span class="keyword">new</span> MyEventArgs());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑问与思考</strong></p><p>其实到这里，我还是不理解为什么要用一个字典型来实现，明明按照示例一个使用类单独维护一个委托队列，那么key就是一个，压根用不到key啊。</p><p>我怀疑可能是为了让<code>eventSet</code>实例复用，像我可以在<code>TypeWithLotsOfEvents</code>类里加一套新的委托，但还是加到原来的<code>eventSet</code>实例中。可以这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventArgs2</span> : <span class="title">EventArgs</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partical</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeWithLotsOfEvents</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">readonly</span> EventKey eventKey2 = <span class="keyword">new</span> EventKey();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;MyEventArgs2&gt; myDelegateList2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">add</span> &#123; eventSet.Add(eventKey2, <span class="keyword">value</span>); &#125;</span><br><span class="line"><span class="keyword">remove</span> &#123; eventSet.Remove(eventKey2, <span class="keyword">value</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDelegate</span>(<span class="params">MyEventArgs2 e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">eventSet.Raise(eventKey2, <span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Simulate</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OnDelegate(<span class="keyword">new</span> MyEventArgs());<span class="comment">// 这条原来就有</span></span><br><span class="line">OnDelegate(<span class="keyword">new</span> MyEventArgs2());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，本节核心思想是维护一个基于key-value的集合，引发事件时会在集合中查找事件标识符，如果找到就调用委托列表，如果没找到意味着没人登记关注所以就不做回调。</p><h1 id="大章12：泛型"><a href="#大章12：泛型" class="headerlink" title="大章12：泛型"></a><center>大章12：泛型</center></h1><h3 id="FCL中的泛型"><a href="#FCL中的泛型" class="headerlink" title="FCL中的泛型"></a>FCL中的泛型</h3><p><strong>泛型是什么</strong></p><p>泛型(generic)是CLR和编程语言提供的一个特殊机制，目的是为了“算法重用”。</p><p><strong>泛型提供更佳的性能</strong></p><p>泛型可以替换很多需要Object装箱拆箱实现的场景，还可以避免强制类型转换，从而提高代码运行速度、减少资源使用。</p><p>比如，一个使用泛型的<code>List&lt;T&gt;</code>比非泛型的ArraryList算法，在面对频繁拆装箱的情况下，能有非常大的性能差距！</p><h3 id="泛型基础结构"><a href="#泛型基础结构" class="headerlink" title="泛型基础结构"></a>泛型基础结构</h3><p><strong>实现泛型</strong></p><p>为了在CLR2.0加入泛型，微软至少做了以下工作：</p><ul><li>创建新的IL指令，使之能够识别类型实参。</li><li>修改编译器和JIT编译器，使之识别处理泛型生成IL代码。</li><li>修改现有元数据表格式，以便表示具有泛型参数的类型名称和方法。</li><li>修改C#、.NET库来支持新语法。</li></ul><p><strong>开放类型、封闭类型</strong></p><ul><li>  开放类型：具有泛型类型参数的类型。</li><li>  封闭类型：为所有类型参数都传递了实际的数据类型的类型。</li><li>  两者使用区别：开放类型无法创建实例，和接口一样；封闭类型可以。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个部分指定的开放类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DictionaryStringKey</span>&lt;<span class="title">TValue</span>&gt; : <span class="title">Dctionary</span>&lt;<span class="title">String</span>,<span class="title">TValue</span>&gt; &#123; &#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 2个都是开放类型</span></span><br><span class="line">Type t1 = <span class="keyword">typeof</span>(Dictionary&lt;,&gt;);</span><br><span class="line">Type t2 = <span class="keyword">typeof</span>(DictionaryStringKey&lt;&gt;);</span><br><span class="line"><span class="comment">// 封闭类型</span></span><br><span class="line">Type t3 = <span class="keyword">typeof</span>(DictionaryStringKey&lt;Int&gt;);</span><br></pre></td></tr></table></figure><p>关于静态字段，开放类型转换成封闭类型后会其分配各自的静态字段，相同的T共用一个静态字段。<br>由此可知，<font color="Red">对于同一个开放类型，相同的T入参会共用一个封闭类型</font>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MyList&lt;<span class="built_in">int</span>&gt;.Test = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">MyList&lt;<span class="built_in">int</span>&gt;.Test = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">MyList&lt;<span class="built_in">string</span>&gt;.Test = <span class="string">&quot;4&quot;</span>;</span><br><span class="line">Console.WriteLine(MyList&lt;<span class="built_in">int</span>&gt;.Test);<span class="comment">// 输出3，而不是1、2</span></span><br><span class="line">Console.WriteLine(MyList&lt;<span class="built_in">string</span>&gt;.Test);<span class="comment">// 输出4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; list</span> = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> Test = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，利用开放类型转换封闭类型时会为static重新分配的技巧，可以如此约束封闭类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; &#123;</span><br><span class="line"><span class="comment">// 每次构造新的封闭类型，都会执行一次这个，所以可以加入一些对类型的限制</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">MyList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(T).IsClass)&#123;</span><br><span class="line"><span class="comment">// 限制该类只允许T为值类型</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Type construct failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型类型的继承</strong></p><p>泛型类型也是类型，他是一样可以继承的，可以继承也意味着可以利用各种类型转换。</p><p>下面实现一个节点为泛型的链表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">Node next</span>)</span>&#123;</span><br><span class="line">next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过泛型实现了类型各不相同的链表，比Node&lt;Object&gt;更优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypedNode</span>&lt;<span class="title">T</span>&gt; : <span class="title">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span> T data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TypedNode</span>(<span class="params">T data</span>) : <span class="title">this</span>(<span class="params">data, <span class="literal">null</span></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TypedNode</span>(<span class="params">T data, Node next</span>) : <span class="title">base</span>(<span class="params">next</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> data.ToString() + ((next == <span class="literal">null</span>)? <span class="built_in">string</span>.Empty : next.ToString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型类型的同一性、相等性</strong></p><p>如果对泛型类型进行派生：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DateTimeList</span> : <span class="title">List</span>&lt;<span class="title">DateTime</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么派生，虽然程序员的意思是想简写<code>List&lt;DateTime&gt;</code>为<code>DateTimeList</code>，但是这样是不可行的，因为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x = false</span></span><br><span class="line"><span class="built_in">bool</span> x = <span class="keyword">typeof</span>(DateTimeList) == <span class="keyword">typeof</span>(List&lt;DateTime&gt;) ;</span><br></pre></td></tr></table></figure><p>这样即使两者数据完全一致，但是仍然在类型上不同。你就无法直接用=给<code>DateTimeList实例</code>赋值了。</p><p>有一种比较好的解决方案是用using重命名<code>List&lt;DateTime&gt;</code>。当然，我的建议不命名，保持<code>List&lt;DateTime&gt;</code>。</p><p><strong>代码爆炸</strong></p><p>这块说的就是因为泛型给程序员带来的书写简便，是由编译器承担更多处理、生成更多IL代码来实现的，所以每次用类型都会生成一个新类型的IL代码，这样内存里的代码量会爆炸。</p><p>CLR为解决这个问题做了2个优化：</p><ol><li>上面提过的，对于同类型同入参T的泛型类型，只进行一次编译，后面复用这个类型。</li><li>CLR会认为所有是引用类型的T实参都完全相同，所以能够共享引用类型的IL代码。意思就是说，因为引用类型的实参或者变量都是在堆上的指针，不同的T类型也只是指针指向的对象不同而已。</li></ol><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p><strong>目的</strong></p><p>除了上面提的泛型（值、引用）类型，泛型接口也非常常用来避免频繁拆装箱：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span>&lt;<span class="title">T</span>&gt; : <span class="title">IDisposable</span>,<span class="title">IEnumerator</span> &#123;</span><br><span class="line">T Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看13章。</p><h3 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h3><p><strong>目的</strong></p><p>泛型委托是为了保证未知类型对象能以安全的方式传给回调方法，且不必装箱。</p><p><strong>本质</strong></p><p>委托实际只是提供了4个方法的一个类，17章会细说，这里展示一下泛型委托：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如此定义泛型委托，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TReturn <span class="title">CallMe</span>&lt;<span class="title">TReturn</span>,<span class="title">TKey</span>,<span class="title">TValue</span>&gt; (<span class="params">Tkey key,TValue <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会转换为这样的类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CallMe</span>&lt;<span class="title">TReturn</span>,<span class="title">TKey</span>,<span class="title">TValue</span>&gt; : <span class="title">MulticastDelegate</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CallMe</span> (<span class="params">Object <span class="built_in">object</span>,IntPtr* method</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> TReturn <span class="title">Invoke</span> (<span class="params">TKey key,TValue <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IAsyncResult <span class="title">BeginInvoke</span> (<span class="params">TKey key, TValue <span class="keyword">value</span>, AsyncCallback callback, Object <span class="built_in">object</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> TReturn <span class="title">EndInvoke</span> (<span class="params">IAsyncResult result</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逆变协变</strong></p><p>协变和逆变是指对返回值和参数的类型进行转换，使得T更灵活。</p><ul><li><strong>不变量(invariant)</strong>，意味着泛型类型参数不能更改。目前为止提过的都是不变量形式的泛型类型参数。</li><li><strong>逆变量(contravariant)</strong>，意味着泛型类型参数可以从一个类更改为它的某个<font color="red">派生类</font>。C#中用<code>in</code>来标记，只能出现在输入位置，比如入参。</li><li><strong>协变量(covariant)</strong>，意味着泛型类型参数可以从一个类更改为它的某个<font color="red">基类</font>。C#中用<code>out</code>来标记，只能出现在输出位置，比如返回值。</li></ul><p>好了，看完上面的概念，反正我是一头雾水，但其实就是下面这玩意：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以这么定义，没错就是Func&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T</span>, <span class="keyword">out</span> <span class="title">TResult</span>&gt; (<span class="params">T arg</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以这么申明</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; fn1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以这么用</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; fn2 = fn1;</span><br><span class="line"><span class="built_in">int</span> i = fn2(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以及上面提到的，返回值协变(基类)，入参逆变(派生类)</span></span><br><span class="line">Func&lt;<span class="built_in">object</span>, <span class="built_in">int</span>&gt; fn3 = <span class="literal">null</span>;</span><br><span class="line">Object i = fn3(<span class="string">&quot;a string&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>示例</strong></p><p>可以很好的让<code>ref</code>、<code>out</code>这两个要求入参必须与签名保持一致的关键字，很好的得到运用。</p><p>具体的可以看之前的9.2节：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T o1, <span class="keyword">ref</span> T o2</span>)</span> &#123;</span><br><span class="line">T temp = o1;</span><br><span class="line">o1 = o2;</span><br><span class="line">o2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型推断</strong></p><p>因为上述这么些泛型方法，<code>&lt;&gt;</code>实在是太多了，所以C#编译器支持泛型方法在调用时，自动推断T类型。<br>比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> n1 = <span class="string">&quot;testA&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> n2 = <span class="string">&quot;testB&quot;</span>;</span><br><span class="line">Swap(<span class="keyword">ref</span> n1,<span class="keyword">ref</span> n2);<span class="comment">//自动推断调用Swap&lt;string&gt;</span></span><br></pre></td></tr></table></figure><p>此外，可以重名定义明确的参数，编译器会选择先调用明确的，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>&#123;</span><br><span class="line">Console.WriteLine(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Display</span>&lt;<span class="title">T</span>&gt;(<span class="params">T o</span>)</span>&#123;</span><br><span class="line">Console.WriteLine(o.ToString());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Display(<span class="string">&quot;Jeff&quot;</span>);<span class="comment">// 调用Display(string)</span></span><br><span class="line">Display(<span class="number">123</span>);    <span class="comment">// 调用Display&lt;T&gt;(T)</span></span><br><span class="line">Display&lt;String&gt;(<span class="string">&quot;Aidan&quot;</span>);   <span class="comment">// 调用Display&lt;T&gt;(T)</span></span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><strong>约束</strong></p><p>向C#编译器承诺，入参T会使用后续类型的实现、派生类。</p><p>就是where：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Min</span>&lt;<span class="title">T</span>&gt;(<span class="params">T o1, T o2</span>) <span class="keyword">where</span> T : IComparable&lt;T&gt;</span></span><br></pre></td></tr></table></figure><p><strong>主要约束</strong></p><p>参数T可以指定0~1个主要约束，主要约束代表类，注意了必须要非密封类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要约束：要求为引用类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeClassType</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 因为T一定是引用类型所以可以指空</span></span><br><span class="line">T temp = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要约束：要求为值类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeValType</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">struct</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Factory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 因为T一定是值类型，值类型隐式有一个公共无参构造器</span></span><br><span class="line">T temp = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>次要约束</strong></p><p>参数T可以指定0~n个次要约束，次要约束代表接口。代码就不show了。</p><p><strong>类型参数约束</strong></p><p>参数T可以指定0~n个次要约束，类型参数约束，就是用参数来约束参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型参数约束 T : TBase</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">TBase</span>&gt; <span class="title">ConvertIList</span>&lt;<span class="title">T</span>, <span class="title">TBase</span>&gt;(<span class="title">IList</span>&lt;<span class="title">T</span>&gt; <span class="title">list</span>) <span class="keyword">where</span> <span class="title">T</span> : <span class="title">TBase</span></span><br><span class="line">&#123;</span><br><span class="line">List&lt;TBase&gt; baseList = <span class="keyword">new</span> List&lt;TBase&gt;(list.Count);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; list.Count ; index++ )&#123;</span><br><span class="line">baseList.Add(list[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> baseList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">IList&lt;IComparable&gt; list = ConvertIList&lt;<span class="built_in">string</span>,IComparable&gt;(ls);</span><br></pre></td></tr></table></figure><p><strong>构造器约束</strong></p><p>参数T可以指定0~1个构造器约束，就是new：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeType</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">new</span>() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Factory</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">// 允许值类型，因为所有值类型隐式有一个公共无参构造器</span></span><br><span class="line"><span class="comment">// 也允许实现了公共无参构造器的引用类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可验证性"><a href="#可验证性" class="headerlink" title="可验证性"></a>可验证性</h3><p><strong>可验证性</strong></p><p>为了确保安全，约束代码有所验证。</p><p><strong>1.泛型类型变量的转换</strong></p><p>如果不提供约束并按照约束规则转型，直接将泛型类型的变量强转型为其他类型会报错：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span> : <span class="title">Test</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供约束并按照约束规则转型，可以编译过。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method1</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>) <span class="keyword">where</span> T : Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> x = (Test)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不兼容的转型，下面这段是编译不过的：无法将T转换为int。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method2</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> x = (<span class="built_in">int</span>)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不约束就只能转换为object！可以编译过。但是如果转型失败会报InvalidCastException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method3</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> x = (<span class="built_in">object</span>)obj;</span><br><span class="line"><span class="keyword">var</span> y = (<span class="built_in">int</span>)(<span class="built_in">object</span>)obj;</span><br><span class="line"><span class="keyword">var</span> z = obj <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.将泛型类型变量设为默认值</strong></p><p>将泛型类型变量设置为null是编译不过的，除非将泛型类型约束成引用类型。</p><p>原因是编译器确定不了T的类型，而值类型不能为null，引用类型可以。<br>添加约束为引用类型就可以合法了。</p><p>但是我们也可以这么做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">// 下面的编译不过</span></span><br><span class="line">T temp = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 下面的编译得过</span></span><br><span class="line">T temp = <span class="literal">default</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.将泛型类型变量与null进行比较</strong></p><p>可以比较。</p><p>如果T是值类型，永远不会为null、永远返回false，编译器知道，所以在生成代码中就会直接理解为false。</p><p><strong>4.两个泛型类型变量相互比较</strong></p><p>如果泛型类型参数不能肯定是引用类型，对同一个泛型类型的两个变量比较也是非法的。</p><p><strong>5.泛型类型变量作为操作数使用</strong></p><p>+、-、*、/ 是非法的。</p><h1 id="大章13：接口"><a href="#大章13：接口" class="headerlink" title="大章13：接口"></a><center>大章13：接口</center></h1><h3 id="实现接口和继承的关系"><a href="#实现接口和继承的关系" class="headerlink" title="实现接口和继承的关系"></a>实现接口和继承的关系</h3><p><strong>关于接口继承</strong></p><p>因为C#不支持多继承，所以推出了“缩水版”的多继承，也就是接口。</p><p><strong>聊下继承</strong></p><p>System.Object类是终极基类，所有类都继承了Object的4个实例方法，这个之前讲过不提了。</p><p>这里要聊一下的是方法签名，就是C#编译器会认为自己在操作Object类的实例（因为继承了Object），可以有各种智能感知等等，但实际操作的可能是其他类的实例。</p><h3 id="接口初识"><a href="#接口初识" class="headerlink" title="接口初识"></a>接口初识</h3><p><strong>聊下接口</strong></p><p>接口，是用来被实现的。</p><p>它实际只是对一组方法签名进行了统一命名。这些方法不提供任何实现，继承了某接口的类需要显式实现该接口定义的所有方法。</p><p>除了实现了多继承，它的另一个好处和类一样，就是“里氏替换原则”：</p><blockquote><p>派生类对象可以在程式中代替其基类对象。</p></blockquote><p><strong>CLR怎么看接口</strong></p><p>其实CLR看来，接口定义就是类型定义。也就是CLR会为接口类型对象定义内部数据结构，同时可通过反射机制来查询接口类型的功能。</p><p>接口支持泛型方法。</p><p><strong>接口“继承”接口</strong></p><p>接口“继承”接口就有点不一样了，这和传统的类继承类不一样，它更接近于将其他接口的协定(contract)包括到新接口中。</p><h3 id="接口幕后"><a href="#接口幕后" class="headerlink" title="接口幕后"></a>接口幕后</h3><p><strong>显式实现接口</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SomeType</span> : <span class="title">IDisposable</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;public Dispose&quot;</span>); &#125;</span><br><span class="line"><span class="comment">// 显式实现，无法限制可访问性必须是private</span></span><br><span class="line"><span class="keyword">void</span> IDisposable.Dispose() &#123; Console.WriteLine(<span class="string">&quot;IDisposable Dispose&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Main()&#123;</span><br><span class="line">SomeType st = <span class="keyword">new</span> SomeType();</span><br><span class="line"><span class="comment">// 调用公共Dispose方法实现</span></span><br><span class="line">st.Dispose();</span><br><span class="line"></span><br><span class="line">IDisposable dp = st;</span><br><span class="line"><span class="comment">// 调用IDispose的Dispose方法实现</span></span><br><span class="line">    dp.Dispose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: public Dispose , IDisposable Dispose</span></span><br></pre></td></tr></table></figure><p>输出不同，说明后者调用到的是显式实现接口的方法。下面再解释为什么。</p><p><strong>隐式实现：编译器是怎么看待接口实现的？</strong></p><p>先再来看隐式实现，并给出编译器执行流程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SomeType</span> : <span class="title">IDisposable</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;public Dispose&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: public Dispose , public Dispose</span></span><br></pre></td></tr></table></figure><p>可以看到，与显式实现比对，输出又相同了。CLR对这段代码的处理流程如下：</p><ol><li>首先CLR加载类型时，会为该类型创建并初始化一个方法表，每个方法都有对应的记录项（第一章）。<br>对于上述<code>SomeType</code>类型的方法表，会生成以下3个记录项：</li></ol><ul><li>Object（隐式继承的基类）定义的所有虚实例方法。</li><li>IDisposable（继承的接口）定义的所有接口方法。这里指Dispose。</li><li>SomeType引入的新方法Dispose。</li></ul><ol start="2"><li><p>为简化编程，C#编译器假定SomeType引入的新方法Dispose是对IDisposable的Dispose方法的实现。因为两者签名和返回值完全一致。</p></li><li><p>C#编译器接下来，会将这新方法和接口方法进行匹配，生成元数据，指明<code>SomeType</code>类型的放发表中的两个记录项应引用同一个实现。</p></li></ol><p>综上，<br>隐式实现接口方法的时候，2个方法在元数据里指向同一个实现，所以完全一致；<br>显式实现接口方法的时候，2个方法在元数据里指向不同的实现，只不过接口的同签名方法是private的，想要调用，需要用接口申明的变量去接这个实例，才能调用到。</p><h3 id="泛型接口-1"><a href="#泛型接口-1" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>使用泛型接口有一些好处：</p><ol><li>类型确定，提高编译时安全性。</li><li>避免装箱拆箱。</li><li>类可以实现同一个接口若干次，只要T不同即可，接口代码复用率提高。</li><li>泛型接口也可以协变逆变，具体看12.4泛型委托里。</li></ol><h3 id="泛型接口约束"><a href="#泛型接口约束" class="headerlink" title="泛型接口约束"></a>泛型接口约束</h3><p>一样是where，书中只举了个方法例子，避免了拆装箱 并 验证了类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值类型实现了IComparable,IConvertible</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SomeMethod</span>&lt;<span class="title">T</span>&gt;(<span class="params">T t</span>) <span class="keyword">where</span> T : IComparable,IConvertible</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main()&#123;</span><br><span class="line"><span class="built_in">int</span> x = <span class="number">5</span>;</span><br><span class="line">Guid g = <span class="keyword">new</span> Guid();</span><br><span class="line"><span class="comment">// 避免装箱，要知道IComparable接口的Compare方法入参是object类型！</span></span><br><span class="line">SomeMethod(x);</span><br><span class="line"><span class="comment">// 编译错误，Guid未实现IConvertible</span></span><br><span class="line">SomeMethod(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再聊显式实现方法"><a href="#再聊显式实现方法" class="headerlink" title="再聊显式实现方法"></a>再聊显式实现方法</h3><p><strong>优点1：可实现多个具有同签名方法的接口</strong></p><p>就是说可以靠显式实现，来实现多个同名、同签名方法的接口。</p><p>基本没用过，不同接口接同一个对象，能有不同的方法实现，这算是另一种意义上的多态吗？</p><p>总之是能有效解决多个接口有同签名方法，一个类无法同时实现多个这样的接口的问题。</p><p><strong>缺点1：无智能感知</strong></p><p><strong>缺点2：无法被派生类调用</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如有一个基类显式实现了IComparable的CompareTo</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 想在派生类里调用基类的CompareTo，下面这样是编译不过的</span></span><br><span class="line"><span class="keyword">base</span>.CompareTo(o);</span><br><span class="line"><span class="comment">// 要这么写</span></span><br><span class="line">((IComparable)<span class="keyword">base</span>).CompareTo(o);</span><br><span class="line"><span class="comment">// 或者在基类写一个公开的虚方法，与显式调用同名同实现</span></span><br></pre></td></tr></table></figure><p><strong>缺点3：值类型调用时需要装箱</strong></p><p>代码不贴了，和2一样，<font color="red">需要转换成对应接口才能调用显式实现方法</font>，而值类型转换接口时需要装箱。</p><h3 id="设计：基类还是接口"><a href="#设计：基类还是接口" class="headerlink" title="设计：基类还是接口"></a>设计：基类还是接口</h3><p><strong>1.IS-A对比CAN-DO关系</strong></p><p>CAN-DO关系，就是很多类型对象都“能”做某事，这需要用接口。</p><p><strong>2.易用性</strong></p><p>基类提供各个方面的功能，接口需要一个个实现。</p><p><strong>3.一致性实现</strong></p><p>基类型可以提供好的默认实现，接口不能提供默认实现，容易让开发人员出错。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> CLR via C# </category>
          
          <category> 第二章 C#类的设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
            <tag> 虚方法 </tag>
            
            <tag> 可访问性 </tag>
            
            <tag> 元数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 网络同步篇</title>
      <link href="/Project/Unity/Moba/HOK/netSyn/"/>
      <url>/Project/Unity/Moba/HOK/netSyn/</url>
      
        <content type="html"><![CDATA[<h1 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h1><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p><strong>什么是同步</strong></p><ul><li>在不同的客户端上表现相同。</li><li>目前市面上的游戏，一般分为帧同步和状态同步。</li></ul><p><strong>什么是帧同步</strong></p><ul><li>是一种网络同步技术。</li><li>由客户端A发送请求到服务端，再轮播给所有客户端各自在本地进行计算。</li><li>帧同步需要确保不同平台运算结果统一。</li></ul><p><strong>什么是状态同步</strong></p><p>与帧同步最大的区别就是，它不需要按<strong>逻辑帧（固定时间间隔）</strong>去同步数据，而是根据<strong>数据发生改变后</strong>才进行同步数据。</p><h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><ul><li>王者荣耀就是用帧同步方式实现的网络同步。另外LOL用的是状态同步。</li></ul><p><strong>帧同步vs状态同步</strong></p><ul><li>战斗逻辑。帧同步是在客户端（或移到服务端）进行计算；状态同步一般只在服务端进行计算。</li><li>开发压力。帧同步因为在客户端算，要解决不同平台浮点数的差异，需要额外开发定点数替换浮点数；状态同步是在服务端算，相对安全，但对服务端负载要求更为高。</li><li>战斗重连。帧同步，玩家重连只能从服务端获取操作序列帧加速运算来恢复重连；状态同步可以随时获取到一个时间点的状态，所以mmo采用这个为主，可以瞬间恢复。</li><li>更新频率。帧同步，服务端必须保持定时推送同步信息给客户端，即使没有任何变更；状态同步，可以等某个状态发生变化了才推送同步信息给客户端。</li></ul><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><ul><li>各种平台的浮点精度不一，计算结果不统一怎么办？通过 定点数运算数学库 替换 浮点运算。</li><li>Unity碰撞环境也是基于浮点运算实现的，无法确保计算结果统一，怎么办？自己实现移动和物理碰撞，自己计算确定性物理碰撞。</li><li>不使用浮点数而使用定点数，或限定各客户端所运行的硬件及操作系统从而浮点数的运算是一致的；</li></ul><p>以下是<a href="https://blog.csdn.net/weixin_39986741/article/details/111669001">完整定义</a>：</p><ul><li>确定性的随机数机制；</li><li>确定性的容器及算法(增加、移除、排序等)；</li><li>隔离和封装逻辑层，以防止其他不确定性的调用；</li><li>如需，则也须做到确定性的物理机制、导航机制、动画骨骼机制等；</li><li>排查所有引起异常(exception)的逻辑。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.png"></p><p>下面只对项目使用的帧同步进行分析，不再涉及状态同步的讨论。</p><h1 id="实时对战"><a href="#实时对战" class="headerlink" title="实时对战"></a>实时对战</h1><h2 id="实现难点与解决"><a href="#实现难点与解决" class="headerlink" title="实现难点与解决"></a>实现难点与解决</h2><p>Q：帧同步需要高频率的网络通信，TCP因为复杂的确认机制导致速度慢而无法满足要求怎么办？<br>A：要实现可靠的UDP通信。</p><p>Q：服务器每秒需要转发大量逻辑帧来驱动客户端表现，因此需要大量通信。我使用15帧，也就是每66ms广播一次。哪怕是15帧也很低，客户端播放看上去很卡怎么办？<br>A：实现逻辑与显示分离，客户端的显示性能拉满不限制帧数，数据则完全是以15帧的逻辑层为准。</p><p>Q：逻辑与显示是分离了，但是显示的空缺帧怎么补？<br>A：客户端进行运动行为预测与插值，来平滑运动轨迹。</p><p>下面一章按照上面的几个回答，一个一个展开。</p><h1 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h1><h2 id="整体框架图"><a href="#整体框架图" class="headerlink" title="整体框架图"></a>整体框架图</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211126004941.png"></p><h2 id="实现可靠的UDP通信"><a href="#实现可靠的UDP通信" class="headerlink" title="实现可靠的UDP通信"></a>实现可靠的UDP通信</h2><blockquote><p>Q：帧同步需要高频率的网络通信，TCP因为复杂的确认机制导致速度慢而无法满足要求怎么办？<br>A：要实现可靠的UDP通信。</p></blockquote><h2 id="逻辑帧与显示帧分离"><a href="#逻辑帧与显示帧分离" class="headerlink" title="逻辑帧与显示帧分离"></a>逻辑帧与显示帧分离</h2><blockquote><p>A：实现逻辑与显示分离，客户端的显示性能拉满不限制帧数，数据则完全是以15帧的逻辑层为准。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/%E8%BF%90%E5%8A%A8%E9%A2%84%E6%B5%8B%E5%8F%8A%E5%B9%B3%E6%BB%91%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.png"></p><ul><li><p>逻辑帧15帧(66ms)，表现帧60帧(16.5ms)的情况，用图表现如上。</p></li><li><p>数据层，依赖于逻辑帧，按照每秒15帧为准，需要完全脱离Unity的框架（甚至可以直接在服务器上跑）。</p></li><li><p>显示层，直接继承MonoBehaviour，按照每秒60帧甚至更高为准，补逻辑帧不够的帧。</p></li></ul><h2 id="运动预测"><a href="#运动预测" class="headerlink" title="运动预测"></a>运动预测</h2><blockquote><p>Q：逻辑与显示是分离了，但是显示的空缺帧怎么补？<br>A：客户端进行运动行为预测与插值，来平滑运动轨迹。</p></blockquote><p><strong>运动预测</strong></p><ul><li>用算法计算出后续运动量，补齐表现帧：</li><li>Position预测偏移 = 逻辑帧速度 * 逻辑帧方向 * 时间。</li><li>Rotation不进行预测。转向的预测不可靠。</li></ul><p><strong>逻辑帧驱动</strong></p><ul><li>服务器推送回来逻辑帧后，立刻更新表现帧。</li></ul><p><strong>预测误差</strong></p><ul><li>如果出现和上面那张图一样，运动预测错误的情况，属于正常范畴，但是尽可能避免与修复。</li></ul><p><strong>网络误差</strong></p><ul><li>网络波动，导致可能不止66ms更新一次逻辑帧，那样就会一直预测跑动，等拉回来后人物会出现瞬移，解决办法是限制补帧的上限值，即两次逻辑帧之间最多只补x帧。</li></ul><h2 id="平滑算法"><a href="#平滑算法" class="headerlink" title="平滑算法"></a>平滑算法</h2><p>比如拐弯行为，会频繁出现 <font color="red">预测误差</font> 导致人物动画很毛糙，所以需要平滑处理。</p><p><strong>线性插值函数Lerp</strong></p><p><code>public static Vector3.Lerp(Vector3 a, Vector3 b, float t)</code>。</p><p>插值，等于 a + (b - a) * t。</p><p><strong>移动平滑</strong></p><ul><li>Position平滑的方法是，使用线性插值</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.position = Vector3.Lerp(transform.position,viewTargetPos,Time.deltaTime * viewPosAccer);</span><br></pre></td></tr></table></figure><p><strong>旋转平滑</strong></p><ul><li>Rotation平滑的方法仍然是使用线性插值，但是和Position不同的是，需要一个增量：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> threshold = Time.deltaTime * viewDirAccer;</span><br><span class="line"><span class="built_in">float</span> angle = Vector3.Angle(RotationRoot.forward, viewTargetDir);</span><br><span class="line"><span class="comment">// 增量：</span></span><br><span class="line"><span class="built_in">float</span> angleMult = (angle / <span class="number">180</span>) * AngleMultiplier * Time.deltaTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (viewTargetDir != Vector3.zero)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 interDir = Vector3.Lerp(RotationRoot.forward, viewTargetDir, threshold + angleMult);</span><br><span class="line">    RotationRoot.rotation = CalcRotation(interDir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 算出旋转角度</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Quaternion <span class="title">CalcRotation</span>(<span class="params">Vector3 targetDir</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Quaternion.FromToRotation(Vector3.forward, targetDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>angleMult</code>其实就是两者唯一的区别，为什么需要一个增量呢？</p><p>// TODO 考虑到角度的偏转可能大可能小，所以做一个根据角度偏转大小成正比的角度变化加成量。但是实际效果需要在理解Vector3.Lerp后才能计算出。</p><h1 id="FPS、Ping计算"><a href="#FPS、Ping计算" class="headerlink" title="FPS、Ping计算"></a>FPS、Ping计算</h1><h2 id="画面FPS"><a href="#画面FPS" class="headerlink" title="画面FPS"></a>画面FPS</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> frameTimeCount;</span><br><span class="line"><span class="built_in">int</span> frameCounter;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateFPS</span>(<span class="params"><span class="built_in">float</span> delta</span>)</span> &#123;</span><br><span class="line">    frameTimeCount += delta;</span><br><span class="line">    ++frameCounter;</span><br><span class="line">    <span class="comment">// 每2秒更新一次FPS数值</span></span><br><span class="line">    <span class="keyword">if</span>(frameTimeCount &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        txtFPS.text = <span class="string">&quot;FPS &quot;</span> + frameCounter / <span class="number">2</span>;</span><br><span class="line">        frameTimeCount -= <span class="number">2</span>;</span><br><span class="line">        frameCounter = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    UpdateFPS(Time.DeltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>通过<strong>心跳机制</strong>来计算ping值。</p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>① 从 客户端连接服务器 成功开始，就定期从客户端发送请求到服务端，频率不用太高（我这里设置每5s一次），在请求包中记录这一次心跳请求的ID。</p><p>② 服务端接收到心跳专用的请求包后，直接发回给对应的客户端，回应包中附带本次心跳请求的ID。</p><p>③ 客户端接收到回应包，里面包含着本次心跳请求的ID（当然需要其他数据也可以附带）。</p><h3 id="基于心跳机制计算ping"><a href="#基于心跳机制计算ping" class="headerlink" title="基于心跳机制计算ping"></a>基于心跳机制计算ping</h3><p>在NetSvc中，维护这样一个List（这里用字典，哈希更快）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uint 是 心跳请求ID, DateTime是请求发送时间</span></span><br><span class="line">Dictionary&lt;<span class="built_in">uint</span>, DateTime&gt; pingDic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">uint</span>, DateTime&gt;();</span><br></pre></td></tr></table></figure><ol><li><p>在上述 心跳机制① 中，每次发送包时都顺带进行<code>pingDic.Add(sendPingId++, DateTime.Now);</code></p></li><li><p>在上述 心跳机制③ 中，每次收到回应包时，都对 pingDic 进行查找，可以找到同ID的请求时间，再用<code>DateTime.Now</code>减去它，就可以获得一次完整的心跳请求需要的时间。这就是ping了，之后只要修改UI显示Ping就可以了。</p></li></ol><h1 id="连接公网服务器"><a href="#连接公网服务器" class="headerlink" title="连接公网服务器"></a>连接公网服务器</h1><p>使用阿里云服务器 ECS。</p><h2 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h2><p>腾讯云4核8G轻量型服务器</p><p>系统 2019 Windows Server</p><p>带宽 10m</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>使用文件夹形式发布，然后拷贝到云服务端。</p><p>这里遇到了个坑，修了一晚上，就是<strong>不要勾选 裁剪未使用的程序集</strong>！！！我不知道是导致dll的引用没了还是动态加载的Assembly缺失，总之就是被坑惨了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220122233615.png"></p><h2 id="配置端口白名单"><a href="#配置端口白名单" class="headerlink" title="配置端口白名单"></a>配置端口白名单</h2><p>在服务器配置的 “安全组”的出、入方向中，添加udp和对应的端口号。</p><h1 id="反作弊"><a href="#反作弊" class="headerlink" title="反作弊"></a>反作弊</h1><p>刚好看到有人聊这个，觉得不错记录一下。</p><p>• 服务器计算关键逻辑。例如一些MMO战斗逻辑泡在服务端<br>• 服务器验证客户端逻辑。包括通过完整战斗逻辑验证和数值范围验证，例如早期的酷跑（可能误杀牛逼的玩家）<br>• 包体加密加签名加验证，防止破解包体。例如一些第三方加固，Unity的MonoDll加密，代码混淆等<br>• 加密本地保存的一些文件。例如对加密PlayerPrefs文件<br>• 加密和扰动运行时内存中关键数据（例如血量数据等）。例如崩3等<br>• 防注入检测（杀死注入进程或者发现注入之后杀死自己）<br>• 虚拟机加密<br>• 加速检测，防止修改本地时间的变速齿轮<br>• 穿墙检测，客户端对关键碰撞做校验<br>• 集成守护进程以及守护进程的自我加密更新<br>• 鼠标宏，按键精灵等进程检测，防止玩家使用这些工具<br>• 增加举报系统查证封号</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
            <tag> C/S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 战斗篇</title>
      <link href="/Project/Unity/Moba/HOK/fight/"/>
      <url>/Project/Unity/Moba/HOK/fight/</url>
      
        <content type="html"><![CDATA[<h1 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211118235252.png"></p><h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p><img src="D:\github\hexo\blog\source_posts\Project\Unity\Moba\HOK\frameSyn.assets\image-20211118234026519.png" alt="image-20211118234026519"></p><h1 id="技能模块"><a href="#技能模块" class="headerlink" title="技能模块"></a>技能模块</h1><p>见技能篇：// TODO link </p><h1 id="一些小功能的实现"><a href="#一些小功能的实现" class="headerlink" title="一些小功能的实现"></a>一些小功能的实现</h1><h3 id="摄像机跟随"><a href="#摄像机跟随" class="headerlink" title="摄像机跟随"></a>摄像机跟随</h3><p>要点是将 人物的位置 映射成 相机的位置。这里简单实现。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211202234518.png"></p><ol><li>将相机的初始偏移值设置好，将角色初始位置能很好的放在中间显示。</li><li>Update中进行position对齐</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FightMgr.Update()&#123;</span><br><span class="line"><span class="comment">// transCameraRoot物体下有一个旋转调整过初始值的相机。</span></span><br><span class="line">mapRoot.transCameraRoot.position = transFollow.position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技能UI映射到地图"><a href="#技能UI映射到地图" class="headerlink" title="技能UI映射到地图"></a>技能UI映射到地图</h3><p><strong>非指向技能1：后羿的2技能</strong></p><p>要点是将 UI拖拽的位置 映射成 地图向量的位置。</p><ol><li>将技能UI拖拽起始点做记录，根据 拖动的点 - 拖拽起始点 = dir 获得一个初始的Vector2值。</li><li>将dir进行映射，具体做法是方向直接用dir.x和dir.y来作为地图的x、z轴，y轴取0；距离用一个倍乘器乘dir的模。映射好放到一个Vector3里。</li><li>将映射好的Vector3，偏转45度，因为相机偏转，技能也一起偏转以便与UI拖拽的方向对其。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skillCfg.releaseMode == ReleaseModeEnum.Position)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从UI映射到地图</span></span><br><span class="line">dir = BattleSys.Instance.SkillDisMultiplier * dir;</span><br><span class="line">Vector2 clampDir = Vector2.ClampMagnitude(dir, skillCfg.targetCfg.selectRange);</span><br><span class="line">Vector3 clampDirVector3 = <span class="keyword">new</span> Vector3(clampDir.x, <span class="number">0</span>, clampDir.y);</span><br><span class="line">clampDirVector3 = Quaternion.Euler(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>) * clampDirVector3;<span class="comment">// 这里的45度是相机偏移的45度</span></span><br><span class="line">viewHero.SetSkillGuide(skillIndex,<span class="literal">true</span>,ReleaseModeEnum.Position,clampDirVector3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非指向技能2：后羿的大招</strong></p><p>也是映射，这个很简单，只要映射方向就行，最后偏转相机角度 + 规格化。<br>直接上代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (skillCfg.releaseMode == ReleaseModeEnum.Direction)</span><br><span class="line">&#123;</span><br><span class="line">Vector3 dirVector3 = <span class="keyword">new</span> Vector3(dir.x, <span class="number">0</span>, dir.y);</span><br><span class="line">dirVector3 = Quaternion.Euler(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>) * dirVector3;<span class="comment">// 这里的45度是相机偏移的45度</span></span><br><span class="line">viewHero.SetSkillGuide(skillIndex,<span class="literal">true</span>,ReleaseModeEnum.Direction,dirVector3.normalized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2种非指向技能的完成图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211202235707.png"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
            <tag> C/S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR Via C#个人笔记3 - 基元类型、引用类型和值类型</title>
      <link href="/Tech/CSharp/CLR-Via-CSharp/cp3/"/>
      <url>/Tech/CSharp/CLR-Via-CSharp/cp3/</url>
      
        <content type="html"><![CDATA[<h1 id="大章5：值类型与引用类型"><a href="#大章5：值类型与引用类型" class="headerlink" title="大章5：值类型与引用类型"></a><center>大章5：值类型与引用类型</center></h1><h3 id="基元类型"><a href="#基元类型" class="headerlink" title="基元类型"></a>基元类型</h3><p><strong>什么是基元类型？</strong></p><ul><li>有些数据类型太常用了，为了方便程序员书写，C#编译器允许代码以简化语法来操纵。这些编译器直接支持的数据类型叫做<font color="#dd0000">基元类型（primitive type）</font>。</li><li>注意一下，一般国人说的类型是指值类型和引用类型的分类，和这里的类型不是一个意思。</li></ul><p>比如以下的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">System.Int32 a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> a = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">System.Int32 a = <span class="keyword">new</span> System.Int32();</span><br></pre></td></tr></table></figure><p>他们4个生成的IL代码是完全一样的。</p><p><strong>基元类型一览</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211112113330.png"></p><p><strong>基元类型的映射</strong></p><ul><li>string和String都是直接映射System.String，所以他们是完全一样的，所以基元类型的本质是<font color="#dd0000">映射到FCL（.NET 的 Framework Class Library）类型</font>。</li><li>不同语言编译器，对于映射的处理不同，比如C#会将long映射到System.Int64而C++是映射Int32。</li><li>隐式转换，C#只会在转换安全的情况下才允许。所谓安全，就是说不会发生数据丢失的情况，比如从低精到高精。显式转换可以允许数据丢失，C#总是会选择将数据截断，而不是取上取整。</li></ul><p><strong>基元类型的溢出检查</strong></p><p>比如以下代码就会溢出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Byte b = <span class="number">100</span>;</span><br><span class="line">b = (Byte)(b + <span class="number">200</span>);<span class="comment">// 溢出了，b已经超过了2^8</span></span><br></pre></td></tr></table></figure><p>溢出处理根据不同编译器，处理结果是不同的。C++不将溢出视为错误，允许值回滚（wrap），程序会继续执行；而C#允许程序员自己选择最合适的处理，是否检查溢出抛错。<br>C#溢出检查默认关闭，意味着我们编译生成的IL代码是无溢出检查版本，代码能更快运行，但要求开发人员能保证不发生溢出。如果执行的是溢出检查版本，运算执行时会稍慢一些，且检查不过关会抛出OverflowException异常。</p><ul><li>C#全局开启溢出检查：编译时使用 /checked+编译器开关。</li><li>C#局部开启溢出检查：用 checked 和 unchecked 关键字</li><li>比较好的控制溢出方案是，对于不希望溢出的核心数据，放在checked中抛异常catch住，然后再catch里得体恢复数据。</li></ul><p>此外，<font color="#dd0000">decimal类型</font>特别特殊，结构和编译器处理不同，上面的checked和unchecked不会起效，<font color="#dd0000">一定会抛出OverflowException异常</font>。</p><h3 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h3><p>CLR允许2种类型：引用类型和值类型。<br>我们要阐明两者的区别。首先说一下引用类型。</p><h4 id="①-内存分配差异"><a href="#①-内存分配差异" class="headerlink" title="① 内存分配差异"></a>① 内存分配差异</h4><p><strong>引用类型</strong><br>5个特点</p><ol><li>内存必须从托管堆分配。</li><li>C#的new操作符返回对象内存地址——即指向对象数据的内存地址。</li><li>堆上分配的每个对象都有一些额外成员，这些额外成员必须初始化。</li><li>对象中的其它字节（为字段而设）总是设为0。</li><li>从托管堆分配对象时，可能强制执行一次GC。</li></ol><p>可以看到，引用类型的开销非常之大，如果全是引用类型，那么程序的性能会显著下降。为了提升简单常用类型的性能，CLR提供了“值类型”的轻量级类型。比较一下。</p><p><strong>vs 值类型</strong></p><ol><li>值类型实例一般在线程栈上分配（当然也可以作为字段嵌入引用类型的对象中，那就在堆上了）。</li><li>在代表值类型的实例中包含的是实例本身的字段，而不是引用or指针。</li><li>值类型的实例不受GC垃圾回收器的控制，意思是不会引起GC，从而有效减少了GC回数。</li><li>未装箱的值类型不会在堆上分配，意味着一旦定义了该类型的实例得方法不再活动，为其分配的存储空间会立刻被释放。</li></ol><p>微软DOCS会清楚指出哪些类是引用类型，哪些是值类型。<font color="#dd0000">叫“类”的是引用类型，叫“结构”、“枚举”的是值类型</font>。<br>继续研究会发现，所有“结构”都是抽象类型<font color="#dd0000">System.ValueType</font>的直接派生类，System.ValueType本身又直接从System.Object派生。所有“枚举”都从System.Enum抽象类型派生，System.Enum本身有直接从System.ValueType派生。简单来说就是：</p><ul><li>  System.Enum &lt;&lt; System.ValueType &lt;&lt; System.Object</li></ul><p>值类型是密封类，目的是为了防止被作为基类，当然可以选择给值类型实现多个接口。</p><h4 id="②-两者使用分配流程"><a href="#②-两者使用分配流程" class="headerlink" title="② 两者使用分配流程"></a>② 两者使用分配流程</h4><p>没啥好说的，总结一下，具体的看图吧。</p><ul><li>值类型，真实的值放在线程栈上；赋值就是深拷贝，我们自己想写值类型用<code>struct</code>关键字。</li><li>引用类型，线程栈上只持有指针，真实的值放在托管堆上，<font color="#dd0000">哪怕类里面有值类型字段，值类型字段也会被放在托管堆上</font>；赋值只是浅拷贝，线程栈上给赋个指针，我们自己写用<code>class</code>关键字。</li><li>还有就是，虽然①里说了，值类型拥有减少GC得好处，但是值类型需要逐位复制，所以期望其类型得实例比较小（小于16字节）。而且struct是密封的，意味着值类型不能作为基类，对代码复用不友好。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211112155709.png"></p><h4 id="③-值类型的装箱和拆箱"><a href="#③-值类型的装箱和拆箱" class="headerlink" title="③ 值类型的装箱和拆箱"></a>③ 值类型的装箱和拆箱</h4><p><strong>什么是装箱？</strong></p><ul><li>一种机制。将值类型转换成引用类型的就叫做装箱机制。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span> Int32 x,y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">ArrayList a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Point p;</span><br><span class="line"><span class="keyword">for</span>(Int32 i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i ++)&#123;</span><br><span class="line">p.x = p.y = i;</span><br><span class="line">a.Add(p);<span class="comment">// 对值类型装箱，将引用添加到ArrayList中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 补充：下面是ArrayList.Add()方法的接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Int32 <span class="title">Add</span>(<span class="params">Object <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>装箱时发生了什么？</strong></p><p>换句话说也就是将值类型转换成引用类型时发生了什么。</p><ol><li>在托管堆中分配内存。分配的内存量时值类型各字段所需的内存量 + 托管堆所有对象都有的两个额外成员（类型对象指针 和 同步块索引）所需的内存量。</li><li>值类型的字段复制到新分配的堆内存中。</li><li>返回对象地址。</li></ol><p>结束这套流程后，返回的是地址，所以变成引用类型了。<br>C#编译器检测到上述代码是向要求引用类型的方法传递值类型，所以自动生成IL代码对对象进行装箱。具体发生的事看下面。</p><p><strong>C#编译器做 装箱 时具体干了什么？</strong></p><p>检测到上述情况后，会把当前存在于Point值类型实例p中的字段复制到新分配的对象中，再把这个对象的引用返回到Add方法作为入参继续执行。外部只知道p是引用类型，可以被继续引用标记，且已装箱的值类型的生存期超过了未装箱值类型的生存期。</p><p><strong>什么是拆箱？</strong></p><ul><li>拆箱不是直接将装箱的过程倒过来！它的代价比装箱小得多。</li><li>拆箱只是指获取指针的过程，获取的是指向包含在一个引用对象中的原始值类型（也就是字段，比如上面的x、y字段）的指针。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定要用以下代码获取ArrayList的第一个元素</span></span><br><span class="line">Point p = (Point) a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p><strong>拆箱时发生了什么？</strong></p><ol><li>获取已装箱Point对象中的各个字段的地址。（这个叫拆箱）</li><li>将字段包含的值从堆中复制到栈的值类型实例中。（拆箱操作经常紧接着一次字段复制）</li></ol><p>注意，以上情况中，如果引用的对象不是所需值类型的已装箱实例，会抛出InvalidCastException异常。比如，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Int32 x = <span class="number">5</span>;</span><br><span class="line">Object o = x;<span class="comment">// 对x装箱，o引用已装箱对象</span></span><br><span class="line">Int16 y = (Int16) o;<span class="comment">// 抛出InvalidCastException异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从逻辑上说，完全能把o从Int32转换成Int16，但是不行，只能转换为最初未装箱时的值类型。</p><p><strong>C#编译器做 拆箱 时具体干了什么？</strong></p><p>其实和上面讲述的是一样的。</p><ol><li>先对o拆箱，生成一条IL指令，获取已装箱对象中的各个字段的地址。</li><li>再复制，生成一条IL指令，将这些字段从堆复制到栈变量中。</li></ol><p><strong>简单的拆装箱优化</strong></p><ul><li>一些常用方法有很多重载，根据入参的不同选择最合适的入参，减少拆装需求</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Int32 v = <span class="number">5</span>;</span><br><span class="line">Object o = v;</span><br><span class="line">v = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的输出结果都一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这一句需要装2次拆1次</span></span><br><span class="line">Console.WriteLine(v + <span class="string">&quot;,&quot;</span> + (Int32) o);<span class="comment">// 为了输出，需要拼接3个字段，底层用的是 public static String Concat (Object arg0, Object arg1, Object arg2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这一句需要装1次</span></span><br><span class="line">Console.WriteLine(v + <span class="string">&quot;,&quot;</span> + o);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这一句需要装0次</span></span><br><span class="line">Console.WriteLine(v.ToString() + <span class="string">&quot;,&quot;</span> + o);<span class="comment">// String已经是引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这一句需要装0次</span></span><br><span class="line">Console.WriteLine(v);<span class="comment">// 底层优化过了，用的是 public static void WriteLine(Int32 value);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样的类多次装箱or拆箱，可以合并为一次</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v是个Int32型</span></span><br><span class="line"><span class="comment">// 下面一句要装3次</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;</span>,v,v,v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面只要装1次</span></span><br><span class="line">Object o = v;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;</span>,o,o,o);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>未装箱值类型vs引用类型</strong></p><p>未装箱值类型更轻：</p><ul><li>不再托管堆上分配。</li><li>没有每个对象都有的额外成员：“类型对象指针” 和 “同步块索引”。</li></ul><p>因为没有同步块索引，所以无法用lock等。</p><p>除此之外，调用一些 未装箱值类型 自己的方法或者重写的方法时是不需要装箱的（比如在struct定义中重写<code>public override String ToString()</code> ）；<br>而由 System.Object 所定义的方法（非虚继承），那么就需要装箱，比如p.GetType();<br>或者你重写的方法里，还调用了基类型的方法，那么就要装箱。</p><p><strong>最后聊一下</strong></p><p>已装箱过的值类型，再拆箱更改其字段的话只是改了拆箱后的栈字段，在堆上的已装箱值类型数据是不会被修改的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">// Point是struct类</span></span><br><span class="line">Object o = p;<span class="comment">// 已装箱过的值类型o</span></span><br><span class="line">((Point) o).Change(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">Console.WriteLine(o);<span class="comment">// 输出1,1</span></span><br></pre></td></tr></table></figure><p>另外，可以用接口欺骗C#，具体的就不说了，可以看书P122。</p><h3 id="对象相等性与同一性"><a href="#对象相等性与同一性" class="headerlink" title="对象相等性与同一性"></a>对象相等性与同一性</h3><p><strong>同一性 identity</strong></p><p>这两个概念都是基于比较对象的概念，比如System.Object类提供的Equals虚方法，是这样的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Object</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Boolen <span class="title">Equals</span>(<span class="params">Object obj</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 如果两个引用指向一个对象，他们肯定包含相同的值</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这不能称之为比较两者是否相等，而是在比较两者指针是否指向同一个堆中对象，这叫做<font color="#dd0000">同一性（identity）</font>。<br>由于是虚方法可以被重写，所以真的想比较 同一性 的话，会选择静态方法 ReferenceEquals。</p><p><strong>相等性 equality</strong></p><p>因为System.Object类提供的Equals方法比较混淆，所以System.ValueType就重写了Object的Equals方法：</p><ol><li>如果obj实参为null，就返回false</li><li>如果this和obj实参引用不同类型的对象（不是对象指针，是之前提过的每个类都会持有自己的类型！），就返回false</li><li>针对类型定义的每个实例字段，进行一一比较（调用字段的Equals方法）。任何字段不相等，就返回false</li><li>返回true！ValueType的Equals方法不调用父类Object的Equals方法</li></ol><p>上述3中的比较，是通过反射完成的。</p><p><strong>重写自己的Equals</strong></p><p>如果想要重写Equals，需要满足下面4个特性：</p><ol><li>Equals必须自反：x.Equals(x)肯定返回true；</li><li>Equals必须对称：x.Equals(y)与y.Equals(x)返回相同的值；</li><li>Equals必须可传递：x.Equals(y)为true、y.Equals(z)也为true，那么x.Equals(z)一定为true</li><li>Equals必须一致</li></ol><p>且我们实际上想写自己的Equals的时候，会这样：</p><ul><li>实现IEquatable<T>接口</li><li>重载==和!=操作符</li></ul><p>如果还需要排序，需要手动实现：</p><ul><li>IComparable接口的CompareTo方法</li><li>IComparable<T>接口的类型安全的CompareTo方法</li><li>重载比较操作符(&lt;、&lt;=、&gt;、&gt;=)，在内部调用类型安全的CompareTo方法</li></ul><h3 id="对象哈希码"><a href="#对象哈希码" class="headerlink" title="对象哈希码"></a>对象哈希码</h3><p>在按照上面重写Equals时会发现，编译器会提示你要求一起重写<code>Object.GetHasCode()</code>方法。包括上面的类型安全实现接口IEquatable<T>，也要求你实现<code>GetHasCode()</code>方法。<br>这是因为由于在System.Collections.Hastable类型、System.Collections.Generic.Dictionary类型以及一些其他集合实现中，要求两个对象必须具有相同哈希码才被视为相等。<br>所以重写Equals就必须重写GetHashCode以保持对象哈希码算法与相等性算法保持一致。</p><p><strong>哈希码是什么</strong></p><p>这里介绍一下哈希码。<br>向集合添加key-val对，首先需要获取key的哈希码。哈希码指出key-val对要存储到哪个哈希桶（bucket）中。<br>集合需要查找键时，会获取指定键对象的哈希码，该哈希码标识了即将要以顺序方式搜索的哈希桶，将会在桶里找对应的key。<br>所以按照上述算法，如果修改了一个键值对的key让它没有存在于正确的哈希桶中，那么就永远找不到它了。所以正确修改key的方法是先删后加。</p><p><strong>重写自己的GetHashCode</strong></p><p>以下规则，全文背诵：</p><ul><li>这个算法要提供良好的随机分布，使哈希表获得最佳性能</li><li>一般不要直接用Object或者ValueType的GetHashCode方法，因为他们性能都不高</li><li>算法至少使用一个实例字段</li><li>理想状态下，算法使用的字段应不可变，在构造时初始化后就不再变是最好的</li><li>算法执行速度尽量快</li><li>包含相同值得不同对象应返回相同哈希码</li><li>不要将哈希码持久化，比如记录进数据库，因为GetHashCode的算法很可能被更新</li></ul><p>举个例子，上面提到的Point类可以这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Point</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> Int32 m_x,m_y;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Int32 <span class="title">GetHasCode</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_x ^ m_y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dynamic基元类型"><a href="#dynamic基元类型" class="headerlink" title="dynamic基元类型"></a>dynamic基元类型</h3><p><strong>dynamic是什么</strong></p><p>dynamic关键字，我的理解，是一个动态决定类型的var。他是为了方便程序员简化代码而推出的不安全类型。具体如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">value</span> = (demo == <span class="number">0</span>) ? (<span class="built_in">dynamic</span>) <span class="number">5</span> :  (<span class="built_in">dynamic</span>) <span class="string">&quot;A&quot;</span> ;</span><br><span class="line"><span class="keyword">value</span> = <span class="keyword">value</span> + <span class="keyword">value</span>;</span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>);<span class="comment">// 输出10和AA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态决定类型，比起纯安全类型，可以省去大量代码。<br>编译器在为dynamic生成特殊IL代码来描述所需要的操作，这种特殊代码叫做<font color="#dd0000">payload（有效载荷）</font>。运行时，payload代码根据dynamic引用的对象的实际类型来决定具体执行操作。</p><p>实际上，dynamic声明一个变量，编译器会把它当作Object来用，IL代码里也就是object，一样的，直到变量被赋值确定了具体类型。</p><p>再来一个简化代码例子来理解dynamic：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用反射调用String.Contains方法</span></span><br><span class="line">Object target = <span class="string">&quot;AAAAAaaa&quot;</span>;</span><br><span class="line">Object arg = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line">Type[] argTypes = <span class="keyword">new</span> Type[]&#123; arg.GetType() &#125;;</span><br><span class="line">MethodInfo method = target.GetType().GetMethod(<span class="string">&quot;Contains&quot;</span>,argTypes);</span><br><span class="line">Object[] arguments = <span class="keyword">new</span> Object[]&#123; arg &#125;;</span><br><span class="line"><span class="built_in">bool</span> result = Convert.ToBoolean(method.Invoke(target,arguments));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是利用dynamic改写上述需求</span></span><br><span class="line"><span class="built_in">dynamic</span> target = <span class="string">&quot;AAAAAaaa&quot;</span>;</span><br><span class="line"><span class="built_in">dynamic</span> arg = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="built_in">bool</span> result = target.Contains(arg);<span class="comment">//注意了，这里Contains是没有智能提示的，但是可以编译过且哪怕没有Contains方法也能编译过。如果不存在该名字的实例方法，执行会抛错。</span></span><br></pre></td></tr></table></figure><p><strong>dynamic调用vs反射调用</strong></p><p>这个要看IL实现，具体的不多深究。总的来说，</p><ul><li>  dynamic调用方法是用到0级缓存，会比反射快一些。</li><li>  代价是需要用到<font color="#dd0000">运行时绑定器(runtime binder类)</font>，它存在于Microsoft.CSharp.dll程序集中，所以必须将该程序集加载到AppDomain中（程序集会进内存），且在payload代码执行时生成动态代码（会进程序集也就是内存里），使得会损害应用程序的性能，增大内存消耗。</li><li>  dynamic无法调用到类型静态方法，只能调用实例方法。</li></ul><p>所以，即使上述代码用dynamic写很整洁，但如果需要用dynamic的地方很少，那一般还是会选择反射实现。</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> CLR via C# </category>
          
          <category> 第二章 C#类的设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR Via C#个人笔记2 - 类与分配</title>
      <link href="/Tech/CSharp/CLR-Via-CSharp/cp2/"/>
      <url>/Tech/CSharp/CLR-Via-CSharp/cp2/</url>
      
        <content type="html"><![CDATA[<h1 id="大章4：类的根基"><a href="#大章4：类的根基" class="headerlink" title="大章4：类的根基"></a><center>大章4：类的根基</center></h1><h3 id="所有类都从System-Object派生"><a href="#所有类都从System-Object派生" class="headerlink" title="所有类都从System.Object派生"></a>所有类都从System.Object派生</h3><p>&nbsp;&nbsp;&nbsp;CLR要求所有类最终都从<font color="#dd0000">System.Object类</font>派生。无论你的类写不写父类，都会继承自此。注意，通过反编译看构造比较难看出这一点，但是很重要。</p><h3 id="System-Object的方法"><a href="#System-Object的方法" class="headerlink" title="System.Object的方法"></a>System.Object的方法</h3><p><strong>public</strong>：</p><ul><li>Equals： 没啥好说，如果不重写默认就是判断值是否相等，==判断的是引用地址是否相等。String的比较特殊，微软重写了，所以”AAA” == “AAA”是会返回true的。</li><li>GetHashCode： 返回对象的值得哈希码。用的少。</li><li>ToString： 返回类型的完整名称(this.GetType().FullName)。经常重写。</li><li>GetType： 获取类型，反射常用的。注意它是非虚，目的是不推荐修改。</li></ul><p><strong>protected</strong>：</p><ul><li>MemberwiseClone： 非虚方法。书里讲得不好，简单来说本方法就是浅拷贝。浅拷贝简单理解为只对类里的值类型字段进行逐位复制，而引用类型字段则拷贝引用。引用也新造，就是深拷贝了。</li><li>Finalize： 在被GC前，会调用一次这个虚方法。</li></ul><h3 id="new-Object-的整个流程"><a href="#new-Object-的整个流程" class="headerlink" title="new Object()的整个流程"></a>new Object()的整个流程</h3><ol><li>计算类型及其所有基类型(一直到System.Object)中定义所有的实例字段需要的字节数。堆上每个对象都需要一些overhead成员，包括<font color="#dd0000">“类型对象指针”和“同步索引块”</font>，CLR利用这些成员管理对象，且这些overhead成员字节数会计入对象大小。</li><li>从托管堆中分配类型需要的字节数，从而分配对象内存，分配的所有字节都设为0。</li><li>初始化overhead成员：“类型对象指针”和“同步索引块”。</li><li>调用类型的实例构造器，传递入参。自动生成构造器代码调用父类的构造器，最终调用到System.Object的构造器，该构造器什么都不做简单返回。</li></ol><p>new执行完了这些操作之后，返回指向新建对象的一个引用（或指针）。<br>这个对象在引用计数归0后会被CLR的GC清理掉。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>  CLR随时都能知道对象的类型是什么，调用GetType方法可以知道确切类型。可以通过<font color="#dd0000">显式转换</font>来转换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Employee(); </span><br><span class="line">Employee e = (Employee) o;</span><br></pre></td></tr></table></figure><p>  此外，我们常用as和is来进行类型转换。比较简单，不多写。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>  就是<code>namespace xxx</code>和<code>using xxx;</code>，目的是提高代码可读性以及让程序员少打点字。</p><blockquote><p>命名空间对相关的类型进行逻辑分组。<br>对于编译器，命名空间的作用就是为类型名称附加以句点分隔的符号，使名称变得更长，更可能具有唯一性。</p></blockquote><p>  <font color="#dd0000">CLR对命名空间一无所知</font>，所以访问类型时，CLR需要知道类型的完整名称。那编译器是怎么实现的呢？如果你写的类再源代码、引用程序集中找不到，那它就把你using的namespace，比如<code>System.IO.</code>放在类名前查看是否匹配，如果不匹配就再尝试<code>System.Text.</code>，如此反复直到匹配。<br>  遇到一个类在多个using里存在的时候，编译器会提示不明确引用的，补上前缀，或者<code>using 别名 = 命名空间.类</code>然后后面用别名写这个类就行。这叫<font color="#dd0000">歧义性</font>。</p><h1 id="大章：方法运行流程⭐"><a href="#大章：方法运行流程⭐" class="headerlink" title="大章：方法运行流程⭐"></a><center>大章：方法运行流程⭐</center></h1><p>  解释类型、对象、线程栈和托管堆再运行时的相互关系，以及调用静态方法、实例方法和虚方法的区别。<br>  原文是非常长的一套整体流程，写的很好，我简化一下搬下来。分成2块，下面拆解，但是在拆解前先引入一个模型。<br>  先列一下整个流程参与的元素：</p><ul><li><p>线程栈、托管堆⭐</p></li><li><p>序幕代码、栈帧、尾声代码</p></li><li><p>类型指针对象、类内部持有的父类类型引用字段</p></li><li><p>对象实例、Class类型对象、Type类型对象</p></li><li><p>非虚方法、虚方法⭐</p></li><li><p>实例字段，静态字段</p></li><li><p>类型对象指针指向的是类型，不是父类！</p><p>能对照着概念能模拟出一遍完整流程就行，非常重要。</p></li></ul><h3 id="先引入一个模型"><a href="#先引入一个模型" class="headerlink" title="先引入一个模型"></a>先引入一个模型</h3><p><font color="#dd0000">线程栈</font>和<font color="#dd0000">堆</font>。 // TODO 具体栈和堆的我会在其它笔记单独写<br>一个进程可能有多个线程，每新开辟一个线程就给它分配1MB的栈。栈空间用于向方法传递实参，方法内部定义的局部变量也在栈上。栈从高位内存地址向低位内存地址构建。<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211110182516.png"></p><h3 id="普通方法的运行流程"><a href="#普通方法的运行流程" class="headerlink" title="普通方法的运行流程"></a>普通方法的运行流程</h3><p>预设有以下代码要进行（调用了M1）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">M1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">String name = <span class="string">&quot;Joe&quot;</span>;</span><br><span class="line">M2(name);</span><br><span class="line"><span class="comment">// do sth...</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">M2</span>(<span class="params">String s</span>)</span>&#123;</span><br><span class="line">Int32 length = s.Length;</span><br><span class="line">Int32 tally;</span><br><span class="line"><span class="comment">// do sth...</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>M1方法开始执行，“序幕”代码（prologue）开始。</li><li>M1序幕代码执行：分配局部变量name的内存，如图2。</li><li>然后调用M2方法，将局部变量name作为实参传递，这造成name局部变量中的地址被压入栈，同时还会将”返回地址“压入栈，如图3。//M2方法内部使用参数变量s标识栈位置</li><li>M2方法开始，M2序幕代码执行：为局部变量length和tally分配内存，如图4。</li><li>M2方法内部代码开始执行，最终return，使得CPU的指令指针被设置成栈中的返回地址，M2的栈帧unwind，恢复成图2的样子。</li><li>之后，M1继续执行M2调用之后的代码，M1的栈帧将准确反映M1需要的状态。</li><li>最终，M1会返回到他的调用者，同样是通过CPU指令指针设置成返回地址（图中未标记，正常情况下在<code>name(String)</code>上方），M1的栈帧unwind。</li><li>恢复成图1，继续执行原处<code>M1();</code>之后的后续代码。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211110185718.png"></p><p><strong>总结一下，执行一个方法的整体流程就是：</strong></p><ol><li>  执行“序幕”代码，也就是<font color="#dd0000">线程栈上分配局部变量的内存</font></li><li>  内部还有方法的话把内部函数的<font color="#dd0000">参数</font>和<font color="#dd0000">{返回地址}</font>压入栈</li><li>  内部方法执行完后（流程与本流程相同），CPU指令指针被设置成上面的{返回地址}，<font color="#dd0000">栈帧展开恢复到遇到此方法之前</font></li><li>  直到方法运行结束或者遇到return，CPU指令指针设置成本方法的返回地址，栈帧展开恢复到遇到本方法之前</li></ol><h3 id="类内调用方法的运行流程"><a href="#类内调用方法的运行流程" class="headerlink" title="类内调用方法的运行流程"></a>类内调用方法的运行流程</h3><p>比上面的情况更复杂点的方法。预设有以下代码要进行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有下面2个类：</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Int32 <span class="title">GetYearsEmployed</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> String <span class="title">GetProgressReport</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Employee <span class="title">Lookup</span>(<span class="params">String name</span>)</span> &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Manager</span> : <span class="title">Employee</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> String <span class="title">GetProgressReport</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要执行下面的方法：</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">M3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      Employee e;</span><br><span class="line">      Int32 year;</span><br><span class="line">      e = <span class="keyword">new</span> Manager();</span><br><span class="line">      e = Employee.Lookup(<span class="string">&quot;Joe&quot;</span>);</span><br><span class="line">      year = e.GetYearsEmployed();</span><br><span class="line">      e.GetProgressReport();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>假设CLR已经加载到其中，托管<font color="#dd0000">堆</font>已初始化，且已经创建一个线程（1MB<font color="#dd0000">栈</font>空间也分配了）。</p><p>① 目前已经执行了一些代码，接下来要调用<code>M3()</code>方法。如图4-6。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111162218.png"></p><p>② 检查方法需要的所有类型是否被创建。</p><ul><li>JIT编译器将M3的IL代码转换成本机CPU指令时，会注意到M3内部引用的所有类型：Employee、Int32、Manager、String(因为<code>&quot;Joe&quot;</code>)。这时CLR要确认这些类型相关的程序集都已经加载，并为其创造一些数据结构来表示这些类。因为Int32和String类很常用，就当作已经在前面创建好了，这里只讨论Employee和Manager。</li><li>如图，堆上所有对象都包含2个额外成员，类型对象指针和同步索引块。定义类型时，<font color="#dd0000">在类型内部定义静态数据字段，为这些字段提供支援的字节在类型对象自身中分配。</font></li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111162931.png"></p><p>③ 和上面普通方法的运行流程一样，分配局部变量。</p><ul><li>当CLR确认方法需要的所有类型对象都已创建后，就在栈上分配局部变量的内存。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111164343.png"></p><p>④ “序幕”代码处理结束。<code>e = new Manager();</code>执行，在托管堆上创建Manager类型实例。</p><ul><li>如图，它的类型对象指针指向自己的类型对象，Manager。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111165618.png"></p><p>⑤ 下一句调用<font color="#dd0000">类内静态方法</font>，<code>e = Employee.Lookup(&quot;Joe&quot;);</code>。</p><ul><li>当调用静态方法时，JIT会去找类型对象的方法表，找到静态方法对应的记录项，编译并执行该方法。</li><li>本方法Lookup假设是要去经理表查询数据库找到Joe，再new一个Manager返回Joe的信息。所以如图，在堆上会新建一个Manager对象，局部变量e持有它的引用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111170356.png"></p><p>⑥ 下一句调用类内<font color="#dd0000">非虚实例方法</font>，<code>year = e.GetYearsEmployed();</code>执行。</p><ul><li>非虚方法执行流程：JIT会找到发出调用的<font color="#dd0000">变量（e）的申明类型（Employee）</font>对应的类型对象，如果Employee类型没有定义正在调用的那个方法，JIT编译器会回溯父类层次结构（一直到Object类），沿途在每个类型中查找该方法。之所以能这样回溯，是因为每个对象都有一个字段引用了他的基类型（图中未展示）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111171309.png"></p><p>⑦ 下一句调用类内<font color="#dd0000">虚实例方法</font>，<code>e.GetProgressReport();</code>执行。</p><ul><li>虚方法执行流程：JIT首先检查发出调用的变量（e），并<font color="#dd0000">跟随引用地址找到发出调用的对象（e引用的是叫“Joe”的Manager对象而不是Employee！）</font>。然后，代码检查对象内部的“类型对象指针”成员，找到类型对象Manager里的方法，如果没有就同⑥一样回溯执行到可执行的类方法为止。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111181049.png"></p><p>⑧ 方法体运行结束。回到前地址，栈帧展开。</p><ul><li>在这里提一下一个理解上的要点，注意类型对象Manager和Employee都有自己的类型对象指针，这意味着，它们本质上也是对象“实例”，指向System.Type类型对象。System.Type类型对象自己也有指针，指向自己。</li><li>顺便一提，<code>System.Object.GetType()</code>方法返回存储在指定对象的“类型对象指针”成员中的地址，也就是指向对象的类型对象的指针。这样就可以判断系统中任何对象的真实类型。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211111180630.png"></p><p><strong>总结一下：</strong></p><p>流程太长全总结了也很难看懂，就提几个问题思考一下。</p><ul><li><p>序幕代码都做了什么（2点）？</p></li><li><p>一个类型对象，都拥有哪些固定字段？</p></li><li><p>静态方法需要的内存是怎么分配的？</p></li><li><p>虚方法和非虚方法，寻找方法流程的主要不同点是什么（1点）？</p></li></ul><p>答案上面都有，答不出来了就再仔细看一遍吧，自勉。</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> CLR via C# </category>
          
          <category> 第二章 C#类的设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
            <tag> 虚方法 </tag>
            
            <tag> 栈堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王者荣耀复刻项目 UI篇</title>
      <link href="/Project/Unity/Moba/HOK/ui/"/>
      <url>/Project/Unity/Moba/HOK/ui/</url>
      
        <content type="html"><![CDATA[<h1 id="跳字优化"><a href="#跳字优化" class="headerlink" title="跳字优化"></a>跳字优化</h1><h2 id="对象池优化"><a href="#对象池优化" class="headerlink" title="对象池优化"></a>对象池优化</h2><p>制作一个对象池来缓存跳字专用的prefab。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------整体流程方法名（以下只展示方法签名）---------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">HPWindow</span> : <span class="title">void</span> <span class="title">SetJumpUpdateInfo</span>(<span class="title">JumpUpdateInfo</span> <span class="title">jui</span>); <span class="comment">// 先使用 pool.PopOne() 从对象池获取一个GameObject,再 Show()。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">JumpNumPool</span> : <span class="title">JumpNum</span> <span class="title">PopOne</span>(); <span class="comment">// Queue弹出一个prefab实例化后的GameObject对象。如果Queue已经空了,就执行CreateOne()新插入一个JumpNum到Queue并初始化,然后弹出返回。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">JumpNum</span> : <span class="title">void</span> <span class="title">Show</span>(<span class="title">JumpUpdateInfo</span> <span class="title">ji</span>); <span class="comment">// 根据JumpUpdateInfo配置 显示跳字。最后执行Recycle()。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">JumpNum</span> : <span class="title">void</span> <span class="title">Recycle</span>(); <span class="comment">// 0.75s后执行回收,将GameObject塞回Queue中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------上述提到的配置类---------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JumpUpdateInfo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> jumpVal;<span class="comment">// 数值</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 pos;<span class="comment">// 位置</span></span><br><span class="line">    <span class="keyword">public</span> JumpTypeEnum jumpType;</span><br><span class="line">    <span class="keyword">public</span> JumpAniEnum jumpAni;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示队列"><a href="#显示队列" class="headerlink" title="显示队列"></a>显示队列</h2><p>实现思路和TipsWindow差不多，就是维护一个队列，然后给定一个频率，按频率去执行跳字，我这里设置的200ms飘一次字。</p><p>把上面的包装好后，外部只要调用<code>血条ItemHP.AddHPJumpNum(JumpNum jn, JumpUpdateInfo jui)</code>就行了。</p><p>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118004333.png"></p><h1 id="小地图"><a href="#小地图" class="headerlink" title="小地图"></a>小地图</h1><h2 id="UI映射轴向一致"><a href="#UI映射轴向一致" class="headerlink" title="UI映射轴向一致"></a>UI映射轴向一致</h2><p>实现，肯定是用逻辑位置去映射到小地图上的位置，然后在位置上展示图标就行了。</p><p>然后关键来了，怎么映射最优呢？</p><p><strong>① 将地图的中心点和小地图的中心点设置为原点坐标。</strong></p><p><strong>② 确保地图与小地图，所实际使用的2个轴向保持一致。</strong></p><p><strong>③ 确保以上2点后，映射的时候直接使用local位置即可。</strong></p><p>好处很多，不单是换算方便，因为地图原点坐标在地图中心点，所以打出log的也会直观很多。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118234305.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118234448.png"></p><h2 id="UI图片和地图资源比例保持一致"><a href="#UI图片和地图资源比例保持一致" class="headerlink" title="UI图片和地图资源比例保持一致"></a>UI图片和地图资源比例保持一致</h2><p>这样可以直接将地图逻辑位置坐标 *<strong>scaler</strong> 缩放就实现了位置映射。</p><h1 id="聊天系统-名字标签"><a href="#聊天系统-名字标签" class="headerlink" title="聊天系统 名字标签"></a>聊天系统 名字标签</h1><p>一般有2种方式实现，都比较简单。</p><p>第一种是使用在发往服务器的消息包中放入玩家的id、英雄的id信息，再去服务器拼接msg字符串。</p><p>第二种是直接在发往服务器的消息包的msg字符串本地拼接，因为在客户端本机相关的数据很全，直接拼接好再发送就可以了。</p><p>用<strong>第二种</strong>节省服务器的操作，属于是一个容易想到的小优化。</p><p>最终效果：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220122180109.png"></p><h1 id="关闭窗口检测"><a href="#关闭窗口检测" class="headerlink" title="关闭窗口检测"></a>关闭窗口检测</h1><p>使用<code>gameObject.activeSelf</code>并不能获取到正确的值，因为直接把父物体给<code>SetActive(false)</code>了，子物体其实还是<code>activeSelf = true</code>的状态。</p><p>这种情况，要使用<code>ameObject.activeInHierarchy</code>来判断。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Moba </category>
          
          <category> 王者荣耀复刻项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 工程 </tag>
            
            <tag> Moba </tag>
            
            <tag> C/S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Hexo?</title>
      <link href="/Tech/Hexo/htUseHexo/"/>
      <url>/Tech/Hexo/htUseHexo/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Markdown个人约束"><a href="#一-Markdown个人约束" class="headerlink" title="一.Markdown个人约束"></a>一.Markdown个人约束</h1><ul><li><p>一级标题：<code># &lt;center&gt;大章：XXX&lt;/center&gt;</code></p></li><li><p>二级标题：<code>### XXX</code></p></li><li><p>三级标题：<code>#### ① XXX</code></p></li><li><p>有序内容：<code>1. XXX</code></p></li><li><p>无序内容：<code>* XXX</code></p></li><li><p>内容：<code>XXX</code></p></li></ul><h1 id="二-Markdown常用语法"><a href="#二-Markdown常用语法" class="headerlink" title="二.Markdown常用语法"></a>二.Markdown常用语法</h1><ul><li><p>引用内容：<code>&gt; XXX</code></p></li><li><p>单行代码：``</p></li><li><p>多行代码：``````</p></li><li><p>其他：<a href="https://www.jianshu.com/p/a6a6a22e9393">https://www.jianshu.com/p/a6a6a22e9393</a></p></li></ul><h1 id="三-Hexo文件头"><a href="#三-Hexo文件头" class="headerlink" title="三.Hexo文件头"></a>三.Hexo文件头</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">title: 如何使用Hexo?</span><br><span class="line">cover:https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/~.png</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">  - 技术</span><br><span class="line">categories:</span><br><span class="line">  - Hexo</span><br><span class="line">    - Hexo1</span><br><span class="line">    Hexo2</span><br><span class="line">    cover: 文章封面图</span><br><span class="line">    top_img: 文章Top图</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR Via C#个人笔记1 - CLR基础</title>
      <link href="/Tech/CSharp/CLR-Via-CSharp/cp1/"/>
      <url>/Tech/CSharp/CLR-Via-CSharp/cp1/</url>
      
        <content type="html"><![CDATA[<h1 id="大章1：CLR基础"><a href="#大章1：CLR基础" class="headerlink" title="大章1：CLR基础"></a><center>大章1：CLR基础</center></h1><h3 id="CLR是什么"><a href="#CLR是什么" class="headerlink" title="CLR是什么"></a>CLR是什么</h3><ul><li><strong>Common Language Runtime 公共语言运行时</strong>，CLR和Java虚拟机一样也<strong>是一个运行时环境</strong>，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。</li></ul><p>再丢几个概念，除了编译器，另外3个会在下面讲PE文件会提到，因为这3个是托管PE文件的构成部分。</p><ul><li><p><strong>「编译器」</strong>检查源代码，确定根据所使用语言语法所写的代码是有意义的，并输出实现其意图的代码。</p></li><li><p><strong>元数据</strong>，每个托管模块都包含元数据表，主要是2种表：描述源代码中定义的类型和成员；描述源代码引用的类型和成员。</p></li><li><p><strong>IL</strong>，中间语言代码，编译器编译源代码时生成的代码。在运行时，CLR将IL编译成本机CPU指令。</p></li><li><p><strong>PE32或PE32+头</strong>，决定程序是以32位还是64位运行的<strong>文件头</strong>，它和VS中的目标平台中选项（下面叫做**/platform开关选项**）相关联</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211022161435339.png" alt="image-20211022161435339"></p></li></ul><h3 id="CLR、程序集是怎么跑起来的"><a href="#CLR、程序集是怎么跑起来的" class="headerlink" title="CLR、程序集是怎么跑起来的"></a>CLR、程序集是怎么跑起来的</h3><h6 id="①-项目运行流程"><a href="#①-项目运行流程" class="headerlink" title="① 项目运行流程"></a>① 项目运行流程</h6><ol><li>Windows检查EXE文件头，决定是创建32位还是64位进程之后，会在进程地址空间加载MSCorEE.dll的对应版本（比如x86版本在%SystemRoot%\System32目录中）。</li><li>然后，进程的主线程调用MSCorEE.dll中定义的一个方法，这个方法初始化CLR，加载EXE程序集，再调用其入口方法（Main）。</li><li>随即，托管应用程序启动并运行。</li></ol><h6 id="②-从代码文件到托管模块运行流程"><a href="#②-从代码文件到托管模块运行流程" class="headerlink" title="②  从代码文件到托管模块运行流程"></a>②  从代码文件到托管模块运行流程</h6><p>源代码 -&gt; 编译器（是面向进行时的编译器） -&gt; 托管模块（是32或64位的Windows可移植执行体文件）</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211021173506928.png" alt="image-20211021173506928"></p><h3 id="IL代码"><a href="#IL代码" class="headerlink" title="IL代码"></a>IL代码</h3><h6 id="①-IL是很高级的机器语言。"><a href="#①-IL是很高级的机器语言。" class="headerlink" title="①  IL是很高级的机器语言。"></a>①  IL是很高级的机器语言。</h6><blockquote><p>IL是与CPU无关的机器语言，它比大多数CPU机器语言都高级。</p><p>IL基于栈。这意味着它的所有指令都要将操作数压入（push）一个执行栈，并从栈中弹出（pop）结果。</p></blockquote><ol><li><p>它是面向对象的，它能访问和操作对象类型，并提供指令初始化对象、调用对象虚方法等。</p></li><li><p>由于C#、VB语言、F#等高级语言，最终都是被对应编译器转换为IL代码，所以比如可以将C#（擅长I/O）、vb.net的代码集成到一个解决方案中一起写，好处是能同时用<strong>各自的语言特性</strong>和<strong>语言所使用的CLR功能模块</strong>。如下，CLS是规定的所有语言必须支持的最小功能集。<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102121640.png"></p></li><li><p>为了执行方法，首先必须把方法的IL转换成本机（native）CPU指令。这是CLR的JIT（just-in-time或者“即时”）编译器的职责。</p><blockquote><p>JIT编译器： 因为JITCompiler是即时编译的，所以被称为JIT just-in-time。</p></blockquote></li></ol><h6 id="②-JITCompiler参与了什么？"><a href="#②-JITCompiler参与了什么？" class="headerlink" title="②  JITCompiler参与了什么？"></a>②  <strong>JITCompiler</strong>参与了什么？</h6><p>   主要是JITCompiler做的事，它会把第一次遇到的IL代码进行验证+编译，最后放进内存中。</p><p>   方法仅在首次调用时才会有一些性能损失，以后对该方法的所有调用都以本机代码的形式全速运行。</p><p>   注意第一次执行方法WriteLine时会比第二次执行WriteLIne所消耗的多：</p><p>   <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211022164732481.png" alt="image-20211022164732481"></p><p>   <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211022170151293.png" alt="image-20211022170151293"></p><h6 id="③-IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。"><a href="#③-IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。" class="headerlink" title="③  IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。"></a>③  IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。</h6><p>   CLR在IL编译成本机CPU时，会进行一步**<font color="#dd0000">验证</font>**工序。它会检查高级IL代码，确定代码所做的一切都是安全的（比如方法的入参是否正确）。<br>   Windows的每个进程都有自己的虚拟地址空间，给进程自己的独立地址空间，是为了相互之间不影响。当然每个进程可以有多个AppDomain，此不多拓展。</p><h6 id="④-unsafe代码"><a href="#④-unsafe代码" class="headerlink" title="④ unsafe代码"></a>④ unsafe代码</h6><p>   c#编译器默认生成safe代码，这种代码安全性可以验证。然而c#编译器也允许unsafe代码存在，这类代码允许直接操作内存地址，并可操作这些地址处的字节。需要用unsafe{}关键字标记，通常用于处理非托管。<br>   winform项目中遇到过，很不建议c#程序员操作内存，非常难定位崩溃原因。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public unsafe void swap(int* p, int *q)</span><br><span class="line">&#123;</span><br><span class="line">int temp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NGen-exe工具"><a href="#NGen-exe工具" class="headerlink" title="NGen.exe工具"></a>NGen.exe工具</h3><p>  .Net Framework提供的NGen.exe工具，可以在应用程序安装到用户计算机时，将IL代码编译成本机代码。<br>  直接使用本机代码可以跳过编译步骤。但在本机代码文件缺失的地方，仍然会去用JIT编译IL代码。<br>  是否用它的利弊很难平衡。启动速度是快了，但如果本机环境一变（比如换了cpu、windows版本等），就会仍然需要JIT编译。而且本机代码，无法像JIT一样对本机做出许多假定，就会少很多优化。</p><h3 id="Framework类库"><a href="#Framework类库" class="headerlink" title="Framework类库"></a>Framework类库</h3><p>  可以了解下Framework都能做什么。</p><ul><li>Web服务 这个用的是ASP.Net，对应的是.NET CORE框架，和framework区别还挺大的。</li><li>GUI 应用程序 一般说的就是wpf、winform，官方提供的，主要写PC客户端程序。</li><li>控制台程序</li><li>Windows服务 通过SCM（windows服务控制管理器）控制，这个不太懂</li><li>数据库存储过程</li><li>组件库 就是自己写的单独程序集，导出，以后当插件用了</li></ul><h3 id="CTS规范"><a href="#CTS规范" class="headerlink" title="CTS规范"></a>CTS规范</h3><p>  通用类型系统 Common Type System，没啥难点，应该是很早的一个规范了。说的就是，</p><ul><li>类成员需要按照Field、Methond、Property、Event这几个去写。</li><li>访问规则要定，就是public、protected那几个。</li></ul><p>  每个不同的语言都拥有自己对类不同的写法和特点，但即使代码不同，它们的行为（也就是想让它实现什么）是可以完全一致的。</p><h1 id="大章2：生成、打包、部署、管理应用程序"><a href="#大章2：生成、打包、部署、管理应用程序" class="headerlink" title="大章2：生成、打包、部署、管理应用程序"></a><center>大章2：生成、打包、部署、管理应用程序</center></h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>  C#编译器在执行一个像下面一样的代码时，<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Program.cs :</span><br><span class="line">public sealed class Program&#123;</span><br><span class="line">public static void Main()&#123;</span><br><span class="line">System.Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  因为，调用了System这个包，所以为了生成这个示例应用程序需要在命令行输入：<br>  <code>csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs</code><br>  这个命令行指示C#编译器生成名为Program.exe的可执行文件(/out:Program.exe)，类型是32位控制台应用程序类型exe。<br>  其中MSCorLib.dll因为太常用了，会自动引用，所以不写也行。</p><h3 id="响应文件"><a href="#响应文件" class="headerlink" title="响应文件"></a>响应文件</h3><p>  响应文件就是个cmd命令集的可执行程序，执行它就相当于对控制台逐行输入命令。<br>  一键设置参数省力用的，它长下面这样：<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// CSC.exe :</span><br><span class="line">/out:MyProject.exe</span><br><span class="line">/target:winexe</span><br></pre></td></tr></table></figure><br>  当用命令行执行响应文件CSC.exe时，还会去其所在目录寻找文件CSC.rsp，里面放你想要全局都引用的dll。</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>  在说元数据之前，先聊一下Program.exe文件，托管PE文件（可移植执行体）由4部分构成：</p><ul><li><p>PE32(+)头： 本篇开头提过，不多说。</p></li><li><p>IL： 前面也讲过了。</p></li><li><p>CLR头： 一个小的信息块，包含需要CLR的功能的模块。还是个模块的集合呗。可以查看CorHdr.h头文件定义的IMAGE_COR20_HEADER来了解CLR头的具体格式。</p></li><li><p><strong>元数据</strong>： 是由几个表构成的二进制数据块。分三种，定义表、引用表和清单表。图放在下面，看看有哪些类型的表来理解下意图就完了。</p></li></ul><p>  <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102170858.png"><br>  <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102171005.png"></p><p>还有例案元数据代码在书35p，这个很推荐自己看代码，下面只记一个重点。<br>以上面写的那个 Program.exe (就那个Hello World)为例，经过ILDasm.exe整理+美化过的元数据表如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102172336.png"></p><p>注意划线的两块，一个是公共静态方法Main，一个是编译器自动生成的默认类构造器。<br>Main，公共静态方法，用IL代码实现，返回类型void，无参。<br>构造器，公共方法，也用IL代码实现，返回类型void，无参。有一个this指针，指向调用方法时构造对象的内存。</p><h3 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h3><p>  上面说的Program.exe不只是PE文件，也是个程序集(assembly)。上面上的元数据表的第三个清单表没讲，在这里引入：清单表包含一下3个信息，</p><ul><li>定义了程序集的可重用的类型</li><li>用一个版本号标记程序集</li><li>可以关联程序集的安全信息</li></ul><p>说的有点复杂了，从用途来看，把它当一个EXE或者DLL就行了。就和DLL一样，如果缺失就会去URL指向的位置下载文件到缓存中，如果仍然没有，就会抛出FileNotFoundException异常。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>  微软采用的就是如下的版本编号方案，建议个人也统一标准采用这个。</p><p>  比如2.5.719.2，2.5是公众对版本的认知；而719是程序集的build号，如果公司每天都生成程序集，那它应该每天递增；revesion是指出当前build的修订次数，如果公司某天内必须生成2次程序集，那revision该递增。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102183028.png"></p><p>剩下2.7 - 2.8(讲config配置文件)实在是太枯燥，看完一遍也整理不出什么，就这样吧。</p><h1 id="大章3：共享程序集和强命名程序集"><a href="#大章3：共享程序集和强命名程序集" class="headerlink" title="大章3：共享程序集和强命名程序集"></a><center>大章3：共享程序集和强命名程序集</center></h1><h3 id="两种程序集，两种部署"><a href="#两种程序集，两种部署" class="headerlink" title="两种程序集，两种部署"></a>两种程序集，两种部署</h3><p>to be continued…    // 粗略看了一遍，感觉最后再看比较好</p>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
          <category> CLR via C# </category>
          
          <category> 第一章 CLR基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
