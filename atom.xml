<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2022-02-08T08:43:06.150Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具篇：本地配置</title>
    <link href="https://codingcodingk.github.io/2022/02/08/Tech/Game/tools/luban_study/"/>
    <id>https://codingcodingk.github.io/2022/02/08/Tech/Game/tools/luban_study/</id>
    <published>2022-02-08T07:27:47.192Z</published>
    <updated>2022-02-08T08:43:06.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识luban"><a href="#初识luban" class="headerlink" title="初识luban"></a>初识luban</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>开源地址 ： <a href="https://github.com/focus-creative-games/luban">github</a></p><p>案例开源地址：<a href="https://github.com/focus-creative-games/luban_examples">github</a></p><blockquote><p>luban高效地处理游戏开发中常见的excel、json、xml之类的数据，检查数据错误，生成c#等各种语言的代码，导出成bytes或json等多种格式。</p><ul><li>强大的数据解析和转换能力 {excel(csv,xls,xlsx), json, bson, xml, yaml, lua, unity ScriptableObject} =&gt; {binary, json, bson, xml, lua, yaml, erlang}</li><li>增强的excel格式，可以简洁地配置出像简单列表、子结构、结构列表，以及任意复杂的深层次的嵌套结构。</li><li>完备的类型系统，<strong>支持OOP类型继承</strong>，搭配excel、json、lua、xml等格式数据<strong>灵活优雅</strong>表达行为树、技能、剧情、副本之类复杂GamePlay数据</li><li>支持生成 protobuf(schema + binary + json)、flatbuffers(schema + json)、msgpack(binary)</li><li>强大的数据校验能力。ref引用检查，path资源路径检查等等</li><li>支持生成c#,java,go,c++,lua,python,javascript,typescript,erlang,rust代码</li><li>完善的本地化支持</li><li>强大灵活的自定义能力，支持代码模板和数据模板</li><li>**==通用型生成和缓存工具==**。也可以用于生成协议、数据库之类的代码，甚至可以用作对象缓存服务</li><li><strong>良好支持主流引擎、全平台、主流热更新方案、主流前后端框架</strong>。支持unity、unreal、cocos2x、微信小游戏等主流引擎。工具自身跨平台，能在Win,Linux,Mac平台良好工作。<a href="https://focus-creative-games.github.io/lubandoc/feature.html#%E6%94%AF%E6%8C%81%E4%B8%BB%E6%B5%81%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80">详见</a></li></ul></blockquote><h1 id="配置第一个Unity项目"><a href="#配置第一个Unity项目" class="headerlink" title="配置第一个Unity项目"></a>配置第一个Unity项目</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>1.下载<a href="https://dotnet.microsoft.com/en-us/download/dotnet/6.0">.net 6.0 sdk</a>。</p><p>2.下载案例luban_examples。</p><p>3.创建Unity工程，从luban_examples\Projects的Csharp_Unity_json中复制 <strong>luban_Libs</strong>目录到Unity工程下。</p><p>4.在Project Settings菜单的Player里，设置开启unsafe。</p><p>5.从luban_examples\Tools复制 <strong>Luban.ClientServer工具库</strong> 和 <strong>MiniDesignerConfigsTemplate文件夹</strong> 到Unity工程下。</p><h2 id="6-配置bat文件"><a href="#6-配置bat文件" class="headerlink" title="6.配置bat文件"></a>6.配置bat文件</h2><p>从luban_examples\Projects的Csharp_Unity_json中复制 <strong>gen_code_json.bat 文件</strong> 到5中的同级目录。之后开始编辑bat文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> WORKSPACE=..\.. -- unity工程目录地址</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> GEN_CLIENT=%WORKSPACE%\Assets\Luban\Luban.ClientServer\Luban.ClientServer.exe -- 运行exe文件地址</span><br><span class="line"><span class="built_in">set</span> CONF_ROOT=%WORKSPACE%\Assets\Luban\MiniDesignerConfigsTemplate -- 自己的配置表的根目录地址</span><br><span class="line"></span><br><span class="line">%GEN_CLIENT% -j cfg --^</span><br><span class="line"> -d %CONF_ROOT%\Defines\__root__.xml ^</span><br><span class="line"> --input_data_dir %CONF_ROOT%\Datas ^ -- 配置表目录地址</span><br><span class="line"> --output_code_dir %WORKSPACE%/Assets/Gen ^ -- 配置表输出地址</span><br><span class="line"> --output_data_dir ..\GenerateDatas\json ^</span><br><span class="line"> --gen_types code_cs_unity_json,data_json ^</span><br><span class="line"> -s all </span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="7-配置表"><a href="#7-配置表" class="headerlink" title="7.配置表"></a>7.配置表</h2><p>上面CONF_ROOT的地址里就是我们的工作文件夹，这里采用案例的 MiniDesignerConfigsTemplate文件夹，在里面的Datas文件夹里有已经做好excel表格案例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识luban&quot;&gt;&lt;a href=&quot;#初识luban&quot; class=&quot;headerlink&quot; title=&quot;初识luban&quot;&gt;&lt;/a&gt;初识luban&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="网络库" scheme="https://codingcodingk.github.io/tags/%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：async-await在unity中的应用</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/unity_await-async/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/unity_await-async/</id>
    <published>2022-02-01T02:52:39.179Z</published>
    <updated>2022-02-01T02:52:39.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>简而言之，Unity协同程序使用C＃对迭代器块的内置支持来实现。 您提供给StartCoroutine方法的IEnumerator迭代器对象由Unity保存，每个框架都会向前转发此迭代器对象，以获取由协调程序返回的新值。 然后，您可以通过Unity读取不同的值，以触发特殊情况行为，例如执行嵌套协同程序（返回另一个IEnumerator）时，延迟几秒钟（返回类型为WaitForSeconds的实例） 等到下一帧（返回null时）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;p&gt;简而言之，Unity协同程序使用C＃对迭代器块的内置支持来实现。 您提供给StartCoroutine方法的IEnumerator迭代器对象</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="协程" scheme="https://codingcodingk.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：定时系统</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingKTimer/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingKTimer/</id>
    <published>2022-02-01T02:52:39.176Z</published>
    <updated>2022-02-08T07:22:53.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h1><p><a href="https://github.com/CodingCodingK/CodingKTimer">CodingKTimer</a></p><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="为什么需要定时系统"><a href="#为什么需要定时系统" class="headerlink" title="为什么需要定时系统"></a>为什么需要定时系统</h2><p>Unity侧：</p><ol><li>  简化协程计时写法。</li><li>  协程基于Monobehaviour来实现，而物体激活属性变化会导致中断调用。这可由定时器解决。</li><li>  不需要依赖于unityAPI。</li></ol><p>服务端侧：</p><p>​       简化代码 =&gt; 支持多线程、指定线程。</p><h1 id="PETimer"><a href="#PETimer" class="headerlink" title="PETimer"></a>PETimer</h1><h2 id="TickTimer-高频高精度的毫秒级定时"><a href="#TickTimer-高频高精度的毫秒级定时" class="headerlink" title="TickTimer (高频高精度的毫秒级定时)"></a>TickTimer (高频高精度的毫秒级定时)</h2><ul><li>  支持多线程；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  可使用外部循环驱动计时，也可使用驱动线程（内部new的）来执行；</li><li>  定时回调默认是线程池工作线程运行，也就是在<strong>驱动线程</strong>中运行，也可<strong>外部自己驱动Handle</strong>运行；</li></ul><p>内部使用线程安全字典ConcurrentDictionary来存储Task，遍历过程中Remove无影响。</p><h3 id="调用线程"><a href="#调用线程" class="headerlink" title="调用线程"></a>调用线程</h3><p>线程可以使用新工作线程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用新线程：</span></span><br><span class="line">timerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(StartTick));</span><br><span class="line">timerThread.Start();</span><br></pre></td></tr></table></figure><p>也可以在Unity的Update中调用计时器内部 UpdateTask() 方法，确定性地使用Unity主线程。</p><p>另外还有一种方式就是自己调用<strong>Handle</strong>，也可以确定性地使用外部线程（比如Unity主线程）来执行任务：</p><ol><li><p>内部的新工作线程不再负责执行任务，而是对一个 线程安全队列 进行任务添加。</p></li><li><p>在<strong>外部 调用HandleTask()方法</strong> 来执行 内部队列 中的任务。</p></li></ol><h2 id="AsyncTimer-大量并发任务的定时"><a href="#AsyncTimer-大量并发任务的定时" class="headerlink" title="AsyncTimer (大量并发任务的定时)"></a>AsyncTimer (大量并发任务的定时)</h2><ul><li>  支持多线程；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  使用 async await异步语法计时，运行在线程池中；</li><li>  定时回调可以在驱动线程中运行，也可在外部 Handle 运行</li></ul><h3 id="时间修正"><a href="#时间修正" class="headerlink" title="时间修正"></a>时间修正</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">task.fixDelta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 限次循环任务</span></span><br><span class="line">     --task.count;</span><br><span class="line">     ++task.loopIndex;</span><br><span class="line">     <span class="comment">// ③ 修正误差</span></span><br><span class="line">     <span class="built_in">int</span> delay = (<span class="built_in">int</span>)(task.delay + task.fixDelta);</span><br><span class="line">     <span class="keyword">if</span> (delay &gt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(delay, task.ct);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// ① 计算出实际开销时间</span></span><br><span class="line">     TimeSpan ts = DateTime.UtcNow - task.startTime;</span><br><span class="line">     <span class="comment">// ② 修正实际时间值 = 理论开销时间 - 实际开销时间</span></span><br><span class="line">     task.fixDelta = (<span class="built_in">int</span>)(task.delay * task.loopIndex - ts.TotalMilliseconds);</span><br><span class="line"></span><br><span class="line">     CallBackTaskCB(task);</span><br><span class="line">&#125; <span class="keyword">while</span> (task.count &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>由于delay的累加会出现问题（主要是因为执行代码本身需要时间），导致出现 真实运行时间 与 逻辑运行时间 有偏差，所以需要修正每次delay的值从而保证真实运行时间。</p><p>比如14:00:00起了个定时任务，delay为1小时，结果15:00:00的时候开始执行任务，任务本身花掉了10s，那么就变成14:00:10的时候去+了一小时的delay。下一次执行就变成16:00:10了而不是计划中的16:00:00。用delta修正即可。</p><h2 id="FrameTimer-主要用于逻辑帧数的定时"><a href="#FrameTimer-主要用于逻辑帧数的定时" class="headerlink" title="FrameTimer (主要用于逻辑帧数的定时)"></a>FrameTimer (主要用于逻辑帧数的定时)</h2><ul><li>  只可在单线程当中运行；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  只能由外部循环驱动计数；</li><li>  定时回调只可以在驱动线程中运行；</li></ul><p>内部不创建线程计时，只能外部驱动。内部没有时间概念，<strong>完全不再计时只计数</strong>。</p><p>在服务端中或和客户端中，按自己的执行帧来每次调用，调用一次算一帧。其实就相当于只有前面两种Timer的Handle方法。</p><p>delay不再是时间，而是帧数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的解决方案&quot;&gt;&lt;a href=&quot;#我的解决方案&quot; class=&quot;headerlink&quot; title=&quot;我的解决方案&quot;&gt;&lt;/a&gt;我的解决方案&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CodingCodingK/CodingKTimer</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="定时系统" scheme="https://codingcodingk.github.io/tags/%E5%AE%9A%E6%97%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：protobuf序列化</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/protobuf/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/protobuf/</id>
    <published>2022-02-01T02:52:39.172Z</published>
    <updated>2022-02-08T07:25:30.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Protobuf-初识"><a href="#Protobuf-初识" class="headerlink" title="Protobuf 初识"></a>Protobuf 初识</h1><h2 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h2><blockquote><p>  Google Protocol Buffers(简单Protobuf或PB) 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关 、可扩展的序列化结构数据格式 。目前，几乎支持所有主流编程语言 。</p></blockquote><p>他和xml、json一样，都属于数据标记语言。</p><h2 id="Protobuf优势"><a href="#Protobuf优势" class="headerlink" title="Protobuf优势"></a>Protobuf优势</h2><ol><li>  序列化与反序列化速度极快。</li><li>  与语言及平台无关，兼容性好，通过 proto文件生成多种语言文件 =&gt; 实现 服务端、客户端之间 跨语言平台的数据转换。</li><li>  数据高度压缩 =&gt; 占用空间少，节省带宽。</li></ol><h2 id="Protobuf使用"><a href="#Protobuf使用" class="headerlink" title="Protobuf使用"></a>Protobuf使用</h2><p><a href="https://github.com/protocolbuffers/protobuf">google官方全版本支持</a></p><p><a href="https://github.com/protobuf-net/protobuf-net">.net专用版本 作者Marc Gravell(本篇使用)</a></p><h2 id="Protobuf对比C-常规序列化"><a href="#Protobuf对比C-常规序列化" class="headerlink" title="Protobuf对比C#常规序列化"></a>Protobuf对比C#常规序列化</h2><p><strong>标签不同</strong>，常规只需要对类打上<code>[Serializable]</code>，而Protobuf需要对类打上<code>[ProtoContract]</code>，再对属性打上<code>[ProtoMember(1)]</code>，中间的数字是tag对应一个属性。</p><p><strong>调用不同</strong>，常规需要 Stream 配合 BinaryFormatter 来实现，protobuf的话是 Stream 配合 ProtoBuf.Serializer：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProtoBuf Serialize</span></span><br><span class="line"><span class="built_in">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    ProtoBuf.Serializer.Serialize(ms, person);</span><br><span class="line">    bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[ms.Length];</span><br><span class="line">    Buffer.BlockCopy(ms.GetBuffer(), <span class="number">0</span>, bytes, <span class="number">0</span>, (<span class="built_in">int</span>)ms.Length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoBuf DeSerialize</span></span><br><span class="line">PersonInfo newPerson = <span class="keyword">new</span> PersonInfo();</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream(bytes))</span><br><span class="line">&#123;</span><br><span class="line">    newPerson = ProtoBuf.Serializer.Deserialize&lt;PersonInfo&gt;(ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoBuf 本地存储读取</span></span><br><span class="line">PersonInfo newPerson_file = <span class="keyword">new</span> PersonInfo();</span><br><span class="line"><span class="keyword">using</span> (FileStream file = File.Create(<span class="string">&quot;person.bytes&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ProtoBuf.Serializer.Serialize(file, person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (FileStream file = File.OpenRead(<span class="string">&quot;person.bytes&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    newPerson_file = ProtoBuf.Serializer.Deserialize&lt;PersonInfo&gt;(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节量大幅优化</strong>，对2种bytes都进行输出，简单使用能直接缩10倍以上：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220201211810.png"></p><h2 id="需求提纯"><a href="#需求提纯" class="headerlink" title="需求提纯"></a>需求提纯</h2><p>那么最后，我们要做什么？</p><ol><li>使用protobuf通信，且<strong>自动化解决</strong>最基础的打标签方式，因为那太过繁琐。</li><li>需要<strong>支持多平台</strong>，所以直接排除<code>[Serializable]</code>。</li></ol><h1 id="Protobuf-网络通信解决方案"><a href="#Protobuf-网络通信解决方案" class="headerlink" title="Protobuf 网络通信解决方案"></a>Protobuf 网络通信解决方案</h1><h2 id="1-制定协议"><a href="#1-制定协议" class="headerlink" title="1.制定协议"></a>1.制定协议</h2><h2 id="2-获取工具"><a href="#2-获取工具" class="headerlink" title="2.获取工具"></a>2.获取工具</h2><p>在 <a href="https://github.com/protobuf-net/protobuf-net">.net专用版本 作者Marc Gravell(本篇使用)</a> 中，编译源码获取 <strong>protoc.exe</strong> 和 压缩包中的 <strong>protogen.exe</strong> 两个文件。</p><h2 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3.生成代码"></a>3.生成代码</h2><h3 id="定义文件-proto"><a href="#定义文件-proto" class="headerlink" title="定义文件  .proto"></a>定义文件  .proto</h3><p><strong>相当于把之前C#实现的整个协议重写一遍。建议使用IDE VSCode来检查语法。</strong></p><p>syntax - 使用proto    package - 定义头文件名</p><p>message - 类    enum - 枚举类</p><p>required - 必须的    optional - 非必须的    repeated - 重复的，用于List</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> LogicProtocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum写法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CMD</span> </span>&#123;</span><br><span class="line">    LogicLogin = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据包写法(支持嵌套类)</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Pkg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> Head head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> Body body = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> CMD cmd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> seq = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> error = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> ReqLogicLogin reqLogicLogin = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> RspLogicLogin rspLogicLogin = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用工具-protogen-exe"><a href="#使用工具-protogen-exe" class="headerlink" title="使用工具 protogen.exe"></a>使用工具 protogen.exe</h3><p>protoc.exe也可以用于生成c#代码，但是数据更多，所以直接使用protogen.exe。</p><ol><li>cmd进入对应路径。</li><li>可以使用<code>protogen -h</code>命令来获取命令help。</li><li>输入指令<code>.\soft\protogen.exe --csharp_out=.\ .\NetProtocol.proto</code>来生成代码。</li></ol><p>指令解析：</p><ul><li>.\soft\protogen.exe 工具位置</li><li>–csharp_out=.\ 输出位置</li><li>.\NetProtocol.proto 文件位置</li></ul><h2 id="4-对比cs和proto协议区别"><a href="#4-对比cs和proto协议区别" class="headerlink" title="4.对比cs和proto协议区别"></a>4.对比cs和proto协议区别</h2><p>proto中的package转换成 <code>namespace</code>。</p><p>为每一个class和enum打上标签 <code>[global::ProtoBuf.ProtoContract()]</code>。括号里面是反射时识别的类名，不写就直接是类名。</p><p>为每一个属性打上标签 <code>[global::ProtoBuf.ProtoMember(1)]</code>。括号里是proto文件中定义的数字。</p><h1 id="我的可视化GUI"><a href="#我的可视化GUI" class="headerlink" title="我的可视化GUI"></a>我的可视化GUI</h1><p>我将集成这些功能到自己做的wpf工具中。</p><p><a href="https://github.com/CodingCodingK/CodingKExcelParser">github地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Protobuf-初识&quot;&gt;&lt;a href=&quot;#Protobuf-初识&quot; class=&quot;headerlink&quot; title=&quot;Protobuf 初识&quot;&gt;&lt;/a&gt;Protobuf 初识&lt;/h1&gt;&lt;h2 id=&quot;什么是Protobuf&quot;&gt;&lt;a href=&quot;#什么是Pro</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="protobuf" scheme="https://codingcodingk.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：帧同步网络库</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingK_Session/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingK_Session/</id>
    <published>2022-02-01T02:52:39.169Z</published>
    <updated>2022-02-08T07:23:31.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h1><p><a href="https://github.com/CodingCodingK/CodingK_Session">CodingK_Session</a></p><h1 id="聊聊网络"><a href="#聊聊网络" class="headerlink" title="聊聊网络"></a>聊聊网络</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>起源于1969年美国国防部的军用项目，最初只是一个单个的分组交换网ARPANET（并不是一个互连的网络）。1983年TCP/IP协议成为ARPANET上的标准协议，使所有使用 TCP/IP协议 的计算机都能利用互连网相互通信。因此1983年被当作因特网（Internet）诞生的时间。之后经过不断发展，形成了如今的英特网（Internet）。</p><h3 id="网络通信是指什么？"><a href="#网络通信是指什么？" class="headerlink" title="网络通信是指什么？"></a>网络通信是指什么？</h3><p>计算设备之间通过网络交换数据，更通俗地说法就是：主机A上的某个程序（进程）与主机B上的某个程序（进程）进行数据交换。</p><h3 id="网络通信如何实现？"><a href="#网络通信如何实现？" class="headerlink" title="网络通信如何实现？"></a>网络通信如何实现？</h3><p>计算设备之间通过共同遵守的 网络协议（network protocol） ，以约定好的规则来交换数据。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>五层协议的体系结构</p><p>OSI七层协议：概念清楚，理论完整，但它复杂不实用。</p><p><strong>TCP/IP四层</strong>协议：应用非常广泛。实质上，TCP/IP只有上面三层，最下层的网络接口层并没有什么具体内容。</p><p>综合前面两者，我们一般采用<strong>五层协议的体系结构</strong>来学习理解计算机网络原理。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220123211028.png"></p><h3 id="五层协议功能划分"><a href="#五层协议功能划分" class="headerlink" title="五层协议功能划分"></a>五层协议功能划分</h3><p><strong>应用层</strong>：直接为用户的应用进程提供服务。这一层的协议很多，比如HTTP协议（浏览器）、SMTP协议（邮件）、FTP协议（文件传输）等。</p><p><strong>运输层</strong>：运输应用层的数据，多个应用进程可同时使用运输层的服务，以及分发运输层的信息到应用层中相应的进程上。运输层主要使用两种协议：</p><ul><li><p>传输控制协议TCP(Transmission Control Protocol）: 面向连接 ，以报文段（segment）为传输单位，保证传输的可靠性。</p></li><li><p>用户数据报协议UDP(User Datagram Protocol）: 无连接 以用户数据报为传输单位，不保证传输的可靠性。</p></li></ul><p><strong>网络层</strong>：把运输层的报文段或用户数据报封装成 分组或包 进行传送。网络层使用IP协议，因此分组也叫作 IP数据报 ，简称数据报。此外网络层还要选择合适的路由，使运输层里的数据通过网络中的路由器找到目的主机。</p><p><strong>数据链路层</strong>：数据在网络上传输时总是在一段一段的链路上传送的（主机和路由器之间或者两个路由器之间），这时需要链接层的协议将网络层交下来的IP数据报组装成 帧（framing） ，以便在相邻的链路之间传送。数据帧里包含了必要的 传输控制信息 。</p><p><strong>物理层</strong>：在物体层上所传数据就是比特流。用不同的电压代表「0」或「1」，在硬件设备上实现数据传输。</p><p>注意：现在我们常提到的TCP/IP并不一定单指TCP和IP两个具体的协议，而是指组成因特网时所使用的整个 TCP/IP协议族 （protocol suite），还包括了其它协议，比如：DNS协议（域名转换为IP地址）、ARP协议（IP地址转换为mac地址）等等。</p><h2 id="TCP对比UDP"><a href="#TCP对比UDP" class="headerlink" title="TCP对比UDP"></a>TCP对比UDP</h2><h3 id="简易TCP通信案例"><a href="#简易TCP通信案例" class="headerlink" title="简易TCP通信案例"></a>简易TCP通信案例</h3><p>TCP所谓的建立连接并不是在物理层面建立什么连接，而是通过在通信两端建立一定的数据结构来维护双方交互的状态，用这样的<strong>数据结构</strong>来保证所谓的面向连接的特性，实现可靠传输。</p><h3 id="简易UDP通信案例"><a href="#简易UDP通信案例" class="headerlink" title="简易UDP通信案例"></a>简易UDP通信案例</h3><p>UDP在局域网基本不会丢包，很多内网的服务都是用UDP开发，简单高效易用。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在.net core使用以下2个包实现TCP/UDP通信，1个包实现指定数据流格式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br></pre></td></tr></table></figure><p>个人简易demo源码（UDP、TCP）：</p><h1 id="实现帧同步网络库"><a href="#实现帧同步网络库" class="headerlink" title="实现帧同步网络库"></a>实现帧同步网络库</h1><p>作为HOK demo的工具组之一。</p><h2 id="为什么使用UDP"><a href="#为什么使用UDP" class="headerlink" title="为什么使用UDP"></a>为什么使用UDP</h2><p>使用帧同步需要非常频繁交互。UDP更快，没有TCP那么繁琐的机制和包头额外数据。</p><h2 id="KCP入门"><a href="#KCP入门" class="headerlink" title="KCP入门"></a>KCP入门</h2><p>一套高效确认算法，可以让数据传输变得可靠有序 。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220124203153.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126215129.png"></p><h3 id="KCP源码"><a href="#KCP源码" class="headerlink" title="KCP源码"></a>KCP源码</h3><p><a href="https://github.com/skywind3000/kcp">源码地址</a>，手册很细致，里面也有一些原理性质的概念。</p><p><a href="https://github.com/KumoKyaku/KCP">C#版本</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>会话ID必须由服务器统一分配，不可重复。</p><p>实现模拟连接以便识别不同客户端数据。</p><p>双端复用代码，抽象网络会话类，进行数据收发。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>在NuGet市场上就有，不用非去github下源码。</p><h2 id="基于KCP实现的可靠UDP通信"><a href="#基于KCP实现的可靠UDP通信" class="headerlink" title="基于KCP实现的可靠UDP通信"></a>基于KCP实现的可靠UDP通信</h2><p>初次连接，传4个空字节过去。</p><p>当服务端收到后知道是新客户端，就生成全局唯一uuid并返回，返回的形式是“4个空字节+uuid”。客户端收到后设置KCPSession的sid。</p><p>kcp添加控制信息的包里，头4个字节的数字对应传入的int值，每一个字节可以转化为对应的0~255的数字。而4个字节刚好对应一个uint32，也就是传入<code>new Kcp(sid, m_handle)</code>的sid。</p><h1 id="基于KCPNet的解决方案"><a href="#基于KCPNet的解决方案" class="headerlink" title="基于KCPNet的解决方案"></a>基于KCPNet的解决方案</h1><p>本人基于KCPNet项目，集成proto协议、KCP算法的 Unity客户端 +.net core/framework服务端 解决方案。</p><p><a href="https://github.com/CodingCodingK/CodingK_Session">CodingK_Session</a></p><p>教程就不写了，我在里面写了2个使用案例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的解决方案&quot;&gt;&lt;a href=&quot;#我的解决方案&quot; class=&quot;headerlink&quot; title=&quot;我的解决方案&quot;&gt;&lt;/a&gt;我的解决方案&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CodingCodingK/CodingK_Sess</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="网络库" scheme="https://codingcodingk.github.io/tags/%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>GameFramework框架学习：应用篇</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/gf_demo/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/gf_demo/</id>
    <published>2022-02-01T02:52:39.166Z</published>
    <updated>2022-02-01T02:52:39.166Z</updated>
    
    <content type="html"><![CDATA[<p>参考写在前面！！！</p><p>本文是在腾讯大佬<a href="https://www.drflower.top/">花桑</a>的GF解析文章的基础上，自己阅读源码并尝试总结、应用、拓展的<strong>个人笔记</strong>！水印以示尊敬。</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>其实半年前就知道gf，但是那时候刚入门unity没多久，看了猫仙人的simple gf来学习，很可惜只学到了皮毛也就是一些常见的设计模式比如状态机、对象池、优先队列轮询在游戏中的应用。经过半年的unity学习与项目积累，再回来看gf的源码觉得，不难且实现优雅，但是内容实在是太多了，记不下来。为了让自己学的结构能穿起来，刨析demo并自己做，很必要。</p><p>参考的也是<a href="https://www.drflower.top/posts/6e65184/#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE">花桑</a>和gf官方的demo。</p><p><font color="red">// TODO 目前只做了刨析demo的流程</font></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://blog-1300673521.cos.ap-guangzhou.myqcloud.com/images/GameFramework%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%BC%96%E5%86%99%E6%B8%B8%E6%88%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="img"></p><h1 id="启动场景全流程"><a href="#启动场景全流程" class="headerlink" title="启动场景全流程"></a>启动场景全流程</h1><h2 id="自己的GameEntry-cs"><a href="#自己的GameEntry-cs" class="headerlink" title="自己的GameEntry.cs"></a>自己的GameEntry.cs</h2><p>是自己的GameEntry类，而不是<code>UnityGameFramework.Runtime</code>中的GameEntry静态类。</p><p>作为游戏的入口，它需要继承MonoBehaviour并在Start方法中进行初始化。因为gf所有控件的初始化是在Awake内结束的，所以Start内拿到他们的时候已经可以安心使用了。</p><ol><li>  将所有默认的 GameFrameworkComponent 通过<code>UnityGameFramework.Runtime.GameEntry.GetComponent</code>获取，赋值到静态字段中，提供全局访问。<strong>这一块不同项目可以通用。</strong></li><li>  将项目中自己创建的 GameFrameworkComponent 派生类 ，与上面一样的操作进行赋值提供访问。</li></ol><h2 id="ProcedureLaunch-流程"><a href="#ProcedureLaunch-流程" class="headerlink" title="ProcedureLaunch 流程"></a>ProcedureLaunch 流程</h2><blockquote><p>  进行一些游戏启动的必要的初始化，支撑后续的启动流程，如：</p><p>  1.初始化构建信息：如版本检测和资源更新的URL信息，更新界面资源等<br>  2.语言设置：若有上次设置记录则使用上次设置记录，若没有则使用默认或系统语言<br>  3.初始化变体：根据当前语言设置，通知后续底层加载对应的资源变体<br>  4.初始本地化文本资源：根据当前语言设置选择对应的文本</p><p>  以上涉及到的资源，包括更新信息文件、更新界面资源、本地化文本等都是build-in资源，也就是发布时就在包内，不可更新的。试想我们发布的游戏是一个仅仅支撑启动的包，所有游戏资源都需要在启动后的热更流程中下载，但一些启动图片，以及热更时的界面本身也是需要资源的，需要给出基本的文本、确认框等，以提供给玩家确认是否下载、下载进度预览，还涉及到更新请求的URL。这部分资源就是我们需要放在包内的不可更新资源，主要用来支撑热更的启动，而ProcedureLaunch流程就是负责初始化这些资源和相关配置。</p></blockquote><p>顺从gf的流程，从这个流程结点开始启动项目。做的是加载在进入热更阶段之前的画面，这些画面和配置不可更新，发布在包内。</p><p><strong>流程转变</strong>发生在OnUpdate，也就是Awake、Start之后的第一帧 进入ProcedureSplash。</p><h3 id="初始化变体"><a href="#初始化变体" class="headerlink" title="初始化变体"></a>初始化变体</h3><ol><li>  根据语言选项，设置对应的 m_CurrentVariant （”en-us”、”zh-cn”、”zh-tw” 其中之一）。</li><li>  m_CurrentVariant 会显示在 LabelField 中。</li><li>  在资源加载中起到作用：ResourceManager.ResourceIniter类的 <strong>OnLoadPackageVersionListSuccess方法</strong> 中，会遍历资源的Variant是否一致。</li></ol><h2 id="ProcedureSplash-流程"><a href="#ProcedureSplash-流程" class="headerlink" title="ProcedureSplash 流程"></a>ProcedureSplash 流程</h2><blockquote><p>  闪屏流程，该流程会播放一个闪屏动画，然后根据当前的资源模式选择下一个流程，分别有</p><p>  1.编辑器模式-&gt;ProcedurePreload<br>  2.整包模式（不可更新）-&gt;ProcedureInitResources<br>  3.可更新模式-&gt;ProcedureCheckVersion</p><p>  编辑器模式下将使用EditorResourceComponent作为资源组件，里面使用的是AssetDatabase的接口直接加载Editor下资源，不涉及任何打包资源，不需要做资源列表初始化等操作。可直接进入ProcedurePreload流程。</p><p>  这个并非必要流程，若不需要闪屏，去掉此流程，把逻辑挪到上一个流程中即可。</p></blockquote><p>其实就是一个switch，决定下一个去往的流程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GameEntry.Base.EditorResourceMode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编辑器模式</span></span><br><span class="line">    ChangeState&lt;ProcedurePreload&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (GameEntry.Resource.ResourceMode == ResourceMode.Package)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 单机模式</span></span><br><span class="line">    ChangeState&lt;ProcedureInitResources&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可更新模式</span></span><br><span class="line">    ChangeState&lt;ProcedureCheckVersion&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProcedureInitResources-流程"><a href="#ProcedureInitResources-流程" class="headerlink" title="ProcedureInitResources 流程"></a>ProcedureInitResources 流程</h2><blockquote><p>  对于整包模式这个分支流程很简单，主要逻辑就是调用ResourceManager.InitResources()，加载包内资源列表，并解析到ResourceManager中，这样就初始化完毕资源的相关信息了，包括AB包、Asset、资源组、文件系统、版本号等。因为整包模式下所有资源都在包体内，只需要一步初始化即可获得所有资源信息，且后续不需要进行更新，所以初始化后便进入ProcedurePreload流程。</p></blockquote><p>单机模式，不需要资源热更的情况，只需要加载资源。</p><p>看代码层层包装，实际做的事就是：</p><ol><li><p>  将所给的地址转化成 带有<code>file://</code> 或 <code>http://</code> 前缀的远端格式。</p></li><li><p>  根据1是否成功的结果，启用携程来发送web请求，获取到返回值后执行对应的 Success 或 Failed 函数（我个人觉得这里可以换成用异步等待）</p></li><li><p><strong>Success函数</strong>：OnLoadPackageVersionListSuccess ，将请求的返回值反序列化成一个<code>PackageVersionList</code>，从中获得版本信息、Asset、Resource、FileSystem、ResourceGroup并装载。</p><p>  <strong>Failed函数</strong>：OnLoadPackageVersionListFailure，抛出GameFrameworkException。</p></li><li><p>  切换状态到 ProcedurePreload 流程。</p></li></ol><h2 id="ProcedureCheckVersion-流程"><a href="#ProcedureCheckVersion-流程" class="headerlink" title="ProcedureCheckVersion 流程"></a>ProcedureCheckVersion 流程</h2><blockquote><p>  此流程主要是调用ResourceManager.UpdateVersionList()，更新版本资源列表，其实就是更新最新的GameFrameworkVersion.dat文件，此文件记录了服务器上最新资源的信息，包括一些校验信息等，这些信息将被用来在下一个ProcedureCheckResources流程中进行资源校验。</p></blockquote><ol><li><p>  向EventPool添加成功失败情况的2个回调。</p></li><li><p>  向服务器请求版本信息。</p></li><li><p>根据版本信息来决策：</p><p>  <strong>需要版本更新</strong>：设置VersionList并切换流程到 ProcedureUpdateVersion 流程。</p><p>  <strong>不需要版本更新</strong>：切换流程到 ProcedureCheckResources 流程。</p></li></ol><h2 id="ProcedureUpdateVersion-流程"><a href="#ProcedureUpdateVersion-流程" class="headerlink" title="ProcedureUpdateVersion 流程"></a>ProcedureUpdateVersion 流程</h2><blockquote><p>  此流程主要是调用ResourceManager.UpdateVersionList()，更新版本资源列表，其实就是更新最新的GameFrameworkVersion.dat文件，此文件记录了服务器上最新资源的信息，包括一些校验信息等，这些信息将被用来在下一个ProcedureCheckResources流程中进行资源校验。</p></blockquote><p>基本上面就是全部了，唯一值得补充的是下载用的是 <strong>DownloadTask 类</strong>，然后放到 DownloadManager 的任务池里。</p><p>成功后执行回调，进入 ProcedureCheckResources 流程。</p><h2 id="ProcedureCheckResources-流程"><a href="#ProcedureCheckResources-流程" class="headerlink" title="ProcedureCheckResources 流程"></a>ProcedureCheckResources 流程</h2><blockquote><p>  资源检测流程，核心逻辑是调用ResourceManager.CheckResources()，GF内部会解析以下3个文件：</p><p>  ​    1.可读写路径下的GameFrameworkVersion.dat，文件记录着服务器上最新的资源信息<br>  ​    2.只读路径下的GameFrameworkList.dat，文件记录着只读路径（包内）下的资源信息<br>  ​    3.可读写路径下的GameFrameworkList.dat，文件记录着可读写路径下（以前通过热更下载的）的资源信息</p><p>  资源模块内部会根据本地资源信息和服务器资源信息作对比，标记出每个资源的状态，包括是否需要更新、是否可用、是否需要删除等。后续可以根据这些状态来加载或更新资源。</p><p>  检测完资源后，有哪些资源是需要更新的就已经明确了，这个时候可以根据项目具体需求选择是否进入更新流程。</p><p>  ​    a.若游戏要求所有资源都为最新时才能进入游戏，则有资源变化就必须进入更新流程更新资源<br>  ​    b.若游戏做了分包下载，进入初始场景不需要更新（初始场景资源无变化），待用到对应资源时才更新，也可以不进入更新流程，在游戏中玩家需要访问未更新资源时，再在后台更新。</p></blockquote><p>看上面就够。实际执行的代码就是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OnEnter：</span><br><span class="line"><span class="comment">// 3项加载解析</span></span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadWritePath, RemoteVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadUpdatableVersionListSuccess, OnLoadUpdatableVersionListFailure), <span class="literal">null</span>);</span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadOnlyPath, LocalVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadReadOnlyVersionListSuccess, OnLoadReadOnlyVersionListFailure), <span class="literal">null</span>);</span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadWritePath, LocalVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadReadWriteVersionListSuccess, OnLoadReadWriteVersionListFailure), <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 完成后执行回调，标记出每个资源的状态，包括是否需要更新、是否可用、是否需要删除等。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCheckResourcesComplete</span>(<span class="params">...</span>)</span>;</span><br><span class="line"></span><br><span class="line">OnUpdate：</span><br><span class="line"><span class="comment">// 根据上面标记的值：是否需要更新，来确定下一个状态。</span></span><br><span class="line">需要版本更新：设置UpdateResourceCount并切换流程到 ProcedureUpdateResources 流程。</span><br><span class="line">不需要版本更新：切换流程到 ProcedurePreload 流程。</span><br></pre></td></tr></table></figure><p><strong>需要版本更新</strong>：设置UpdateResourceCount并切换流程到 ProcedureUpdateResources 流程。<br><strong>不需要版本更新</strong>：切换流程到 ProcedurePreload 流程。</p><h2 id="ProcedureUpdateResources-流程"><a href="#ProcedureUpdateResources-流程" class="headerlink" title="ProcedureUpdateResources 流程"></a>ProcedureUpdateResources 流程</h2><blockquote><p>  资源更新流程，如上文所说，在本流程可以根据项目具体需求，更新此刻需要更新的资源。例如游戏内做了资源分组，把一些活动、副本等资源单独分组了，则可以在此时只更新基础资源，待玩家访问到还没更新的活动、副本相关资源时，再在后台更新活动、副本的资源。更新的最小单位为一个资源组。</p><p>  另外这个流程还需要实现热更时的当前进度、下载速度、剩余大小等界面表现。</p><p>  更新完成后正式进入游戏业务流程。</p></blockquote><p>获取上个流程传来的 UpdateResourceCount，之后传入委托到EventPool。这4个委托的核心是维护一个<code>List&lt;UpdateLengthData&gt;</code>队列 <strong>m_UpdateLengthData</strong>（下称进度队列） 。而这个进度队列的数据结构，只有 Name、Length、TotalZipLength 三个属性。</p><p>花桑的demo里用了4个委托的情况：</p><ol><li>  OnResourceUpdateStart：为进度队列添加内容。</li><li>  OnResourceUpdateChanged：为进度队列更新进度。</li><li>  OnResourceUpdateSuccess：修改 m_UpdateSuccessCount++，并为进度队列更新进度。</li><li>  OnResourceUpdateFailure：Retry并为进度队列回退进度。如果Retry次数超过设定次数，就直接返回。</li></ol><p>设置好委托后，执行 StartUpdateResources方法。这个方法内将资源列表放到了一个 资源等待更新队列。ResourceManager的Update里会去轮询这个 资源等待更新队列，一帧一个（TODO why？）地，加入DownloadManager的TaskPool里。</p><p>等待更新任务完成后，切换到最终流程 ProcedurePreload流程。</p><h2 id="ProcedurePreload-流程"><a href="#ProcedurePreload-流程" class="headerlink" title="ProcedurePreload 流程"></a>ProcedurePreload 流程</h2><blockquote><p>   预加载流程，这一流程已经属于游戏业务层，但大部分游戏其实都需要这么一个流程，所以这里也把他规划到通用流程中，流程中主要负责设置框架的功能模块，预加载数据表，初始化游戏中的功能系统等。</p></blockquote><p>找到 Config（配置） 和 Localization（本地化组件） 的路径，传入GF进行异步加载。再对所有Data进行Preload。</p><p>完成后进入 ProcedureLoadingScene流程。</p><h2 id="ProcedureLoadingScene-流程"><a href="#ProcedureLoadingScene-流程" class="headerlink" title="ProcedureLoadingScene 流程"></a>ProcedureLoadingScene 流程</h2><p>加载Scene流程，也是通用的。先根据id获取一个SceneData类型，这个SceneData类型是装在一个字典中的，在ProcedurePreload 流程的时候会初期化。</p><p>SceneData类型附带了场景名字路径等，以及，下一个流程的名字。当Scene加载完后，根据上面取得的配置，切换到下一个流程中。</p><p>按正常顺序走，第一个场景是 Menu场景。</p><h2 id="ProcedureMenu-流程"><a href="#ProcedureMenu-流程" class="headerlink" title="ProcedureMenu 流程"></a>ProcedureMenu 流程</h2><p>对应的是游戏选关卡的界面。其实就是主城啦。</p><p>展示UI、展示关卡等等。当选择关卡后，会进入 ProcedureLoadingScene流程，一样读取SceneData切换到对应关卡并进入 ProcedureLevel流程。</p><h2 id="ProcedureLevel-流程"><a href="#ProcedureLevel-流程" class="headerlink" title="ProcedureLevel 流程"></a>ProcedureLevel 流程</h2><p>战斗流程。</p><p>根据关卡配置创建关卡 LevelControl类型，里面包含了所有战斗需要的东西，有点类似于自己常写的“BattleMgr”。</p><p>LevelControl并不继承Mono，只继承一个IReference接口。它由<strong>ProcedureLevel.OnUpdate</strong>驱动每一帧做的事，同时OnUpdate还会检测一个flag判断是否要执行切换场景了（进入 ProcedureLoadingScene流程）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考写在前面！！！&lt;/p&gt;
&lt;p&gt;本文是在腾讯大佬&lt;a href=&quot;https://www.drflower.top/&quot;&gt;花桑&lt;/a&gt;的GF解析文章的基础上，自己阅读源码并尝试总结、应用、拓展的&lt;strong&gt;个人笔记&lt;/strong&gt;！水印以示尊敬。&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="GameFramework框架" scheme="https://codingcodingk.github.io/categories/Unity/GameFramework%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity渲染原理</title>
    <link href="https://codingcodingk.github.io/2022/01/22/Tech/Game/Rendering/"/>
    <id>https://codingcodingk.github.io/2022/01/22/Tech/Game/Rendering/</id>
    <published>2022-01-22T07:20:06.125Z</published>
    <updated>2022-01-22T07:20:06.126Z</updated>
    
    <content type="html"><![CDATA[<p>渲染原理学习。</p><h1 id="Rending面板"><a href="#Rending面板" class="headerlink" title="Rending面板"></a>Rending面板</h1><h2 id="Color-Space"><a href="#Color-Space" class="headerlink" title="Color Space"></a>Color Space</h2><p>以前的阴极射线管电视，需要更强烈的色彩来弥补差设备显示，但现在硬件提升已经不需要了。</p><p>这就是为什么把Rendering的Color Space从Gamma切到Linear。</p><h3 id="阴极-真空管-电视"><a href="#阴极-真空管-电视" class="headerlink" title="阴极 真空管 电视"></a>阴极 真空管 电视</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118131229.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染原理学习。&lt;/p&gt;
&lt;h1 id=&quot;Rending面板&quot;&gt;&lt;a href=&quot;#Rending面板&quot; class=&quot;headerlink&quot; title=&quot;Rending面板&quot;&gt;&lt;/a&gt;Rending面板&lt;/h1&gt;&lt;h2 id=&quot;Color-Space&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/categories/Unity/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Unity常见UI基础问题手册</title>
    <link href="https://codingcodingk.github.io/2022/01/22/Tech/Game/Guide_UnityUI/"/>
    <id>https://codingcodingk.github.io/2022/01/22/Tech/Game/Guide_UnityUI/</id>
    <published>2022-01-22T07:20:06.124Z</published>
    <updated>2022-01-22T07:20:06.124Z</updated>
    
    <content type="html"><![CDATA[<p>仅作个人笔记用途。</p><h1 id="UI顶层显示"><a href="#UI顶层显示" class="headerlink" title="UI顶层显示"></a>UI顶层显示</h1><h2 id="方法一-做一个新的UI摄像机"><a href="#方法一-做一个新的UI摄像机" class="headerlink" title="方法一.做一个新的UI摄像机"></a>方法一.做一个新的UI摄像机</h2><p>① Canvas的Render Mode设置为<strong>Screen Space - Camera</strong></p><p>② 新建摄像机（后面称之为UI摄像机），放到原先摄像机的下面</p><p>③ 拖拽UI摄像机到Canvas的Render Camera</p><p>④ UI摄像机的 Clear Flags 设置为 <strong>Depth only</strong>，用来去掉背景；Culling Mask设置为 <strong>UI</strong>。</p><p>⑤ 确保 UI摄像机的Depth &gt; 其他摄像机的Depth （值小的会先渲染，所以值大的会在前面）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1dK4y1b7be?spm_id_from=333.999.0.0">超级细致的调试教学视频</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅作个人笔记用途。&lt;/p&gt;
&lt;h1 id=&quot;UI顶层显示&quot;&gt;&lt;a href=&quot;#UI顶层显示&quot; class=&quot;headerlink&quot; title=&quot;UI顶层显示&quot;&gt;&lt;/a&gt;UI顶层显示&lt;/h1&gt;&lt;h2 id=&quot;方法一-做一个新的UI摄像机&quot;&gt;&lt;a href=&quot;#方法一-做一</summary>
      
    
    
    
    <category term="Unity个人积累" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>GameFramework框架学习：原理篇</title>
    <link href="https://codingcodingk.github.io/2022/01/22/Tech/Game/GF/"/>
    <id>https://codingcodingk.github.io/2022/01/22/Tech/Game/GF/</id>
    <published>2022-01-22T07:20:06.123Z</published>
    <updated>2022-02-01T02:52:39.165Z</updated>
    
    <content type="html"><![CDATA[<p>参考写在前面！！！</p><p>本文是在腾讯大佬<a href="https://www.drflower.top/">花桑</a>和大佬<a href="http://www.maodaodao.top/">猫刀刀</a>的GF解析文章的基础上，阅读源码并尝试总结、应用、拓展的<strong>个人笔记</strong>！无其他用途，水印以示尊敬。</p><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>基于MonoBehaviour来实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GameFrameworkComponent</span> : <span class="title">MonoBehaviour</span> &#123; </span><br><span class="line">    <span class="comment">// 游戏框架组件初始化。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameEntry.RegisterComponent(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GameEntry</span> &#123;</span><br><span class="line">    <span class="comment">// 提供api方便外部访问这个链队，从而获取组件</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">readonly</span> <span class="title">GameFrameworkLinkedList</span>&lt;<span class="title">GameFrameworkComponent</span>&gt; s_GameFrameworkComponents</span> = <span class="keyword">new</span> GameFrameworkLinkedList&lt;GameFrameworkComponent&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterComponent</span>(<span class="params">GameFrameworkComponent gameFrameworkComponent</span>)</span>&#123;</span><br><span class="line">        Type type = gameFrameworkComponent.GetType();</span><br><span class="line">        ... <span class="comment">// 确保链队未添加过同type元素</span></span><br><span class="line">        s_GameFrameworkComponents.AddLast(gameFrameworkComponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------执行完上述base.Awake()后，回到各自的Awake()逻辑。下面用ProcedureComponent举例。------------------</span></span><br><span class="line">ProcedureComponent.<span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.Awake(); <span class="comment">// 上面做的事</span></span><br><span class="line">    m_ProcedureManager = GameFrameworkEntry.GetModule&lt;IProcedureManager&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="GameFrameworkModule"><a href="#GameFrameworkModule" class="headerlink" title="GameFrameworkModule"></a>GameFrameworkModule</h3><p>GameFrameworkModule（GF层中各个模块的基类）采用懒加载。在Awake中GetModule的时候时，GameFrameworkEntry会先检测内部有没有这个模块对象，没有时再调用内部的CreateModule来实例化该模块。</p><p>CreateModule是通过传入的接口去掉第一个字符I，然后反射调用构造器的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------GameFrameworkEntry.GetModule&lt;T&gt;() where T : class-----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的 type 是接口 (比如 IProcedureManager)</span></span><br><span class="line"><span class="built_in">string</span> typeName = Utility.Text.Format&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;&quot;</span>, type.Namespace, type.Name.Substring(<span class="number">1</span>));</span><br><span class="line">...</span><br><span class="line">GameFrameworkModule instance = (GameFrameworkModule) Activator.CreateInstance(Type.GetType(typeName));</span><br><span class="line">... <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br></pre></td></tr></table></figure><p>最后这个类（比如 ProcedureManager），就在GF框架里而不是UGF框架了。这个是一个很好的解耦。</p><p>然后我们讲讲CreateModule方法里省略的代码，①里做的事：</p><p>根据<code>instance.Priority</code>优先级，插入到<code>GameFrameworkEntry。s_GameFrameworkModules</code>全局队列中合适的节点位置。这么做是为了保证链队始终保持优先级从大到小排序，等后面Update的时候就直接foreach遍历就完事了！</p><h2 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220120143413.png"></p><p>Tick部分逻辑比较轻：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GameFrameworkComponent</span> : <span class="title">MonoBehaviour</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BaseComponent</span> : <span class="title">GameFrameworkComponent</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameFrameworkEntry.Update(Time.deltaTime, Time.unscaledDeltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GameFrameworkEntry</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接foreach就可以！初始化① 的时候保证了链队是按优先级顺序排的</span></span><br><span class="line">        <span class="keyword">foreach</span> (GameFrameworkModule gameFrameworkModule <span class="keyword">in</span> GameFrameworkEntry.s_GameFrameworkModules)</span><br><span class="line">            gameFrameworkModule.Update(elapseSeconds, realElapseSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ShutDown"><a href="#ShutDown" class="headerlink" title="ShutDown"></a>ShutDown</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220120150856.png"></p><p>卸载。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ShutdownType : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仅关闭游戏框架。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭游戏框架并重启游戏。</span></span><br><span class="line">    Restart,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭游戏框架并退出游戏。</span></span><br><span class="line">    Quit,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameEntry.Shutdown(ShutdownType shutdownType)&#123;</span><br><span class="line">    baseComponent.Shutdown();</span><br><span class="line">    s_GameFrameworkComponents.Clear();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.None) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.Restart)</span><br><span class="line">    &#123;</span><br><span class="line">        SceneManager.LoadScene(GameFrameworkSceneId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.Quit)</span><br><span class="line">    &#123;</span><br><span class="line">        Application.Quit();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------下面只讨论None：仅关闭游戏框架。-----------------------</span></span><br><span class="line"></span><br><span class="line">BaseComponent.Shutdown()</span><br><span class="line">&#123;</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseComponent.OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">    GameFrameworkEntry.Shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameFrameworkEntry.Shutdown()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>() &#123; ... &#125; <span class="comment">// 从后往前遍历 s_GameFrameworkModules 所有成员执行 Shutdown(); </span></span><br><span class="line">    </span><br><span class="line">    GameFrameworkEntry.s_GameFrameworkModules.Clear();</span><br><span class="line">    ReferencePool.ClearAll();</span><br><span class="line">    Utility.Marshal.FreeCachedHGlobal();</span><br><span class="line">    GameFrameworkLog.SetLogHelper((GameFrameworkLog.ILogHelper) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GF书写习惯"><a href="#GF书写习惯" class="headerlink" title="GF书写习惯"></a>GF书写习惯</h1><p>GF整体代码的书写习惯是利用 接口 + Dictionary + List 来实现对外的api调用。</p><p>而<strong>接口的实际对象</strong>正如前面所说，绝大部分都是Awake的时候反射构造 <strong>同名实现类</strong> 实现的。</p><p>这一点对于扩展来说非常开闭，就是提高了熵。</p><p>知道了这一点后，下面的探究就不再对GF的接口进行关注了，而是只看他们的实现类了。</p><h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;Player&gt; fsm; <span class="comment">//一个状态机</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;FsmState&lt;Player&gt;&gt; stateList; <span class="comment">//状态结点List</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建状态列表</span></span><br><span class="line">        stateList = <span class="keyword">new</span> List&lt;FsmState&lt;Player&gt;&gt;() &#123; <span class="keyword">new</span> IdleState(), <span class="keyword">new</span> MoveState() &#125;;</span><br><span class="line">        <span class="comment">//创建状态机，注意，对于所有持有者为Player类型的状态机的名字参数&quot;name&quot;不能重复</span></span><br><span class="line">        fsm = GameEntry.fsmComponent.fsmManager.CreateFsm&lt;Player&gt;(<span class="string">&quot;name&quot;</span>, <span class="keyword">this</span>, stateList);</span><br><span class="line">        <span class="comment">//以IdleState为初始状态，启动状态机</span></span><br><span class="line">        fsm.Start&lt;IdleState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FsmManager"><a href="#FsmManager" class="headerlink" title="FsmManager"></a>FsmManager</h2><p>FsmManager 和 IFsmManager。状态机最外层的存在，有Update会被循环，外部直接调用它的<code>CreateFsm</code>方法。</p><p>值得注意的是（下面）用了2次foreach完成1次轮询，为什么要这么做？</p><p><strong>因为如果在第一次foreach的时候就直接调用fsm.Update很可能导致m_Fsms的更改，从而导致迭代器的损坏。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级60</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FsmManager</span> : <span class="title">GameFrameworkModule</span>, <span class="title">IFsmManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> Dictionary&lt;TypeNamePair, FsmBase&gt; m_Fsms;</span><br><span class="line">    <span class="keyword">readonly</span> List&lt;FsmBase&gt; m_TempFsms;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        m_TempFsms.Clear();</span><br><span class="line">        <span class="keyword">foreach</span>(m_Fsms) &#123; ... &#125; <span class="comment">// 将m_Fsms全部放入干净的m_TempFsms中。</span></span><br><span class="line">        <span class="keyword">foreach</span>(m_TempFsms) &#123; fsm.Update(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fsm-lt-T-gt"><a href="#Fsm-lt-T-gt" class="headerlink" title="Fsm&lt; T &gt;"></a>Fsm&lt; T &gt;</h2><p>一个状态机。继承自FsmBase，也就是上面字典的申明类型。<strong>FsmBase抽象类</strong> 就不介绍了，是一些状态机的通用属性比如Name、IsDestory之类的属性。</p><p>T传进去的是你的数据类型，和结点<code>FsmState&lt;T&gt;</code>传的T一致。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Fsm</span>&lt;<span class="title">T</span>&gt; : <span class="title">FsmBase</span>, <span class="title">IReference</span>, <span class="title">IFsm</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> Dictionary&lt;Type, FsmState&lt;T&gt;&gt; m_States;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, Variable&gt; m_Datas;</span><br><span class="line">    <span class="keyword">private</span> FsmState&lt;T&gt; m_CurrentState;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>&lt;<span class="title">TState</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        FsmState&lt;T&gt; state = GetState&lt;TState&gt;();</span><br><span class="line">        m_CurrentState = state;</span><br><span class="line">        m_CurrentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_CurrentState.OnUpdate(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个是对FsmState结点提供的方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">ChangeState</span>&lt;<span class="title">TState</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type stateType = <span class="keyword">typeof</span>(TState);</span><br><span class="line">        FsmState&lt;T&gt; state = GetState(stateType); <span class="comment">// GetState 就是从m_States里查找</span></span><br><span class="line">        m_CurrentState.OnLeave(<span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">        m_CurrentState = state;</span><br><span class="line">        m_CurrentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FsmState-lt-T-gt"><a href="#FsmState-lt-T-gt" class="headerlink" title="FsmState&lt; T &gt;"></a>FsmState&lt; T &gt;</h2><p>一个状态结点。一个状态机对应多个状态结点，想象一下状态机的图就行了。</p><p><strong>一般来说，我们需要自己实现的就只有这个类。</strong></p><p>对上面调用过的方法进行展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FsmState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 生命周期（全是虚方法，具体行为要自己实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params">IFsm&lt;T&gt; fsm, <span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnLeave</span>(<span class="params">IFsm&lt;T&gt; fsm, <span class="built_in">bool</span> isShutdown</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不对外提供的方法，在自己实现的状态结点代码内互相切换状态。当然你可以在子类里选择公开它。</span></span><br><span class="line">    <span class="comment">// 一般在OnUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ChangeState</span>&lt;<span class="title">TState</span>&gt;(<span class="params">IFsm&lt;T&gt; fsm</span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        Fsm&lt;T&gt; fsmImplement = (Fsm&lt;T&gt;)fsm;</span><br><span class="line">        fsmImplement.ChangeState&lt;TState&gt;(); <span class="comment">// 调用上面的 Fsm.ChangeState方法 来实现切换状态。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己实现这个抽象类的时候，ChangeState调用的时机一般写在 <strong>OnUpdate</strong> 方法里。比如每帧都判断一个flag，flag为true就切换到其他状态。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实可以更深层次的拓展出<strong>状态栈</strong>：如果状态被某个状态打断，可以恢复到之前的状态。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>在ProcedureComponent组件（下面）中提到，是通过m_AvailableProcedureTypeNames来创建实例，并以m_EntranceProcedure为起始状态，启动流程状态机，那么这两个变量是怎么来的呢。</p><p>如图所示，我们直接通过流程组件的Inspector来配置，<strong>GF会通过反射获取所有继承ProcedureBase的子类，并展示在此面板</strong>，我们只需要勾选需要流程即可把它加入到m_AvailableProcedureTypeNames中，而面板上的Entrance Procedure则代表了m_EntranceProcedure，这里我们选择了StarForce.ProcedureLaunch作为起始状态，那么ProcedureLaunch类中的OnEnter方法中的逻辑，就是我们游戏启动后最先执行的游戏业务逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/GameFramework_Procedure_Config.png"></p><p>代码上看，是对有限状态机的封装。功能上看，如果把游戏整体看作一部电影的话，那玩家游玩时刻总是在整个游戏的某个流程结点罢了。</p><p>常见的二次元游戏流程线：打开游戏app &gt; 热更 &gt; 登陆 &gt; 主城： 各种丰富的业务（任务系统、商城系统、养成系统、etc） ，选择了副本系统 &gt; 战斗，战斗结束回到主城</p><p>我个人认为这么划分基本就涵盖了所有的业务。在花卷的博客里写了：</p><blockquote><p>  一般地说，一个游戏拥有的流程数量是非常有限的，如果规划出数十个流程出来，很可能是对流程的理解有所偏差。例如一个塔防游戏有数十个关卡，每个关卡的内容都不一样，但关卡中的地图，炮塔，敌人生成等，其实都是数据驱动的，而他们的逻辑其实是一样的，只是数据不同造成表现不同，所以无论是哪个关卡，他们都应该属于同一个流程。</p></blockquote><p>所以我觉得 主城系统里的各种养成系统，都是一个流程结点；战斗系统里各种副本，也属于一个流程结点。</p><h2 id="ProcedureBase"><a href="#ProcedureBase" class="headerlink" title="ProcedureBase"></a>ProcedureBase</h2><p>非常简单，就是继承了一下 FsmState 并指定类型 IProcedureManager 罢了。本质就是个状态结点。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ProcedureBase</span> : <span class="title">FsmState</span>&lt;<span class="title">IProcedureManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProcedureManager"><a href="#ProcedureManager" class="headerlink" title="ProcedureManager"></a>ProcedureManager</h2><p>内部包裹了<strong>一个 FsmManager 和 一个Type为ProcedureManager的状态机</strong>，也就是状态机的最外层。</p><ol><li>  字段m_FsmManager为有限状态机管理器，会在Initialize方法初始化时作为参数传入，m_ProcedureFsm为管理流程用的有限状态机。</li><li>  方法Initialize会取得FsmManager实例和包括所有流程（继承ProcedureBase的对象）的列表，并用FsmManager创建出一个状态机实例储存于m_ProcedureFsm中。</li><li>  与Fsm模块类似，流程模块提供HasProcedure、GetProcedure接口来查询和获取指定流程对象，CurrentProcedure获得当前处于的流程，CurrentProcedureTime获取当前流程持续时间。</li><li>  <strong>StartProcedure</strong>方法，令状态机从指定流程启动，这里是游戏框架正式启动游戏的关键入口。该方法其实就是调用了内部状态机的Start。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级-10</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ProcedureManager</span> : <span class="title">GameFrameworkModule</span>, <span class="title">IProcedureManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsmManager m_FsmManager;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;IProcedureManager&gt; m_ProcedureFsm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">IFsmManager fsmManager, <span class="keyword">params</span> ProcedureBase[] procedures</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_FsmManager = fsmManager;</span><br><span class="line">        m_ProcedureFsm = m_FsmManager.CreateFsm(<span class="keyword">this</span>, procedures); <span class="comment">// procedures就是所有流程！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProcedureComponent"><a href="#ProcedureComponent" class="headerlink" title="ProcedureComponent"></a>ProcedureComponent</h2><p>ProcedureManager的<strong>Initialize</strong>方法会取得FsmManager实例和包括所有流程（继承ProcedureBase的对象）的列表，并用FsmManager创建出一个状态机实例储存于m_ProcedureFsm中。这些是在ProcedureComponent里完成的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ProcedureComponent</span> : <span class="title">GameFrameworkComponent</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所有流程的列表</span></span><br><span class="line">        ProcedureBase[] procedures = <span class="keyword">new</span> ProcedureBase[m_AvailableProcedureTypeNames.Length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_AvailableProcedureTypeNames.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Type procedureType = Utility.Assembly.GetType(m_AvailableProcedureTypeNames[i]);</span><br><span class="line">            procedures[i] = (ProcedureBase)Activator.CreateInstance(procedureType);</span><br><span class="line">            <span class="keyword">if</span> (m_EntranceProcedureTypeName == m_AvailableProcedureTypeNames[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据名字，寻找初始流程</span></span><br><span class="line">                m_EntranceProcedure = procedures[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Initialize，把 所有流程的列表procedures 传进去了</span></span><br><span class="line">        m_ProcedureManager.Initialize(GameFrameworkEntry.GetModule&lt;IFsmManager&gt;(), procedures);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始流程，游戏运行！</span></span><br><span class="line">        m_ProcedureManager.StartProcedure(m_EntranceProcedure.GetType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcedureComponent继承了Mono类，上面的Start方法会被Unity内部主动调用，调用后会根据<strong>m_AvailableProcedureTypeNames通过反射来创建流程对象</strong>，进行一系列初始化，再以<strong>m_EntranceProcedure为起始状态</strong>，启动流程状态机。</p><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>其实 流程模块 完全是状态机实例完成，那么功能上没必要单独做成一个模块，但是GF却单独提取成一个模块。很大的原因是因为状态机的状态内部对外是不希望透明的，而流程内部的流程结点是希望对外透明、可访问的。</p><h2 id="完整的启动流程"><a href="#完整的启动流程" class="headerlink" title="完整的启动流程"></a>完整的启动流程</h2><p><a href="">GameFramework框架学习：应用篇</a></p><p><a href="https://www.drflower.top/posts/6e65184/#ProcedureLaunch">花桑启动流程博文</a></p><h1 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126163846.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://www.drflower.top/posts/16213a73/#UIFormInfo">花卷博客UI篇</a>很细，这里只简述。</p><h3 id="UIManager"><a href="#UIManager" class="headerlink" title="UIManager"></a>UIManager</h3><p>UIManager是外部访问框架UI模块的入口。</p><p><strong>UIManager</strong> 持有 Dictionary&lt;string, **UIGroup**&gt;。</p><blockquote><p>  UIManager内部会用GF的对象池模块创建一个对象池，用于缓存UIForm对象的GameObject实例，外部调用OpenUIForm来打开UI时，会先尝试从对象池获取该界面，若对象池中有同类型的空闲实例，则直接取出使用，若没有则从资源模块加载，加载成功后，会注册到对象池中，再交给UIManager使用。而调用CloseUIForm来关闭UI时，UIForm会被加到Queue类型的字段m_RecycleQueue中，在下一次Update时，会把队列所有元素取出，回收到对象池中。</p><p>  内部维护了一个私有字段m_Serial，每次调用OpenUIForm的时候，m_Serial都会自增1，他表示了每个UIForm在其生命周期内的唯一标识符，即使是同一个UIForm实例，被关闭后放回对象池，再被取出来使用，其m_Serial也会发生变化。</p></blockquote><h3 id="UIGroup"><a href="#UIGroup" class="headerlink" title="UIGroup"></a>UIGroup</h3><p>UIGroup是一系列窗口集合，内部用链队存储了一个 LinkedListNode&lt; **UIFormInfo** &gt;，用链表来模栈式结构（链头在最上层）。有Depth的概念。</p><blockquote><p>  Refresh：UIGroup的核心逻辑，根据链表顺序以及UIForm的属性，去调用UIForm的OnDepthChanged、OnCover、OnReveal、OnPause、OnResume这些方法。</p></blockquote><h3 id="UIFormInfo"><a href="#UIFormInfo" class="headerlink" title="UIFormInfo"></a>UIFormInfo</h3><p>UIFormInfo持有<strong>UIForm</strong>的引用。</p><p>既然UIForm是窗口，那为什么要对它再包一层Info呢？它只多了Paused和Covered两个状态，用来表示状态，提供给UIGroup或外界。</p><h3 id="UIForm"><a href="#UIForm" class="headerlink" title="UIForm"></a>UIForm</h3><p>UIForm是UI窗口类，被UIGroup直接管理，每个UI窗口都会有一个UIForm实例，同时也拥有一个<strong>UIFormLogic</strong>实例（一般是它的派生类）。有唯一标识符字段m_SerialId。</p><h3 id="UIFormLogic"><a href="#UIFormLogic" class="headerlink" title="UIFormLogic"></a>UIFormLogic</h3><p>UIFormLogic为UI界面的具体逻辑类，类内有UIForm的所有生命周期方法。</p><p>游戏业务层不对UIForm做扩展，而是<strong>对UIFormLogic继承进行扩展</strong>，也就是自己的脚本继承UIFormLogic，正常写。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126175427.png"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126181213.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126181431.png"></p><h1 id="引用池"><a href="#引用池" class="headerlink" title="引用池"></a>引用池</h1><p>就是对象池结构。</p><p>关于对象池我的一些个人理解：对象池本身的存在理由是，因为频繁创建-销毁对象，会让堆产生大量的内存碎片，导致gc的压缩更频繁。这不好，所以直接申请一大块内存，保持在游戏运行时不释放它。 </p><p>但在GF中并不要求开发者在创建的时候就传入引用池capacity，默认会是0，然后动态扩容。我个人认为，可能是因为分配大量内存而不用的危害远比频繁压缩大，所以<strong>gf中对象池的核心作用只是复用对象，也就是减少mono对象和类对象的创建</strong>。</p><p>每个对象的内存大小是固定的，未使用的对象会保留在内存中。</p><blockquote><p>  GF中池子有两种，一种叫引用池，一种叫对象池，两者原理一样，但具体实现和针对的对象不同，引用池一般用来储存普通的C#类型对象，而对象池则一般用于储存UnityEngine下的对象（如Unity中的GameObject对象）。</p></blockquote><h2 id="ReferencePool"><a href="#ReferencePool" class="headerlink" title="ReferencePool"></a>ReferencePool</h2><p>ReferencePool 静态类，是外部访问引用池模块的入口。</p><p>内部维护了一个Dictionary&lt;Type, **ReferenceCollection**&gt;，这个字典就是所有的引用池，Typa对应引用池类型。</p><p>采用惰性初始化：当内部有需要获取某引用池实例（比如外界调用API获取引用，内部就先需要get到这个池子），如果在这个字典里Type的池子并不存在，则构造一个加入字典再返回。</p><h2 id="ReferenceCollection"><a href="#ReferenceCollection" class="headerlink" title="ReferenceCollection"></a>ReferenceCollection</h2><p>引用池。每一个引用池都有自己对应的Type，不同类型的对象储存在各自类型的池子中。</p><p>① 需要对构造器传入一个Type，在初期化时会保存好Type。</p><p>② <strong>Queue存储引用</strong>：内部维护了一个Queue&lt; **IReference** &gt;，来储存池子中的对象。</p><p>③ <strong>池容量动态扩容</strong>：创建时不需要指定池的capacity，设置为0。容量的扩大，完全靠动态扩容（具体思考看本节开头）。</p><h2 id="IReference"><a href="#IReference" class="headerlink" title="IReference"></a>IReference</h2><blockquote><p>   IReference接口只包含一个Clear方法，此方法会在对象回收池被调用，每一个需要被引用池储存的类型都需要实现此接口，以能清空当前状态，恢复到初始状态，供下次使用。</p></blockquote><p>引用池-&gt;对象复用 的根本。</p><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>引用池一般用来储存普通的C#类型对象。</p><p>比如可以实现复用状态机的状态：</p><ol><li>  状态内实现Create方法，去引用池Acquire（取）一个空闲的相同状态。</li><li>  状态内实现Clear方法（IReference接口），清空所有字段变回初始值。</li></ol><p>之后调用，只需要在new状态机的时候Create，Destory时Clear就可以了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 花桑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;Player&gt; fsm;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建状态列表(不用引用池)</span></span><br><span class="line">        <span class="comment">//List&lt;FsmState&lt;Player&gt;&gt; stateList = new List&lt;FsmState&lt;Player&gt;&gt;() &#123; new IdleState(), new MoveState() &#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建状态列表(使用引用池)</span></span><br><span class="line">        List&lt;FsmState&lt;Player&gt;&gt; stateList = <span class="keyword">new</span> List&lt;FsmState&lt;Player&gt;&gt;() &#123; IdleState.Create(), MoveState.Create() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --------------------------下面和原来一样--------------------------</span></span><br><span class="line">        <span class="comment">//创建状态机，注意，对于所有持有者为Player类型的状态机的名字参数不能重复，这里用自增ID避免重复</span></span><br><span class="line">        fsm = GameEntry.Fsm.CreateFsm&lt;Player&gt;((SERIAL_ID++).ToString(), <span class="keyword">this</span>, stateList);</span><br><span class="line">        <span class="comment">//以IdleState为初始状态，启动状态机</span></span><br><span class="line">        fsm.Start&lt;IdleState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出状态机所有状态</span></span><br><span class="line">        FsmState&lt;Player&gt;[] states = fsm.GetAllStates();</span><br><span class="line">        <span class="comment">//销毁状态机</span></span><br><span class="line">        GameEntry.Fsm.DestroyFsm(fsm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把状态实例归还引用池</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> states)</span><br><span class="line">        &#123;</span><br><span class="line">            ReferencePool.Release((IReference)item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inspector面板监视"><a href="#Inspector面板监视" class="headerlink" title="Inspector面板监视"></a>Inspector面板监视</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220127141559.png"></p><p><strong>Enable Strick Check</strong>：开启类型检测。对象池内部操作时，一方面检测Type是不是非抽象Class且实现了IReference接口的Class；另一方面是释放对象（也就是把对象放回对象池时），需要检查这个对象是不是已经空闲着了。如果 类型不满足、空闲还要求释放 ，就抛错。不过这个检测开启会影响性能，所以只建议测试时开。</p><p><strong>面板用途</strong>：可以通过此面板方便地检查业务逻辑中有没有正确使用引用池，例如某个对象只会在某个流程中会使用，我们可以检测在流程循环中，这个对象的Acquire和Release是否相等，而流程结束时，Using是否为0，Unused是否与Add相等。</p><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>GF中对象池与引用池作用类似，一般用于储存UnityEngine下的对象（如Unity中的GameObject对象）。</p><p>对象池的实现我们可以把他分成3部分，上图中从上到下每一行就是一部分，分别是</p><ol><li>  <strong>物体部分</strong>（抽象类ObjectBase，Object&lt; T &gt;，结构体ObjectInfo），</li><li>  <strong>对象池部分</strong>（抽象类ObjectPoolBase，ObjectPool&lt; T &gt;，委托ReleaseObjectFilterCallback），</li><li>  <strong>对象池管理器部分</strong>（接口IObjectPoolManager，类ObjectPoolManager）。</li></ol><p>其中Object和ObjectPool是ObjectPoolManager的内部私有类。</p><h2 id="整体关系⭐"><a href="#整体关系⭐" class="headerlink" title="整体关系⭐"></a>整体关系⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220127173856.png"></p><p>对象池：ObjectPool&lt; T &gt;类。它继承 ObjectPoolBase抽象类，且内部持有一个**Object&lt; T &gt;**一对多GF字典。</p><p>对象：Object&lt; T &gt; 类。它内部持有一个T对象的引用，且要求T必须继承自 <strong>ObjectBase抽象</strong>类。它实现 IReference接口，所以Create的时候是从引用池分配的。</p><p>对象抽象：ObjectBase 类，也就是上面2个类中限定的T 。内部持有一个<strong>object字段（m_Target）</strong>，这才是真正的 System.Object对象。</p><h2 id="物体部分"><a href="#物体部分" class="headerlink" title="物体部分"></a>物体部分</h2><h3 id="ObjectBase"><a href="#ObjectBase" class="headerlink" title="ObjectBase"></a>ObjectBase</h3><p>通过Initialize方法可把目标对象传递给m_Target字段，这才是object。通过重写OnSpawn、OnUnspawn方法实现对象获取、回收时执行的逻辑。</p><h3 id="Object-lt-T-gt"><a href="#Object-lt-T-gt" class="headerlink" title="Object&lt; T &gt;"></a>Object&lt; T &gt;</h3><p>它实现 IReference接口，Create的时候是从引用池分配的，Release。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object&lt;T&gt; <span class="title">Create</span>(<span class="params">T obj, <span class="built_in">bool</span> spawned</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    internalObject = ReferencePool.Acquire&lt;Object&lt;T&gt;&gt;();</span><br><span class="line">    internalObject.m_Object = obj; <span class="comment">// m_Object就是持有的ObjectBase对象引用</span></span><br><span class="line">    internalObject.m_SpawnCount = spawned ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> internalObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"><span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Object.Release(isShutdown);</span><br><span class="line">    ReferencePool.Release(m_Object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象池-1"><a href="#对象池-1" class="headerlink" title="对象池"></a>对象池</h2><h3 id="ObjectPool-lt-T-gt"><a href="#ObjectPool-lt-T-gt" class="headerlink" title="ObjectPool&lt; T &gt;"></a>ObjectPool&lt; T &gt;</h3><p>对象池，继承自 ObjectPoolBase抽象类 和 IObjectPool接口。两者其实很相似，但是却要做成2个是因为IObjectPool是泛型接口，而ObjectPoolBase不是泛型，后者在使用起来的时候可以不需要明确ObjectBase类型。</p><p>内部持有：一个<code>&lt;string, Object&lt;T&gt;&gt;</code>类型类型的一对多GF字典，一个<code>&lt;object, Object&lt;T&gt;&gt;</code>类型的普通字典。</p><p>Spawn方法：获取对象。字典中，有空闲的就返回，没有就返回null。也就是说，<strong>并不会新建对象</strong>。</p><p>Register方法：创建对象。</p><p>AutoReleaseInterval 属性：执行Release的频率。</p><p>Release方法：自动释放，频率由AutoReleaseInterval 决定，每个池可不同。Release过程会先获取可释放对象序列，然后通过委托ReleaseObjectFilterCallback对可释放物体序列进行筛选后，最后仅对筛选后的对象调用ReleaseObject进行释放。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">T obj, <span class="built_in">bool</span> spawned</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object&lt;T&gt; internalObject = Object&lt;T&gt;.Create(obj, spawned); <span class="comment">// Create方法在上面一小节有展示</span></span><br><span class="line">    m_Objects.Add(obj.Name, internalObject);</span><br><span class="line">    m_ObjectMap.Add(obj.Target, internalObject);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_ObjectMap.Count &gt; m_Capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        Release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    toReleaseCount = Count - m_Capacity; <span class="comment">// 当前对象池中对象的数量 - 池容量</span></span><br><span class="line">    expireTime = DateTime.UtcNow.AddSeconds(-m_ExpireTime); <span class="comment">// 计算出过期时间点</span></span><br><span class="line">    ...</span><br><span class="line">    GetCanReleaseObjects(m_CachedCanReleaseObjects);</span><br><span class="line">    List&lt;T&gt; toReleaseObjects = releaseObjectFilterCallback(m_CachedCanReleaseObjects, toReleaseCount, expireTime);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">foreach</span> (T toReleaseObject <span class="keyword">in</span> toReleaseObjects)</span><br><span class="line">    &#123;</span><br><span class="line">        ReleaseObject(toReleaseObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① <code>GetCanReleaseObjects(m_CachedCanReleaseObjects);</code> 方法：遍历m_ObjectMap的Value值，非使用中状态、非锁定状态、以及自定义释放标记为True时被认为是可释放对象。将所有可释放对象传入m_CachedCanReleaseObjects。</p><p>② <code>releaseObjectFilterCallback(m_CachedCanReleaseObjects, toReleaseCount, expireTime)</code> 委托方法：这个方法负责从可释放对象序列中进一步选出符合要求的对象，之后再进行释放。默认有DefaultReleaseObjectFilterCallback方法，也可以自己传入委托。</p><p>③ ReleaseObject 方法：会把从对应的<code>Object&lt;T&gt;</code>对象从m_Objects和m_ObjectMap中移除。</p><h2 id="对象池管理"><a href="#对象池管理" class="headerlink" title="对象池管理"></a>对象池管理</h2><h3 id="ObjectPoolManager"><a href="#ObjectPoolManager" class="headerlink" title="ObjectPoolManager"></a>ObjectPoolManager</h3><p>在内部使用字典保存所有对象池 ObjectPool&lt; T &gt;。</p><p>CreateSingleSpawnObjectPool方法 和 CreateMultiSpawnObjectPool方法 创建对象池，分别对应一个对象同时只能被获取一次的对象，以及一个对象能被同时获取多次两种类型的对象池。正常对象是必须用Single模式的，只有一些资源部分可以用Multi。</p><p>这一层在</p><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>需要一个逻辑物体<strong>ObjectBase</strong>，以及继承Mono的表现物体<strong>GameFrameworkComponent</strong>。</p><p>官方Demo的示例：</p><p><strong>HPBarItemObject</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HPBarItemObject</span> : <span class="title">ObjectBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HPBarItemObject <span class="title">Create</span>(<span class="params"><span class="built_in">object</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HPBarItemObject hpBarItemObject = ReferencePool.Acquire&lt;HPBarItemObject&gt;();</span><br><span class="line">        hpBarItemObject.Initialize(target);</span><br><span class="line">        <span class="keyword">return</span> hpBarItemObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"><span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 销毁血条的GameObject</span></span><br><span class="line">        HPBarItem hpBarItem = (HPBarItem)Target;</span><br><span class="line">        Object.Destroy(hpBarItem.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HPBarComponent</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HPBarComponent</span> : <span class="title">GameFrameworkComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> HPBarItem m_HPBarItemTemplate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Transform m_HPBarInstanceRoot = <span class="literal">null</span>; <span class="comment">// 设置生成物体的Root</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_InstancePoolCapacity = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IObjectPool&lt;HPBarItemObject&gt; m_HPBarItemObjectPool = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HPBarItem&gt; m_ActiveHPBarItems = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Canvas m_CachedCanvas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_HPBarInstanceRoot == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Error(<span class="string">&quot;You must set HP bar instance root first.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_CachedCanvas = m_HPBarInstanceRoot.GetComponent&lt;Canvas&gt;();</span><br><span class="line">        <span class="comment">// 传入对象池名字、对象池容量作为参数，并持有这个对象池的接口引用</span></span><br><span class="line">        m_HPBarItemObjectPool = GameEntry.ObjectPool.CreateSingleSpawnObjectPool&lt;HPBarItemObject&gt;(<span class="string">&quot;HPBarItem&quot;</span>, m_InstancePoolCapacity);</span><br><span class="line">        m_ActiveHPBarItems = <span class="keyword">new</span> List&lt;HPBarItem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HideHPBar</span>(<span class="params">HPBarItem hpBarItem</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不再需要该对象时</span></span><br><span class="line">        hpBarItem.Reset();</span><br><span class="line">        m_ActiveHPBarItems.Remove(hpBarItem);</span><br><span class="line">        m_HPBarItemObjectPool.Unspawn(hpBarItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HPBarItem <span class="title">CreateHPBarItem</span>(<span class="params">Entity entity</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HPBarItem hpBarItem = <span class="literal">null</span>;</span><br><span class="line">        HPBarItemObject hpBarItemObject = m_HPBarItemObjectPool.Spawn();</span><br><span class="line">        <span class="keyword">if</span> (hpBarItemObject != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果对象池里有空闲对象,就直接返回</span></span><br><span class="line">            hpBarItem = (HPBarItem)hpBarItemObject.Target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果对象池里无空闲对象,就自己在外部建好物体,然后由此创建为ObjectBase,最后丢到池里注册</span></span><br><span class="line">            hpBarItem = Instantiate(m_HPBarItemTemplate);</span><br><span class="line">            Transform transform = hpBarItem.GetComponent&lt;Transform&gt;();</span><br><span class="line">            transform.SetParent(m_HPBarInstanceRoot);</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">            m_HPBarItemObjectPool.Register(HPBarItemObject.Create(hpBarItem), <span class="literal">true</span>); <span class="comment">// true:注册时就立马使用; false:注册时不立马使用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hpBarItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inspector面板监视-1"><a href="#Inspector面板监视-1" class="headerlink" title="Inspector面板监视"></a>Inspector面板监视</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220128142351.png"></p><h2 id="引用池与对象池的区别"><a href="#引用池与对象池的区别" class="headerlink" title="引用池与对象池的区别"></a>引用池与对象池的区别</h2><ol><li>  引用池从池子内部通过默认构造方法创建对象，只适合普通的C#对象。对象池是在外部自行创建对象后再注册进去，能用于必须通过Unity API才能实例化的对象。</li><li>  引用池仅提供Clear接口来清除对象状态，在移除对象时没有任何额外处理，仅仅是去掉引用，适用于受GC管理的类型。而对象池提供OnSpawn，OnUnspawn两个操作，且在移除对象时，提供Release接口，对于Unity中的GameObject需要在Release写上Destroy(gameObject)的逻辑才能销毁。</li><li>  对象池提供自行释放的机制，可指定每个池子自动释放周期、物体过期时长、池子容量，并在可一定程度上自定义每个池子的释放策略。引用池没有以上机制，仅可通过Remove接口主动移除对象。</li><li>  对象池提供锁定物体、自定义释放标记功能，可进一步定制释放策略。</li></ol><h2 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h2><p><strong>同一个对象池中，为什么还要以Name区分对象集合？</strong></p><p>在同一个prefab上挂上相同的脚本，最后以他们的资源路径名字作为Name，则可在一个对象池中对不同外形的陨石进行区分，以实现向一个对象池取不同外型的陨石的需求。</p><blockquote><p>  官方Demo StarForce中的陨石对象池，虽然他们都是同一个类型，具有相同的逻辑，但他们可能有不一样的外型。我们把外型不同的陨石做成单独prefab，并在这些prefab上挂上相同的脚本，最后以他们的资源路径名字作为Name，则可在一个对象池中对不同外形的陨石进行区分，以实现向一个对象池取不同外型的陨石的需求。</p></blockquote><p><strong>在同一个对象池中以Name区分对象，与用多个对象池储存不同Name的对象有什么区别？</strong></p><p>让开发者能更好地规划释放策略。</p><blockquote><p>  主要区别就在于一个对象池执行同一个释放逻辑，而多个对象池是各自执行各自的释放逻辑。继续以上面的陨石为例子，我们一共有3种陨石，我希望储存陨石的对象池总容量是60，我们随机去生成不同种类的陨石，如果随机结果不均匀，最终池子里可能有种类一40个，种类二15个，种类三5个，在我们把他们放在同一对象池下管理情况下，这没有什么问题，无论怎样它都很好地以总数量为60个的策略去管理。但如果我们把不同外形的陨石分到不同的对象池去管理，我们很难去动态调整3个池子的容量平衡，以达到总数量为60的策略。</p></blockquote><p><strong>为什么既有引用池又有对象池，全部用对象池不是就可以满足需求了吗？</strong></p><p>对象池太繁琐，引用池使用更轻便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考写在前面！！！&lt;/p&gt;
&lt;p&gt;本文是在腾讯大佬&lt;a href=&quot;https://www.drflower.top/&quot;&gt;花桑&lt;/a&gt;和大佬&lt;a href=&quot;http://www.maodaodao.top/&quot;&gt;猫刀刀&lt;/a&gt;的GF解析文章的基础上，阅读源码并尝试总结、应用</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="GameFramework框架" scheme="https://codingcodingk.github.io/categories/Unity/GameFramework%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 小概念篇</title>
    <link href="https://codingcodingk.github.io/2022/01/22/Tech/CSharp/Essence/tips/"/>
    <id>https://codingcodingk.github.io/2022/01/22/Tech/CSharp/Essence/tips/</id>
    <published>2022-01-22T07:20:06.119Z</published>
    <updated>2022-01-22T07:20:06.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。但该变量提供的值并非变量创建时的值，而是<strong>在外部新建一个对象再把对象的引用传给内层函数</strong>。</p><h2 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h2><p>比如在winform想实现：当用户关闭窗体时，给用户一个提示框。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">string</span> tipWords = <span class="string">&quot;您将关闭当前对话框&quot;</span>;</span><br><span class="line">       <span class="keyword">this</span>.FormClosing += <span class="built_in">delegate</span></span><br><span class="line">       &#123;</span><br><span class="line">            MessageBox.Show(tipWords);</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h2><p>因为内层函数取得的外层函数是其“在父函数范围内（看闭包实现可以知道这不准确）”的最终值，所以遇到需要变动的值（比如循环变量）很容易写错代码。</p><p>比如说你想输出1-100的数字：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     Console.WriteLine(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 100 100 ...</span></span><br></pre></td></tr></table></figure><p>你会发现和你想做的事，根本不一样，这就是闭包陷阱！正确的做法是<strong>使用临时变量保存</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">        Console.WriteLine(j);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然还是利用了闭包特性，但是临时变量j的最终值是1-100的100个数字！</p><h2 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h2><p>通过反编译再精简代码，看看C#编译器帮我们做了什么。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TempClass tempClass = <span class="keyword">new</span> TempClass();</span><br><span class="line">    tempClass.i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tempClass.i &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Run(<span class="keyword">new</span> Action(tempClass.tempMethod));</span><br><span class="line">        tempClass.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TempClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">tempMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来只是帮我们新建了一个类，然后在循环内部大家<strong>共用一个对象</strong>！</p><p>但是只是共用一个对象，为什么输出全是100？线程输出的时候，又不一定是100啊。确实是这样，当我将循环次数改到10000（或者在循环中加入Delay）的时候，发现结果不一样了，输出了好多10000以外的数字。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     Console.WriteLine(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 7086 8755 8787 7366 9888 ... 10000 10000 10000 10000 10000 ...</span></span><br></pre></td></tr></table></figure><p>所以只是循环的太快了而已！确实跟反编译的结果一致，是<strong>共用一个对象，而不是父函数范围内的最终值</strong>。</p><p>最后再来看一下加了临时变量后的反编译结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TempClass tempClass = <span class="keyword">new</span> TempClass();</span><br><span class="line">        tempClass.j = i;</span><br><span class="line">        Task.Run(<span class="keyword">new</span> Action(tempClass.tempMethod));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TempClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">tempMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，优化的跟前面结构完全不一样了，使用临时变量后，现在是大家<strong>不共用一个对象</strong>了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h1&gt;&lt;h2 id=&quot;闭包的概念&quot;&gt;&lt;a href=&quot;#闭包的概念&quot; class=&quot;headerlink&quot; title=&quot;闭包的概念&quot;&gt;&lt;/a&gt;闭包的概</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 值类篇</title>
    <link href="https://codingcodingk.github.io/2022/01/22/Tech/CSharp/Essence/structAndObject/"/>
    <id>https://codingcodingk.github.io/2022/01/22/Tech/CSharp/Essence/structAndObject/</id>
    <published>2022-01-22T07:20:06.118Z</published>
    <updated>2022-02-01T02:52:39.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单讲下String"><a href="#简单讲下String" class="headerlink" title="简单讲下String"></a>简单讲下String</h1><h2 id="String是什么类型？"><a href="#String是什么类型？" class="headerlink" title="String是什么类型？"></a>String是什么类型？</h2><p>是个特殊的引用类型。</p><h2 id="怎么个特殊法呢？"><a href="#怎么个特殊法呢？" class="headerlink" title="怎么个特殊法呢？"></a>怎么个特殊法呢？</h2><p>String类型对象直接派生自Object，所以String是引用类型，它在堆上分配内存。</p><p>但是String类型却又有值类型的特性，具体来说它用的时候像值类型一样，也就是不变性，两个变量赋一样的String类型，修改其中一个并不会让另一个变量跟着变。</p><h2 id="聊聊不变性"><a href="#聊聊不变性" class="headerlink" title="聊聊不变性"></a>聊聊不变性</h2><p>不变性简单来说就是String对象一旦创建，就不能再更改，包括不能变长、变短或修改其中任何字符。</p><p>所以上面我提到的“修改其中一个变量”，实际上做的事是创建了一个新的String对象并让变量指向这个新对象。</p><p>不变性的好处：</p><ol><li>  项目里用ToUpper、Substring之类的获取新字符串，不会影响到原对象。</li><li>  因为不可变，所以不会有线程同步问题</li></ol><p>不变性的坏处：</p><ol><li>  项目里拼接的时候，比如我想用+操作符拼接字符串，过程中每一步都会生成一个新字符串。这样就增加了额外开销，影响GC。</li></ol><p>想避免坏处可以使用StringBuilder类。不过呢，CLR有对string有着留用机制、字符串池这两项优化手段，所以一般来说问题不算大。</p><h2 id="CLR字符串留用"><a href="#CLR字符串留用" class="headerlink" title="CLR字符串留用"></a>CLR字符串留用</h2><p>比如你对两个变量都赋值一个字符串字面值，那么它们指向的都是堆上的同一个对象。这是CLR帮你优化的。</p><p>CLR初始化时，会在内部创建一个哈希表，这个表中，key是字符串，value则是托管堆中String对象的引用。然后编译时，CLR默认会对程序集的元数据中描述的所有字面值字符串进行留用，也就是让他们指向同一个对象。但是这并不可靠，有CompilationRelaxationsArrtibute和NoStringInterning两个特性会让CLR不留用，而且运算时确定的string值也是不会被留用的。</p><p>只有显示调用<code>Intern</code>方法（获取参数String对象的哈希码，并在内部哈希表中检查是否有相匹配，没有就创建再返回引用）才能确定可靠的被留用。</p><h2 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h2><p>是和元数据量有关的。编译源代码时，编译器必须处理每个字面值字符串，并在托管模块的元数据中嵌入。为了让元数据小点，对于相同的字面值，在元数据中第一次会写入，后面只会引用元数据的同一个字符串。</p><h2 id="使用StringBuilder避免坏处"><a href="#使用StringBuilder避免坏处" class="headerlink" title="使用StringBuilder避免坏处"></a>使用StringBuilder避免坏处</h2><p>由于String类型是不可变的，FCL推出StringBuilder类对应可变字符串的需求。</p><p>StringBuilder 对象包含一个字段，该字段引用了由Char结构构成的数组（字符数组）。StringBuilder提供很多方法来操作这个字符数组。<strong>正是这样避免了不可变性带来的坏处，每次操作不会像String一样新建对象。</strong></p><p>它还会动态扩容。如果字符串变大，超过了事先分配的字符数组大小，StringBuilder会新建一个StringBuilder对象并对构造器传入自己，再将其作为前结点，然后将自己维护的char数组重新赋值为需要额外分配的chunk大小（new char[]）。<strong>所以StringBuilder其实是一个单链表。</strong></p><p>最后调用ToString方法把他转换为String型，就能正常使用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单讲下String&quot;&gt;&lt;a href=&quot;#简单讲下String&quot; class=&quot;headerlink&quot; title=&quot;简单讲下String&quot;&gt;&lt;/a&gt;简单讲下String&lt;/h1&gt;&lt;h2 id=&quot;String是什么类型？&quot;&gt;&lt;a href=&quot;#String是什么</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CLR Via C#个人笔记7 - 线程处理</title>
    <link href="https://codingcodingk.github.io/2022/01/14/Tech/CSharp/CLR-Via-CSharp/cp7/"/>
    <id>https://codingcodingk.github.io/2022/01/14/Tech/CSharp/CLR-Via-CSharp/cp7/</id>
    <published>2022-01-14T12:18:29.003Z</published>
    <updated>2022-02-08T09:19:14.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大章26：线程基础"><a href="#大章26：线程基础" class="headerlink" title="大章26：线程基础"></a><center>大章26：线程基础</center></h1><h2 id="Widnows的线程概念"><a href="#Widnows的线程概念" class="headerlink" title="Widnows的线程概念"></a>Widnows的线程概念</h2><p>在<strong>没有线程概念</strong>的时候，机器都是“单线程”运行的，长时间运行的任务会阻止其他任务执行（16位windows下打印文档很容易“冻结”整个机器导致各种程序出错）。</p><p>所以微软设计新的OS内核来改进这些问题，该内核决定在进程中运行应用程序的每个实例。<strong>进程</strong>实际是应用程序的实例要使用的资源的集合，每个进程都被赋予了一个虚拟地址空间来避免被其它进程访问。</p><p>但是光这样还不够，如果机器只有一个CPU，应用程序死循环仍然会导致其他程序无法运行。<strong>线程</strong>就是微软交出的解决方案，它是一个Windows概念，它的职责是对CPU进行虚拟化，为每个进程都提供该进程专用的线程（功能相当于原来的一个物理CPU）。所以单物理CPU机器，一个进程死循环，不影响其他进程。</p><h2 id="线程开销⭐"><a href="#线程开销⭐" class="headerlink" title="线程开销⭐"></a>线程开销⭐</h2><p>和一切虚拟化机制一样，线程有空间（内存耗用）和时间（运行时的执行性能）上的开销。</p><p>下面对每个线程都有的开销一一介绍。</p><h3 id="①线程内核对象-thread-kernel-object"><a href="#①线程内核对象-thread-kernel-object" class="headerlink" title="①线程内核对象 (thread kernel object)"></a>①线程内核对象 (thread kernel object)</h3><p>这是OS为系统中创建的每个线程都分配并初始化的数据结构之一。</p><p>对象中包括对线程进行描述的属性、**线程上下文(thread context)**：线程上下文是包含CPU寄存器集合的内存块，x64使用约1240字节的内存。上下文是线程上一次执行完毕后，CPU寄存器的状态。</p><h3 id="②线程环境块-thread-environment-block-TEB"><a href="#②线程环境块-thread-environment-block-TEB" class="headerlink" title="②线程环境块 (thread environment block,TEB)"></a>②线程环境块 (thread environment block,TEB)</h3><p>TEB耗用一个内存页（x64中4KB），</p><p>里面有**异常处理链首(head)**：线程每进入一个try块，都会在链首(head)中插入一个节点(node)，退出try块时删除该节点。</p><p>此外，TEB中还有<strong>GDI(图形设备接口)和OpenGL</strong>用的一些数据。</p><h3 id="③用户模式栈-user-mode-stack"><a href="#③用户模式栈-user-mode-stack" class="headerlink" title="③用户模式栈 (user- mode stack)"></a>③用户模式栈 (user- mode stack)</h3><p>堆栈概念中的栈说的就是这个了，默认分配1MB内存（其实windows是保留1MB容量，等用了才调拨给你）。</p><p>用户模式栈存储传给方法的<strong>局部变量和实参</strong>。还包含一个<strong>返回地址</strong>：指出当前方法返回时线程该从什么地方执行。</p><h3 id="④内核模式栈-kernel-mode-stack"><a href="#④内核模式栈-kernel-mode-stack" class="headerlink" title="④内核模式栈 (kernel- mode stack)"></a>④内核模式栈 (kernel- mode stack)</h3><p>分配x86是12KB，x64是24KB。</p><p>应用程序代码向OS中的内核模式函数传递实参时，会复制 用户模式栈 传去的实参并加以验证并不允许修改。最后OS内核代码开始处理复制的值。</p><p><strong>应用程序代码发起内核模式函数调用 -&gt; 用户模式栈 -&gt; 内核模式栈 -&gt; 内核模式函数</strong></p><h3 id="⑤DLL线程连接-attach-和线程分离-detach-通知"><a href="#⑤DLL线程连接-attach-和线程分离-detach-通知" class="headerlink" title="⑤DLL线程连接 (attach)和线程分离 (detach)通知"></a>⑤DLL线程连接 (attach)和线程分离 (detach)通知</h3><p>一个Windows机制：在进程中创建线程时，都会调用进程中加载的所有非托管DLL的 DllMain方法并向该方法传递 <strong>DLL_THREAD_ATTACH</strong>标志；终止线程时，同样调用 DllMain方法并向该方法传递 <strong>DLL_THREAD_DETACH</strong>标志。</p><p>有的DLL需要这些通知才能为进程中 创建/销毁 的每个线程执行特殊的 初始化/资源清理 ，比如C-Runtime库DLL。</p><h3 id="上下文调度"><a href="#上下文调度" class="headerlink" title="上下文调度"></a>上下文调度</h3><p>首先搞清楚一点，下面讨论的都是<strong>单物理CPU（或者单核CPU）且线程数&gt;CPU数</strong>的情况！！！想看Windows的调度，去看“线程调度和优先级”节。</p><p>Windows任何时刻都只将一个线程分配给一个CPU(或CPU核，下面称CPU)。</p><p>CPU会为线程执行一个<strong>时间片 (quantum)<strong>的时长，大概30ms吧，等时间片到期了，就会进行</strong>上下文调度</strong>切换执行另一个线程。<strong>上下文</strong>是线程上一次执行完毕后，CPU寄存器的状态。</p><p>上下文调度具体流程：</p><ol><li>  将CPU寄存器的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。</li><li>从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有， Windows在<br>  开始执行任何代码或者接触任何数据之前，还必须切换CPU“看见”的虚拟地址空间。</li><li>  将所选上下文结构中的值加载到CPU的寄存器中。</li></ol><p>上下文调度之后线程切换完成，CPU就会执行所选的线程，直到下一个时间片过了又要切换。</p><p>毫无疑问，这个机制是一个非常大的开销，特别是数据不在cache中的时候访问会很慢导致还没做点啥就切换别的线程了。</p><p>上下文切换是<strong>净开销</strong>，也就是说它所产生的开销不会换来任何内存或性能上的收益，只是为了能够提供一个健壮的、响应灵敏的操作系统。比如，一个应用程序的线程进入死循环， Windows会定期抢占( preempt)它，将新线程分配给CPU从而使新线程有机会运行。假如新线程是任务管理器线程，就能终止包含了死循环线程的进程。</p><h4 id="多核情况"><a href="#多核情况" class="headerlink" title="多核情况"></a>多核情况</h4><p>理解了上面说的机制，再来理解多核心CPU的情况：</p><p>安装了多个CPU（或者一个多核CPU）的计算机可以真正同时运行几个线程，Windows为每个CPU内核都分配一个线程，每个内核都自己执行到其他线程的上下文切换，<strong>且Windows确保单个线程不会同时在多个内核上调度</strong>。</p><h2 id="停止疯狂"><a href="#停止疯狂" class="headerlink" title="停止疯狂"></a>停止疯狂</h2><p>知道了上下文调度机制，不难得出：<strong>如果只关心性能，线程数和CPU核心数一致才是最好的。</strong>如果线程数超过了CPU的数目，就会产生上下文切换和性能损失。如果每个CPU只有一个线程，就不会有上下文切换，线程将全速运行。</p><p>但是仍然选择这么做，是因为能让Windows整体更不容易崩溃、提高响应能力。</p><p>那么标题为什么要叫停止疯狂呢？</p><p>因为打开我的任务管理器一看，发现一台4核的cpu跑了300多个进程4000个线程，光给线程就分配掉了4GB的内存，离大谱！而大部分线程压根没被调用就是挂着，是一种极大的浪费。</p><h3 id="CPU发展趋势"><a href="#CPU发展趋势" class="headerlink" title="CPU发展趋势"></a>CPU发展趋势</h3><p>了解即可，讲讲硬件有个概念。</p><p>CPU厂商过去只知道一味地提高CPU速度。但CPU厂商没有延续这个趋势，因为高速运行的CPU会产生大量热量。</p><p>所以发展方向变成了实现多线程，物理上有这么些手段：</p><ul><li>  多个CPU，不适合普通用户。</li><li>  超线程芯片，硬件上实现多线程。通过分支预测错误和缓存未命中和等待数据的优化，来不停切换线程，实现1个线程能当2个用。WindowsOS层面并不知道硬件CPU其实是超线程的，他只知道有2个线程在并发执行。</li><li>  多核芯片，适合普通用户。</li></ul><h2 id="CLR线程和-Windows线程"><a href="#CLR线程和-Windows线程" class="headerlink" title="CLR线程和 Windows线程"></a>CLR线程和 Windows线程</h2><p>CLR使用 Windows的线程处理功能。</p><h2 id="使用专用线程"><a href="#使用专用线程" class="headerlink" title="使用专用线程"></a>使用专用线程</h2><h3 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h3><p>创建线程来执行异步的计算限制(compute- bound)操作，不过这门技术并不推荐，<strong>推荐使用线程池来执行异步</strong>。</p><p>但还是说回来，不用线程池而是显式创建线程来专门执行一个计算限制的操作的情况，一般是线程池方式做不到的事，比如以下几种：</p><ul><li>  线程需要以非普通线程优先级运行。（所有线程池线程都以普通优先级运行）</li><li>  需要线程表现为一个前台线程，防止应用程序在线程结束任务前终止。</li><li>  计算限制的任务需要长时间运行。（线程池为了判断是否需要创建一个额外的线程）</li><li>  要启动线程，并可能调用 Thread的 Abort方法来提前终止它。</li></ul><h3 id="创建专用线程，并执行异步的计算限制操作"><a href="#创建专用线程，并执行异步的计算限制操作" class="headerlink" title="创建专用线程，并执行异步的计算限制操作"></a>创建专用线程，并执行异步的计算限制操作</h3><p>为了创建专用线程，要构造 System.Threading.Thread类的实例，向构造器传递一个方法<br>名。以下是 Thread的构造器的原型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Thread</span> : <span class="title">CriticalFinalizerObject</span>, ... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span>(<span class="params">ParameterizedThreadStart start</span>)</span>;</span><br><span class="line">    <span class="comment">// 未列出不常用的构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start参数表示<strong>专用线程要执行的方法</strong>，这个方法必须和 ParameterizedThreadStart委托的签名匹配：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">ParameterizedThreadStart</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;</span><br></pre></td></tr></table></figure><p>光创建线程还不算完，并不会真的创建一个操作系统线程。要实际创建一个操作系统线程，并让它开始执行回调方法，必须调用 <strong>Thread的Start方法</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="comment">// Main thread: starting a dedicated thread (专用线程)</span></span><br><span class="line">    Thread dedicatedThread = <span class="keyword">new</span> Thread(ComputeBoundOp);</span><br><span class="line">    dedicatedThread.Start(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>); <span class="comment">// 模拟做其他工作(10秒)</span></span><br><span class="line">    dedicatedThread.Join();<span class="comment">// 等待线程终止。Join：在此实例表示的线程终止前，阻止调用线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法的签名必须和 ParameterizedThreadStart委托匹配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ComputeBoundOp</span> (<span class="params"><span class="built_in">object</span> state</span>)</span> &#123;</span><br><span class="line">    WriteLine(state);</span><br><span class="line">    Thread. Sleep(<span class="number">1000</span>); <span class="comment">// 模拟做其他任务(1秒)</span></span><br><span class="line">    <span class="comment">// 这个方法返回后，专用线程将终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 5</span></span><br></pre></td></tr></table></figure><h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><h4 id="画面响应（通常是对于客户端GUI应用程序）"><a href="#画面响应（通常是对于客户端GUI应用程序）" class="headerlink" title="画面响应（通常是对于客户端GUI应用程序）"></a>画面响应（通常是对于客户端GUI应用程序）</h4><p>Windows为每个进程提供它自己的线程，确保发生死循环的应用程序不会妨碍其他应用程序。类似的，在客户端GUI应用程序中，可以将一些工作交给一个线程进行，使GUI线程能灵敏地响应用户输入。</p><h4 id="性能（对于客户端和服务器应用程序）"><a href="#性能（对于客户端和服务器应用程序）" class="headerlink" title="性能（对于客户端和服务器应用程序）"></a>性能（对于客户端和服务器应用程序）</h4><p>由于Windows每个CPU调度一个线程，而且多个（核）CPU能并发执行这些线程，所以能提升性能。</p><h2 id="线程调度和优先级⭐"><a href="#线程调度和优先级⭐" class="headerlink" title="线程调度和优先级⭐"></a>线程调度和优先级⭐</h2><h3 id="Windows的线程调度"><a href="#Windows的线程调度" class="headerlink" title="Windows的线程调度"></a>Windows的线程调度</h3><p>前面讲过单核CPU的上下文切换，属于是线程调度的最初级理论，下面由Windows的机制深入。</p><h4 id="重温一下上下文切换流程"><a href="#重温一下上下文切换流程" class="headerlink" title="重温一下上下文切换流程"></a>重温一下上下文切换流程</h4><p>**上下文(context)**结构反映了线程上一次执行完毕后CPU寄存器的状态。</p><p>在一个**时间片(time-slice)**之后，Windows检查现存的所有线程内核对象，在这些对象中只有那些没有正在等待什么的线程才合适调度。</p><h4 id="饥饿-starvation"><a href="#饥饿-starvation" class="headerlink" title="饥饿(starvation)"></a>饥饿(starvation)</h4><p>而在这些线程中，系统调度CPU执行哪一个线程，是由线程自己的<strong>优先级</strong>决定的，有0<del>31(31最高)的优先级。只要存在可调度的优先级31的线程，系统就永远不会调度CPU给0</del>30的任何线程。高优先级的线程占用CPU太久，使低优先级线程无法运行，这种情况称为**饥饿(starvation)**。</p><p><strong>多处理器</strong>的机器很少出现饥饿情况，因为能同时并行执行很多线程。</p><h4 id="抢占式操作系统"><a href="#抢占式操作系统" class="headerlink" title="抢占式操作系统"></a>抢占式操作系统</h4><p>Windows是<strong>抢占式多线程(preemptive multithreaded)操作系统</strong>，线程可在任何时间停止（被抢占）并调度另一个线程。</p><p>Windows是<strong>抢占式</strong>，低优先级的线程哪怕时间片没用完，也会被立刻挂起执行优先级更高的线程。</p><h4 id="零页线程-zero-page-thread"><a href="#零页线程-zero-page-thread" class="headerlink" title="零页线程(zero page thread)"></a>零页线程(zero page thread)</h4><p>系统启动时会创建一个特殊的<strong>零页线程</strong>，优先级为0，在没有其他线程需要“干活儿”的时候，零页线程将系统RAM的所有空闲页清零。Windows不允许其他线程的优先级为0。</p><h3 id="线程优先级and进程优先级"><a href="#线程优先级and进程优先级" class="headerlink" title="线程优先级and进程优先级"></a>线程优先级and进程优先级</h3><p>前面讲过了优先级是0~31，现在看一下自己写的程序可控制的优先级映射。</p><p>进程可通过**优先级类(priority class)**来控制优先级，一共6种；线程7种。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112120814.png"></p><p>注意，表中没有值为0的线程优先级。这是因为0优先级保留给零页线程了，系统不允许其他线程的优先级为0。而且，以下优先级也不可获得：17,18,19,20,21,27,28,29或者30。以内核模式运行的设备驱动程序才能获得这些优先级。</p><p>我们可以通过System.Diagnostics的<strong>Process类和ProcessThread类</strong>获取进程线程的windows视图。也可以通过<strong>AppDomain和Thread类</strong>获取线程的CLR视图。</p><h2 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h2><p>CLR将每个线程要么视为前台线程，要么视为后台线程。一个进程的所有<strong>前台线程</strong>停止运行时，CLR强制终止仍在运行的任何<strong>后台线程</strong>。这些后台线程被直接终止；不抛出异常。</p><p>每个AppDomain都可运行一个单独的应用程序，而每个应用程序都有自己的前台线程。如果应用程序退出，造成它的前台线程终止，则CLR仍需保持活动并运行，使其他应用程序能继续运行。所有应用程序都退出，它们的所有前台线程都终止后，整个进程就可以被销毁了。</p><p>用<strong>Thread类</strong>新建线程默认是前台线程，<strong>线程池</strong>线程默认是后台线程。当然，可以通过<strong>Thread.Isbackground属性</strong>随时修改线程是前台还是后台。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>一般我们拿前台线程做画面，后台线程IO，这样用户关闭了程序界面 =&gt; 前台线程关闭 =&gt; 后台IO线程自动被关闭 =&gt; IO不执行下去（比如写入数据到Excel），是合理的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新线程（默认为前台线程）</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(Worker);</span><br><span class="line">    <span class="comment">// 使线程成为后台线程</span></span><br><span class="line">    t.IsBackground = <span class="literal">true</span>;</span><br><span class="line">    t.Start();<span class="comment">// 启动线程</span></span><br><span class="line">    <span class="comment">// ⭐如果t是前台线程，则应用程序大约10秒后才终止</span></span><br><span class="line">    <span class="comment">// ⭐如果t是后台线程，则应用程序立即终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Thread. sleep(<span class="number">10000</span>);<span class="comment">// 模拟做10秒钟的工作</span></span><br><span class="line">    <span class="comment">// 下面这行代码只有在由一个前台线程执行时才会显示</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Returning from Worker&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大章27：计算限制的异步操作"><a href="#大章27：计算限制的异步操作" class="headerlink" title="大章27：计算限制的异步操作"></a><center>大章27：计算限制的异步操作</center></h1><h2 id="CLR线程池基础"><a href="#CLR线程池基础" class="headerlink" title="CLR线程池基础"></a>CLR线程池基础</h2><p>一个CLR拥有一个**线程池(thread pool)**。如果一个CLR下有多个AppDomain，那么它们共享一个线程池；如果一个进程中加载了多个CLR，那么每个CLR都有自己的线程池。</p><h3 id="向线程池请求流程⭐"><a href="#向线程池请求流程⭐" class="headerlink" title="向线程池请求流程⭐"></a>向线程池请求流程⭐</h3><p>CLR初始化时，线程池中是没有线程的。在内部，线程池维护了一个<strong>操作请求队列</strong>。应用程序执行一个异步操作时，就会对线程池进行请求，具体是将一个<strong>记录项(entry)<strong>追加到队列中。线程池会从这个队列中提取记录项，将这个记录项</strong>派发(dispatch)<strong>给一个线程池的线程；如果线程池没有线程，就创建一个新线程。当这个线程完成任务后并</strong>不销毁，而是返回线程池、进入空闲状态</strong>。但是如果一个线程在线程池里闲太久了（应用程序很久不向线程池发出请求），为了避免资源浪费，CLR才会<strong>终止</strong>它。</p><h2 id="使用ThreadPool"><a href="#使用ThreadPool" class="headerlink" title="使用ThreadPool"></a>使用ThreadPool</h2><p>使用ThreadPool执行简单的计算限制操作。</p><p>调用<code>ThreadPool.QueueUserWorkItem(WaitCallback cb);</code>或<code>ThreadPool.QueueUserWorkItem(WaitCallback cb, object state);</code>。这两个方法向线程池的队列添加一个**工作项(work item)**以及可选的状态数据，然后方法立刻返回。</p><p>传递的回调方法必须满足<code>delegate void WaitCallback(Object state);</code>。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面演示一下如何让一个线程池线程以异步方式调用一个方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem(DoSth, <span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread start ,id:&quot;</span> + + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread end ,id:&quot;</span> + +Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;thread from ThreadPool is doing sth ,state:&quot;</span> + state + <span class="string">&quot; thread id: &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于是异步进行的，所以有时会输出</span></span><br><span class="line"><span class="comment">//main thread start ,id:1</span></span><br><span class="line"><span class="comment">//thread from ThreadPool is doing sth ,state:5 thread id: 3</span></span><br><span class="line"><span class="comment">//main thread end ,id:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时会输出</span></span><br><span class="line"><span class="comment">//thread from ThreadPool is doing sth ,state:5 thread id: 3</span></span><br><span class="line"><span class="comment">//main thread start ,id:1</span></span><br><span class="line"><span class="comment">//main thread end ,id:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是不难看出，执行任务的线程是从线程池拿的，不再是主线程</span></span><br></pre></td></tr></table></figure><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>每个线程都关联了一个**执行上下文(execution context)**数据结构。它包含了安全设置(压缩栈、 Thread的 Principal属性和 Windows身份)、宿主设置、逻辑调用上下文数据。</p><p>每当一个**线程(初始线程)<strong>使用另一个</strong>线程(辅助线程，也就是线程使用的线程)<strong>执行任务时，为了确保两者的操作使用相同的安全设置和宿主设置，前者的上下文应</strong>流向 flow(复制到)**辅助线程。复制，这要耗费不少时间。</p><h3 id="阻断上下文的流向-flow"><a href="#阻断上下文的流向-flow" class="headerlink" title="阻断上下文的流向(flow)"></a>阻断上下文的流向(flow)</h3><p>可以使用<code>System.Threading.ExecutionContext</code>类来控制线程的执行上下文流到另一个线程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ExecutionContext</span> : <span class="title">IDisposable</span>, <span class="title">ISerializable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncFlowControl <span class="title">SuppressFlow</span>(<span class="params"></span>)</span>; <span class="comment">// 取消执行上下文在异步线程之间的流动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RestoreFlow</span>(<span class="params"></span>)</span>; <span class="comment">// 恢复执行上下文在异步线程之间的流动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFlowSuppressed</span>(<span class="params"></span>)</span>; <span class="comment">// 指示当前是否取消了执行上下文的流动</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个类，你可以<strong>阻止执行上下文的流动</strong>。当初始线程的上下文不流向辅助线程，辅助线程会使用上一次和它关联的任意执行上下文。所以你想要阻止流动，就需要确保<strong>辅助线程不应执行任何要依赖于执行上下文状态</strong>，比如用用户的Windows身份。</p><p>一般只拿来优化服务端应用程序，这样做对客户端程序优化甚微。</p><h4 id="阻断例子"><a href="#阻断例子" class="headerlink" title="阻断例子"></a>阻断例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将一些数据放到Main线程的逻辑调用上下文中</span></span><br><span class="line">    CallContext.LogicalSetData(<span class="string">&quot;Name&quot;</span>,<span class="string">&quot;Jeffrey&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化要由一个线程池线程做的一些工作,</span></span><br><span class="line">    <span class="comment">// 线程池线程能访问逻辑调用上下文数据</span></span><br><span class="line">    ThreadPool.QueueUserWorkItem (state =&gt; Console.WriteLine(<span class="string">&quot;Before:&quot;</span> + CallContext.LogicalGetData(<span class="string">&quot;Name&quot;</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在，阻止Main线程的执行上下文的流动</span></span><br><span class="line">    ExecutionContext.SuppressFlow();</span><br><span class="line">    <span class="comment">// 然后，再做同样的事</span></span><br><span class="line">    ThreadPool.QueueUserWorkItem (state =&gt; Console.WriteLine(<span class="string">&quot;After:&quot;</span> + CallContext.LogicalGetData(<span class="string">&quot;Name&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Before:Jeffrey</span></span><br><span class="line"><span class="comment">// After:</span></span><br></pre></td></tr></table></figure><p>阻断后的输出After，为空。注意，无论是对于ThreadPool还是Task对象，都有效。</p><h2 id="线程池如何管理线程"><a href="#线程池如何管理线程" class="headerlink" title="线程池如何管理线程"></a>线程池如何管理线程</h2><h3 id="设置线程池限制"><a href="#设置线程池限制" class="headerlink" title="设置线程池限制"></a>设置线程池限制</h3><p>CLR允许开发人员设置线程池要创建的最大线程数。书中说默认大概1000。不推荐自己设置，但是可以使用ThreadPool类提供的几个静态方法：GetMaxThreads、SetMaxThreads、GetMinThreads、SetMinThreads、GetAvailableThreads 来获取或更改线程数信息。</p><h3 id="线程池调度机制"><a href="#线程池调度机制" class="headerlink" title="线程池调度机制"></a>线程池调度机制</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220114141818.png"></p><h4 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h4><p>当调用ThreadPool.QueueUserWorkItem、Timer类、Task时，任务会被添加进<strong>全局队列</strong>中，全局队列采用<strong>先进先出FIFO</strong>的方式，让工作者线程们自己去取任务。</p><p>全局队列使用<strong>线程同步锁</strong>，这是为了避免多个线程同时取到一个任务。</p><h4 id="本地队列"><a href="#本地队列" class="headerlink" title="本地队列"></a>本地队列</h4><p>在全局队列中领完的任务会放入工作者线程各自的<strong>本地队列</strong>，本地队列采用<strong>后入先出LIFO</strong>的方式来执行任务。</p><p>本地队列一般不锁，因为只有对应的工作者线程访问它。但是也有例外，看下面。</p><h4 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h4><p>下面从工作者线程的角度去理解整体调度流程。</p><p>如果工作者线程发现自己<strong>本地队列空</strong>了，就会尝试从另一个工作者线程的本地队列“偷”一个Task。这个Task在本地队列的队尾，并会要求获取一个线程同步锁。</p><p>如果<strong>所有本地队列都空</strong>了，工作者线程会使用FIFO算法从全局队列取出一个工作项并获得它的锁。</p><p>如果<strong>全局队列也为空</strong>，工作者线程会进入睡眠状态。</p><p>如果<strong>工作者线程睡眠时间很长</strong>，它会自己醒来并销毁自身，释放线程使用的资源（内核、栈等）。</p><h2 id="协作式取消和超时"><a href="#协作式取消和超时" class="headerlink" title="协作式取消和超时"></a>协作式取消和超时</h2><p>讲的是可以用一个辅助类，可以传递自己的一个bool字段作为参数给线程，也可以注册一些回调事件。当执行这个辅助类的<strong>Cancel方法</strong>时，会将bool字段设置成false并执行那些回调。从而实现操控线程停止事务。</p><p>无论是ThreadPool方法还是Task，都能使用这种方法。</p><h3 id="CancellationTokenSource"><a href="#CancellationTokenSource" class="headerlink" title="CancellationTokenSource"></a>CancellationTokenSource</h3><p>System.Threading.CancellationTokenSource就是上面说的辅助类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CancellationTokenSource</span>: <span class="title">IDisposable</span><span class="comment">// 一个引用类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CancellationTokenSource</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;<span class="comment">// 释放资源,比如WaitHandle</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean IsCancellationRequested &#123; <span class="keyword">get</span>; &#125;<span class="comment">// 执行Cancel后就会变成false</span></span><br><span class="line">    <span class="keyword">public</span> CancellationToken Token &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cancel</span>(<span class="params"></span>)</span>;<span class="comment">// 内部调用 Cancel并传递 false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cancel</span>(<span class="params">Boolean throwOnFirstException</span>)</span>;<span class="comment">// 如果true,回调执行一遇到抛错就立刻返回;如果false,直到全部回调执行结束才会抛出一个报错list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类通过<strong>Token</strong>方法可以获得一个或多个CancellationToken（一个值类型），可以对它<strong>注册回调</strong>，当Source.Cancel的时候会触发Token们的回调</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CancellationToken &#123; <span class="comment">// 一个值类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CancellationToken None &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean IsCancellationRequested &#123; <span class="keyword">get</span>; &#125; <span class="comment">// 由非通过Task调用的操作调用(ThreadPool)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThrowIfCancellationRequested</span>(<span class="params"></span>)</span>; <span class="comment">// 由通过Task调用的操作调用(Task)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CancellationTokenSource， WaitHandle会收到信号</span></span><br><span class="line">    <span class="keyword">public</span> Waithandle Waithandle &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">// Gethashcode, Equals, operator==和 operator!=成员未列出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean Canbecanceled &#123; <span class="keyword">get</span>; &#125;<span class="comment">// 很少使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CancellationTokenRegistration <span class="title">Register</span>(<span class="params">Action&lt;<span class="built_in">object</span>&gt; callback, Object state, Boolean useSynchronizationContext</span>)</span>;<span class="comment">// 未列出更简单的重载版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">CancellationToken token = cts.Token;</span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">token.Register(() =&gt; Console.WriteLine(<span class="string">&quot;Count is cancelled, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">ThreadPool.QueueUserWorkItem(_ =&gt; Count(token, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Press &lt;Enter&gt; to cancel Thread Works&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line">cts.Cancel();</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params">CancellationToken token, <span class="built_in">int</span> countTo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> count = <span class="number">0</span>; count &lt; countTo; count++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 当Source执行Cancel时，会变成false</span></span><br><span class="line"><span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;break, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Console.WriteLine(count);</span><br><span class="line">Thread.Sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Press &lt;Enter&gt; to cancel Thread Works</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Count is cancelled, thread 1</span></span><br><span class="line"><span class="comment">// break, thread 3</span></span><br></pre></td></tr></table></figure><p>可以考虑这么用<strong>IsCancellationRequested字段</strong>以及<strong>Token回调事件</strong>。</p><p>注意了，输出的线程号不一样：**回调事件是调用线程做的(就是主线程thread 1)**。</p><h2 id="使用任务-Task"><a href="#使用任务-Task" class="headerlink" title="使用任务(Task)"></a>使用任务(Task)</h2><p>使用<strong>ThreadPool</strong>的方法，很容易就能发起一次异步的计算限制操作。但是它不透明，你无法知道什么时候完成，也无法对其添加回调函数。所以我们通过<strong>System.Threading.Tasks</strong>中的类型来使用任务。</p><h3 id="Task与ThreadPool等价写法"><a href="#Task与ThreadPool等价写法" class="headerlink" title="Task与ThreadPool等价写法"></a>Task与ThreadPool等价写法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(DoSth, <span class="number">5</span>);<span class="comment">// 用线程池方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Task(DoSth, <span class="number">5</span>).Start();<span class="comment">// 用Task做相等的事</span></span><br><span class="line">Task.Run(() =&gt; Dosth(<span class="number">5</span>));<span class="comment">// 与上面等价</span></span><br></pre></td></tr></table></figure><p>注意！<strong>无论是ThreadPool还是Task.Run，他们都是从线程池取线程</strong>。</p><h3 id="等待任务"><a href="#等待任务" class="headerlink" title="等待任务"></a>等待任务</h3><p>使用<code>Task.Wait();</code>可以让线程等待返回结果，返回类型在创建线程<code>Task&lt;TResult&gt;</code>的时候指定，返回值通过<code>Task.Result</code>获取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">            Thread.Sleep(<span class="number">3000</span>); <span class="comment">// 模拟做其他工作(3秒)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    task.Start(); <span class="comment">// 此时才开始执行任务</span></span><br><span class="line">    </span><br><span class="line">    task.Wait(); <span class="comment">// 进行3秒的等待</span></span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(task.Result); <span class="comment">// Result属性内部会调用Wait !!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3秒后output: 100</span></span><br></pre></td></tr></table></figure><p>如果在Task中抛错，异常会被吞噬并存储到一个集合中，线程会回到线程池。等到再调用Wait或Result时，会抛出<strong>System.AggregateException对象</strong>，它就是那个存储异常的集合。</p><p>但是如果一直不调用Wait或Result，就抛不出错。你可以通过向TaskScheduler.UnobservedTaskException事件登记回调函数来使Task被GC时抛出其异常。</p><h4 id="Task-WaitAny"><a href="#Task-WaitAny" class="headerlink" title="Task.WaitAny"></a>Task.WaitAny</h4><p>WaitAny静态方法 会阻塞调用线程，直到数组中的任何Task对象完成。方法返回一个int索引值，指明完成的是数组中哪个Task对象。方法返回后，线程被唤醒并继续运行，如果发生超时返回-1。</p><h4 id="Task-WaitAll"><a href="#Task-WaitAll" class="headerlink" title="Task.WaitAll"></a>Task.WaitAll</h4><p>WaitAll静态方法 也会阻塞调用线程，直到数组中的所有Task对象完成。方法返回一个bool值，true代表完成，false代表超时。</p><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>前面使用CancellationTokenSource的IsCancellationRequested属性来取消ThreadPool事务，这边Task类似，不过用的是Source的<strong>ThrowIfCancellationRequested方法</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Dosth</span>(<span class="params">CancellationToken ct, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(; n &gt; <span class="number">0</span>; n--)&#123;</span><br><span class="line">        <span class="comment">// 调用该Source的Cancel方法后,会抛出OperationCanceledException,否则不会抛出。</span></span><br><span class="line">        ct.ThrowIfCancellationRequested();</span><br><span class="line">        </span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和正常Task抛错一样会被吞，直到你调用Wait或Result才会抛出来。</p><h3 id="延续任务"><a href="#延续任务" class="headerlink" title="延续任务"></a>延续任务</h3><p>任务完成时自动启动新任务，用<strong>ContinueWith方法</strong>。在任务结束后，会调用线程池的<strong>其他线程</strong>继续帮你完成任务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; t = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;thread id &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">Thread.Sleep(<span class="number">3000</span>); <span class="comment">// 模拟做其他工作(3秒)</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">Task cwt = t.ContinueWith(task =&gt; Console.WriteLine(task.Result + <span class="string">&quot;,thread id &quot;</span> + Thread.CurrentThread.ManagedThreadId)); <span class="comment">// 结束后调用线程池的其他线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// thread id 3</span></span><br><span class="line"><span class="comment">// 100,thread id 4</span></span><br></pre></td></tr></table></figure><p>具体看thread id，执行任务 和 执行延续任务 的线程不是同一个。</p><p>可以传递一个<strong>TaskContinuationOptions位标志</strong>枚举类给延续任务，默认是None，有一个可能用到的TaskContinuationOptions.OnlyOnRanToCompletion枚举值，传这个代表只有在第一个任务成功执行（无抛错无取消）的情况才会执行延续任务。</p><h3 id="任务启动子任务"><a href="#任务启动子任务" class="headerlink" title="任务启动子任务"></a>任务启动子任务</h3><p>套娃。直到所有子任务运行结束，父任务才认为自己结束。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    Task t = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;main task,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub1,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line"><span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub2,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line"><span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub3,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line">        <span class="comment">// 这回咱们不sleep了,就看看是不是用了回收的线程,结果确实用了!</span></span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// main,thread id:1</span></span><br><span class="line"><span class="comment">// main task,thread id:3</span></span><br><span class="line"><span class="comment">// sub1,thread id:4</span></span><br><span class="line"><span class="comment">// sub3,thread id:3</span></span><br><span class="line"><span class="comment">// sub2,thread id:4</span></span><br></pre></td></tr></table></figure><p>看输出，顺便测试了一下子线程会不会借助已经回收到线程池的父线程来完成任务，结果是<strong>肯定</strong>的！</p><h3 id="任务内部揭秘"><a href="#任务内部揭秘" class="headerlink" title="任务内部揭秘"></a>任务内部揭秘</h3><p>Task比起ThreadPool多了很多可控性，但是这不是无偿的，Task方式起线程会比ThreadPool方法至少多了：</p><ul><li>  Task唯一标识id，从1开始递增分配。只有查询时才分配，一经分配不会重复发放相同数字。</li><li>  执行状态id。通过Task.Status属性查询。</li><li>  父任务引用、回调方法引用、回调方法需要参数的引用</li><li>  一个CancellationToken、ContinueWithTask对象集合</li><li>  etc.</li></ul><h4 id="Task的生命周期"><a href="#Task的生命周期" class="headerlink" title="Task的生命周期"></a>Task的生命周期</h4><p>可通过<strong>Task.Status属性</strong>查询执行状态id。只展开聊这个，透过它能理解Task的生命周期。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> TaskStatus &#123;</span><br><span class="line">    <span class="comment">// -----------这里只贴出生命周期内的状态-----------</span></span><br><span class="line">    </span><br><span class="line">    Created, <span class="comment">// 任务已显式创建：可以手动 Start()这个任务</span></span><br><span class="line">    WaitingForActivation, <span class="comment">// 任务已隐式创建：会自动开始</span></span><br><span class="line">    </span><br><span class="line">    WaitingToRun, <span class="comment">// 任务已调度，但尚末运行</span></span><br><span class="line">    Running, <span class="comment">// 任务正在运行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务正在等待它的子任务完成，子任务完成后它才完成</span></span><br><span class="line">    WaitingForChildrenToComplete,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务的最终状态是以下3个之一</span></span><br><span class="line">    RanToCompletion,</span><br><span class="line">    Canceled,</span><br><span class="line">    Faulted,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面贴出微软文档的这个类，补全一下，看的话看上面的就行。</p><table><thead><tr><th>枚举</th><th>值</th><th>详细</th></tr></thead><tbody><tr><td>Canceled</td><td>6</td><td>该任务已通过对其自身的 CancellationToken 引发 OperationCanceledException 对取消进行了确认，此时该标记处于已发送信号状态；或者在该任务开始执行之前，已向该任务的 CancellationToken 发出了信号。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/task-cancellation">任务取消</a>。</td></tr><tr><td>Created</td><td>0</td><td>该任务已初始化，但尚未被计划。</td></tr><tr><td>Faulted</td><td>7</td><td>由于未处理异常的原因而完成的任务。</td></tr><tr><td>RanToCompletion</td><td>5</td><td>已成功完成执行的任务。</td></tr><tr><td>Running</td><td>3</td><td>该任务正在运行，但尚未完成。</td></tr><tr><td>WaitingForActivation</td><td>1</td><td>该任务正在等待 .NET 基础结构在内部将其激活并进行计划。</td></tr><tr><td>WaitingForChildrenToComplete</td><td>4</td><td>该任务已完成执行，正在隐式等待附加的子任务完成。</td></tr><tr><td>WaitingToRun</td><td>2</td><td>该任务已被计划执行，但尚未开始执行。</td></tr></tbody></table><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h3><p>就是<strong>TaskScheduler</strong>，它负责执行被调度的任务，同时向VS调试器公开任务信息。</p><p>官方提供2种TaskScheduler：</p><ul><li>  线程池任务调度器(thread pool task scheduler)</li><li>  同步上下文任务调度器(synchronization context task scheduler)</li></ul><p>默认情况，应用程序使用<strong>线程池任务调度器</strong>。它将任务调度给线程池的工作者线程。调用<code>TaskScheduler.Default</code>方法获取线程池任务调度器引用。</p><p>同步上下文任务调度器将借助画面线程！调用<code>TaskScheduler.FromCurrentSynchronizationContext</code>方法获取同步上下文任务调度器引用。</p><h4 id="同步上下文任务调度器"><a href="#同步上下文任务调度器" class="headerlink" title="同步上下文任务调度器"></a>同步上下文任务调度器</h4><p>同步上下文任务调度器适合提供了图形用户界面的应用程序，比如wpf。它将所有任务都调度给应用程序的GUI线程，使所有任务代码都能成功更新UI组件。</p><p><strong>该调度器不使用线程池，它调度的还是画面线程</strong>。如果用Default调度器的策略，线程池线程执行更新UI组件，会抛InvalidOperationException。</p><h4 id="用Task更新UI例子-♥wpf"><a href="#用Task更新UI例子-♥wpf" class="headerlink" title="用Task更新UI例子 ♥wpf"></a>用Task更新UI例子 ♥wpf</h4><p>wpf与unity一样，都是单ui线程的，其他线程没有办法调用它的api来修改ui。</p><p>所以下面可以看到，用上下文同步给Task从而实现更新UI，**实际上仍然是借调了主线程(ui线程)**，这个Task执行的时候你可以明显感觉到画面卡顿，因为画面线程在干活。</p><p>从来就没有什么魔法…</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> TaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        taskScheduler = TaskScheduler.FromCurrentSynchronizationContext();</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GUI thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t = Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;timing 1 thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.ContinueWith(o =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;timing 2 thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            myTextBox.Text = t.Result.ToString();</span><br><span class="line">        &#125;, taskScheduler); <span class="comment">// 注意!!! 如果这里不使用上下文同步的taskScheduler,会抛InvalidOperationException且更新UI失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// GUI thread id:1</span></span><br><span class="line"><span class="comment">// timing 1 thread id:3</span></span><br><span class="line"><span class="comment">// timing 2 thread id:1</span></span><br></pre></td></tr></table></figure><h4 id="其他自定义调度器"><a href="#其他自定义调度器" class="headerlink" title="其他自定义调度器"></a>其他自定义调度器</h4><p>![image-20220113173939283](E:\My Github\hexo\blog\source_posts\Tech\CSharp\CLR-Via-CSharp\cp7.assets\image-20220113173939283.png)</p><h2 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h2><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><p>静态 <strong>System.Threading.Tasks.Parallel 类</strong>，内部使用Task对象，可以用线程池的线程来<strong>并行执行</strong>操作。</p><p>要注意，并行执行对应<strong>顺序执行</strong>，它是无法保证顺序的。</p><h4 id="For、ForEach、Invoke"><a href="#For、ForEach、Invoke" class="headerlink" title="For、ForEach、Invoke"></a>For、ForEach、Invoke</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池的线程并行完成</span></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">1000</span>, i=&gt; DoSth(i));</span><br><span class="line">Parallel.ForEach(collection, item =&gt; DoSth(item)); <span class="comment">// ForEach要用迭代器遍历,比For稍慢</span></span><br><span class="line"></span><br><span class="line">Parallel.Invoke(</span><br><span class="line">    () =&gt; Method1(),</span><br><span class="line">    () =&gt; Method2(),</span><br><span class="line">    () =&gt; Method3(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另外，Invoke有一个可控性极强的重载，指定 <strong>localInit、body、localFinally委托</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parallel.ForEach&lt;TSource,TLocal&gt; (IEnumerable&lt;TSource&gt; item, Func&lt;&gt; localInit, Func&lt;&gt; body, Func&lt;&gt; localFinally);</span><br><span class="line"></span><br><span class="line"><span class="comment">// item 是集合的每个子元素。</span></span><br><span class="line"><span class="comment">// localInit(初始化委托) 为参与工作的每个任务都调用一次该委托,在body前调用。</span></span><br><span class="line"><span class="comment">// body(主体委托) 为参与工作的每个任务都调用一次该委托。</span></span><br><span class="line"><span class="comment">// localFinally(终结委托) 为参与工作的每个任务都调用一次该委托,在body后调用。</span></span><br></pre></td></tr></table></figure><h4 id="返回值ParallelLoopResult"><a href="#返回值ParallelLoopResult" class="headerlink" title="返回值ParallelLoopResult"></a>返回值ParallelLoopResult</h4><p>For、ForEach都返回一个ParallelLoopResult实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ParallelLoopResult &#123;</span><br><span class="line">    <span class="comment">// 如果操作提前终止，以下方法返回 false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">// 保证得到处理的最低一项的索引</span></span><br><span class="line">    <span class="keyword">public</span> Int64? LowestBreakIteration &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 IsCompleted == true 说明全部运行完成，</p><p>如果 IsCompleted == false、LowestBreakIteration == null 说明某个线程调用了Stop，</p><p>如果 IsCompleted == false、LowestBreakIteration != null 说明某个线程break了。</p><h3 id="并行语言继承查询-PLINQ"><a href="#并行语言继承查询-PLINQ" class="headerlink" title="并行语言继承查询(PLINQ)"></a>并行语言继承查询(PLINQ)</h3><p>当只用一个线程来<strong>顺序执行</strong>调用LINQ时，我们称之为<strong>LINQ</strong>；当用<strong>并行的方式</strong>执行LINQ时，我们称之为**PLINQ(Parallel LINQ)**。</p><p>使用扩展方法<strong>AsParallel</strong>实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ParallelQuery</span>&lt;<span class="title">TSource</span>&gt; <span class="title">AsParallel</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParallelQuery <span class="title">Asparallel</span> (<span class="params"><span class="keyword">this</span> IEnumerable source</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="执行定时计算限制操作"><a href="#执行定时计算限制操作" class="headerlink" title="执行定时计算限制操作"></a>执行定时计算限制操作</h2><h3 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h3><p>定时器，在<code>System.Threading</code>中定义的。</p><p>Timer的构造函数需要传入一个<strong>TimerCallback委托</strong> 回调函数，在时间到达后使用线程池线程调用这个回调函数。</p><h3 id="TimerCallback委托"><a href="#TimerCallback委托" class="headerlink" title="TimerCallback委托"></a>TimerCallback委托</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object state</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="Timer内部实现"><a href="#Timer内部实现" class="headerlink" title="Timer内部实现"></a>Timer内部实现</h3><p>在内部，线程池为所有Timer对象<strong>只打算使用一个线程</strong>。这个线程知道下一个Timer对象在什么时候到期（计时器还有多久触发）。下一个Timer对象到期时，线程就会唤醒，在内部调用 Threadpool的 QueueUserWorkItem,将一个工作项添加到线程池的队列中，使你的回调方法得到调用。</p><p>那么如果new了很多个Timer，那么有可能出现并行执行的情况，这个时候会用<strong>新的线程</strong>来帮你同时执行回调方法。</p><p>想避免用新线程，可以在构造Timer时传入<strong>period参数指定Timeout.Infinite</strong>，这样，计时器就只触发一次。然后，在你的回调方法中，调用 Change方法来指定一个新的<strong>dueTime</strong>，dueTime告诉CLR在首次调用回调方法之前需要等待多少毫秒，可以传递0立刻执行。</p><h3 id="例子、await允许线程返回"><a href="#例子、await允许线程返回" class="headerlink" title="例子、await允许线程返回"></a>例子、await允许线程返回</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Timer timer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Timer(回调, 回调参数, dueTime, period)</span></span><br><span class="line">    timer = <span class="keyword">new</span> Timer(Status, <span class="literal">null</span>, <span class="number">0</span>, Timeout.Infinite);</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Status</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Timer.Change(dueTime, period)</span></span><br><span class="line">    timer.Change(<span class="number">2000</span>, Timeout.Infinite); <span class="comment">// 返回前让Timer在2秒后再次触发</span></span><br><span class="line">    <span class="comment">// 这个方法返回后，线程回归池中，等待下一个工作项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:32 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:35 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:38 4</span></span><br></pre></td></tr></table></figure><p>然后书中用了await/async写一个等效的实现。我这里打印了线程号，可以观察出来其实两者并不同。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Status(<span class="literal">null</span>);</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; main &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Status</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now + <span class="string">&quot; &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟做2秒的事</span></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 2秒之后，某个线程池的线程会在await之后介入并继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:33 1</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:34 main 1</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:36 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:39 4</span></span><br></pre></td></tr></table></figure><p>观察输出理解await做了什么：</p><p>画面线程走到await之前都是正常顺序执行的，但是遇到了await之后立刻退出了方法并继续执行了；而<strong>Status方法借由线程池线程来继续执行</strong>。</p><p>所以画面既没卡死，也在不断更新UI。我估计await这里的做法就是起了个Task把回调包进去，然后传递了同步上下文给它让他可以更新UI。</p><h1 id="大章28：I-O限制的异步操作⭐"><a href="#大章28：I-O限制的异步操作⭐" class="headerlink" title="大章28：I/O限制的异步操作⭐"></a><center>大章28：I/O限制的异步操作⭐</center></h1><p>讲述如何异步执行I/O限制的操作，允许将任务交由硬件设备处理，期间完全不占用线程和CPU资源。当然这还是离不开线程池得处理。</p><h2 id="Windows如何执行I-O操作"><a href="#Windows如何执行I-O操作" class="headerlink" title="Windows如何执行I/O操作"></a>Windows如何执行I/O操作</h2><h3 id="从硬件开始理解"><a href="#从硬件开始理解" class="headerlink" title="从硬件开始理解"></a>从硬件开始理解</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220114151554.png"></p><p>图中展示的是连接了几个硬件设备的OS。</p><p>其实每个硬件都有自己的电路板，知道如何驱动自己的设备（寻道、读写数据、与计算机内存交换数据），所以其实不需要计算机线程来处理这些事。</p><h3 id="程序请求I-O流程⭐"><a href="#程序请求I-O流程⭐" class="headerlink" title="程序请求I/O流程⭐"></a>程序请求I/O流程⭐</h3><p>当你使用<code>FileStream fs = new FileStream(...); var bytes = fs.Read();</code>之后发生了这些事：</p><p>① 线程从托管代码转变为本机代码，Read内部<strong>调用Win32 ReadFile函数</strong>。</p><p>② ReadFile分配一个小数据结构，称作<strong>I/O请求包也就是IRP</strong> (I/O Request Packet)。</p><p>③ <strong>IRP结构初始化</strong>后包括：文件句柄，文件中的偏移量（字节读取开始位置）、一个Byte[]数组地址（用于写入读取的字节）等等。</p><p>④ 之后ReadFile将线程从 本机/用户模式代码=&gt;本机/内核模式代码，从而<strong>调用Windows内核并向其传递IRP数据包</strong>。Windows内核根据IRP中得设备句柄，传递给对应硬件设备的驱动程序的<strong>IRP队列</strong>。</p><p>⑤ 对应设备驱动软件在自己的IRP队列拿到IRP数据包，将信息传给物理硬件设备得电路板，执行I/O操作。</p><p>⑥ 设备执行I/O期间，发出请求的线程将无事可做，所以Windows将其变成<strong>睡眠</strong>状态。</p><p>⑦ 最终，硬件完成I/O操作。Windows会唤醒你的线程，并调度给一个CPU使它从内核模式返回用户模式，再<strong>返回至托管代码</strong>。</p><h3 id="异步请求I-O流程⭐"><a href="#异步请求I-O流程⭐" class="headerlink" title="异步请求I/O流程⭐"></a>异步请求I/O流程⭐</h3><p>上面演示了正常(同步)请求I/O流程，可以看⑥中你的线程在等待I/O期间是无所事事的。这是极大的浪费。</p><p>当你以异步方式发送I/O请求（用<strong>ReadAsync</strong>而不是Read） <code>FileStream fs = new FileStream(...,FileOptions.Asynchronous); Task&lt;int&gt; task = fs.ReadAsync();</code> 时发生了这些事：</p><p>① ReadAsync内部分配一个<code>Task&lt;int&gt;</code>对象来代表用于完成读取操作的代码。</p><p>② 和同步一样的方式，初始化IRP并发送到对应驱动软件IRP队列。</p><p>③ 驱动软件根据IRP数据包让硬件执行I/O，此刻，你的线程并<strong>不再睡眠</strong>，而是直接<strong>返回你的代码</strong>。</p><p>④ 从代码上看，你的线程会从ReadAsync的调用中很快返回，但是IRP可能还未处理好，所以不能在ReadAsync之后的代码中访问获取的Byte[]。</p><p>那么什么时候可以访问结果Byte[]呢？答案是为①中返回的<code>Task&lt;int&gt;</code>对象添加延续任务<strong>ContinueWith</strong>来执行回调方法。C#的<strong>异步函数</strong>可以简化这部分代码，从而以顺序方式写代码让你感觉像写同步I/O代码一样。</p><h3 id="I-O异步对比同步优势"><a href="#I-O异步对比同步优势" class="headerlink" title="I/O异步对比同步优势"></a>I/O异步对比同步优势</h3><p>资源上来说，同步阻塞线程，会导致CLR线程池不得不开辟更多线程来继续操作，<strong>增大开销</strong>；当I/O结束时线程又会回到线程池，导致<strong>过饱和</strong>，下场就是CPU同步上下文轮询花费更久。</p><p>效率上来说，一个线程去同步执行10个下载任务，每个5秒就得50秒；异步执行就只需要5秒。</p><h2 id="C-的异步函数⭐"><a href="#C-的异步函数⭐" class="headerlink" title="C#的异步函数⭐"></a>C#的异步函数⭐</h2><p>前面聊过了使用 <strong>ReadAsync + Task.ContinueWith</strong> 来实现异步，但是那么写代码比较复杂，于是微软推出了 <strong>异步函数 + Task</strong> 的方案，使开发者能够以同步顺序写代码实现异步。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; before &quot;</span> + <span class="string">&quot;tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Test(<span class="number">3</span>);</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; after &quot;</span> + <span class="string">&quot;tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">var</span> result = i * i;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; body &quot;</span> + result + <span class="string">&quot; tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">//  17:16:35 before tid:1</span></span><br><span class="line"><span class="comment">//  17:16:35 after tid:1</span></span><br><span class="line"><span class="comment">//  17:16:38 body 9 tid:4</span></span><br></pre></td></tr></table></figure><p>照这个示例来一步一步说明。</p><h3 id="async-gt-状态机"><a href="#async-gt-状态机" class="headerlink" title="async =&gt; 状态机"></a>async =&gt; 状态机</h3><p>我们很容易分辨Test是异步函数，因为他用async来修饰。</p><p>一旦方法被标记为async，编译器就会将方法的代码转换成实现了<strong>状态机</strong>的一个类型。具体下节讨论。</p><h3 id="await-gt-Task-ContinueWith"><a href="#await-gt-Task-ContinueWith" class="headerlink" title="await =&gt;Task.ContinueWith"></a>await =&gt;Task.ContinueWith</h3><p><code>await Task.Delay(3000);</code>这一句，Delay方法会在内部分配一个Task并实现<code>task.ContinueWith(await之后所有的代码);</code>等价的效果。</p><h3 id="最后，状态机恢复"><a href="#最后，状态机恢复" class="headerlink" title="最后，状态机恢复"></a>最后，状态机恢复</h3><p>当把后续代码包到Task的延续任务之后，线程不再等待Task的执行完毕，而是直接回到调用方法的地方<code>Test(3);</code>执行它之后的代码…</p><p>等到Task内部方法运行结束后，一个线程池线程会通知Task对象，开始激活ContinueWith回调方法（线程恢复状态机）。</p><h2 id="编译器如何将异步函数转换成状态机⭐"><a href="#编译器如何将异步函数转换成状态机⭐" class="headerlink" title="编译器如何将异步函数转换成状态机⭐"></a>编译器如何将异步函数转换成状态机⭐</h2><p>通过实现一个简单的异步函数使用案例，然后将IL代码反编译成C#代码来理解编译器到底做了些什么。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type1</span> &#123; &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type2</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Type1&gt; <span class="title">Method1Async</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 异步执行一些操作，最后返回一个Type1对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Type2&gt; <span class="title">Method2Async</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 异步执行一些操作，最后返回一个Type2对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">MyMethodAsync</span>(<span class="params"><span class="built_in">int</span> arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> local = arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Type1 result1 = <span class="keyword">await</span> Method1Async();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line">Type2 result2 = <span class="keyword">await</span> Method2Async();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Catch&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>IL反编译成C#并精简后的代码：</p><p>要点是观察状态机的状态<strong>m_state</strong>在什么地方变化。</p><p>然后再观察<strong>m_x</strong>怎么实现的await循环<code>for()&#123; await ...&#125;;</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AsyncStateMachine特性指出这是一个异步方法（对使用反射的工具有用）</span></span><br><span class="line"><span class="comment">// 类型指出实现状态机的是哪个结构</span></span><br><span class="line">[<span class="meta">DebuggerStepThrough, AsyncStateMachine(typeof(StateMachine))</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">MyMethodAsync</span>(<span class="params">Int32 arg</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建状态机实例并初始化它</span></span><br><span class="line">    StateMachine stateMachine = <span class="keyword">new</span> StateMachine() &#123;</span><br><span class="line">        <span class="comment">// 创建 builder,从这个存根方法返回Task&lt;String&gt;</span></span><br><span class="line">        <span class="comment">// 状态机访问builder来设置Task完成/异常</span></span><br><span class="line">        m_builder = AsyncTaskMethodBuilder&lt;<span class="built_in">string</span>&gt;.Create(),</span><br><span class="line">        </span><br><span class="line">        m_state = <span class="number">-1</span>, <span class="comment">// 初始化状态机位置</span></span><br><span class="line">        m_arg = arg, <span class="comment">// 将实参拷贝到状态机字段</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行状态机</span></span><br><span class="line">    stateMachine.m_builder.Start(<span class="keyword">ref</span> statemachine):</span><br><span class="line">    <span class="keyword">return</span> stateMachine.m_builder.Task; <span class="comment">// 返回状态机的Task</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是状态机结构</span></span><br><span class="line">[<span class="meta">CompilerGenerated, StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> StateMachine : IAsyncStateMachine &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表状态机 builder(Task)及其位置的字段</span></span><br><span class="line">    <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="built_in">string</span>&gt; m_builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> m_state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实参和局部变量现在成了字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> m_argument, m_local, m_x;</span><br><span class="line">    <span class="keyword">public</span> Type1 m_resultType1;</span><br><span class="line">    <span class="keyword">public</span> Type2 m_resultType2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个 awaiter 类型一个字段</span></span><br><span class="line">    <span class="comment">// 任何时候这些字段只有一个是重要的，那个字段引用最近执行的、以异步方式完成的 await</span></span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter&lt;Type1&gt; m_awaiterType1;</span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter&lt;Type2&gt; m_awaiterType2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是状态机方法本身</span></span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.MoveNext() &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="literal">null</span>; <span class="comment">// Task的结果值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 编译器插入txy块来确保状态机的任务完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">bool</span> executeFinally = <span class="literal">true</span>; <span class="comment">// 先假定逻辑上离开try块</span></span><br><span class="line">            <span class="keyword">if</span>(m_state == <span class="number">-1</span>) &#123;         <span class="comment">// 如果第一次在状态机方法中，</span></span><br><span class="line">                m_ local = m_argument;  <span class="comment">// 原始方法就从头开始执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 原始代码中的try块</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                TaskAwaiter&lt;Type1&gt; awaiterType1;</span><br><span class="line">                TaskAwaiter&lt;Type2&gt; awaiterType2;</span><br><span class="line">                </span><br><span class="line">                 <span class="keyword">switch</span>(m_state) &#123;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// 开始执行源代码中try块中的代码</span></span><br><span class="line">                         <span class="comment">// 调用 Method1Async并获得它的 awaiter</span></span><br><span class="line">                         awaiterType1 = Method1Async().GetAwaiter();</span><br><span class="line">                         <span class="keyword">if</span>(!awaiterType1.IsCompleted)&#123;</span><br><span class="line">                             m_state = <span class="number">0</span>; <span class="comment">// Method1Async要以异步方式完成</span></span><br><span class="line">                             m_awaiterType1 = awaiterType1; <span class="comment">// 保存awaiter以便将来返回</span></span><br><span class="line">                </span><br><span class="line">                             <span class="comment">// 告诉awaiter在操作完成时调用MoveNext</span></span><br><span class="line">                             m_builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiterType1, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                             <span class="comment">// 上述代码调用 awaiterType1 的 OnCompleted,它会在被等待的任务上调用 ContinueWith(t=&gt; MoveNext())</span></span><br><span class="line">                             <span class="comment">// 任务完成后ContinueWith调用MoveNext</span></span><br><span class="line">                             </span><br><span class="line">                             executeFinally = <span class="literal">false</span>; <span class="comment">// 逻辑上不离开try块</span></span><br><span class="line">                             <span class="keyword">return</span>; <span class="comment">// 线程返回至调用者</span></span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// Method1Async以同步方式完成了</span></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                         </span><br><span class="line">                     <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// Method1Async 以异步方式完成了</span></span><br><span class="line">                         awaiterType1 = m_awaiterType1; <span class="comment">// 恢复最新的awaiter</span></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Method2Async 以异步方式完成了</span></span><br><span class="line">                         awaiterType2 = m_awaiterType2; <span class="comment">// 恢复最新的awaiter</span></span><br><span class="line">                         <span class="keyword">goto</span> ForLoopEpilog;</span><br><span class="line">                 &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在第一个await后，我们捕捉结果并启动for循环</span></span><br><span class="line">                m_resultType1 = awaiterType1.GetResult(); <span class="comment">// 获取awaiter的结果</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//序幕</span></span><br><span class="line">                ForLoopPrologue:</span><br><span class="line">                m_x = <span class="number">0</span>; <span class="comment">// for循环初始化</span></span><br><span class="line">                <span class="keyword">goto</span> ForLoopBody;</span><br><span class="line">                <span class="comment">//收场</span></span><br><span class="line">                ForLoopEpilog:</span><br><span class="line">                m_resultType2 = awaiterType2.GetResult();</span><br><span class="line">                m_x ++;</span><br><span class="line">                <span class="comment">// 循环主体</span></span><br><span class="line">                ForLoopBody:</span><br><span class="line">                <span class="keyword">if</span>(m_x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="comment">// 调用 Method2Async并获取它的 awaiter</span></span><br><span class="line">                        awaiterType2 = Method2Async().GetAwaiter();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(!awaiterType2.IsCompleted)&#123;</span><br><span class="line">                            m_state = <span class="number">1</span>; <span class="comment">// Method2Async要以异步方式完成</span></span><br><span class="line">                            m_awaiterType2 = awaiterType2; <span class="comment">// 保存 awaiter以使将来返回</span></span><br><span class="line">                            </span><br><span class="line">                              <span class="comment">// 告诉 awaiter在操作完成时调用 MoveNext</span></span><br><span class="line">                        m_builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiterType2, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                        executeFinally = <span class="literal">false</span>; <span class="comment">// 逻辑上不离开try块</span></span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 线程返回至调用者</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Method2Async以同步方式完成了</span></span><br><span class="line">                        <span class="keyword">goto</span> ForLoopEpilog; <span class="comment">// 如果走这个goto,意味着以同步方式完成就再次循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">             </span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Catch&quot;</span>); <span class="comment">// 源代码的catch块</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 本来,只要线程物理上离开try就会执行finally,</span></span><br><span class="line">                <span class="comment">// 但我们希望在线程逻辑上离开try时才执行这些代码</span></span><br><span class="line">                <span class="keyword">if</span>(executeFinally)&#123;</span><br><span class="line">                    Console.WriteLIne(<span class="string">&quot;Finally&quot;</span>); <span class="comment">// 源代码的finally块</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="string">&quot;Done&quot;</span>; <span class="comment">// 源代码最后一句</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 未处理的异常：通过设置异常来完成状态机的Task</span></span><br><span class="line">            m_builder.SetException(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常：通过返回结果来完成状态机的Task</span></span><br><span class="line">        m_builder.SetResult(result):</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="梳理一下"><a href="#梳理一下" class="headerlink" title="梳理一下"></a>梳理一下</h3><p>当编译器遇到<strong>async</strong>时，会尝试将方法编译成一个<strong>new状态机</strong>。</p><p>当编译器遇到<strong>await</strong>时，编译器会在它上面调用<strong>GetAwaiter</strong>方法。调用该方法所返回的对象为awaiter，正是它将被等待的对象与状态机粘合起来。</p><p>状态机获得awaiter后会查询其<strong>IsCompleted</strong>属性：如果操作以同步方式执行就返回true，如果以异步方式完成就返回false。如果为false，状态机调用awaiter的<strong>OnCompleted</strong>方法并传递一个委托（内含原任务和MoveNext）。此刻，状态机允许它的线程回到原地以执行其他代码。</p><p>将来某个时候，awaiter会在完成任务时调用委托以执行<strong>MoveNext</strong>，状态机往下运行，从而使得方法也回到当初离开的位置继续执行。之后，方法内其他的awaiter得以以同样的方式执行。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220117144608.png"></p><h2 id="异步函数扩展性"><a href="#异步函数扩展性" class="headerlink" title="异步函数扩展性"></a>异步函数扩展性</h2><p>在扩展性方面，只要是能用Task对象包装的操作，都可以用await来等待。</p><h3 id="TaskLogger"><a href="#TaskLogger" class="headerlink" title="TaskLogger"></a>TaskLogger</h3><p>clr作者自制的类，可用它打印尚未完成的异步操作。会影响性能，可以只在调试的时候启用。</p><p>// TODO</p><h2 id="await支持void"><a href="#await支持void" class="headerlink" title="await支持void"></a>await支持void</h2><p>异步函数的返回类型一般是<code>Task</code>或<code>Task&lt;Result&gt;</code>，它们代表函数的状态机完成。</p><p>但是异步函数是支持<strong>返回void</strong>的，毕竟所有事件签名几乎都是这么写的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventHandlerCallback</span>(<span class="params">Object sender, EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><p>C#编译器仍然会给返回void的异步函数创建状态机，但不再创建Task对象（因为创建了也没法使用）。<strong>所以你无法知道返回void的异步函数状态机在什么时候运行完毕。</strong></p><p>但这一般不致命，因为一般不需要知道它什么时候结束，只要可以在它执行结束完再执行后续代码就行了。</p><h2 id="异步函数和异常处理"><a href="#异步函数和异常处理" class="headerlink" title="异步函数和异常处理"></a>异步函数和异常处理</h2><p>如果硬件驱动收到IRP后，在进行I/O时虽然完成了但是内部出现错误，他就会向CLR的线程池post已完成的IRP。一个线程池线程会完成Task对象并设置异常，当你的状态机恢复后，await操作符会发现操作失败并引发该异常。</p><p>前面提过，当你用<code>Task.Start()</code>这种方式时，通常抛出一个<strong>AggregateException</strong>；但是如果你用<code>await someTask</code>的方式，编译器会优化体验，直接抛出<strong>第一个内部异常</strong>。</p><h2 id="线程处理模型：GUI线程⭐"><a href="#线程处理模型：GUI线程⭐" class="headerlink" title="线程处理模型：GUI线程⭐"></a>线程处理模型：GUI线程⭐</h2><p>简单聊下<strong>线程处理模型</strong>，.NET framework 支持很多种不同的应用程序模型，每种模型有自己的线程处理模型。比如说控制台应用程序没有任何线程处理模型。</p><h3 id="GUI线程"><a href="#GUI线程" class="headerlink" title="GUI线程"></a>GUI线程</h3><p>而GUI应用程序比如wpf引入了一个线程处理模型，<strong>这个模型中UI元素只能由创建它的线程更新</strong>，而这个线程我们叫做<strong>GUI线程</strong>。</p><p>如果通过线程池线程来更新UI元素，就会抛出异常。</p><h3 id="await优化-恢复上下文"><a href="#await优化-恢复上下文" class="headerlink" title="await优化 = 恢复上下文"></a>await优化 = 恢复上下文</h3><p><code>System.Threading.SynchronizationContext</code> 类的派生对象将应用程序模型连接到它的线程处理模型。<br>我们不和这个类打交道，只要知道它可以让你获得正确的<strong>同步上下文</strong>就行了。</p><p><code>await someTask;</code>的await关键字发生等待前，它会传递一个SynchronizationContext对象过去。之后，异步发生，会抽一个线程池线程来执行Task。<strong>当线程池线程完成Task后，会使用该SynchronizationContext对象</strong>，确保为应用程序模型使用正确的线程处理模型，换成人话就是<strong>会调用wpf的GUI线程来做事</strong>。</p><p>这就是await做的优化：<code>await someTask;</code>之后的代码如果有更新UI元素也能正常实现。但是注意，Task是由线程池线程来执行的，所以你在Task里面更新UI元素仍然会抛错。</p><p>来个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    Test();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GUI thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> t =  Task.Run(() =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;task thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    <span class="keyword">await</span> t;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;after task thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    myTextBox.Text = <span class="string">&quot;123&quot;</span>; <span class="comment">// 3秒后成功更新UI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// GUI thread id: 1</span></span><br><span class="line"><span class="comment">// task thread id: 3</span></span><br><span class="line"><span class="comment">// after task thread id: 1</span></span><br></pre></td></tr></table></figure><h2 id="I-O请求优先级"><a href="#I-O请求优先级" class="headerlink" title="I/O请求优先级"></a>I/O请求优先级</h2><p>Windows允许线程在发出I/O请求时指定优先级。但是只允许指定本进程的，不允许指定其他进程的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> (ThreadIO.BeginBackgroundProcessing())&#123;</span><br><span class="line">        <span class="comment">// 在这里执行低优先级I/O请求(例如：调用 ReadAsync/ WriteAsync)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大章29：基元线程同步构造"><a href="#大章29：基元线程同步构造" class="headerlink" title="大章29：基元线程同步构造"></a><center>大章29：基元线程同步构造</center></h1><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁的存在是为了实现线程同步、避免多个线程同时修改一个数据源从而造成数据损坏。锁的存在意义是一次只允许一个线程访问资源。什么时候不需要锁？多个线程如果只访问不修改一个数据源，是不需要锁的。</p><p>锁的缺点很多，</p><p>即便是最快的锁，也会损害性能，需要时间开销；</p><p>一次只允许一个线程访问资源是锁的存在意义，但是也就意味着某个线程会被锁阻塞，导致线程池不得不创建更多的线程来处理其他问题。</p><h2 id="类库和线程安全"><a href="#类库和线程安全" class="headerlink" title="类库和线程安全"></a>类库和线程安全</h2><p><strong>FCL(Framework Class Library)确保其所有静态方法都是线程安全的</strong>。比如Console类就有一个静态字段，类的许多方法都要释放获取这个字段上的锁，从而保证一次只有一个线程访问控制台。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果你的代码在进程中有<strong>多个线程同时运行</strong>一段代码，如果每次执行的结果都和单线程运行时的<strong>结果一致</strong>， 那么就是线程安全的。</p><p>线程安全方法并不意味着一定需要线程同步锁。</p><p>比如System.Math的静态Max方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Max</span>(<span class="params"><span class="built_in">int</span> val1, <span class="built_in">int</span> val2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (val1 &lt; val2) ? val2 : val1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是线程安全的，它没有获取任何锁。多个线程可以同时调用Max方法，每个线程都处理的是自己的栈上数据，互不干扰。</p><h3 id="使所有实例方法非线程安全，使静态方法线程安全"><a href="#使所有实例方法非线程安全，使静态方法线程安全" class="headerlink" title="使所有实例方法非线程安全，使静态方法线程安全"></a>使所有实例方法非线程安全，使静态方法线程安全</h3><p>FCL并不保证实例方法是线程安全的。并不是不保证，而是没必要。正如标题，FCL是遵守这个原则的。</p><p>为什么说不保证实例方法线程安全？首先是<strong>没必要</strong>，线程在构造对象时，只有这个线程才拥有对象引用，其他线程都不能访问那个对象。其次是<strong>要了不好</strong>，线程同步锁会严重影响性能。</p><p>然而这句话也<strong>不是绝对的</strong>，如果线程随后公开了这个对象引用（比如把它放到一个静态字段中），传给了一个ThreadPool或Task的线程，那么<strong>在多个线程可能同时进行非只读访问的前提下，就需要线程同步</strong>。</p><h2 id="基元用户模式和内核模式构造"><a href="#基元用户模式和内核模式构造" class="headerlink" title="基元用户模式和内核模式构造"></a>基元用户模式和内核模式构造</h2><h3 id="基元-primitive"><a href="#基元-primitive" class="headerlink" title="基元 (primitive)"></a>基元 (primitive)</h3><p>基元，是指可以在代码中使用的最简单的构造。有两种基元构造：<strong>用户模式</strong>(user-mode)和<strong>内核模式</strong>( kernel-mode)。</p><p>用户模式的速度显著快于内核模式，但是这个速度的优势是由于<strong>协调是在硬件中发生的</strong>，这也同样意味着Windows操作系统永远检测不到一个线程在基元用户模式的构造上阻塞了。</p><p>而内核模式是<strong>由Windows操作系统自身提供</strong>的，所以它们在获取其他线程资源时，Windows会阻塞线程以避免它浪费CPU时间，直到资源可用才恢复线程。</p><p>线程在 用户模式 和 内核模式 之间转换，是一个巨大的开销。</p><h3 id="死锁活锁"><a href="#死锁活锁" class="headerlink" title="死锁活锁"></a>死锁活锁</h3><p>当一个线程遇到资源等待的问题时，</p><p>如果它是用户模式的，那么线程就会一直在一个CPU上运行，称为 <strong>活锁</strong>(livelock)；</p><p>如果它是内核模式的，那么线程就会一直阻塞，称为 <strong>死锁</strong>(deadlock)。</p><p><strong>死锁永远优于活锁</strong>，要知道，死锁只是卡死一个线程那也只是浪费了内存，而活锁线程除了内存，还一直在占用CPU的时间片。</p><h2 id="用户模式构造"><a href="#用户模式构造" class="headerlink" title="用户模式构造"></a>用户模式构造</h2><h3 id="原子性⭐"><a href="#原子性⭐" class="headerlink" title="原子性⭐"></a>原子性⭐</h3><p>CLR保证对以下数据类型变量的读写是原子性的：bool、char、(S)Byte、Int16、Int32、IntPtr、Single以及引用类型。这意味着<strong>变量中的所有字节都一次性读取或写入</strong>。</p><p>什么意思呢，比如执行以下代码时，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">0x01234567</span>;</span><br><span class="line"></span><br><span class="line">Int64 y;</span><br><span class="line">y = <span class="number">0x0123456789abcdef</span>;</span><br></pre></td></tr></table></figure><p>x变量会<strong>一次性（原子性）</strong>地从0x00000000变成0x01234567。另一个线程不可能看到处于中间状态的值。</p><p>y变量就不同了，其他线程查询到它的值可能是0x0000000000000000 到 0x0123456789abcdef的值，因为读取和写入操作不是原子性的。这称为一次 <strong>torn read</strong>（撕裂读取：一次读取被撕成两半，或者在机器级别上要2个MOV指令才能读完）。</p><p>有两种基元<strong>用户模式</strong>线程同步构造：易变构造和互锁构造。</p><p>易变构造：在特定的时间，它在包含一个简单数据类型的变量上执行原子性的<strong>读或写</strong>操作。</p><p>互锁构造：在特定的时间，它在包含一个简单数据类型的变量上执行原子性的<strong>读和写</strong>操作。</p><h3 id="易变构造-volatile-construct"><a href="#易变构造-volatile-construct" class="headerlink" title="易变构造 (volatile construct)"></a>易变构造 (volatile construct)</h3><p>说的就是由于代码是由 C#编译器转换为IL语言、再由JIT将IL语言转换成本机CPU指令，最后再执行的，所以其中包括很多的<strong>编译器优化</strong>，导致你最终生成的代码运行顺序与你书写的不同。</p><p>可以使用两个<code>System.Threading.Volatile</code>类（<strong>易变构造</strong>）的静态方法来确保代码顺序执行而不被优化得偏离你的意图：</p><p><strong>Volatile.Write</strong> 方法执行一次原子性的写入操作。强迫location中的值在调用时写入。按照编码顺序，之前的加载和存储操作必须在调用Volatile.Write之前发生。</p><p><strong>Volatile.Read</strong> 方法执行一次原子性的读取操作。强迫location中的值在调用时读取。按照编码顺序，之后的加载和存储操作必须在调用Volatile.Read之后发生。</p><h4 id="易变构造volatile-例子"><a href="#易变构造volatile-例子" class="headerlink" title="易变构造volatile 例子"></a>易变构造volatile 例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序可能被优化到偏离意图的执行案例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Before</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法由一个线程执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        val = <span class="number">5</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法由另一个线程执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意：value可能先于flag读取</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span><br><span class="line">            Console.WriteLine(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后,确保按照意图执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">After</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// flag的写入 必然在所有前面代码之前</span></span><br><span class="line">        val = <span class="number">5</span>;</span><br><span class="line">        Volatile.Write(<span class="keyword">ref</span> flag, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// flag的读取 必然在所有后续代码之前</span></span><br><span class="line">        <span class="keyword">if</span>(Volatile.Read(<span class="keyword">ref</span> flag) == <span class="number">1</span>) &#123;</span><br><span class="line">            Console.WriteLine(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互锁构造"><a href="#互锁构造" class="headerlink" title="互锁构造"></a>互锁构造</h3><p>互锁，说的是<code>System.Threading.Interlocked</code>类提供的方法，Interlocked类中的每个方法都执行一次原子读取以及写入操作。Interlocked的所有方法都建立了完整的<strong>内存栅栏</strong>(memory fence)：调用某个Interlocked方法之前的任何变量写入都在这个Interlocked方法之前执行；这个调用之后的任何变量读取都在这个调用之后读取。</p><h4 id="Interlocked类"><a href="#Interlocked类" class="headerlink" title="Interlocked类"></a>Interlocked类</h4><p>展示对int处理的接口，来理解他能做哪些事。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Interlocked</span> &#123;</span><br><span class="line">    <span class="comment">// return (++location)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Increment</span> (<span class="params"><span class="keyword">ref</span> Int32 location</span>)</span>;</span><br><span class="line">    <span class="comment">// return (--location)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Decrement</span> (<span class="params"><span class="keyword">ref</span> Int32 location</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Add</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Exchange</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">CompareExchange</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span>, Int32 comparand</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// TODO 后面的都略了，太需要实战应用，光看不够</p><h1 id="大章30：混合线程同步构造"><a href="#大章30：混合线程同步构造" class="headerlink" title="大章30：混合线程同步构造"></a><center>大章30：混合线程同步构造</center></h1><h2 id="双检锁技术"><a href="#双检锁技术" class="headerlink" title="双检锁技术"></a>双检锁技术</h2><p>双检锁(Double- Check Locking)是一个非常著名的技术，开发人员用它将单实例(singleton)对象的构造推退到应用程序首次请求该对象时进行。也就是<strong>懒加载（也叫延迟初始化 lazy init）</strong>。</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// s_lock对象是实现线程安全所需要的。定义这个对象时，我们假设创建单实例对象的</span></span><br><span class="line">    <span class="comment">// 代价高于创建一个System.Object对象，并假设可能根本不需要创建单实例对象</span></span><br><span class="line">    <span class="comment">// 否则，更经济、更简单的做法是在一个类构造器中创建单实例对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> s_lock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">        </span><br><span class="line">        Monitor.Enter(s_lock); <span class="comment">// Monitor.Enter: 获取指定对象上的排他锁</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            Singleton temp = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="comment">// 将引用保存到instance中(参见正文的详细讨论)</span></span><br><span class="line">            Volatile.Write(<span class="keyword">ref</span> instance, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Monitor.Exit(s_lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存栅栏"><a href="#内存栅栏" class="headerlink" title="内存栅栏"></a>内存栅栏</h4><p>由于CLR对任何锁方法的调用都构成了一个<strong>完整的内存栅栏</strong>，在柵栏之前写入的任何变量都必须在栅栏之前完成；在栅栏之后的任何变量读取都必须在栅栏之后开始。所以第二个if中instance的值必须等待锁结束后，其他线程才能获取到，而不是什么缓存到寄存器中的东西。</p><p>放到JAVA就不一样了，它因为不保证完整的内存栅栏，导致第二个if可能读取到缓存到寄存器中的instance数值，从而返回true。</p><h4 id="发布-publishing"><a href="#发布-publishing" class="headerlink" title="发布(publishing)"></a>发布(publishing)</h4><p>而<code>Volatile.Write(ref instance, temp);</code>是解决了什么问题呢？</p><p>使一个值对其他线程可见称为<strong>发布</strong>。如果按照常规思路写<code>instance = new Singleton();</code>，编译器可能并不会按照你顺序写的代码来执行。它可能会先为Singleton分配内存，将引用发布到instance，然后再调用构造器，这导致了其他线程看到的instance不为null也不为正确的构造好的Singleton对象，而是一个<strong>正在构造的Singleton对象</strong>。</p><h3 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本与前面的效果是一样的！即使它没用“双检锁”也能保证<strong>线程安全</strong>。具体原因看下面。</p><p>在首次有线程访问这个Singleton的时候，CLR就会自动调用类构造器，创建并返回一个对象实例。</p><h4 id="线程安全⭐"><a href="#线程安全⭐" class="headerlink" title="线程安全⭐"></a>线程安全⭐</h4><p>关于线程安全需要特別说明一下，由于程序可能在多线程环境下运行，也就是可能出现同时多个线程准备执行静态构造函数的情況。<strong>CLR确保这个过程是安全的</strong>，实际上调用静态构造函数的线程需要先获得一个<strong>互斥线程同步锁</strong>，如果有多个线程试图执行类型的静态构造函数，只有一个线程能获得该锁；获得锁的线程完成初始类型初始化操作，<strong>其它线程只能等待</strong>；当初始化完成，等待的线程被唤醒，然后发现静态构造函数已经被执行过，就不会再执行，此时获得的字段也是初始化完成后的状态。</p><p>下面献上我自己的测试代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task1 Started&quot;</span>);</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task1 &quot;</span> + Singleton.Instance().counter.ToString());</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task1 End&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Utils.WriteLine( <span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task2 Started&quot;</span>);</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task2 &quot;</span> + Singleton.Instance().counter.ToString());</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; Task2 End&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">counter++;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; ctor bf&quot;</span> + counter);</span><br><span class="line">Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">counter += <span class="number">10</span>;</span><br><span class="line">Utils.WriteLine(<span class="string">&quot; ctor af&quot;</span> + counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">Instance</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Utils</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteLine</span>(<span class="params"><span class="built_in">string</span> txt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(Thread.CurrentThread.ManagedThreadId + txt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态构造、实例构造、内联执行顺序"><a href="#静态构造、实例构造、内联执行顺序" class="headerlink" title="静态构造、实例构造、内联执行顺序"></a>静态构造、实例构造、内联执行顺序</h4><p>引用：<a href="https://www.cnblogs.com/xiaoxiaotank/p/11155886.html">https://www.cnblogs.com/xiaoxiaotank/p/11155886.html</a></p><p>一般情况下是 <strong>静态字段内联 &gt; 静态构造 &gt; 实例字段内联 &gt; 实例构造</strong>。</p><p>如果加上基类就是：</p><p>Child静态字段内联 &gt; Child静态构造 &gt; Child实例字段内联 &gt; Base静态字段内联 &gt; Base静态构造 &gt; Base实例字段内联 &gt; Base实例构造 &gt; Child实例构造</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;---------------一般初始化顺序---------------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child1();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n---------------子类静态字段初始化需要使用父类静态字段时初始化顺序---------------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child2();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n---------------子类静态构造函数中使用父类静态字段时初始化顺序---------------&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> child3 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child1</span> : <span class="title">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 静态构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"><span class="comment">// 静态构造器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Child1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line"><span class="comment">// 实例构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Child1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child2</span> : <span class="title">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 子类静态字段初始化需要使用父类静态字段</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>, () =&gt; BaseStatic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Child2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Child2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child3</span> : <span class="title">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 子类静态构造函数中使用父类静态字段</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Child3</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> baseStatic = BaseStatic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Child3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 3个Base类相同，这里是为了演示静态成员的初始化</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 静态字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"><span class="comment">// 静态构造器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Base1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"><span class="comment">// 实例构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Base1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Base2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Base2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Base3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Base3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Display</span>(<span class="params"><span class="built_in">string</span> msg, Func&lt;Display&gt; displayFunc = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(msg);</span><br><span class="line"><span class="keyword">var</span> display = displayFunc?.Invoke();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">---------------一般初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br><span class="line"></span><br><span class="line">---------------子?静?字段初始化需要使用父?静?字段?初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br><span class="line"></span><br><span class="line">---------------子?静??造函数中使用父?静?字段?初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br></pre></td></tr></table></figure><h3 id="Lazy模式"><a href="#Lazy模式" class="headerlink" title="Lazy模式"></a>Lazy模式</h3><p>FCL有两个类型封装了上面描述的模式，也就是<strong>懒汉模式</strong>。</p><p>下面是泛型System.Lazy类(方法未列完)：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lazy</span>&lt;<span class="title">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lazy</span>(<span class="params">Func&lt;T&gt; valueFactory, LazyThreadSafetyMode mode</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> Boolean IsValueCreated &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> T Value &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line">LazyThreadSafetyMode &#123;</span><br><span class="line">    None, <span class="comment">// 完全没有线程安全支持(适合GUI应用程序)</span></span><br><span class="line">    ExecutionAndPublication, <span class="comment">// 使用双检锁技术</span></span><br><span class="line">    PublicationOnly, <span class="comment">// 使用Interlocked.CompareExchange技术</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个“延迟初始化”包装器，它将Datetime的获取包装起来</span></span><br><span class="line">    Lazy&lt;<span class="built_in">string</span>&gt; s = <span class="keyword">new</span> Lazy&lt;<span class="built_in">string</span>&gt;(() =&gt; DateTime.Now.ToLongTimeString(), <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(s.IsValueCreated); <span class="comment">// 还没查询Value，返回false</span></span><br><span class="line">    Console.WriteLine(s.Value); <span class="comment">// 开始调用委托</span></span><br><span class="line">    Console.WriteLine(s.IsValueCreated); <span class="comment">// 已经查询了Value，返回true</span></span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">    Console.WriteLine(s.Value); <span class="comment">// 委托没有被重复调用，显示相同结果是正常的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo output:</span></span><br><span class="line"><span class="comment">// False</span></span><br><span class="line"><span class="comment">// 2:40:42 PM</span></span><br><span class="line"><span class="comment">// True</span></span><br><span class="line"><span class="comment">// 2:40:42 PM</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大章26：线程基础&quot;&gt;&lt;a href=&quot;#大章26：线程基础&quot; class=&quot;headerlink&quot; title=&quot;大章26：线程基础&quot;&gt;&lt;/a&gt;&lt;center&gt;大章26：线程基础&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;Widnows的线程概念&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="CLR via C#" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/"/>
    
    <category term="第五章 线程基础" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="线程" scheme="https://codingcodingk.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://codingcodingk.github.io/2022/01/07/Tech/Game/01knapsack/"/>
    <id>https://codingcodingk.github.io/2022/01/07/Tech/Game/01knapsack/</id>
    <published>2022-01-07T09:12:15.483Z</published>
    <updated>2022-01-14T12:18:29.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础01背包"><a href="#基础01背包" class="headerlink" title="基础01背包"></a><center>基础01背包</center></h1><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>n种物品每种只有1个。</p><p>每个物品有自己的weight和value，求解一个MAX_Weight的容量的背包尽可能多装value的解法。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>背包MAX重量为4。</p><p>每个物品只有2个状态（0或1），直接用回溯算法进行<strong>枚举</strong>。解决本题的时间复杂度为<strong>O(2^n) = 8</strong>。</p><h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><h3 id="dp数组"><a href="#dp数组" class="headerlink" title="dp数组"></a>dp数组</h3><p>一个二维数组，</p><p>下标i 对应条件0~i 的物品任取，下标j 对应背包重量。</p><p><code>dp[i][j]</code> 的值 对应 当0~i的物品任取、一个容量为j的背包所放物品的最大value。</p><h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><p>考虑一个<code>dp[i][j]</code>的前后。</p><p>首先<code>dp[i][j]</code>前面说过，代表i、j情况下的最大value，</p><p>那么<strong>不放物品i的最大价值</strong>：<code>dp[i-1][j]</code>（不考虑放入物品i但保持j背包重量的情况下的最大价值）</p><p>从而推出<strong>放物品i的最大价值</strong>：<code>dp[i-1][j-weight[i]] + value[i]</code>（一定放物品i的背包的最大价值）</p><p>从上面的递进关系可以推出公式，<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) ;</code></p><h3 id="dp数组初始化"><a href="#dp数组初始化" class="headerlink" title="dp数组初始化"></a>dp数组初始化</h3><p>利用推出的公式<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) ;</code></p><p>![image-20220112140432011](E:\My Github\hexo\blog\source_posts\Tech\Game\01knapsack.assets\image-20220112140432011.png)</p><p>因为所有的数据都是 max(正上方数据，左上角某一个数据 + value[i])。所以初始化只要把<strong>第一行和第一列正确初始化</strong>，其他的都可以靠递推公式推出。</p><p>第一列因为背包容量为0所以固定全是0，而第一行很容易计算。</p><p>最后初始化完成结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112141044.png"></p><h3 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h3><p>二维dp数组其实都可以（因为确定数值时左上方的数值都已确定），但是常规选择：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(物品)</span><br><span class="line">    <span class="keyword">for</span>(背包)</span><br><span class="line">        递推公式 dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]] + <span class="keyword">value</span>[i]);</span><br></pre></td></tr></table></figure><h3 id="解题案例"><a href="#解题案例" class="headerlink" title="解题案例"></a>解题案例</h3><p>题目还是前面的那个题目。手写一遍，再代码实现一遍。</p><h4 id="动态规划手写"><a href="#动态规划手写" class="headerlink" title="动态规划手写"></a>动态规划手写</h4><p>不说了…图画了我半小时…</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112144431.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112144446.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><center>完全背包</center></h1><h2 id="问题概述-1"><a href="#问题概述-1" class="headerlink" title="问题概述"></a>问题概述</h2><p>n种物品每种有无限个。</p><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><center>多重背包</center></h1><h2 id="问题概述-2"><a href="#问题概述-2" class="headerlink" title="问题概述"></a>问题概述</h2><p>n种物品每种物品个数各不相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础01背包&quot;&gt;&lt;a href=&quot;#基础01背包&quot; class=&quot;headerlink&quot; title=&quot;基础01背包&quot;&gt;&lt;/a&gt;&lt;center&gt;基础01背包&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题概述&quot;&gt;&lt;a href=&quot;#问题概述&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/Game/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="01背包" scheme="https://codingcodingk.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>C#传入方法中的是一个指针</title>
    <link href="https://codingcodingk.github.io/2021/12/26/Tech/CSharp/experience/20211222_1/"/>
    <id>https://codingcodingk.github.io/2021/12/26/Tech/CSharp/experience/20211222_1/</id>
    <published>2021-12-26T06:13:43.710Z</published>
    <updated>2021-12-26T06:13:43.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>起因是工作中，在一个方法中对一个List进行了重赋值大概是，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rezeptTekiyouUiList是参数</span></span><br><span class="line">rezeptTekiyouUiList = rezeptTekiyouUiList.OrderBy(o =&gt; o.SubSeq).ThenBy(o =&gt; o.KomokuSeq).ToList();</span><br><span class="line"><span class="comment">// ...后续对rezeptTekiyouUiList继续操作</span></span><br></pre></td></tr></table></figure><p>然后发现退出方法后，后续对list的操作不起效了…查了一会之后发现，不止是ToList，这样的也会失效：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReSort</span>(<span class="params">List&lt;Test&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">list = <span class="keyword">new</span> List&lt;Test&gt;();</span><br><span class="line">list.Add(<span class="keyword">new</span> Test()&#123;val = <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//甚至下面的也不行，val修改失败</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReSort</span>(<span class="params">Test test</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">test = <span class="keyword">new</span> Test();</span><br><span class="line">test.val = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>那到这里问题就很明显了，是指针问题，不难得出一个结论：</p><ol><li>  进入方法后，参数会被分配空间并压在栈上。这个参数与调用处传入的变量不是一个东西，它只是调用处传入变量的一个浅拷贝，<strong>两者内容相等但不是同一个物体</strong>。</li><li>  执行<code>test = new Test();</code>，是在堆上新分配了一个实例并赋值其地址给参数，这时候这个参数和调用处传入变量已经一点关系也没有了。后续操作<code>test.val = 2;</code>也只是对堆上新实例操作。</li><li>  方法体结束，栈帧unwind恢复，方法体内那个指着新堆中对象的参数凉了，而调用处传入得变量毫无变化。</li></ol><p>至于<code>.ToList()</code>和new一样的，因为List不可变性。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>解决比较简单，就是ref or out传参。但如果内部用了lambda操作这个参数，那就没法用ref，所以最保险的是别用void了，直接return。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h1&gt;&lt;p&gt;起因是工作中，在一个方法中对一个List进行了重赋值大概是，&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="一些坑" scheme="https://codingcodingk.github.io/categories/CSharp/%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="一些坑" scheme="https://codingcodingk.github.io/tags/%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>CLR Via C#个人笔记6 - 核心机制</title>
    <link href="https://codingcodingk.github.io/2021/12/26/Tech/CSharp/CLR-Via-CSharp/cp6/"/>
    <id>https://codingcodingk.github.io/2021/12/26/Tech/CSharp/CLR-Via-CSharp/cp6/</id>
    <published>2021-12-26T06:13:43.705Z</published>
    <updated>2022-01-14T12:18:28.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大章20：异常和状态管理"><a href="#大章20：异常和状态管理" class="headerlink" title="大章20：异常和状态管理"></a><center>大章20：异常和状态管理</center></h1><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p><strong>什么是“异常”</strong></p><p>首先对异常有一个基本理解，对于一些预想外的情况（比如中途转换失败），需要对既有代码进行进一步的安全性保证，就需要由对异常的处理。</p><p>平时代码throw抛出就会<strong>结束后续代码的执行，终止进程</strong>，<font color="pink">但是如果在try里throw就会被catch接住，执行catch内代码；如果catch也抛出但被更上层的catch抓住了，抛出地点的后续代码就不会执行了，但仍然会执行对应finally内的代码，之后finally结束后的代码不会执行。</font></p><p><strong>异常处理标准流程</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do method</span></span><br><span class="line">&#125;</span><br><span class="line">    catch (InvalidOperationException)&#123;</span><br><span class="line">        <span class="comment">// 异常预想情况1，从InvalidOperationException恢复的代码放在这</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException)&#123;</span><br><span class="line">        <span class="comment">//  异常预想情况2，从IOException恢复的代码放在这</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123;</span><br><span class="line">        <span class="comment">// 上述异常以外的其他异常恢复代码放在这</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 因为是未预想到的异常，恢复代码不可靠，所以一般抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 对try块代码的操作，进行后处理</span></span><br><span class="line">        <span class="comment">// finally总是执行，无论是否抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有在catch中抛出异常，就继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try块</strong></p><p>介绍略了。</p><p>对于程序设计时，多少代码放到try块中是很难把控的，应该根据catch和finally的对应处理来思考这个问题：</p><ol><li>  一段代码，catch后的挽回处理如果各不相同，那就该考虑多分几块<code>try&#123;&#125;catch()&#123;&#125;</code>了</li><li>  一段代码，他们的finally清理代码如果都不相同，那就不应该放在一起</li></ol><p><strong>catch块⭐</strong></p><p>先说下<strong>捕捉类型</strong>，就是<code>catch()</code>括号里的玩意。C#要求捕捉类型必须是<code>System.Exception</code>以及它的派生类。当你括号里不指定时，就相当于捕捉<code>System.Exception</code>这个类型了，不过这样也没法在后续代码块里访问到异常信息了。</p><p>再说下关键，<strong>catch抓取错误的机制</strong>，也就是整个异常处理的机制。</p><ol><li>  try中代码抛出异常后，CLR将搜索捕捉类型与抛出异常相同(或是其基类)的catch块。</li><li>  如果catch没有任何捕捉类型与抛出的异常匹配，CLR会去回溯查找调用堆栈更高的一层的catch捕捉类型。</li><li>  直到找到调用堆栈的顶部，仍然没有找到匹配的catch块，就会发生未处理的异常，这个后面讨论。</li><li>  一旦CLR找到匹配的catch块，就会执行内层所有finally块中的代码，也就是 <font color="brown">从抛出异常的try块-到匹配到异常的catch块之间</font> 所有的finally块。顺序是：内层finally块 =&gt; 抓取到异常的catch块 =&gt; 抓取到异常的catch块的finally块 =&gt; …。</li></ol><p>然后再说下catch到后，常用的<strong>catch块末尾处理选择</strong>，提供3种：</p><ol><li>  重新抛出相同的异常，向调用栈高一层的代码通知异常的发生。</li><li>  抛出一个不同的异常，向调用栈高一层的代码通知异常的发生。</li><li>  啥也不抛，正常从线程底部退出。</li></ol><p>当选择3，线程从catch块的底部退出后，它将立即执行包含在finally块中的代码。如果没有，就执行catch块结束的后续代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Test1(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Test2();</span><br><span class="line">&#125;</span><br><span class="line">catch</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test1 catched&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Test3();</span><br><span class="line">&#125;</span><br><span class="line">catch</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test2 catched&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentOutOfRangeException(<span class="string">&quot;test!!!&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Test3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Test2 catched</span></span><br><span class="line"><span class="comment">// Test2</span></span><br><span class="line"><span class="comment">// Test1</span></span><br></pre></td></tr></table></figure><p>最后，再说一下捕捉到异常时，会有一个变量将引用抛出的System.Exception对象：<code>catch (Exception e)</code>。可以用这个变量打印出<strong>堆栈调用</strong>。</p><p><strong>finally块</strong></p><p>包裹的是确保会执行的代码。</p><p>前面粉字里也说过，即使catch里也抛出了错误，仍然会执行finally内的代码。</p><p>除了Win32的TerminateThread杀死线程，或者TerminateProcess或System.Environment的FailFast方法杀死进程，finally块就不会执行。</p><h2 id="非CLS异常"><a href="#非CLS异常" class="headerlink" title="非CLS异常"></a>非CLS异常</h2><p><strong>RuntimeWrappedException类</strong></p><p>上面说的都是<strong>CLS标准的异常</strong>（也就是继承于<strong>Exception类</strong>的），但是也存在C#调用了其他编程语言写的方法，而且那个方法抛出了一个非CLS相容的异常，那么C#代码根本不能捕捉这个异常，从而造成安全隐患。</p><p>于是微软引入了全新的<code>System.Runtime.CompilerServices</code>的<strong>RuntimeWrappedException类</strong>，该类派生自Exception，所以他本身与CLR相容。当非CLS相容的异常被抛出时，CLR会自动构造这个类，并初始化+引用实际抛出的异常。也就是完成了 非CLS标准异常 =&gt; CLS标准异常。</p><h2 id="Exception-StackTrace属性"><a href="#Exception-StackTrace属性" class="headerlink" title="Exception.StackTrace属性"></a>Exception.StackTrace属性</h2><p><strong>异常抛出</strong></p><p>其实CLR可以让异常抛出任何类型的实例，String、Int32都行。但是为了能够简化使用，协定为统一使用System.Exception类。</p><p><strong>Exception.StackTrace属性</strong></p><p>Exception包含几个公共属性：String Message、IDictionary Data、String Source、String StackTrace、MethodBase TargetSite、String HelpLink、Exception InnerException、Int32 HResult。</p><p>讲一下其只读的StackTrace属性，它指出异常发生前调用了哪些方法。</p><p>新构造Exception类时，StackTrace是null。</p><p><strong>StackTrace的捕捉范围</strong></p><p>抛出异常时，CLR会重置异常起点，所以CLR只能记录最新的异常对象的抛出位置。</p><p>比如catch中又抛出了异常<code>throw e;</code>，那么StackTrace捕捉的起始点就又更新了，前面抛出的堆栈抓不到了，只能抓到最底一层的。</p><p>最后生成一个字符串来指出从异常抛出位置到异常捕捉位置的所有方法。</p><p><strong>System.Diagnostics.StackTrace类型</strong></p><p>该类型定义了一些属性和方法，允许开发人员程序化地处理堆栈跟踪以及构成堆栈跟踪的栈帧。</p><p>用这个类型来自己定制一套堆栈记录机制，实现抓取到多层抛错的堆栈记录。</p><h2 id="定义自己的异常类"><a href="#定义自己的异常类" class="headerlink" title="定义自己的异常类"></a>定义自己的异常类</h2><p><strong>设计原则</strong></p><p>创建自定义异常类应严格遵循几个原则</p><ol><li>声明可序列化（用于进行序列化写入，当然如果你不需要序列化。那么可以不声明为可序列化的）</li><li>添加一个默认的构造函数</li><li>添加包含message的构造函数</li><li>添加一个包含message,及内部异常类型参数的构造函数</li><li>添加一个序列化信息相关参数的构造函数.</li><li>可以把序列化重新继承ISerializable接口，重写序列化反序列化的方法</li></ol><p><strong>简单实践</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>] <span class="comment">//声明为可序列化的 因为要写入文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PayOverflowException</span> : <span class="title">Exception</span> <span class="comment">// 如有需求，可以继承ISerializable接口，重写序列化反序列化的方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"><span class="built_in">string</span> message</span>): <span class="title">base</span>(<span class="params">message</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"><span class="built_in">string</span> message, Exception inner</span>): <span class="title">base</span>(<span class="params">message, inner</span>)</span> &#123; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">10000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ex = <span class="keyword">new</span> PayOverflowException(<span class="string">&quot;The employee&#x27;s max pay should be no more than 10000.&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DoSth(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (PayOverflowException ex)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">var</span> file = <span class="keyword">new</span> FileStream(<span class="string">@&quot;c:\customerexception.txt&quot;</span>, FileMode.Create);</span><br><span class="line">         <span class="comment">//以序列化方式写入</span></span><br><span class="line">         BinaryFormatter bf = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">         bf.Serialize(file, ex);</span><br><span class="line">         file.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>书中的泛型Exception示例</strong></p><p>比较复杂，就贴上图看一下。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211217161743.png"></p><h2 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h2><p><strong>善用finally</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">@&quot;C:\Data.bin&quot;</span>, FileMode.Open);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do sth to fs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO  清理代码放这，这样哪怕抛错也会把fs正确关闭</span></span><br><span class="line">fs.Close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C#自动实现finally</strong></p><p>为了方便程序员，只要使用了lock、using、foreach语句和析构器时，C#编译器就会<strong>自动生成try/finally块代码</strong>，如下：</p><ul><li>  使用lock语句时，锁在finally块中释放。</li><li>  使用using语句时，在finally块中调用对象的Dispose方法。</li><li>  使用foreach语句时，在finally块中调用IEnumerator对象的Dispose方法。</li><li>  定义析构器方法时，在finally块中调用基类的Finalize方法。</li></ul><p>比如下面这个方法的实现，和上面的代码编译结果一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法的实现和上面的代码编译结果一样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">@&quot;C:\Data.bin&quot;</span>, FileMode.Open)) &#123;</span><br><span class="line">        <span class="comment">// do sth to fs</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备份、回滚状态</strong></p><p>对于一些目前无法掌控到的异常，想要修复会无从下手。可以考虑一下下面的状态回滚：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> beforeDoing = num; <span class="comment">// 1.备份数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DoSth(num); <span class="comment">// 执行处理num的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch&#123;</span><br><span class="line">        num = beforeDoing; <span class="comment">// 2.回滚状态</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 抛出错误，让程序员知道发生了什么</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>包装抛错</strong></p><p>有的时候接受到了抛错，提前协定好，可以向外抛出不一样的错误类型。</p><p>因为直接让别人用你自己的包装类方法，如果抛错了，可能预料不到，抓不到错；如果提前协定好某些情况固定抛什么Exception，那么其他开发者就能提前预知要去抓这些错了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">PhoneBook</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> m_pathname; <span class="comment">// 地址簿文件的路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部调用的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPhoneNumber</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">string</span> phoneNum;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fs = <span class="keyword">new</span> FileStream(m_pathname, FileMode.Open);</span><br><span class="line">            ... phoneNum = ... <span class="comment">// 这里是查找代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 协定好的Exception类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e) &#123;</span><br><span class="line">            <span class="comment">// 协定好的Exception类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fs != <span class="literal">null</span>) fs.Close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未处理的异常"><a href="#未处理的异常" class="headerlink" title="未处理的异常"></a>未处理的异常</h2><p><strong>未处理异常的处理</strong></p><p>异常抛出时，CLR在调用栈中向上查找与抛出的异常对象的类型匹配的catch块。如果没有任何catch块匹配抛出的异常类型，就发生一个<strong>未处理的异常</strong>，CLR一旦检测到有未处理的异常的存在，就会终止进程。</p><p>CLR的默认策略时将未处理的异常，写进Windows事件日志。</p><p><strong>Windows事件日志</strong></p><p>上述的未处理异常，在“事件查看器&gt;Windows日志&gt;应用程序”中可以看到，我个人推荐直接WIN+R运行<code>eventvwr.msc</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211217182146.png"></p><h2 id="对异常进行调试"><a href="#对异常进行调试" class="headerlink" title="对异常进行调试"></a>对异常进行调试</h2><p><strong>VS 调试&gt;异常</strong></p><p>讲的是VS的菜单 “调试”&gt;“异常”，能打开CLR和自己定义的所有能被识别的Exception类型，并可以选择在抛出某Exception时中断（本来的话要异常未处理才会中断）。</p><p>这个用到了直接百度吧，知道有这个功能就行。</p><h2 id="约束执行区域-CER"><a href="#约束执行区域-CER" class="headerlink" title="约束执行区域 CER"></a>约束执行区域 CER</h2><p><strong>PrepareConstrainedRegions</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In try&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        Type1.M();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Type1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这里抛出错误，M就得不到调用</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Type1&#x27;s static ctor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// In try</span></span><br><span class="line"><span class="comment">// Type1&#x27;s static ctor called</span></span><br></pre></td></tr></table></figure><p>像上述这样的代码执行顺序，不难看出，finally里的错误就抓不住了，而且中间出错影响finally块代码执行。</p><p>我们想实现<font color="brown">除非保证catch和finally块内的代码得到执行，否则就不执行try块中的代码</font>。可以使用<strong>PrepareConstrainedRegions</strong>方法，JIT编译器如果发现在一个try块之前调用了这个方法，就会提前编译与try块关联的catch和finally块中的代码。JIT编译器会加载任何程序集，创建任何类型对象，调用任何静态构造器，并对任何方法进行JIT编译。如果其中任何操作造成异常，这个异常会在线程进入try块之前发生。</p><p>此外，JIT编译器提前准备方法时，还会遍历整个调用图，寻找应用了<strong>ReliabilityConstractAttribute</strong>特性的方法，提前准备这些被调用的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    RuntimeHelpers.PrepareConstrainedRegions(); <span class="comment">// System.Runtime.CompilerServices命名空间</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In try&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        Type2.M();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Type2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Type2&#x27;s static ctor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ReliabilityConstractAttribute(Consistency.WillNotCorruptState. Cer.Success)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Type2&#x27;s static ctor called</span></span><br><span class="line"><span class="comment">// In try</span></span><br></pre></td></tr></table></figure><p><strong>ReliabilityConstractAttribute</strong></p><p>聊一下这个属性，前面提到了，这个属性要配合PrepareConstrainedRegions方法使用。这样JIT编译器提前准备方法时，会遍历整个调用图，寻找应用了<strong>ReliabilityConstractAttribute</strong>特性的方法，提前准备这些被调用的方法。</p><p>首先会对这个属性实例传递一个枚举成员 Consistency：</p><table><thead><tr><th>枚举成员</th><th>value</th><th>详细</th></tr></thead><tbody><tr><td>MayCorruptAppDomain</td><td>1</td><td>在遇到异常情况时，公共语言运行时 (CLR) 对当前应用程序域中的状态一致性不做任何保证。</td></tr><tr><td>MayCorruptInstance</td><td>2</td><td>在遇到异常情况时，此方法保证将状态损坏限制到当前实例。</td></tr><tr><td>MayCorruptProcess</td><td>0</td><td>在遇到异常情况时，CLR 对状态一致性不做任何保证；即这种情况可能损坏进程。</td></tr><tr><td>WillNotCorruptState</td><td>3</td><td>在遇到异常情况时，此方法保证不损坏状态。 （不保证此方法永远不会失效；但确实可以保证此类故障将永远不损坏状态。）</td></tr></tbody></table><p>以及枚举成员 Cer：</p><table><thead><tr><th>枚举成员</th><th>value</th><th>详细</th></tr></thead><tbody><tr><td>MayFail</td><td>1</td><td>在遇到异常情况时，此方法可能会失败。 在这种情况下，此方法将向调用方法报告它是否成功。 该方法的方法体周围必须有 CER 以确保它可以报告返回值。</td></tr><tr><td>None</td><td>0</td><td>方法、类型或程序集没有 CER 的概念。 它不利用 CER 保证。</td></tr><tr><td>Success</td><td>2</td><td>在遇到异常情况时，保证此方法获得成功。 应始终在调用的方法周围构造 CER，即使是在非 CER 区域内调用该方法。 如果方法完成了其任务，则该方法成功。 例如，用 ReliabilityContractAttribute(Cer.Success)意味着当它在 CER 下运行时，它始终返回 ArrayList 中的元素的数目计数，并且它永远不能将内部的字段保留为不确定状态。</td></tr></tbody></table><p><strong>TODO</strong></p><p>我说实话这节没有看懂，主要问题是不理解AppDomain的“状态”到底指的是什么，书中说22章会讲。以后在这里补吧。</p><h2 id="代码协定"><a href="#代码协定" class="headerlink" title="代码协定"></a>代码协定</h2><p><strong>是什么</strong></p><p>代码协定的核心是静态类System.Diagnostics.Contracts.Contract。</p><p>协定采取的形式：</p><ul><li>  前条件：一般用于对实参进行验证。</li><li>  后条件：方法因为一次普通的返回或抛出异常而终止时，对状态进行验证。</li><li>  对象不变性(Object Invariant)：在对象的整个生命期内，确保对象的字段的良好状态。</li></ul><p><strong>怎么用</strong></p><p>下面举个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Item</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Item</span>&gt; m_cart</span> = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line">    <span class="keyword">private</span> Decimal m_totalCost = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShoppingCart</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params">Item item</span>)</span> &#123;</span><br><span class="line">        AddItemHelper(m_cart, item, <span class="keyword">ref</span> m_totalCost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddItemHelper</span>(<span class="params">List&lt;Item&gt; m_cart, Item newItem, <span class="keyword">ref</span> Decimal totalCost</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 前条件</span></span><br><span class="line">        Contract.Requires(newItem != <span class="literal">null</span>);</span><br><span class="line">        Contract.Requires(Contract.ForAll(m_cart, s =&gt; s!= newItem));</span><br><span class="line">        <span class="comment">// 后条件</span></span><br><span class="line">        Contract.Ensures(Contract.Exists(m_cart, s=&gt; s == newItem));</span><br><span class="line">        Contract.Ensures(totalCost &gt;= Contract.OldValue(totalCost));</span><br><span class="line">        Contract.EnsureOnThrow&lt;IOException&gt;(totalCost == Contract.OldValue(totalCost));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做一些事，可能抛出IOException</span></span><br><span class="line">        m_cart.Add(newItem);</span><br><span class="line">        totalCost += <span class="number">1.00</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象不变性</span></span><br><span class="line">    [<span class="meta">ContractInvariantMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ObjectInvariant</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Contract.Invariant(m_totalCost &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>有空看看吧，这个技术太老了，工作中没见过。</p><h1 id="大章21：托管堆和垃圾回收"><a href="#大章21：托管堆和垃圾回收" class="headerlink" title="大章21：托管堆和垃圾回收"></a><center>大章21：托管堆和垃圾回收</center></h1><h2 id="托管堆⭐"><a href="#托管堆⭐" class="headerlink" title="托管堆⭐"></a>托管堆⭐</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>访问一个资源所需的步骤：</p><ol><li>  调用IL指令newobj，为代表资源的类型分配内存（C#中用new操作符完成）。</li><li>  初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。</li><li>  访问类型的成员来使用资源（有必要可以重复）。</li><li>  摧毁资源的状态以进行清理。</li><li>  释放内存。垃圾回收器独自负责这一步。</li></ol><p>C#为了简化编程，将大多数类的4这一步略去了，也就是不需要资源清理，由垃圾回收器来自动释放内存。遇到需要特殊清理不等待GC的类时，不推荐写unsafe代码，而是在类中调用额外的<strong>方法Dispose</strong>以按照自己的节奏清理资源。</p><h3 id="1-从托管堆分配资源"><a href="#1-从托管堆分配资源" class="headerlink" title="1.从托管堆分配资源"></a>1.从托管堆分配资源</h3><p><strong>NextObjPtr</strong></p><p>CLR要求所有对象从托管堆分配源。进程初始化时，CLR划出一个连续的地址空间区域作为托管堆。CLR还会维护一个指针NextObjPtr，它指向下一个对象在堆中的分配位置。</p><p>一个区域被非垃圾对象填满后，CLR会分配更多的区域。这个过程一直重复直至整个进程地址空间都被填满。所以，你的应用程序的内存受进程的虚拟地址空间的限制，32位进程最多能分配1.5GB，64位进程最多能分配8TB。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211221105618.png"></p><p><strong>new操作符执行流程</strong></p><p>new操作符导致CLR执行以下步骤：</p><ol><li>  计算类型（包括基类继承的字段）的<strong>字段</strong>所需的字节数。</li><li>  加上对象的<strong>overhead开销字段</strong>所需的字节数。每个对象都有2个开销字段：类型都西昂指针和同步块索引。对于32位应用程序，这2个字段各需32位，所以每个对象要+<strong>8字节</strong>；对于64位，各需要64位，所以每个对象要+<strong>16字节</strong>。</li><li>  CLR检查区域中是否有分配对象所需的字节数。如果托管堆空间足够，就在NextObjPtr指针指向的地址放入对象，为对象分配的字节会被清零。接着调用类型构造器(为this参数传递NextObjPtr)返回初始化好的对象的引用，并让NextObjPtr移动到新地址：原地址+这个类占用的内存字节数。</li></ol><p><strong>堆性能很强</strong></p><p>正如上述所说，对于托管堆，分配对象只需要在指针上加一个值；寻找对象时，因为同时分配的对象内存是连续的（比如FileStream）且往往有业务联系，所以因为**局部化(locality)**会获得性能提升。</p><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><p><strong>垃圾回收的起因</strong></p><p>托管堆性能并不是无敌的，前面说的有一个大前提——内存无限，CLR总能分配新对象。如果托管堆没有大小限制，那C#的执行速度要优于c了(托管堆的结构让它有比c运行时堆更快的对象分配速度)。但是内存不可能是无限的，所以CLR有“垃圾回收”GC。</p><p><strong>垃圾回收的基本原理</strong></p><p>回收分为两个阶段： <strong>标记 –&gt; 压缩</strong></p><p>标记的过程，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含可达(已标记)与不可达(未标记)对象。</p><p>标记完成后，进入压缩阶段。在这个阶段中，垃圾回收器线性的遍历堆，以寻找不可达对象的连续内存块。并把可达对象移动到这里以压缩堆。这个过程有点类似于磁盘空间的碎片整理。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211221112506.png"></p><p>如上图所示，绿色框表示可达对象，黄色框为不可达对象。不可达对象清除后，移动可达对象实现内存压缩(变得更紧凑)。</p><p>压缩之后，“指向这些对象的指针”的变量和CPU寄存器现在都会失效，垃圾回收器必须重新访问所有根，并修改它们来指向对象的新内存位置。这会造成显著的性能损失。这个损失也是托管堆的主要缺点。</p><p><strong>GC不是用引用计数</strong></p><p>引用计数是COM(Component Object Model)使用的办法，GC并不是用这个，而是用的从根遍历。了解即可。说的是堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一“部分”到达代码某个不再需要对象的地方，就递减这个计数，直到0就可以删除了。</p><p><strong>根（Root）</strong></p><p>我们将所有引用类型的变量都成为<strong>根</strong>，类中定义的任何静态字段，方法的参数，局部变量(仅限引用类型变量)等都是根，另外cpu寄存器中的对象指针也是根。根是CLR在堆之外可以找到的各种入口点。</p><p><strong>可达和不可达</strong></p><p>对象可达与不可达(Objects reachable and unreachable)：</p><p>如果一个根引用了堆中的一个对象，则该对象为“可达”，否则即是“不可达”。</p><p><strong>引用跟踪 GC算法详解</strong></p><p>CLR针对无法处理循环引用的情况，推出了引用跟踪算法，它只关心引用类型的变量，因为只有这种变量能引用堆上的对象。</p><p>GC时，</p><ol><li><p>  CLR先<strong>暂停进程中的所有线程</strong>，避免检查时对象状态被更改。</p></li><li><p>  CLR进入GC的<strong>标记阶段</strong>。这个阶段中，CLR先遍历堆中所有对象，将<font color="brown">同步块索引中的一位</font>设为0：这一位是0代表着对象未被引用要删除，是1代表对象被引用着。</p></li><li><p>  然后检查所有活动根，查看它们引用的对象，如果对象是null就跳过；否则就进行标记(就是上面说的一位改为1)。一个对象A第一次被标记后，CLR会检查这个对象A中的根(也就是这个对象A中自己的字段啥的)，查看是否也引用了其他对象BCD，有就标记。当下次有根标记这个对象A的时候，就不再检查内部字段了。这样能解决循环引用：根引用了A，A中有B导致B被标记，B中有A发现A已经被标记就不标记了。</p></li><li><p>  标记阶段结束，进入<strong>压缩</strong>阶段。这个阶段中CLR让堆中的所有幸存对象都紧挨在一起，使内存的地址空间得到释放。操作完内存后，将所有引用幸存对象的根减去所引用的对象在内存中偏移的字节数，从而保证每个根引用与以前一样的对象。</p></li></ol><p>结束GC后，如果GC并没有分出足够的内存给新的new操作，就会抛出OutOfMemoryException异常。</p><h3 id="根的作用域"><a href="#根的作用域" class="headerlink" title="根的作用域"></a>根的作用域</h3><p>根一旦离开作用域，它引用的对象就会变得“不可达”。</p><p>下面演示一个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object o</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now);</span><br><span class="line">    <span class="comment">// 执行一次强制垃圾回收</span></span><br><span class="line">    GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行会发现，程序只输出了一次，而不是每2秒一次。</p><p>原因是<code>GC.Collect();</code>这句，回收开始时，会假设堆中所有都对象不可达，而CLR发现Main方法再也没有继续用过变量t，所以会回收它的内存。</p><p>然而神奇的是，这么写也是不对的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">    <span class="comment">// 想在Read之后引用t但是失败了，因为编译器优化了这一段</span></span><br><span class="line">    t  = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方法应该这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">    <span class="comment">// 在Read之后引用t（在Dispose方法返回之前，t会在GC中存活）</span></span><br><span class="line">    t.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分代-Generation-算法"><a href="#分代-Generation-算法" class="headerlink" title="分代(Generation)算法"></a>分代(Generation)算法</h2><p><strong>假设原则</strong></p><p>CLR的GC对代码做出了以下几点假设：</p><ul><li>  对象越新，生存期越短。</li><li>  对象越老，生存期越长。</li><li>  回收堆的一部分，速度快于回收整个堆。</li></ul><p>以此为方针，制定GC的机制。</p><p><strong>回收机制</strong></p><p>简单来说就是回收时，不可达的直接销毁，可达的压缩并放到下一代中，称作“存活对象”。</p><p>CLR托管堆支持3代：第0代，第1代，第2代。便于理解，可以将第0代的空间理解为256KB，第1代理解为2M，第2代理解为10M。新构造的对象会被分配到第0代。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211228093933.png"></p><p>如上图所示，当第0代的空间满时，垃圾回收器启动回收，不可达对象(上图C、E)会被回收，存活的对象被归为第1代。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211228093946.png"></p><p>当第0代空间已满，第1代也开始有很多不可达对象以至空间将满时，这时两代垃圾都将被处理：存活下来的对象(可达对象)，第0代升为第1代，第1代升为第2代。</p><p><strong>“预算”机制</strong></p><p>如果说GC时，第1代中有一些“不可达”的存在，但是第1代已用的内存开销小于<strong>预算</strong>，那么就不用担心不够用，此时去扫描一遍第1代整体进行GC处理是非常多余的。所以这个时候，CLR就会选择<strong>忽略</strong>第1代的GC，直到某一次GC发现第1代的开销到达了预算。</p><p>实际CLR的代回收机制更加“智能”，如果新创建的对象生存周期很短，第0代垃圾也会立刻被垃圾回收器回收(不用等空间分配满)。另外，如果回收了第0代，发现还有很多对象“可达”，并没有释放多少内存，就会增大第0代的预算至512KB，回收效果就会转变为：垃圾回收的次数将减少，但每次都会回收大量的内存。如果还没有释放多少内存，垃圾回收器将执行完全回收(3代)，如果还是不够，则会抛出“内存溢出”异常。</p><p>也就是说，垃圾回收器会根据回收内存的大小，动态的调整每一代的分配空间预算！达到自动优化。</p><p><strong>GCNotification</strong></p><p>该类在 第0代 or 第2代 回收时引发一个事件，可用来计算2次回收的间隔时间、分配了多少内存。</p><h2 id="强制垃圾回收"><a href="#强制垃圾回收" class="headerlink" title="强制垃圾回收"></a>强制垃圾回收</h2><h3 id="垃圾回收触发方式"><a href="#垃圾回收触发方式" class="headerlink" title="垃圾回收触发方式"></a>垃圾回收触发方式</h3><ul><li>  0代超过预算时自动触发GC</li><li>  代码显式调用<strong>System.GC的静态Collect</strong>方法</li><li>  Windows报告低内存情况</li><li>  CLR正在卸载AppDomain、CLR正在关闭</li></ul><h3 id="System-GC"><a href="#System-GC" class="headerlink" title="System.GC"></a>System.GC</h3><p>GC.Collect最复杂的重载签名也就这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span>(<span class="params">Int32 generation, GCCollectionMode mode, Boolean blocking</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>  generation：最多回收到x代（最高2）。</li><li>  blocking：阻塞（非并发）或后台（并发）回收的一个Boolean值。</li><li>  mode：如下表。</li></ul><table><thead><tr><th>符号名称</th><th>说明 GCCollectionMode枚举类</th></tr></thead><tbody><tr><td>Default</td><td>等同于不传递任何符号名称。目前还等同于传递 Forced,但CLR未来的版本可能对此进行修改</td></tr><tr><td>Forced</td><td>强制回收指定的代（以及低于它的所有代）</td></tr><tr><td>Optimized</td><td>只有在能释放大量内存或者能减少碎片化的前提下，才执行回收。如果垃圾回收没有什么效率，当前调用就没有任何效果</td></tr></tbody></table><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>前面讨论的都是小对象，对于大对象（出书时是85000字节以上），CLR会区分对待：</p><p>内存不是在小对象的地址空间分配，而是进程地址空间的其他地方分配；总是第2代；目前不支持压缩。</p><h3 id="垃圾回收模式"><a href="#垃圾回收模式" class="headerlink" title="垃圾回收模式"></a>垃圾回收模式</h3><p>默认使用工作站GC模式，可以在配置文件中修改。</p><p><strong>工作站</strong></p><p>针对客户端的GC模式，假设其他应用程序不占用太多CPU资源。GC造成的延时很低，程序挂起时间很短。</p><p><strong>服务器</strong></p><p>针对服务端的GC模式，假设没有其他应用程序，所有的CPU都可用来辅助完成GC。优化了吞吐量和资源利用。每个CPU都跑一个特殊线程，它和其他线程并发回收自己的区域。</p><h2 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h2><h3 id="Finalize方法对GC过程的影响"><a href="#Finalize方法对GC过程的影响" class="headerlink" title="Finalize方法对GC过程的影响"></a>Finalize方法对GC过程的影响</h3><p>写代码时，理解的是GC时Finalize方法会被得到调用。实际上CLR是用了2个专门的列表来操作的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115018.png"></p><p>**一个是终结列表(finalization list)**，</p><p>对象创建(new)时，CLR检测到他们的Finalize方法被重写，就会把这些对象的指针扔进终结列表。</p><p>**另一个是F-reachable队列(finalization reachable Arrary)**，</p><p>一个无情的只顾执行对象Finalize方法然后将其移除的队列。</p><p>它们之间的协作：</p><p>终结列表中的对象在得知需要被回收后，会从终结列表转移到F-reachable队列中。此时，对象变得不在被认为是垃圾，还不能回收他的内存，被标记为垃圾但是不被认为是垃圾，叫<strong>复活</strong>了。垃圾回收器会递归该对象中所有的引用，让它们也不被内存回收，但是会被GC到更老的一代。<strong>下次GC时</strong>早已经执行完Finalize方法，会发现之前复活的对象们已经不可达，然后会回收。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115028.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115038.png"></p><h3 id="有一些特殊的类，需要清理本机资源"><a href="#有一些特殊的类，需要清理本机资源" class="headerlink" title="有一些特殊的类，需要清理本机资源"></a>有一些特殊的类，需要清理本机资源</h3><p>上面说的类都是只需要内存资源就行，但是有些类比如FileStream类型需要占用本机资源(打开文件保存句柄)。</p><p>GC清理不了这些本机资源。</p><p>这里就可以使用Finalize方法来<strong>清理本机资源</strong>。</p><h3 id="Finalize-1"><a href="#Finalize-1" class="headerlink" title="Finalize"></a>Finalize</h3><p>GC判定对象是垃圾后，会调用其Finalize方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeType</span>&#123;</span><br><span class="line">    ~SomeType() &#123; Finalize方法体 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; C#实际生成代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeType</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="title">Finalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           Finalize方法体 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">base</span>.Finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLR用一个特殊的高优先级的<strong>专用线程</strong>调用Finalize方法来避免死锁。Finalize方法如果阻塞(比如死循环)，会导致该线程瘫痪，致使整个程序内存不停泄露并无法捕捉到此异常。</p><h3 id="SafeHandle-CriticalFinalizerObject"><a href="#SafeHandle-CriticalFinalizerObject" class="headerlink" title="SafeHandle : CriticalFinalizerObject"></a>SafeHandle : CriticalFinalizerObject</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Safehandle</span> : <span class="title">CriticalFinalizerObject</span>, <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这是本机资源的句柄</span></span><br><span class="line"><span class="keyword">protected</span> IntPtr handle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Safehandle</span>(<span class="params">IntPtr invalidhandlevalue, Boolean ownsHandle</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.handle = invalidhandlevalue;</span><br><span class="line"><span class="comment">// 如果ownsHandle为true,那么这个从 Safehandle派生的对象被回收时，</span></span><br><span class="line"><span class="comment">//本机资源会被关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Sethandle</span>(<span class="params">IntPtr handle</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.handle = handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这个默认实现会忽略 disposing参数</span></span><br><span class="line"><span class="comment">// 如果资源已经释放，那么返回</span></span><br><span class="line"><span class="comment">// 如果 ownsHandle为false,那么返回</span></span><br><span class="line"><span class="comment">// 设置一个标志来指明该资源已经释放</span></span><br><span class="line"><span class="comment">// 调用虚方法 ReleaseHandle</span></span><br><span class="line"><span class="comment">// 调用GC, SuppressFinalize(this)方法来阻止调用Finalize方法</span></span><br><span class="line"><span class="comment">// 如果 ReleaseHandle返回true,那么返回</span></span><br><span class="line"><span class="comment">// 如果走到这一步，就激活 releaseHandleFailed托管调试助手（MDA)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的 Finalize实现（如下所示）正是我们希望的。强烈建议不要重写这个方法</span></span><br><span class="line">~Safehandle() &#123; Dispose(<span class="literal">false</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.需要重写以实现释放资源的代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">ReleaseHandle</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetHandleAsInvalid</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 设置标志来指出这个资源已经释放</span></span><br><span class="line"><span class="comment">// 调用GC, SuppressFinalize(this)方法来阻止调用Finalize方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> IsClosed</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 返回指出资源是否释放的一个标志</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.派生类要重写这个属性</span></span><br><span class="line"><span class="comment">// 如果句柄的值不代表资源(通常意味着句柄为0或-1),实现应返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> IsInvalid</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进一步深入了解SafeHandle类，上下都介绍一下：</p><p><strong>父类，CriticalFinalizerObject</strong></p><p>CLR特殊对待的类，它的行为：</p><ol><li>  首次构造时就进行此类Finalize方法JIT编译，保证不会出现内存满后无法编译Finalize导致无法执行的情况。</li><li>  在所有非CriticalFinalizerObject派生类的Finalize执行完后才开始执行它们的Finalize，这样非CriticalFinalizerObject派生类可以在Finalize中安全调用它们。</li><li>  AppDomain被宿主应用程序强行中断，也会调用CriticalFinalizerObject类的Finalize方法。</li></ol><p><strong>子类1，SafeFileHandle</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SafeFileHandle</span>: <span class="title">SafeHandleZeroOrMinusOneIsInvalid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeFileHandle</span>(<span class="params">Intptr preexistingHandle, Boolean ownsHandle</span>) : <span class="title">base</span>(<span class="params">ownshandle</span>)</span></span><br><span class="line">    &#123;     </span><br><span class="line"><span class="keyword">base</span>. Sethandle(preexistinghandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Boolean <span class="title">Releasehandle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 告诉 Windows我们希望本机资源关闭</span></span><br><span class="line">        <span class="keyword">return</span> Win32Native.CloseHandle(<span class="keyword">base</span>.handle);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GC句柄表"><a href="#GC句柄表" class="headerlink" title="GC句柄表"></a>GC句柄表</h3><p>是说CLR为每个AppDomain都提供了一个**GC句柄表(GC Handle table)<strong>，允许程序监视or手动控制对象的生存期。句柄表启动时是空白的，每个记录项都包含了</strong>对托管堆中的一个对象的引用，以及指出如何监视或控制对象的标志(flag)**。</p><p>使用<code>System.Runtime.InteropServices.GCHandle</code>类型在表中添加或删除记录项。在表中创建一个记录项调用该类的<code>public static GCHandle Alloc(object value, GCHandleType type);</code>，对象+标志。</p><p><strong>GCHandleType</strong>有下面4种枚举类：</p><p><strong>Weak</strong><br>该标志允许监视对象的生存期。具体地说，可检测垃圾回收器在什么时候判定该对象<br>在应用程序代码中不可达。注意，此时对象的 Finalize方法可能执行，也可能没有执<br>行，对象可能还在内存中。</p><p><strong>Weaktrackresurrection</strong><br>该标志允许监视对象的生存期。具体地说，可检测垃圾回收器在什么时候判定该对象<br>在应用程序的代码中不可达。注意，此时对象的 Finalize方法（如果有的话）已经执行，<br>对象的内存已经回收。</p><p><strong>Normal</strong><br>该标志允许控制对象的生存期。具体地说，是告诉垃圾回收器：即使应用程序中没有<br>变量（根）引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存可<br>以压缩（移动）。不向Ale方法传递任何 Gchandle Type标志，就默认使用<br>Gchandle T’ype Normal</p><p><strong>Pinned</strong><br>该标志允许控制对象的生存期。具体地说，是告诉垃圾回收器：即使应用程序中没有<br>变量（根）引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存不<br>能压缩（移动）。需要将内存地址交给本机代码时，这个功能很好用。本机代码知道GC<br>不会移动对象，所以能放心地向托管堆的这个内存写入。</p><h1 id="大章22：CLR寄宿和AppDomain"><a href="#大章22：CLR寄宿和AppDomain" class="headerlink" title="大章22：CLR寄宿和AppDomain"></a><center>大章22：CLR寄宿和AppDomain</center></h1><h2 id="CLR寄宿"><a href="#CLR寄宿" class="headerlink" title="CLR寄宿"></a>CLR寄宿</h2><p>**寄宿(hosting)**使任何应用程序都能使用CLR的功能。</p><p>所有托管模块和程序集文件都必须使用 Windows PE文件格式，而且要么是 Windows EXE文件，要么是DLL文件。</p><p><strong>开发CLR时， Microsoft实际是把它实现成包含在一个DLL中的COM服务器。</strong>很遗憾，这一句对于目前的我来说还无法深入理解，放着吧。</p><p>**垫片(slim)**，MSCorEE.dll。</p><p>CLRCreateInstance函数在MSCorEE.dll文件中实现。“垫片”的工作是决定创建哪个版本的CLR（1.0、2.0、3.0的CLR代码在MSCorWks.dll文件中；版本4则在Clr.dll文件中）。CLRCreateInstance函数可返回一个ICLRMetaHost接口。宿主应用程序可调用这个接口的GetRuntime函数，指定宿主要创建的CLR版本。然后，垫片将所需版本的CLR加载到宿主的进程中。</p><h2 id="初识AppDomain"><a href="#初识AppDomain" class="headerlink" title="初识AppDomain"></a>初识AppDomain</h2><p><strong>AppDomain是什么</strong></p><p>CLR COM服务器初始化时会创建一个AppDomain。<strong>AppDomain是一组程序集的逻辑容器，它存在的目的是为了隔离。</strong>CLR初始化时创建的第一个AppDomain称为“默认AppDomain”，这个默认的AppDomain只有在Windows进程终止时才会被销毁。</p><p>在 Windows中，线程总是在一个进程的上下文中创建，而且线程的整个生存期都在该进程的生存期内。<strong>但线程和Appdomain没有一对一关系。</strong>一个Windows进程可包含多个Appdomain，所以线程能执行一个Appdomain中的代码，再执行另一个AppDomain中的代码。从CLR的角度看，<strong>线程一次只能执行一个Appdomain中的代码。</strong></p><p><strong>AppDomain长这样</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230160015.png"></p><p>AppDomain #1和AppDomain #2完全不共享信息，以至于他们都用了System.dll却不共用。虽然有些浪费内存资源，但是这就是AppDomain的本质，“隔离”。</p><p>另外针对这种浪费，CLR也提供了一种<strong>AppDoamin中立</strong>加载方式的程序集。CLR会为它们维护一个特殊的Loader堆，该Loader堆中的所有资源都会共享给同一个进程中的其他AppDomain。省下资源的代价是这样的程序集永远不能卸载，只能终止Windows进程让Windows回收资源。</p><p><strong>AppDomain特点</strong></p><p><strong>①一个AppDomain的代码不能直接访问另一个AppDomain的代码创建的对象。</strong><br>一个AppDomain中的代码创建了一个对象后，该对象便被该AppDomain“拥有”。换言之，它的生存期不能超过创建它的代码所有的AppDomain。一个AppDomain中的代码要访问另一个AppDomain的对象，只能使用“按引用封送”或者“按值封送”的予以。这就强制建立了清晰的分割和边界，因为一个AppDomain中的代码不能直接引用另一个AppDomain中的代码创建的对象。这种隔离使AppDomain能很容易地从进程中卸载，不会影响其他AppDomain正在运行的代码<br><strong>②AppDomain可以卸载</strong><br>CLR不支持从AppDomain中卸载特定的程序集，但可以告诉CLR卸载一个AppDomain，从而卸载该AppDomain当前包含的所有程序集<br><strong>③AppDomain可以单独保护</strong><br>AppDomain创建后会应用一个权限集，它决定了想这个AppDomain中运行的程序集授予最大权限，正是由于存在这样的权限，所以当宿主加载一些代码后，可以保证这些代码不会破坏（或读取）宿主本身使用的一些重要数据结构<br><strong>④AppDomain可以单独配置</strong><br>AppDomain创建后会关联一组配置设置。这些设置主要影响CLR在AppDomain中加载程序集的方式，设计搜索路径、版本绑定重定向、卷影复制以及加载器优化</p><p><strong>跨越AppDomain边界访问对象</strong></p><p>一个AppDomain中的代码可以和另一个AppDomain中的类型和对象通信，但只能通过良好定义的机制执行。</p><p>抄个网上的可运行demo，做了解吧，以后深入ILRuntime之后再补一些理解：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication7</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Marshalling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Marshalling</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取AppDomain引用（“调用线程”当前正在该AppDomain中执行）</span></span><br><span class="line">AppDomain adCallingThreadDomain = Thread.GetDomain();</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个AppDomain都分配了友好字符串名称（以便调试）</span></span><br><span class="line"><span class="comment">//获取这个AppDomain的友好名称并显示它</span></span><br><span class="line">String CallingDomainName = adCallingThreadDomain.FriendlyName;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;默认AppDomain友好的名称=&#123;0&#125;&quot;</span>, adCallingThreadDomain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并显示我们的AppDomain中包含了“Main”方法的程序集</span></span><br><span class="line">String exeAssembly = Assembly.GetEntryAssembly().FullName;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;包含“Main”方法的程序集=&#123;0&#125;&quot;</span>, exeAssembly);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义局部变量来引用一个AppDomain</span></span><br><span class="line">AppDomain ad2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line"><span class="comment">//************************************************************ DEMO 1：使用“按引用封送”进行跨AppDomain通信 ***</span></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; Demo1 按引用封送&quot;</span>, Environment.NewLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个AppDomain（从当前AppDomain继承安全性和配置）</span></span><br><span class="line">ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">MarshalByRefType mbrt = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将我们的程序集加载到新AppDomain,构造一个对象，把它封送回我们的AppDomain（实际得到对一个代理的引用）</span></span><br><span class="line">mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Type=&#123;0&#125;&quot;</span>, mbrt.GetType());<span class="comment">//CLR在类型上撒谎了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//证明得到的是对一个代理对象的引用</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Is proxy=&#123;0&#125;&quot;</span>, RemotingServices.IsTransparentProxy(mbrt));</span><br><span class="line"></span><br><span class="line"><span class="comment">//看起来像是在MarshalByRefType上调用了一个方法，实则不然。</span></span><br><span class="line"><span class="comment">//我们是在代理类型上调用了一个方法，代理是线程切换到拥有对象的那个</span></span><br><span class="line"><span class="comment">//AppDomain,并在真实的对象上调用这个方法</span></span><br><span class="line">mbrt.SomeMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载新的AppDomain</span></span><br><span class="line">AppDomain.Unload(ad2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时，mbrt引用了一个有效的代理对象；代理对象引用一个无效的AppDomain</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">mbrt.SomeMethod();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch (AppDomainUnloadedException)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用失败，AppDomain被卸载了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line"><span class="comment">//************************************************************ DEMO 2：使用“按值封送”进行跨AppDomain通信 ***</span></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; Demo2 按值封送&quot;</span>, Environment.NewLine);</span><br><span class="line">ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的方法返回所返回对象的副本</span></span><br><span class="line"><span class="comment">//对象按值（而非按引用）封送</span></span><br><span class="line">MarshalByValType mbvt = mbrt.MethodWithReturn();</span><br><span class="line"><span class="comment">//证明得到的是对一个代理对象的引用</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Is proxy=&#123;0&#125;&quot;</span>, RemotingServices.IsTransparentProxy(mbvt));</span><br><span class="line"><span class="comment">//看起来在MarshalByValType上调用一个方法，实际也是如此</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Return object created &quot;</span> + mbvt.ToString());</span><br><span class="line"><span class="comment">//卸载新的AppDomain</span></span><br><span class="line">AppDomain.Unload(ad2);</span><br><span class="line"><span class="comment">//此时，mbrt引用了一个有效的x代理对象；代理对象引用一个无效的AppDomain</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//卸载AppDomain之后调用mbvt方法不会抛出异常</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Return object created &quot;</span> + mbvt.ToString());</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch (AppDomainUnloadedException)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;调用失败，AppDomain被卸载了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line"><span class="comment">//************************************************************ DEMO 3：使用不可封送的类型进行跨AppDomain通信 ***</span></span><br><span class="line"><span class="comment">//************************************************************************************************************</span></span><br><span class="line">ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">NonMarshalableType nmt = mbrt.MethodArgAndReturn(CallingDomainName);<span class="comment">//抛出异常:未标记为可序列化</span></span><br><span class="line">&#125;</span><br><span class="line">catch (SerializationException)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;抛出异常:未标记为可序列化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该类型的实例可跨越AppDomain的边界“按引用封送”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByRefType</span> : <span class="title">MarshalByRefObject</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MarshalByRefType</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; ctor running in &#123;1&#125;&quot;</span>, GetType(), Thread.GetDomain().FriendlyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Executing in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MarshalByValType <span class="title">MethodWithReturn</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Execute in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">MarshalByValType t = <span class="keyword">new</span> MarshalByValType();</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> NonMarshalableType <span class="title">MethodArgAndReturn</span>(<span class="params"><span class="built_in">string</span> callingDomainName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意：callingDomainName是可序列化的</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Calling from &#x27;&#123;0&#125;&#x27; to &#x27;&#123;1&#125;&#x27;.&quot;</span>, callingDomainName, Thread.GetDomain().FriendlyName);</span><br><span class="line">NonMarshalableType t = <span class="keyword">new</span> NonMarshalableType();</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该类的实例可跨越AppDomain的边界“按值封送”</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByValType</span> : <span class="title">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> DateTime m_creationTime = DateTime.Now;<span class="comment">//注意：DateTime是可序列化的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MarshalByValType</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; ctor running in &#123;1&#125;, Created no &#123;2:D&#125;&quot;</span>, GetType(), Thread.GetDomain().FriendlyName,</span><br><span class="line">m_creationTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_creationTime.ToLongDateString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该类的实例不能跨AppDomain边界进行封送</span></span><br><span class="line"><span class="comment">//[Serializable]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">NonMarshalableType</span> : <span class="title">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NonMarshalableType</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Execute in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作AppDomain"><a href="#操作AppDomain" class="headerlink" title="操作AppDomain"></a>操作AppDomain</h2><h3 id="卸载AppDomain"><a href="#卸载AppDomain" class="headerlink" title="卸载AppDomain"></a>卸载AppDomain</h3><p>调用<strong>AppDomain的静态Unload方法</strong>可以实现卸载，CLR会按顺序执行以下操作：</p><ol><li>  挂起进程中的所有线程。</li><li>  检查每一个线程栈，如果线程在执行即将卸载的AppDomain中的代码，就抛出一个ThreadAbortException，并执行所有遇到的finally块。线程终止，进程可继续运行。</li><li>  所有线程离开目标AppDomain后，CLR遍历堆，为所有引用了目标AppDomain中的对象设置一个标志，告诉它们引用的真实对象已经不在了，再调用它们会抛出AppDomainUnloadedException异常。</li><li>  强制垃圾回收目标AppDomain的对象。</li><li>  Unload执行完毕，恢复剩余所有线程运行，此刻调用了AppDomain.Unload方法的线程才会继续运行。</li></ol><h3 id="监视AppDomain"><a href="#监视AppDomain" class="headerlink" title="监视AppDomain"></a>监视AppDomain</h3><p>// TODO 本章后续的内容等实际工作用到再看吧。</p><h1 id="大章23：程序集加载和反射"><a href="#大章23：程序集加载和反射" class="headerlink" title="大章23：程序集加载和反射"></a><center>大章23：程序集加载和反射</center></h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><h3 id="程序集可以用Load加载"><a href="#程序集可以用Load加载" class="headerlink" title="程序集可以用Load加载"></a>程序集可以用Load加载</h3><p>使用System.Reflection.Assembly类的静态Load方法可以在运行时加载程序集。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">publiv <span class="keyword">class</span> <span class="title">Assembly</span>&#123;</span><br><span class="line">    <span class="comment">// 2种常用重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">Load</span>(<span class="params">AssemblyName assemblyRef</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">Load</span>(<span class="params">String assemblyString</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据路径加载，内部只是找到AssemblyName作为参数传给Load方法</span></span><br><span class="line">    <span class="comment">// ex: Assembly a  = Assembly.LoadFrom(@&quot;http://Wintellect.com/SomeAssembly.dll&quot;);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">LoadFrom</span>(<span class="params">String assemblyString</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和Load不同的是，不会用版本策略，指定哪个版本就用那个版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">ReflectionOnlyLoadFrom</span>(<span class="params">String assemblyFile</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Load内部，CLR会应用绑定重定向"><a href="#在Load内部，CLR会应用绑定重定向" class="headerlink" title="在Load内部，CLR会应用绑定重定向"></a>在Load内部，CLR会应用绑定重定向</h3><p>在GAC(全局程序集缓存）中查找程序集。如果没找到就接着去应用程序的基目录、私有路径子目录和 codebase位置查找。如果调用Load时传递的是<a href="https://www.cnblogs.com/w6w6/p/10592356.html">弱命名程序集</a>，Load就不会向程序集应用版本绑定重定向策略，CLR也不会去GAC査找程序集。</p><p>找到指定程序集后，会返回对代表已加载程序集的一个Assembly对象的引用，否则会抛出IO异常。</p><h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><h3 id="使用反射构建动态可扩展应用程序"><a href="#使用反射构建动态可扩展应用程序" class="headerlink" title="使用反射构建动态可扩展应用程序"></a>使用反射构建动态可扩展应用程序</h3><p>通过反射的运行时序列化，使得应用程序在运行时可显式加载程序集构造类型的实例，再调用类型中定义的方法，这种绑定方法叫做<strong>晚期绑定</strong>。</p><h3 id="反射的性能"><a href="#反射的性能" class="headerlink" title="反射的性能"></a>反射的性能</h3><ol><li>  反射造成编译时无法保证类型安全性，严重依赖字符串。搜索”int”是没法找到”System.Int32”的。</li><li>  反射速度慢。</li></ol><p>针对第2点，提一些具体情况来理解慢在哪里：</p><ul><li>  类型及其成员的名称在编译时未知，需要用字符串名称标识每个类型以及成员。<strong>反射机制会不停的对字符串进行搜索。</strong></li><li>  用反射调用方法时，必须将实参打包(pack)成数组；在内部，反射必须将这些实参解包(unpack)到线程栈上。导致CLR必须检查实参的数据类型是否正确、以及访问权限。</li></ul><p>那么针对反射速度慢，有一些常见构造方案来实现类的动态行为，避免反射：</p><ul><li>  <strong>继承+重载</strong>。用父类变量接子类实例(转型)，再调用基类虚方法。</li><li>  <strong>接口</strong>。用接口变量接实例(转型)，再调用接口定义的方法。</li></ul><h3 id="来点反射代码"><a href="#来点反射代码" class="headerlink" title="来点反射代码"></a>来点反射代码</h3><h4 id="程序集-反射"><a href="#程序集-反射" class="headerlink" title="程序集+反射"></a>程序集+反射</h4><p>通过反射获取一个程序集定义了哪些类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        String dataAssembly =<span class="string">&quot;System, Data, veraionm4,0.0.0, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;culture-neutral, Publickeytoken=b77a5c561934e089&quot;</span>;</span><br><span class="line">        LoadAssemAndShowPublicTypes(dataAssembly);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadAssemAndShowPublicTypes</span>(<span class="params">String assemId</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 显式地将程序集加载到这个Appdomain中</span></span><br><span class="line">        Assembly a =  Assembly.Load(assemId);</span><br><span class="line">        <span class="comment">// 在一个循环中显示已加载程序集中每个公开导出Type的全名</span></span><br><span class="line">        <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> a.Exportedtypes)&#123;</span><br><span class="line">            <span class="comment">//显示类型全名</span></span><br><span class="line">            Console.Writeline(t.Fullname):</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h4><p>Type只是轻量级的对象引用，想要更多类型信息，可用TypeInfo对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type someType = <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line">TypeInfo info = someType.GetTypeInfo(); <span class="comment">// Extensions:System.Reflection.Introspections.GetTypeInfo </span></span><br></pre></td></tr></table></figure><h4 id="批量加载"><a href="#批量加载" class="headerlink" title="批量加载"></a>批量加载</h4><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106144143.png"></p><h3 id="反射构造类型实例"><a href="#反射构造类型实例" class="headerlink" title="反射构造类型实例"></a>反射构造类型实例</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol><li>  System.Activator 的 CreateInstance 方法。</li><li>  System.Activator 的 CreateInstanceFrom 方法。</li><li>  System.AppDomain 的方法。4种实例方法，可以指定在哪个AppDomain中构造对象。</li><li>  System.Reflection.ConstructorInfo 的 Invoke 实例方法。绑定到特定的构造器到ConstructorInfo 中。</li></ol><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>System.Array 的 静态CreateInstance方法。</p><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>MethodInfo 的 静态CreateDelegate方法。</p><h4 id="开放类型"><a href="#开放类型" class="headerlink" title="开放类型"></a>开放类型</h4><p>MakeGenericType方法。</p><p>![image-20220106145501671](E:\My Github\hexo\blog\source_posts\Tech\CSharp\CLR-Via-CSharp\cp6.assets\image-20220106145501671.png)</p><h2 id="反射-程序集加载-设计支持加载项的应用程序⭐"><a href="#反射-程序集加载-设计支持加载项的应用程序⭐" class="headerlink" title="反射+程序集加载 = 设计支持加载项的应用程序⭐"></a>反射+程序集加载 = 设计支持加载项的应用程序⭐</h2><p><strong>接口是中心。</strong>假设要写一个应用程序来无缝地加载和使用别人创建的类型，</p><ol><li>  创建“宿主SDK (Host SDK)”程序集，<strong>接口的方法</strong>作为宿主应用程序与加载项之间的通信机制使用。</li><li>  创建单独的“宿主应用程序”程序集，引用“宿主SDK”程序集，随意开发。</li></ol><p><strong>来看一个上述的例子</strong>：</p><p>首先是<strong>宿主SDK</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostSDK.dll 程序集</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Wintellect.HostSDK</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAddIn</span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">DoSomething</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次是引用了HostSDK.dll的<strong>AddInTypes.dll程序集</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddInTypes.dll 程序集</span></span><br><span class="line"><span class="keyword">using</span> Wintellect.HostSDK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AddIn_A</span> : <span class="title">IAddIn</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddIn_A</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddIn_A:&quot;</span> + x.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AddIn_B</span> : <span class="title">IAddIn</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddIn_B</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddIn_B:&quot;</span> + (x * <span class="number">2</span>).ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们写一个简单的Host.exe程序集的代码，也就是<strong>宿主应用程序</strong>。它必须引用HostSDK.dll程序集。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Host.exe 程序集</span></span><br><span class="line"><span class="keyword">using</span> Wintellect.HostSDK;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找宿主EXE文件所在的目标</span></span><br><span class="line">        String AddInDir = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);</span><br><span class="line">        <span class="comment">// 假定加载项程序集和宿主EXE文件在一个目录</span></span><br><span class="line">        <span class="keyword">var</span> AddInAssemblies = Directory.EnumerateFiles(AddInDir, <span class="string">&quot;*.dll&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建可由宿主使用的所有加载Type的一个集合</span></span><br><span class="line">        <span class="keyword">var</span> AddInTypes = </span><br><span class="line">            <span class="keyword">from</span> file <span class="keyword">in</span> AddInAssemblies</span><br><span class="line">            <span class="keyword">let</span> assembly = Assembly.Load(file)</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> assembly.ExportedTypes <span class="comment">// 公开导出的类型</span></span><br><span class="line">            <span class="comment">// 如果类型实现了IAddIn接口，该类型就可由宿主使用。A.IsAssignableFrom(B) 查看B是否实现or继承了A。</span></span><br><span class="line">            <span class="keyword">where</span> t.IsClass &amp;&amp; <span class="keyword">typeof</span>(IAddIn).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo())</span><br><span class="line">            <span class="keyword">select</span> t;</span><br><span class="line">        <span class="comment">// 初始化完成:宿主已发现了所有可用的加载项</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面示范宿主如何构造加载项对象并使用它们</span></span><br><span class="line">        <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> AddInTypes)&#123;</span><br><span class="line">            IAddIn ai = (IAddIn) Activator.CreateInstance(t);</span><br><span class="line">            Console.WriteLine(ai.DoSth(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用反射发现类型的成员"><a href="#使用反射发现类型的成员" class="headerlink" title="使用反射发现类型的成员"></a>使用反射发现类型的成员</h2><p>揭示WPF、ILDasm等的窗体设计器是如何利用反射实现需求的。</p><h3 id="反射获取类型成员"><a href="#反射获取类型成员" class="headerlink" title="反射获取类型成员"></a>反射获取类型成员</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106164233.png"></p><p>可以先用<code>System.Reflection.MemberInfo</code>抽象基类来接对象，然后再具体判别是什么：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();</span><br><span class="line">    <span class="keyword">foreach</span>(Assembly a <span class="keyword">in</span> assemblies) &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(Type t <span class="keyword">in</span> a.ExportedTypes) &#123;</span><br><span class="line">            <span class="keyword">foreach</span>(MemberInfo mi <span class="keyword">in</span> t.GetTypeInfo().DeclaredMembers) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> Type) &#123; 嵌套类型 &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> FieldInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> MethodInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> ConstructorInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> PropertyInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> EventInfo) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聊下MemberInfo"><a href="#聊下MemberInfo" class="headerlink" title="聊下MemberInfo"></a>聊下MemberInfo</h3><p>上面看到了MemberInfo类是成员层次结构的根，它的实现意味着所有派生成员的实现。下面解析下它：</p><h4 id="MemberInfo属性和方法"><a href="#MemberInfo属性和方法" class="headerlink" title="MemberInfo属性和方法"></a>MemberInfo属性和方法</h4><ul><li>  Name。成员名称</li><li>  DeclaringType。成员类型。</li><li>  Module。</li><li>  CustomAttributes。返回一个<code>IEnumerable&lt;CustomAttributeData&gt;</code>，特性实例。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106172200.png"></p><h4 id="MemberInfo调用"><a href="#MemberInfo调用" class="headerlink" title="MemberInfo调用"></a>MemberInfo调用</h4><p><strong>FieldInfo</strong><br>调用 Getvalue获取字段的值<br>调用 Setvalue设置字段的值</p><p><strong>Constructorlnfo</strong><br>调用 Invoke构造类型的实例并调用构造器</p><p><strong>MethodInfo</strong><br>调用 Invoke来调用类型的方法</p><p><strong>PropertyInfo</strong><br>调用 Getvalue来调用的属性的get访问器方法<br>调用 Setvalue来调用属性的set访问器方法</p><p><strong>Eventlnfo</strong><br>调用 Addeventhandler来调用事件的add访问器方法<br>调用 Removeeventhandler来调用事件的 remove访问器方法</p><h4 id="使用绑定句柄减少进程的内存消耗"><a href="#使用绑定句柄减少进程的内存消耗" class="headerlink" title="使用绑定句柄减少进程的内存消耗"></a>使用绑定句柄减少进程的内存消耗</h4><p>很多情况下会这么写代码：绑定了一组类型(Type)或类型成员(MemberInfo派生)，并将这些对象保存在某种形式的集合中。然后只需要搜索这个集合就可以找到特定对象，并调用(比如Invoke)它。</p><p>这样写很方便，但是会导致一个问题，Type和MemberInfo派生对象需要大量内存，如果只是偶尔调用会造成严重浪费。</p><p>可以使用**运行时句柄(runtime handle)**代替对象以减小该Assembly的内存占用。使用System下的<code>RuntimeTypeHandle</code>、<code>RuntimeFieldHandle</code>、<code>RuntimeMethodHandle</code>。三个类型都是值类型，只包含了一个IntPtr，也就是一个句柄，指向AppDomain的Loader堆中的一个类型/方法/字段。可以使用<code>Type.GetTypeFromHandle</code>和<code>Type.GetTypeHandle</code>方法实现Type和IntPtr的相互转换。</p><h1 id="大章24：运行时序列化"><a href="#大章24：运行时序列化" class="headerlink" title="大章24：运行时序列化"></a><center>大章24：运行时序列化</center></h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>序列化是将<strong>对象or对象图(比如数组)<strong>转换成</strong>字节流</strong>的过程，反序列化是将字节流转换回对象图的过程。</p><p>再举一些例子：</p><ul><li>  ASP.NET利用序列化反序列化来保存和还原会话状态。</li><li>  WPF的对象剪切板由序列化反序列化实现。</li><li>  深拷贝/备份 对象</li><li>  不同端末之间的交互（pc与服务器）</li></ul><h3 id="序列化反序列化API"><a href="#序列化反序列化API" class="headerlink" title="序列化反序列化API"></a>序列化反序列化API</h3><p>微软提供 BinaryFormatter 和 SoapFormatter 两个格式化器，他们都是实现了<code>System.Runtime.Serialization.IFormatter</code>这个序列化专用的接口。</p><p>SoapFormatter在.net3.5废了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectGraph = <span class="keyword">new</span> List&lt;String&gt; &#123; <span class="string">&quot;Jeff&quot;</span>, <span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Grant&quot;</span> &#125;;</span><br><span class="line">MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 to stream</span></span><br><span class="line">formatter.Serialize(stream, objectGraph);</span><br><span class="line"><span class="comment">// 反序列化 to obj</span></span><br><span class="line">stream.Position = <span class="number">0</span>; <span class="comment">// 流的当前位置归零!否则在末尾</span></span><br><span class="line">Object obj = formatter.Deserialize(stream);</span><br></pre></td></tr></table></figure><p>序列化对象之后，会将类型的全名和字段都写入流中，甚至还会将程序集的信息写入进去。</p><p>我们尝试一下，发现直接转字符串是不行的，也是毕竟是流，要先转Byte，再转成人能看的懂的字节：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> readBuffer = <span class="keyword">new</span> <span class="built_in">byte</span>[stream.Length];</span><br><span class="line"><span class="built_in">int</span> count = stream.CanRead ? stream.Read(readBuffer, <span class="number">0</span>, readBuffer.Length) : <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> charCount = Encoding.Default.GetCharCount(readBuffer, <span class="number">0</span>, count);</span><br><span class="line"><span class="keyword">var</span> readCharArray = <span class="keyword">new</span> <span class="built_in">char</span>[charCount];</span><br><span class="line"></span><br><span class="line">Encoding.Default.GetDecoder().GetChars(readBuffer, <span class="number">0</span>, count, readCharArray, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; readCharArray.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    test += readCharArray[i];</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(test);</span><br></pre></td></tr></table></figure><p>最后输出这么个东西，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">&quot;\0\u0001\0\0\0\u0001\0\0\0\0\0\0\0\u0004\u0001\0\0\0\u007fSystem.Collections.Generic.List`1[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\u0003\0\0\0\u0006_items\u0005_size\b_version\u0006\0\0\b\b\t\u0002\0\0\0\u0003\0\0\0\u0003\0\0\0\u0011\u0002\0\0\0\u0004\0\0\0\u0006\u0003\0\0\0\u0004Jeff\u0006\u0004\0\0\0\u0005Aidan\u0006\u0005\0\0\0\u0005Grant\n\v&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理一下上面</span></span><br><span class="line">System.Collections.Generic.List`<span class="number">1</span>[[System.String, mscorlib, Version=<span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>, Culture=neutral, PublicKeyToken=b77a5c561934e089]]</span><br><span class="line">_items</span><br><span class="line">_siz_versio</span><br><span class="line">Jeff Aidan Grant</span><br></pre></td></tr></table></figure><p>转义符很多，程序集信息、字段信息确实都在里面。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>可以看到上面的那一串东西，</p><p>反序列化时，格式化器先获取程序集标识信息，并通过调用System.Reflection.Assembly的Load方法确保程序集已加载到正在执行的 Appdomain中。</p><p>然后在程序集中查找对应的类型，找不到就抛出异常。</p><p>找到类型就创建类型实例，并用流中的值对其字段初始化。如果字段名不完全匹配，就抛出SerializationException异常。</p><h2 id="使类型可序列化"><a href="#使类型可序列化" class="headerlink" title="使类型可序列化"></a>使类型可序列化</h2><h3 id="SerializebleAttribute"><a href="#SerializebleAttribute" class="headerlink" title="SerializebleAttribute"></a>SerializebleAttribute</h3><p>直接序列化一个类，会抛出SerializationException异常。因为你没有使用定制特性**[SerializebleAttribute]**。</p><p>该定制特性只能应用于<strong>引用类型(class)、值类型(struct)、枚举类型(enum)和委托类型(delegate)<strong>。其中，</strong>枚举类型和委托类型</strong>不必申明，他们总是可序列化的；对于<strong>类</strong>，可序列化特性不能被子类继承，但基类型如果不被申明可序列化那么子类无法可序列化，毕竟父类是子类的一部分。</p><h3 id="控制序列化和反序列化"><a href="#控制序列化和反序列化" class="headerlink" title="控制序列化和反序列化"></a>控制序列化和反序列化</h3><p>使用**[NonSerialized]**特性来使部分字段不参与序列化。</p><p>使用**[OnDeserialized]**特性来控制反序列化。它是用来修饰方法的，当实例所有字段被反序列化完后，方法才会被执行。你可以在里面给忽略的字段赋值或者标准化数据。</p><p>同样的还有特性**[OnDeserializing] (反序列化前)<strong>、</strong>[OnSerializing] (序列化前)<strong>、</strong>[OnSerialized]  (序列化后)**。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面4个特性时，必须获取一个StreamingContext参数并返回void：</span></span><br><span class="line">[<span class="meta">OnSerialized</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSerialized</span>(<span class="params">StreamingContext context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 举例：在序列化后，恢复任何需要恢复的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格式化器序列化流程"><a href="#格式化器序列化流程" class="headerlink" title="格式化器序列化流程"></a>格式化器序列化流程</h3><p>微软提供了FormatterServices类型，里面只有静态方法，下面刨析一下流程。</p><p>序列化：</p><ol><li>格式化器调用 Formatterservices的 GetSerializableMembers方法，<strong>反射获取类型的字段</strong>。<br>  <code>public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context)</code></li><li>  格式化器调用 Formatterservices的 GetObjectData方法，该方法<strong>输入一个MemberInfo[]输出一个Object[]，而输出的Object[]是MemberInfo[]对应字段的值</strong>，两者一一对应。<code>public static Object[] GetObjectData(Object obj, MemberInfo[] members)</code></li><li>  格式化器将程序集标识和类型的完整名称写入流中。</li><li>  格式化器然后遍历两个数组中的元素，将每个成员的名称和值写入流中。</li></ol><p>反序列化：</p><ol><li>  格式化器从流中读取程序集标识和完整类型名称，如果程序集没加载到AppDomain中，就会加载它。确保程序集被加载后，格式化器将程序集标识信息和类型全名传给 FormatterServices的静态方法 GetTypeFromAssembly来<strong>获取反序列化对象的Type</strong>。<code>public static Type GetTypeFromAssembly(Assembly assem, String name)</code></li><li>  格式化器调用 FormatterServices的静态方法 GetUninitializedObject，<strong>为对象分配内存并初始化字段</strong>为null、0，但不调用构造器。<code>public static Object GetUninitializedObject(Type type)</code></li><li>  格式化器调用 Formatterservices的 GetSerializableMembers方法，<strong>构造并初始化一个MemberInfo[] 数组</strong>，等待着对应的字段值。</li><li>  格式化器根据流中包含的数据<strong>创建并初始化一个 Object数组</strong>，是与3中一一对应的字段值。</li><li>将新分配对象、 MemberInfo[] 数组以及并行 Object数组（其中包含字段值）的引用传给<br>  FormatterServices的静态方法 PopulateObjectMembers：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">PopulateObjectMembers</span>(<span class="params">Object obj, MemberInfo[] members, Object[] data</span>)</span>;</span><br></pre></td></tr></table></figure><p>这个方法遍历数组，将每个字段初始化成对应的值。</p><h2 id="完全控制序列化-反序列化"><a href="#完全控制序列化-反序列化" class="headerlink" title="完全控制序列化/反序列化"></a>完全控制序列化/反序列化</h2><p>可以自己定义序列化和序列化的方法，来实现完全控制，具体是用<strong>ISerializable和IDeserializationCallback</strong>来实现。</p><h3 id="ISerializable-接口"><a href="#ISerializable-接口" class="headerlink" title="ISerializable 接口"></a>ISerializable 接口</h3><p>只有GetObjectData一个方法，但是同时需要提供一个特殊签名的构造器，反序列化的时候会调用那个构造器，一般拿来暂存 SerializationInfo。</p><h3 id="IDeserializationCallback接口"><a href="#IDeserializationCallback接口" class="headerlink" title="IDeserializationCallback接口"></a>IDeserializationCallback接口</h3><p>只有OnDeserialization一个方法。当然你可以不把赋值逻辑写在这里，可以直接写在构造器里，就不必实现本接口。</p><h3 id="看个例子"><a href="#看个例子" class="headerlink" title="看个例子"></a>看个例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ISerializable</span>,<span class="title">IDeserializationCallback</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> A;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> B;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存序列化用的字段</span></span><br><span class="line">    <span class="keyword">private</span> SerializationInfo _info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ISerializable 接口要求实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">info.AddValue(<span class="string">&quot;A&quot;</span>,A);</span><br><span class="line">info.AddValue(<span class="string">&quot;B&quot;</span>,B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特别签名的构造器，接口不要求实现，但是反序列化Deserialize的时候会被调用，没有会抛错，且不保存后续调不到SerializationInfo的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Test</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_info = info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDeserializationCallback 接口要求实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDeserialization</span>(<span class="params"><span class="built_in">object</span> sender</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">A = (<span class="built_in">string</span>)_info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">B = (<span class="built_in">string</span>)_info.GetValue(<span class="string">&quot;B&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动为父类实现-ISerializable"><a href="#手动为父类实现-ISerializable" class="headerlink" title="手动为父类实现 ISerializable"></a>手动为父类实现 ISerializable</h3><p>有时候父类没实现ISerializable，子类却想实现ISerializable来完全控制序列化，那么可以手动为父类实现 ISerializable。</p><p>观察下面代码，关键在于<code>info.GetValue(baseType.FullName + &quot;+&quot; + fi.Name, fi.FieldType)</code>和<code>info.AddValue(baseType.FullName + &quot;+&quot; + mi[i].Name, ((FieldInfo) mi[i]).GetValue(this));</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISerializable 接口要求的特殊构造器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Test</span> (<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 手动为父类实现序列化</span></span><br><span class="line">Type baseType = <span class="keyword">this</span>.GetType().BaseType;</span><br><span class="line">MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;mi.Length; i++)&#123;</span><br><span class="line">        FieldInfo fi = (FieldInfo) mi[i];</span><br><span class="line">        fi.SetValue(<span class="keyword">this</span>, info.GetValue(baseType.FullName + <span class="string">&quot;+&quot;</span> + fi.Name, fi.FieldType)); <span class="comment">// 这一句很关键</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后实现本类的序列化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span>&#123;</span><br><span class="line">    Type baseType = <span class="keyword">this</span>.GetType().BaseType;</span><br><span class="line">    MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;mi.Length; i++)&#123;</span><br><span class="line">        info.AddValue(baseType.FullName + <span class="string">&quot;+&quot;</span> + mi[i].Name, ((FieldInfo) mi[i]).GetValue(<span class="keyword">this</span>)); <span class="comment">// 这一句对应上面关键的那句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看下 FormatterServices.GetSerializableMembers方法获取出来的东西：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220110153044.png"></p><h3 id="为单例序列化的技巧"><a href="#为单例序列化的技巧" class="headerlink" title="为单例序列化的技巧"></a>为单例序列化的技巧</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例序列化Helper</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SingletonSerializationHelper</span>: <span class="title">IObjectReference</span>&#123;</span><br><span class="line">    <span class="comment">//这个方法在对象（它没有字段）反序列化之后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">GetRealObject</span>(<span class="params">streaming</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.GetSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例类</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> : <span class="title">ISerializable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> Instance; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)&#123;</span><br><span class="line">        info.SetType(<span class="keyword">typeof</span>(SingletonSerializationHelper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流上下文-StreamingContext"><a href="#流上下文-StreamingContext" class="headerlink" title="流上下文 StreamingContext"></a>流上下文 StreamingContext</h2><p>前面的 ISerializable接口也好 FormatterServices.GetSerializableMembers方法也好，都用到了 StreamingContext这个类，<strong>它存储着关于程序集的上下文</strong>。</p><p>这个类内一共2个字段：</p><ul><li>  Context：Object类型，一个对象引用，对象中包含用户希望的任何上下文信息。</li><li>  State：StreamingContextStates枚举类型，一组位标志( bit flag)，指定要序列化/反序列化的对象的来源或目的地。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220110153439.png"></p><p>State就不多举例了，只说这个All：来源或目的地可能是上述任何一个上下文。这是默认设定。</p><h2 id="序列化代理"><a href="#序列化代理" class="headerlink" title="序列化代理"></a>序列化代理</h2><p>自定义一个序列化器。看了一遍，感觉XLua的Loader是参照了这里的解决方案。</p><h3 id="ISerializationSurrogate-接口"><a href="#ISerializationSurrogate-接口" class="headerlink" title="ISerializationSurrogate 接口"></a>ISerializationSurrogate 接口</h3><p>实现序列化代理项选择器，此选择器允许一个对象对另一个对象执行序列化和反序列化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISerializationSurrogate</span> &#123;</span><br><span class="line">    <span class="comment">// 使用序列化对象所需的数据填充所提供的 SerializationInfo。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">Object, SerializationInfo, StreamingContext</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SerializationInfo 中的信息填充对象。</span></span><br><span class="line"><span class="function">Object <span class="title">SetObjectData</span>(<span class="params">Object, SerializationInfo, StreamingContext, ISurrogateSelector</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现之后怎么用？</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    IFormatter formatter = <span class="keyword">new</span> SoapFormatter();</span><br><span class="line">    SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">    <span class="comment">// 告诉代理选择器为 Datetime对象使用我们的代理MyProxy</span></span><br><span class="line">    ss.AddSurrogate(<span class="keyword">typeof</span>(DateTime), formatter.Context, <span class="keyword">new</span> MyProxy());</span><br><span class="line">    formatter.SurrogateSelector = ss;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至此，上面已经实现了一个formatter可以通过代理来 序列化/反序列化 DateTime类型。</span></span><br><span class="line">    formatter.Serialize(stream, someTime);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> test = (DateTime)formatter.Deserialize(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当格式化器准备好已登记的代理类型（如上述），调用格式化器的 Serialize方法时，会在<strong>SurrogateSelector维护的集合（一个哈希表）</strong>中查找每个对象的类型。如果发现一个匹配，就调用 ISerializationSurrogate.GetObjectData方法来获取写入流的信息。Deserialize方法同理。</p><p>上面提到的SurrogateSelector维护的集合是一个私有哈希表，调用AddSurrogate时，Type和StreamingContext构成了哈希表的key，对应的value就是ISerializationSurrogate对象。</p><h3 id="代理选择器链"><a href="#代理选择器链" class="headerlink" title="代理选择器链"></a>代理选择器链</h3><p>多个SurrogateSelector对象可链接到一起。</p><p>看一下 ISurrogateSelector怎么实现的，有点类似迭代器（不是真的实现了迭代器）：</p><p><strong>ChainSelector</strong>方法负责将参数插入到当前Selector后面。</p><p><strong>GetNextSelector</strong>方法返回对链表中的下一个 IsurrogateSelector对象的引用（如果当前操作的对象是链尾，就返回null）。经过测试发现，GetNextSelector并不会像迭代器的 GetEnumerator方法一样调用一次就改变一次Current，单纯只是返回值罢了。</p><p><strong>GetSurrogate</strong>方法返回对应Type的 ISurrogateSelector实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISurrogateSelector</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChainSelector</span>(<span class="params">ISurrogateSelector selector</span>)</span>;</span><br><span class="line">    <span class="function">ISurrogateSelector <span class="title">GetNextSelector</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">ISerializationSurrogate <span class="title">GetSurrogate</span>(<span class="params">Type, StreamingContext, <span class="keyword">out</span> ISurrogateSelector</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意了，格式化器在里面找对应的Type，如果到了第一个就直接调用对应方法，不会再找第二个了。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> objectGraph = <span class="keyword">new</span> Test &#123;A=<span class="string">&quot;3&quot;</span>, B=<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"></span><br><span class="line">BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">SurrogateSelector ss2 = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">ss.AddSurrogate(<span class="keyword">typeof</span>(<span class="built_in">string</span>), formatter.Context, <span class="keyword">new</span> StringProxy());</span><br><span class="line">ss2.AddSurrogate(<span class="keyword">typeof</span>(Test), formatter.Context, <span class="keyword">new</span> TestProxy());</span><br><span class="line">ss.ChainSelector(ss2);</span><br><span class="line">formatter.SurrogateSelector = ss;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至此，上面已经实现了一个formatter可以通过代理来 序列化/反序列化 String和Test类型。只会调用链中第一个找到的Test类型。</span></span><br><span class="line">formatter.Serialize(stream, objectGraph);</span><br><span class="line">stream.Position = <span class="number">0</span>;</span><br><span class="line">Test obj = (Test)formatter.Deserialize(stream);</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">        <span class="comment">// 最后，obj.isMoreThanFive 值为true;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestProxy</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> datas = (Test) obj;</span><br><span class="line">info.AddValue(<span class="string">&quot;A&quot;</span>, datas.A);</span><br><span class="line">info.AddValue(<span class="string">&quot;B&quot;</span>, datas.B);</span><br><span class="line">info.AddValue(<span class="string">&quot;A_Int&quot;</span>, <span class="built_in">int</span>.Parse(datas.A));</span><br><span class="line">info.AddValue(<span class="string">&quot;B_Int&quot;</span>, <span class="built_in">int</span>.Parse(datas.B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> datas = <span class="keyword">new</span> Test();</span><br><span class="line">datas.A = (<span class="built_in">string</span>)info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">datas.B = (<span class="built_in">string</span>)info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">datas.A_Int = (<span class="built_in">int</span>)info.GetValue(<span class="string">&quot;A_Int&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">datas.B_Int = (<span class="built_in">int</span>)info.GetValue(<span class="string">&quot;B_Int&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">datas.isMoreThanFive = datas.A_Int + datas.B_Int &gt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">return</span> datas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StringProxy</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// do sth</span></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> A;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> B;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> A_Int;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> B_Int;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isMoreThanFive;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与之类似的SerializationBinder：反序列化对象时重写程序集-类型"><a href="#与之类似的SerializationBinder：反序列化对象时重写程序集-类型" class="headerlink" title="与之类似的SerializationBinder：反序列化对象时重写程序集/类型"></a>与之类似的SerializationBinder：反序列化对象时重写程序集/类型</h3><p>讲的是 SerializationBinder类，<code>格式化器.Binder</code>可以指定，也就是也可以自定义。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Ver1ToVer2SerializationBinder</span> : <span class="title">SerializationBinder</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Type <span class="title">BindToType</span>(<span class="params"><span class="built_in">string</span> assemblyName, <span class="built_in">string</span> typeName</span>)</span> &#123;</span><br><span class="line">        AssemblyName assemVer1 = Assembly.GetExecutingAssembly().GetName();</span><br><span class="line">        assemVer1.Version = <span class="keyword">new</span> Version(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果是1.0.0.0版本的程序集,就返回 Ver2类</span></span><br><span class="line">        <span class="keyword">if</span>(assemblyName == assemVer1.ToString() &amp;&amp; typeName == <span class="string">&quot;Ver1&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span>(Ver2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就返回参数指定程序集的Type(默认实现)</span></span><br><span class="line">        <span class="keyword">return</span> Type.GetType(String.Format(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, typeName, assemblyName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大章25：与-WinRT组件互操作"><a href="#大章25：与-WinRT组件互操作" class="headerlink" title="大章25：与 WinRT组件互操作"></a><center>大章25：与 WinRT组件互操作</center></h1><h2 id="WinRT-is-what？"><a href="#WinRT-is-what？" class="headerlink" title="WinRT is what？"></a>WinRT is what？</h2><p>**WinRT (Window Runtime, Windows运行时)**，是windows8带来的新类库。</p><p>WinRT 组件内部作为“组件对象模型”(COM)组件来实现。</p><p>WinRT 的特点是，他是异步的。</p><p>// TODO 本章只做基本了解，日后有需求补齐。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>WinRT与CLR是隐式映射的，通过各种解决方案来讲两者机制默默帮你处理成一致。</p><p>WinRT与.Net之间是显式映射的，写代码的时候调的是WinRT的API。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大章20：异常和状态管理&quot;&gt;&lt;a href=&quot;#大章20：异常和状态管理&quot; class=&quot;headerlink&quot; title=&quot;大章20：异常和状态管理&quot;&gt;&lt;/a&gt;&lt;center&gt;大章20：异常和状态管理&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;异常处理机制&quot;&gt;</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="CLR via C#" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/"/>
    
    <category term="第四章 核心机制" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="可访问性" scheme="https://codingcodingk.github.io/tags/%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/"/>
    
    <category term="核心机制" scheme="https://codingcodingk.github.io/tags/%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>A*算法</title>
    <link href="https://codingcodingk.github.io/2021/12/18/Tech/Game/AStar/"/>
    <id>https://codingcodingk.github.io/2021/12/18/Tech/Game/AStar/</id>
    <published>2021-12-18T06:56:08.414Z</published>
    <updated>2022-01-01T04:54:19.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a><center>A*算法</center></h1><h3 id="A-算法是什么"><a href="#A-算法是什么" class="headerlink" title="A*算法是什么"></a>A*算法是什么</h3><p><strong>原理</strong></p><p>主要利用到3个数值，</p><ul><li>  <strong>G Cost</strong>：从出发点到该点已花费的距离。</li><li>  <strong>H Cost</strong>：从该点到终点的最乐观距离（不考虑障碍等因素）。</li><li>  <strong>F Cost = G Cost + H Cost</strong>，它越低，作为寻径选择就越有吸引力。</li></ul><p>目标是简单选择最低的F Cost，一步一步往后踩，每一步都记录附近没踩过的格子的F Cost到列表里。每踩下去一步后，如果发现周围邻近的格子F Cost都比过去的某个列表里的格子的F Cost大，就用那个列表里的格子继续踩。</p><p>不断重复，直到我们到达目标节点。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211208131158.png"></p><p><strong>NodeBase</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Nodebase</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> G &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> H &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> F =&gt; G+H</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> Nodebase Connection &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span> &#125; </span><br><span class="line">    <span class="keyword">public</span> List&lt;NodeBase&gt; Neighbors &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setconnection</span>(<span class="params">Nodebase nodebase</span>)</span> =&gt; &#123; Connection = nodebase; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetDistance</span>(<span class="params">NodeBase other</span>)</span> =&gt; Coords.GetDistance(other.Coords); <span class="comment">// reduce noise,优化的话主要就优化这里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetG</span>(<span class="params"><span class="built_in">float</span> g</span>)</span> =&gt; G=<span class="function">g</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetH</span>(<span class="params"><span class="built_in">float</span> h</span>)</span> =&gt; H=h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;NodeBase&gt; <span class="title">FindPath</span>(<span class="params">NodeBase startNode, NodeBase targetNode</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 接下来需要探索的结点。</span></span><br><span class="line"><span class="keyword">var</span> toSearch = <span class="keyword">new</span> List&lt;NodeBase&gt;() &#123; startNode &#125;;</span><br><span class="line"><span class="comment">// 已处理过的结点。一旦进入该队列，就再也不会更新结点值、探索了。</span></span><br><span class="line"><span class="keyword">var</span> processed = <span class="keyword">new</span> List&lt;NodeBase&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (toSearch.Any())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> current = toSearch[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> toSearch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 0.获取一个【乐观总长F】最好的结点，或者F相同但是【乐观H】最好的结点</span></span><br><span class="line">            <span class="keyword">if</span> (t.F &lt; current.F || t.F == current.F &amp;&amp; t.H &lt; current.H) current = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.将此结点作为探测完毕的结点</span></span><br><span class="line">processed.Add(current);</span><br><span class="line">toSearch.Remove(current);</span><br><span class="line">current.SetColor(ClosedColor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.探测是否是终点结点</span></span><br><span class="line"><span class="keyword">if</span> (current == targetNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> currentPathTile = targetNode;</span><br><span class="line"><span class="keyword">var</span> path = <span class="keyword">new</span> List&lt;NodeBase&gt;();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (currentPathTile != startNode)</span><br><span class="line">&#123;</span><br><span class="line">path.Add(currentPathTile);</span><br><span class="line">currentPathTile = currentPathTile.Connection;</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">Debug.Log(<span class="string">&quot;sdfsdf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> tile <span class="keyword">in</span> path) tile.SetColor(PathColor);</span><br><span class="line">startNode.SetColor(PathColor);</span><br><span class="line">Debug.Log(path.Count);</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将该结点的所有邻居结点进行更新(只更新未被加入已处理队列的)</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> neighbor <span class="keyword">in</span> current.Neighbors.Where(t =&gt; t.Walkable &amp;&amp; !processed.Contains(t)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ① 如果该邻居不在未来需要探索的结点队列中</span></span><br><span class="line"><span class="keyword">var</span> inSearch = toSearch.Contains(neighbor);</span><br><span class="line"><span class="comment">// ② 如果该邻居的开销G &gt; 本结点开销G + 本结点到该邻居距离</span></span><br><span class="line"><span class="keyword">var</span> costToNeighbor = current.G + current.GetDistance(neighbor);</span><br><span class="line"><span class="comment">// ① || ②</span></span><br><span class="line"><span class="keyword">if</span> (!inSearch || costToNeighbor &lt; neighbor.G)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ③ 根据当前结点的【开销G】，更新所有邻居的G和路线为目前最优解。</span></span><br><span class="line">neighbor.SetG(costToNeighbor);</span><br><span class="line">neighbor.SetConnection(current);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inSearch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ④ 如果更新了的数据结点不在探索队列，就更新它的【乐观H】，并将其加入探索队列</span></span><br><span class="line">neighbor.SetH(neighbor.GetDistance(targetNode));</span><br><span class="line">toSearch.Add(neighbor);</span><br><span class="line">neighbor.SetColor(OpenColor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们确定这个新邻居G Cost的值，然后如果它不在搜索列表中，或者这个G值比现在的G值好，那就设置它的Connection，并更新它的G值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CacheNeighbors</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Neighbors = GridManager.Instance.Tiles.Where(t =&gt; Coords.GetDistance(t.Value.Coords) == <span class="number">1</span>).Select(t=&gt;t.Value).ToList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考</strong></p><ol><li>  GetDistance是优化的重点，想减少噪音，如何根据具体业务选择最好的算法是值得思考的。</li><li>  算法核心就是上面代码的<code>3.</code>这一块：每走一步当前最优时需要更新所有的未探索邻居结点，从中找出更优解作为继续探索的起点。</li></ol><h1 id="实践：使用WPF实现"><a href="#实践：使用WPF实现" class="headerlink" title="实践：使用WPF实现"></a><center>实践：使用WPF实现</center></h1><h2 id="方格版本"><a href="#方格版本" class="headerlink" title="方格版本"></a>方格版本</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-算法&quot;&gt;&lt;a href=&quot;#A-算法&quot; class=&quot;headerlink&quot; title=&quot;A*算法&quot;&gt;&lt;/a&gt;&lt;center&gt;A*算法&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;A-算法是什么&quot;&gt;&lt;a href=&quot;#A-算法是什么&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/Game/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="算法" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="A*" scheme="https://codingcodingk.github.io/tags/A/"/>
    
  </entry>
  
  <entry>
    <title>CLR Via C#个人笔记5 - 基本类型</title>
    <link href="https://codingcodingk.github.io/2021/12/18/Tech/CSharp/CLR-Via-CSharp/cp5/"/>
    <id>https://codingcodingk.github.io/2021/12/18/Tech/CSharp/CLR-Via-CSharp/cp5/</id>
    <published>2021-12-18T06:56:08.414Z</published>
    <updated>2021-12-26T06:13:43.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大章14：字符、字符串和文本处理"><a href="#大章14：字符、字符串和文本处理" class="headerlink" title="大章14：字符、字符串和文本处理"></a><center>大章14：字符、字符串和文本处理</center></h1><h3 id="字符Char类型"><a href="#字符Char类型" class="headerlink" title="字符Char类型"></a>字符Char类型</h3><p><strong>System.Char</strong></p><ol><li>Char类型，在.NET中总是表示成16位Unicode代码值。</li><li>Char类型，提供2个静态只读字段：<code>MinValue = \0</code> 和 <code>MaxValue = \uffff</code>。</li><li>Char类型，提供GetUnicodeCategory方法，它返回枚举类，表明该字符是Unicode标准定义的控制字符、货币符号、小写字母、大写字母、标点符号、数学符号还是其它字符。</li><li>Char类型，在使用ToLower和ToUpper方法时，会需要使用到语言文化来转换，语言文化通过<code>System.Threading.Thread.CurrentCulture静态方法</code>获取。</li></ol><p><strong>Char转换数值类型</strong></p><ol><li>强转，效率最高。</li><li>用Convert类的静态方法。</li><li>用IConvertible接口，效率最低，因为要装箱。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Main()&#123;</span><br><span class="line"><span class="built_in">char</span> c;</span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.强转</span></span><br><span class="line">c = (Char) <span class="number">65</span>;</span><br><span class="line">n = (<span class="built_in">int</span>) c;</span><br><span class="line">Console.WriteLine(c);<span class="comment">// output:&quot;A&quot;</span></span><br><span class="line">Console.WriteLine(n);<span class="comment">// output:&quot;65&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Convert类</span></span><br><span class="line">c = Convert.ToChar(<span class="number">65</span>);</span><br><span class="line">n = Convert.ToInt32(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.IConvertible</span></span><br><span class="line">c = ((IConvertible) <span class="number">65</span>).ToChar(<span class="literal">null</span>);</span><br><span class="line">n = ((IConvertible) c).ToInt32(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringInfo处理字符</strong></p><p>可以用StringInfo类提供的方法来实现处理字符、获取字符长度与文本元素等，具体不说了。</p><p>值得了解的是一个概念：Char实际代表一个16位Unicode码值，但是该值不一定就等于一个抽象Unicode字符。比如有的抽象Unicode字符是2个码值的组合，U+0625和U+0650字符组合起来构成一个抽象字符或者文本元素。</p><p>上述提到的一些Unicode抽象字符或者文本元素要求用2个16位值表示，第一个叫“高位代理项(high surrogate)”，第一个叫“低位代理项(low surrogate)”。两个代理项，Unicode可以表示100万以上不同的字符。</p><h3 id="字符串String类型⭐"><a href="#字符串String类型⭐" class="headerlink" title="字符串String类型⭐"></a>字符串String类型⭐</h3><p><strong>System.String</strong></p><ol><li>String代表一个不可变(immutable)的顺序字符集。</li><li>String直接继承自Object，所以是引用类型、总在堆上。</li></ol><p><strong>构造String</strong></p><p>string虽然是引用类型，却不可以用new、只能用简化过的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hi there.&quot;</span>;</span><br><span class="line"><span class="comment">// =&gt;IL Code</span></span><br><span class="line">IL_0000: ldstr <span class="string">&quot;Hi there.&quot;</span></span><br><span class="line">IL_0005: stloc<span class="number">.0</span></span><br><span class="line">IL_0006: ldloc<span class="number">.0</span></span><br></pre></td></tr></table></figure><p>可见，String构造新实例用的是ldstr(load string)指令 而不是类通用的newobj指令，来处理从元数据获得的字面值(literal) “Hi there.”字符串。</p><p><strong>逐字字符串@</strong></p><p>推出这个是因为C#编译器会对String的实例实行转义机制，在使用比如输出时，会把诸如<code>\r \n</code>进行语义转换。</p><p>逐字字符串(verbatim string)，用<code>@关键字</code>。抛弃转义，所有字符都被视为字符串的一部分。</p><p><strong>字符串是不可变的⭐</strong></p><p>字符串是不可变(immutable)的，也就是说一经创建就不能更改任何字符。</p><ol><li>对字符串的变更操作（比如<code>Substring()</code>）会返回新的字符串。因为它们都在堆上，所以频繁对字符串进行处理会影响GC。执行大量字符串操作更推荐用<code>StringBuilder类</code>。</li><li>不可变所以不会发生线程同步问题。</li><li>CLR会将”字符串留用“，多个String实例共享一个String内容。</li></ol><p><strong>字符串留用⭐</strong></p><p>字符串一经创建不可变更，所以CLR为了提升性能推出了字符串留用(string interning)机制。</p><p>CLR在初始时会创建一个空的内部哈希表，key是字符串，value是对托管堆中String对象的引用。String类提供了2个方法来访问这个内部哈希表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把入参str作为哈希值去找内部哈希表，如果存在则返回引用，如果不存在则创建入哈希表并返回引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Intern</span>(<span class="params">String str</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把入参str作为哈希值去找内部哈希表，如果存在则返回引用，如果不存在则返回null,不会添加到哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">IsInterned</span>(<span class="params">String str</span>)</span>;</span><br></pre></td></tr></table></figure><p>注意了，这种字符串留用机制录入的字符串，因为哈希表引用着String，所以永远不会被GC；一般的新建字符串方法，会被GC。</p><p><strong>重点来了，那么，对于我们日常的字符串写法<code>var s = &quot;Hello&quot;;</code>会进入留用哈希表吗？答案是不一定，但大概率会。</strong></p><p>书中说了，如果<font color="red">元数据中</font>存在“字面值”字符串定义，C#编译器会在加载AppDomain时对这些字面值进行留用。</p><p>在CLR4.5以前的版本中，由于<code>System.Runtime.CompilerServices.CompilationRelaxationsArrtibute</code>和<code>System.Runtime.CompilerServices.NoStringInterning</code>两个标志的标记，CLR会不留用。</p><p>目前的CLR版本中，我测试了，默认是留用的。但是注意了，留用只限于元数据中存在的、编译时就可确定的那些字面值。运行时确定的是不行的。下面展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 1.元数据内能确定的字面值，目前CLR版本留用</span></span><br><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;Hell&quot;</span> + <span class="string">&quot;o&quot;</span>;</span><br><span class="line">String b1 = String.IsInterned(s1); <span class="comment">// 返回&quot;Hello&quot;！目前版本留用！</span></span><br><span class="line"><span class="keyword">var</span> eq1 = Object.ReferenceEquals(s1, s2); <span class="comment">// 返回true！堆中目标只有一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.元数据内不能确定的字面值，比如需要运行时决定，一定不留用</span></span><br><span class="line">String s3 = <span class="string">&quot;Hell&quot;</span> + <span class="string">&quot;O&quot;</span>.ToLower();</span><br><span class="line"><span class="keyword">var</span> eq2 = Object.ReferenceEquals(s1, s3); <span class="comment">// 返回false！堆中目标一定不同！</span></span><br><span class="line">String s4 = s3.Substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> chaos = String.IsInterned(s4); <span class="comment">// 返回null！一定不留用！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.正确可靠的留用机制使用方式：显式调用Intern</span></span><br><span class="line">String s5 = String.Intern(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String s6 = String.Intern(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> eq3 = Object.ReferenceEquals(s5, s6); <span class="comment">// 返回true！一定留用！堆中目标只有一个。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，怎么说呢，这块概念很重要，便于去理解C#留用机制的实现。但是真写代码是不会用这么麻烦的<code>String.Intern</code>写法的。</p><p><strong>字符串池</strong></p><p>字符串留用机制之外的另一个优化。</p><p>CLR处理字面值字符串并嵌入元数据，同一个字符串在源代码中多次出现，把它们都嵌入元数据会使生成的文件无谓地增大。</p><p>所以只在元数据中嵌入一次该字符串，剩下的全部是持有那个字符串的实例。</p><p><strong>比较字符串（语言文化）</strong></p><p>了解即可。</p><p>用来比较的<code>String.Equals();String.Compare()</code>等的重载，一般都有一个<font color="red">StringComparison枚举类型</font>或者<font color="red">CompareOptions枚举类型</font>参数，这2个枚举类型跟语言文化有关，可以改变比较的思路。下面进行展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringComparison枚举类型</span></span><br><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StringComparison &#123;</span><br><span class="line">CurrentCulture = <span class="number">0</span>, <span class="comment">// 使用语言文化</span></span><br><span class="line">CurrentCultureIgnoreCase = <span class="number">1</span>, <span class="comment">// 使用语言文化</span></span><br><span class="line">InvariantCulture = <span class="number">2</span>,</span><br><span class="line">InvariantCultureIgnoreCase = <span class="number">3</span>,</span><br><span class="line">Ordinal = <span class="number">4</span>, <span class="comment">// 忽略语言文化</span></span><br><span class="line">OrdinalIgnoreCase = <span class="number">5</span>, <span class="comment">// 忽略语言文化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareOptions枚举类型</span></span><br><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CompareOptions &#123;</span><br><span class="line">None = <span class="number">0</span>,</span><br><span class="line">IgnoreCase = <span class="number">1</span>,</span><br><span class="line">IgnoreNonSpace = <span class="number">2</span>,</span><br><span class="line">IgnoreSymbols = <span class="number">4</span>,</span><br><span class="line">IgnoreKanaType = <span class="number">8</span>,</span><br><span class="line">Ordinal = <span class="number">0x40000000</span>, <span class="comment">// 忽略指定语言文化</span></span><br><span class="line">OrdinalIgnoreCase = <span class="number">0x10000000</span>, <span class="comment">// 忽略指定语言文化</span></span><br><span class="line">StringSort = <span class="number">0x20000000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果进行一些url、值得比较，不需要语言文化，那就选择忽略语言文化。</p><p>下面讲一下语言文化，.NET把语言文化放在<code>System.Globalization.CultureInfo类</code>表示一个”语言/国家“对，例如”en-US“。</p><p>在CLR中，每个线程都关联了2个特殊属性，每个属性都引用一个<font color="red">CultureInfo对象</font>。它们是：</p><ul><li>CurrentUICulture属性：在GUI或者Web窗体等等程序中，UI元素的显示资源用的就是它。</li><li>CurrentCulture属性：不适合CurrentUICulture属性的场合就用它，例如数字和日期格式化、字符串比较。</li></ul><p>在许多计算机上，线程的<font color="red">CurrentUICulture属性</font> 与 <font color="red">CurrentCulture属性</font>都被设为同一个CultureInfo对象。但是也可以不同。</p><p>下面根据语言文化进行比较的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;Strasse&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;Straβe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eq1 = false</span></span><br><span class="line"><span class="built_in">bool</span> eq1 = String.Compare(s1, s2, StringComparison.Ordinal) == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// StringComparison 一个枚举值，用于指定比较中要使用的规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eq2 = true</span></span><br><span class="line">CultureInfo ci = <span class="keyword">new</span> CultureInfo(<span class="string">&quot;de-DE&quot;</span>);</span><br><span class="line"><span class="built_in">bool</span> eq2 = String.Compare(s1, s2, <span class="literal">true</span>, ci) == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Compare(String, String, Boolean, CultureInfo)</span></span><br><span class="line"><span class="comment">// Boolean 是否在比较过程中忽略大小写</span></span><br><span class="line"><span class="comment">// CultureInfo 一个对象，提供区域性特定的比较信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高效率构造字符串StringBuilder类型"><a href="#高效率构造字符串StringBuilder类型" class="headerlink" title="高效率构造字符串StringBuilder类型"></a>高效率构造字符串StringBuilder类型</h3><p><strong>StringBuilder是什么</strong></p><p>StringBuilder代表可变(mutable)字符串。也就是说StringBuilder的大多数成员都能更改字符数组的内容，同时不会造成在托管堆上分配新对象。<br>只有以下2种情况会分配新对象：</p><ul><li>动态构造字符串，其长度超过了设置的“容量”。</li><li>调用StringBuilder的ToString方法。</li></ul><p><strong>StringBuilder是怎么做的</strong></p><ol><li><p>StringBuilder对象包含一个字段，这个字段引用了由Char结构构成的数组。可以利用StringBuilder的各个成员来操纵该字符数组，高效缩短字符串或更改字符串中的字符，而不是和String一样只能新建。</p></li><li><p>如果字符串变大，超过了事先分配的字符数组大小，StringBuilder会自动分配一个新的、更大的数组，复制字符并开始使用新数组。前一个数组被GC。</p></li><li><p>使用ToString转换为String对象。</p></li></ol><p><strong>StringBuilder构造概念</strong></p><p>StringBuilder就是个普通的类，不会把他当作基元类型。</p><p>下面介绍一些StringBuilder的核心元素：</p><p>1.<strong>最大容量</strong>：一个Int32值，指定了能放到字符串中的最大字符数。默认值是Int.MaxValue（约20亿）。<br>创建完之后，这个最大容量就不能修改了。</p><p>2.<strong>容量</strong>：一个Int32值，指定了由StringBuilder维护的字符数组的长度。默认为16，可以在构造时自己设置。<br><font color="red">向字符数组追加字符时，StringBuilder会检测数组会不会超过设定的容量。如果会，StringBuilder会自动倍增容量字段，用新容量来分配新数组，并将原始数组的字符复制到新数组中。随后，原始数组可以被GC。</font>尽量避免分配不合适导致的动态扩容，会影响性能。</p><p>3.<strong>字符数组</strong>：一个由Char结构构成的数组，负责维护“字符串”的字符内容。字符数可用StringBuilder的Length属性来获取，它总是 &lt;= “容量”、“最大容量”。</p><p>4.<strong>构造器</strong>：可以在构造StringBuilder时传递一个String来初始化字符数组。不传递字符串，数组刚开始就不会包含任何字符，Length=0。</p><p><strong>StringBuilder构造实际</strong></p><p>上面介绍了核心概念，下面讲一下StringBuilder核心、常用的成员：</p><table><thead><tr><th>成员名称</th><th>成员类型</th><th>说明</th></tr></thead><tbody><tr><td>MaxCapacity</td><td>只读属性</td><td>返回字符数组能容纳的最大字符数(最大容量)。</td></tr><tr><td>Capacity</td><td>可读可写属性</td><td>字符数组的长度(容量)。比MaxCapacity大会抛错。</td></tr><tr><td>EnsureCapacity(Int32)</td><td>方法</td><td>如果传给方法的值大于当前容量，当前容量就会自动增大；如果小于当前容量，就不做。</td></tr><tr><td>Length</td><td>可读可写属性</td><td>存储着的字符数组的实际长度(使用)。设置为0就会重置StringBuilder为空字符串。</td></tr><tr><td>Chars[]</td><td>可读可写索引器属性</td><td>用于操作指定索引位置的字符。</td></tr><tr><td>ToString</td><td>方法</td><td>返回代表StringBuilder的字符数组的一个String。</td></tr><tr><td>Equals</td><td>方法</td><td>只有2个StringBuilder对象具有相同的 最大容量、字符数组容量和字符内容才返回true。</td></tr><tr><td>CopyTo</td><td>方法</td><td>将StringBuilder的字符内容的一个子集复制到一个Char数组中。</td></tr><tr><td>Append、Insert等插入方法</td><td>方法</td><td>向字符数组中插入一个对象。如由必要，数组会进行扩容。</td></tr></tbody></table><p>个人觉得，主要就是看MaxCapacity、Capacity、Length这三个容量相关的核心属性，以及EnsureCapacity(Int32)方法的机制。</p><h3 id="ToString方法"><a href="#ToString方法" class="headerlink" title="ToString方法"></a>ToString方法</h3><p><strong>默认实现</strong></p><p>面对对象理念下，所有类型都有责任提供转换为字符串表示的方法。</p><p>System.Object提供了一个public、virtual的ToString默认实现，它只返回对象所属类型的全名。</p><p>C#的许多核心类型（Byte、int、uint、double等）都进行了ToString方法重写。</p><p><strong>IFormattable接口</strong></p><p>用于指定 格式(比如x进制、日期) 和 语言文化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFormattable</span> &#123;</span><br><span class="line"><span class="function">String <span class="title">ToString</span>(<span class="params">String format, System.IFormatProvider formatProvider</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有基元类型、所有枚举类型都定义或自动实现了IFormattable接口。</p><p>介绍下这个签名的2个参数，</p><ol><li>format，告诉方法如何格式化对象。比如DateTime类型支持用“d”表示短日期、“Y”表示年等。</li><li>formatProvider，提供具体文化信息。可以传null，默认调用线程关联的语言文化信息。System.IFormatProvider实现的类型不多，CultureInfo算一个。</li></ol><p><strong>String.Format方法</strong></p><p>就是常用的format方法，在内部Format方法会调用每个对象的ToString方法来获取对象的字符串表示，再依次拼接。<br>StringBuilder.AppendFormat方法也差不多。</p><p>当然，每个对象都要调用ToString意味着他们都要使用他们的常规格式和调用线程的语言文化来格式化，但是你可以像下面这样指定：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = String.Format(<span class="string">&quot;On &#123;0:D&#125;,&#123;1&#125; is &#123;2:E&#125; years old.&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> DateTime(<span class="number">2012</span>,<span class="number">4</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">35</span>,<span class="number">5</span>), <span class="string">&quot;Aidan&quot;</span>, <span class="number">9</span>);</span><br><span class="line">Console.WriteLine(e);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// On SUnday,April 22,2012,Aidan is 9.000000E+000 years old.</span></span><br></pre></td></tr></table></figure><p><strong>定制格式化器</strong></p><p>可以通过实现<code>ICustomFormatter接口</code>和<code>IFormatProvider接口</code>实现自定义StringBuilder的AppendFormat方法的行为。它将不再为每个对象调用ToString，而是调用定制的方法。</p><p>具体看书，提供一下调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Main &#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.AppendFormat(<span class="keyword">new</span> BoldInt32s(), <span class="string">&quot;&#123;0&#125; &#123;1&#125; &#123;2:M&#125;&quot;</span>, <span class="string">&quot;Jeff&quot;</span>, <span class="number">123</span>, DateTime.Now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BoldInt32s</span> : <span class="title">IFormatProvider</span>, <span class="title">ICustomFormatter</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析字符串获取对象：Parse</strong></p><p>能解析字符串的任何类型都提供了公共静态方法Parse。它们如下形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String解析为Int32</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Parse</span>(<span class="params">String s, NumberStyle style, IFormatProvider provider</span>)；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 列举几个解析方法</span></span></span><br><span class="line"><span class="function">NumberStyle</span> &#123;</span><br><span class="line">None, <span class="comment">// 无特殊</span></span><br><span class="line">AllowLeadingWhite, <span class="comment">// 解析时跳过最靠前的空行</span></span><br><span class="line">HexNumber, <span class="comment">// 解析十六进制数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编码解码：字符和字节的互转"><a href="#编码解码：字符和字节的互转" class="headerlink" title="编码解码：字符和字节的互转"></a>编码解码：字符和字节的互转</h3><p><strong>不同的字节码</strong></p><p>只说CLR常见的2个：</p><ul><li>UTF-16：每个16位字符编码成2个字节，又称作“Unicode编码”。</li><li>UTF-8：将部分字符编码成1 or 2 or 3 or 4个字节。值在0x0080下用1个字节，适合美国语言；值在0x0080~0x07FF用2个字节，适合中东语言；值在0x07FF以用3个字节，适合东亚语言；代理项对(surrogate pair)表示4个字节。</li></ul><p>其他的诸如UTF-7、UTF-32、ASCII之类的就不展开了。</p><p><strong>编码解码</strong></p><p>用<code>System.IO.BinaryWriter 或者 System.IO.StreamWriter类型</code>将字符串发送给文件或网络流时，通常要进行编码；<br>用<code>System.IO.BinaryReader 或者 System.IO.StreamReader类型</code>从文件或网络流读取字符串时，通常要进行解码。<br>不显式指定一种编码方案，所有这些类型都默认使用UTF-8。</p><p><strong>Sytem.Text.Encoding</strong></p><p>要编码或解码一组字符时，应获取从Sytem.Text.Encoding派生的一个类的实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;Hi there.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.应获取从Sytem.Text.Encoding派生的一个类的实例</span></span><br><span class="line">Encoding encodingUTF8 = Encoding.UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将字符串 编码 成字节数组</span></span><br><span class="line">Byte[] encodedBytes = encodingUTF8.GetBytes(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将字节数组 解码 回字符串</span></span><br><span class="line"><span class="built_in">string</span> decodedString = encodingUTF8.GetString(encodedBytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出看结果</span></span><br><span class="line">Console.WriteLine(encodedBytes);</span><br><span class="line">Console.WriteLine(decodedString);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 48-69-20-74-68-65-72-65-2E</span></span><br><span class="line"><span class="comment">// Hi there.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节流</strong></p><p>字节流通常以<strong>数据块(data chunk)</strong>的形式传输。</p><p>不能以常规方法解码，假设要通过<code>System.Net.Sockets.NetworkStream</code>来读取UTF-16字符串，可能从流中先读取5个字节，再读取7个字节。如果使用UTF-16的Encoding来解码，那么第一次GetString就只能正确解码2个字，第二次GetString就只能正确解码3个字，那样数据就损坏了。</p><p>字节块正确的解码方法是：</p><ol><li>获取一个Encoding派生对象，再调用其GetDecoder方法</li><li>方法返回对一个新构造对象的引用，该对象的类型从System.Text.Decoder类派生。</li><li>执行Decoder对象的<strong>GetChars</strong>或者<strong>GetCharCount</strong>方法：它会尽可能多地解码字节数组，假如字节数组包含的字节不足以完成一个字符，剩余的字节会保存到Decoder对象内部。下次再调用其中一个方法时，Decoder对象会利用之前剩余的字节再加上传给它地新字节数组进行解码。</li></ol><p>上面提到的，<br>GetChars：将一个字节序列解码为一组字符。<br>GetCharCount：计算对一个字节序列进行解码所产生的字符数，不实际进行解码。</p><h3 id="安全字符串SecureString"><a href="#安全字符串SecureString" class="headerlink" title="安全字符串SecureString"></a>安全字符串SecureString</h3><p><strong>System.Security.SecureString</strong></p><p>就是说String对象可能在GC之前，被非托管代码操作或者执行unsafe方法，导致String对象的使用内存无法被重用，导致String一直在进程内存里逗留着。万一这个String式机密数据，那就会泄露。</p><p>为了解决上述问题，推出了<code>System.String,System.Security.SecureString类型</code>。</p><p>SecureString类型的字符串是加密的。会为它分配一块非托管内存块，为了逃避GC。<br>它也有AppendChar、InsertAt、RemoveAt这几个方法，便于增删改查，但是它们都是通过解密后处理再加密实现的。</p><p>访问它的话，需要用unsafe方法，因为要访问到非托管内存。</p><h1 id="大章15：枚举类型和位标志"><a href="#大章15：枚举类型和位标志" class="headerlink" title="大章15：枚举类型和位标志"></a><center>大章15：枚举类型和位标志</center></h1><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p><strong>枚举类型(enumerated type)是值类型</strong></p><p>枚举类型都从System.Enum派生，System.Enum从System.ValueType派生，所以枚举类型是值类型，会有装箱拆箱发生，但是不能定义定义任何方法、属性或事件。</p><p>另外，枚举类型也是基元类型。</p><p><strong>枚举类型内部构造</strong></p><p>比如我们这么定义一个枚举类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Color &#123;</span><br><span class="line">White,</span><br><span class="line">Red,</span><br><span class="line">Blue,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#编译器会这么看待它（不是真的生成这样的代码，不过效果相同）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Color : System.Enum &#123;</span><br><span class="line"><span class="comment">// 内部的枚举就是一些public常量字段，可被反射调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> Color White = (Color)<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> Color Red = (Color)<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> Color Blue = (Color)<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共实例字段，无法通过代码引用引用，包含Color变量的值</span></span><br><span class="line"><span class="keyword">public</span> Int32 value__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举类型的值</strong></p><p>C#枚举类型的值默认是int类型的。它还可以是byte、sbyte、short、ushort、int、uint、long、ulong。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值定义成byte类型</span></span><br><span class="line"><span class="built_in">enum</span> Color : <span class="built_in">byte</span> &#123;</span><br><span class="line">White,</span><br><span class="line">Red,</span><br><span class="line">Blue,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过Enum类型的静态方法GetUnderlyingType方法获取到基础类型</span></span><br><span class="line">Console.WriteLine(Enum.GetUnderlyingType(<span class="keyword">typeof</span>(Color)));</span><br><span class="line"><span class="comment">// output: System.Byte</span></span><br></pre></td></tr></table></figure><p><strong>枚举类型常用方法</strong></p><p>简单说下<strong>枚举类型名称&lt;=&gt;值</strong>之间得转换。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> nameArr = (Color[])Enum.GetValues(<span class="keyword">typeof</span>(Color));</span><br><span class="line"><span class="comment">// String =&gt; 枚举类型名称</span></span><br><span class="line"><span class="keyword">var</span> someName = (Color)Enum.Parse(<span class="keyword">typeof</span>(Color), <span class="string">&quot;White&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型名称 =&gt; 值</span></span><br><span class="line"><span class="keyword">var</span> val1 = (<span class="built_in">int</span>)nameArr[<span class="number">0</span>];<span class="comment">// val1 = 1</span></span><br><span class="line"><span class="keyword">var</span> val2 = (<span class="built_in">int</span>)someName;<span class="comment">// val2 = 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//枚举类型名称</span></span><br><span class="line">White = <span class="number">1</span>,</span><br><span class="line">Red = <span class="number">2</span>,</span><br><span class="line">Blue = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位标志"><a href="#位标志" class="headerlink" title="位标志"></a>位标志</h3><p><a href="#jump">注：如果前面的理解了直接从“位运算”看起。</a></p><p><strong>什么是位标志(bit flag)</strong></p><p>比如要解决这么一个问题：</p><p>假如我从早上到晚上一天有12节课，我希望用一串数来记录每节课我有没有去。</p><p>首先会想到定制规则，1是去0是不去：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211209103726.png"></p><p>会变成如上一串数字，解决了问题，但这不就是一个二进制数吗？转换成十进制数902。</p><p>这串数字就是一种位标志。</p><p>下面也会提到“0x0001”这样的位标志，“0x”指的是16进制，“0001”是16进制数。</p><p><strong>什么是位运算</strong></p><p>现在，我有新的需求：我发现1、2节课漏记了去上课了，需要补上。</p><p>那只需要用 <code>001110000110 | 110000000000</code> 得运算结果就完成了，转换成十进制它看上去就是 <strong>“902 | 3072”</strong>，计算得出的结果更新就行了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">902</span> | <span class="number">3072</span>;</span><br><span class="line">Console.WriteLine(Convert.ToString(x,<span class="number">2</span>));<span class="comment">// x = 3974(10进制) 输出为 111110000110(2进制)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我想检查1、2节课我去上课了没，那也很容易：</p><p>用 <code>001110000110 &amp; 110000000000</code> ，也就是 <strong>“902 &amp; 3072”</strong> 判断计算得到十进制结果的是不是0，如果是0那就意味着并不重复，可以去。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">902</span> &amp; <span class="number">3072</span>;</span><br><span class="line">Console.WriteLine(x);<span class="comment">// x = 0(10进制)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump"><strong>C#位运算</strong></span></p><p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p><p>A = 0011 1100<br>B = 0000 1101</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td align="left">(A | B) 将得到 61，即为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td align="left">~</td><td align="left">按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><p><strong>C#位标记：[Flags]特性</strong></p><p>C#的位标记离不开[Flags]特性，<br>这个特性的作用就是<code>someEnum.ToString()</code>是”ReadOnly, Hidden”这个枚举名称的字符串。<br>如果没有[Flags]特性，就会为具体的数值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>] <span class="comment">//增加Flags标记便可申明一个位标记</span></span><br><span class="line"><span class="built_in">enum</span> Action</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Walk = <span class="number">0x0001</span>,</span><br><span class="line">    Run = <span class="number">0x0002</span>,</span><br><span class="line">    Speak = <span class="number">0x0004</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位标记的实例应用</span></span><br><span class="line"><span class="function">vod <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//申明一个行为</span></span><br><span class="line"><span class="keyword">var</span> action = Action.None;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询目前拥有行为</span></span><br><span class="line">Console.WriteLine(action.ToString()); <span class="comment">// output:None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加行走和奔跑行为</span></span><br><span class="line">action = action | Action.Walk | Action.Run;</span><br><span class="line">Console.WriteLine(action.ToString()); <span class="comment">// output:Walk,Run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数值转换为标志字符串</strong></p><p>存在<strong>[Flags]特性</strong>时<code>枚举实例.ToString()</code>的工作流程：</p><ol><li>获取枚举类型定义的数值集，并按降序排列。</li><li>每个数值将会与枚举实例的值进行“按位与&amp;”计算，假如结果等于该数值，与该数值关联的字符串便会追加到输入字符串中，对应的位会被认为考虑过了(设置为0)。反复到每一个数值都计算完。</li><li>如果2中计算出的数值结果仍然不为0，说明枚举实例的一些“1”状态的位，在枚举类里压根没定义过，那么ToString<font color="brown">直接返回枚举实例原始值的字符串</font>。</li><li>如果2中计算出的数值结果为0，那么再检查枚举实例原始值：</li><li>如果枚举实例原始值不为0，那么ToString<font color="brown">返回符号名称之间以逗号分隔的字符串</font>。</li><li>如果枚举实例原始值为0，那么再检查枚举类型定义的符号中有没有值为0的，有的话ToString<font color="brown">返回值为0的符号名称</font>；没有的话ToString<font color="brown">返回值“0”</font>。</li></ol><p>为什么能这么做？因为确保过枚举类型中定义的每一个枚举的值，都只代表一位的开关。就是<code>0001</code>、<code>0010</code>、<code>0100</code>这样下去，转换成十进制的话，全是2的整数次方。</p><p>但是也有唯一一个例外不是2的整数次方，比如可以添加一个枚举类<code>Action.All = Action.Walk | Action.Run | Action.Speak</code>，它的值是<code>0x0007</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="built_in">enum</span> Action</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Walk = <span class="number">0x0001</span>,</span><br><span class="line">    Run = <span class="number">0x0002</span>,</span><br><span class="line">    Speak = <span class="number">0x0004</span>,</span><br><span class="line">    All = <span class="number">0x0007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标志字符串转换为数值</strong></p><p>将逗号分割的符号字符串转换为数值，这是通过Enum的静态方法Parse和TryParse来实现的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Action a = (Action) Enum.Parse(<span class="keyword">typeof</span>(Action),<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Console.WriteLine(a);</span><br><span class="line"><span class="comment">// output: Walk , Run</span></span><br><span class="line"><span class="comment">// &quot;3&quot;对应16位的&quot;0x0003&quot;，转换二进制是&quot;0000000000000011&quot;，所以是Walk、Run</span></span><br></pre></td></tr></table></figure><p>Enum的静态方法Parse和TryParse的工作流程：</p><ol><li>删除字符串头尾所有的空白字符。</li><li>如果字符串第一个字符是数字、+、-，该字符串会被认为是一个数字，方法返回会一个枚举类型实例，数值为字符串转换后的数值。</li><li>将2得到的数值转换为2进制，再将每一位的”1”都单独分割成一个2进制数，用<code>,</code>分隔，比如0110 =&gt; 0100,0010。</li><li>把3中得到的每一个数都去枚举类型中匹配，如果有匹配不到的就<font color="brown">抛错ArgumentExpection</font>；如果匹配的到就与动态结果进行“按位或|”计算（动态结果初始值是0），再查找下一个符号。</li><li>查找并找到所有标识后，<font color="brown">以Object形式返回这个动态结果值所表示的枚举类型名称们</font>，格式是“名称1 , 名称2”。</li></ol><p>上面的3-4我是猜的，因为书里写的token我不明白，搜也没搜到。<br>但是像这么做的确可以实现，4的目的，是记录已经找到的枚举类型名称罢了。</p><p><strong>向枚举类型添加方法</strong></p><p>枚举类型中不能定义方法，但是可以通过<strong>拓展方法</strong>来实现模拟向枚举类型添加方法。</p><h1 id="大章16：数组"><a href="#大章16：数组" class="headerlink" title="大章16：数组"></a><center>大章16：数组</center></h1><h3 id="数组是什么"><a href="#数组是什么" class="headerlink" title="数组是什么"></a>数组是什么</h3><p><strong>数组 is a Array</strong></p><p>所有数组类型都隐式从<strong>System.Array抽象类</strong>派生，System.Array又从Object派生，所以数组都是<strong>引用类型</strong>。</p><p>所有数组同时隐式实现IEnumerable、ICollection、IList接口。</p><p><strong>多维数组 ≠ 交错数组</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 1.申明、new构造器不同</span></span><br><span class="line"><span class="built_in">int</span>[,] test1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span>[][] test2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>][];<span class="comment">// 不可指定第二个[]内的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.交错数组存着的每个数组可以不等长，多维数组的每个数组必须等长</span></span><br><span class="line"><span class="comment">// 且交错数组存着的每个数组必须new</span></span><br><span class="line">test2[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">test2[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.存储结构不同，赋值写法不同</span></span><br><span class="line">test1[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">test2[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><p><strong>new一个数组⭐</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Int32[] myIntegers = new Int32[100];// 包含100个Int32的数组</span><br><span class="line"></span><br><span class="line">Control[] myControls = new Control[50];// 包含50个Control引用的数组</span><br></pre></td></tr></table></figure><p>像上面这样new，</p><ol><li>首先，数组是引用类型，所以数组都是在堆里的，分配内存也是在堆里分配。</li><li>其次，数组单个元素的类型，<br>如果是值类型比如上面的Int32，就会在托管堆上分配100个未装箱Int32所需的内存块，并给每个Int32实例都附上default值0；<br>如果是引用类型比如上面的Control，就会在托管堆上分配50个Control引用的内存块，并给每个引用都附上null。</li><li>最后，给一个类型对象指针、一个同步块索引和一些overhead字段(开销字段)分配内存。</li><li>返回上面分配完的内存块地址，保存到array变量中。</li></ol><p>堆上的图大概可以这么理解（这里给myControls数组提前new了几个实例）：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211209155727.png"></p><p><strong>初始化数组元素 语法糖</strong></p><p>C#提供了语法糖方便初始化数组，由编译器帮你推断最佳类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建+初始化数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span>[] &#123;<span class="string">&quot;Sim&quot;</span>, <span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Grant&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这么写会编译不过：error 找不到隐式类型数组的最佳类型</span></span><br><span class="line"><span class="keyword">var</span> namesError!!!! = <span class="keyword">new</span>[] &#123;<span class="string">&quot;Sim&quot;</span>, <span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Grant&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建+初始化匿名数组</span></span><br><span class="line"><span class="keyword">var</span> kids = <span class="keyword">new</span>[] &#123; <span class="keyword">new</span> &#123;Name=<span class="string">&quot;Aidan&quot;</span>&#125;, <span class="keyword">new</span> &#123;Name=<span class="string">&quot;Grant&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p><strong>数组转型</strong></p><p>两种方法：</p><p>1.显式或隐式转型：要求数组维数相同、且必须存在从元素源类型到目标类型的显式或隐式转换。所有的值类型都不允许用这个方式转。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileStream[,] fsArr = <span class="keyword">new</span> FileStream[<span class="number">5</span>,<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 隐式、显式 可以</span></span><br><span class="line">Object[,] o2Arr_1 = fsArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型不能 隐式、显式转</span></span><br><span class="line"><span class="built_in">int</span>[,] intArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>,<span class="number">10</span>];</span><br><span class="line">Object[,] o2Arr_2 = intArr;<span class="comment">// 编译无法通过!</span></span><br></pre></td></tr></table></figure><p>2.Array.Copy(fromArr, toArr, length)：浅拷贝，可以拆箱装箱所以能接受值类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line">Object[] objArr = <span class="keyword">new</span> Object[intArr.Length];</span><br><span class="line"><span class="comment">// 值类型数组 装箱转换到 引用类型数组</span></span><br><span class="line">Array.Copy(intArr, objArr, intArr.Length);</span><br></pre></td></tr></table></figure><h3 id="所有数组都会偷偷…"><a href="#所有数组都会偷偷…" class="headerlink" title="所有数组都会偷偷…"></a>所有数组都会偷偷…</h3><p><strong>所有数组都隐式派生自System.Array</strong></p><p>随意声明一个数组，它都隐式派生自System.Array类型，</p><p>System.Array类型定义了很多常用的实例方法、静态方法和属性，比如Clone、CopyTo、GetLength、IndexOf等。</p><p><strong>所有数组都隐式实现IEnumerable、ICollection、IList接口</strong></p><p>System.Array类型也实现了IEnumerable、ICollection、IList这几个接口，但是它是把他们都当作Object类型来处理的。</p><p>全当作Object类来处理会很不方便，影响性能，甚至可能患有类型不安全，所以数组重新实现了这几个接口，用泛型：</p><p>当你新创建 一维数组 时，会将其类型传入并实现<code>IEnumerable&lt;T&gt;、ICollection&lt;T&gt;、IList&lt;T&gt;</code>这几个泛型接口。同时为会传入类型的父类也实现这3个接口，直到Array的默认实现。可以看结构展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">FileStream[] fsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码会自动实现大量的IEnumerable&lt;T&gt;、ICollection&lt;T&gt;、IList&lt;T&gt;接口，结构如下：</span></span><br><span class="line"><span class="function">Object</span></span><br><span class="line"><span class="function"><span class="title">Arrary</span> (<span class="params">非泛型IEnumerable, ICollection, IList</span>)</span></span><br><span class="line"><span class="function">Object[] (<span class="params">IEnumerable&lt;Object&gt;, ICollection&lt;Object&gt;, IList&lt;Object&gt;</span>)</span></span><br><span class="line"><span class="function">String[] (<span class="params">IEnumerable&lt;String&gt;, ICollection&lt;String&gt;, IList&lt;String&gt;</span>)</span></span><br><span class="line"><span class="function">Stream[] (<span class="params">IEnumerable&lt;Stream&gt;, ICollection&lt;Stream&gt;, IList&lt;Stream&gt;</span>)</span></span><br><span class="line"><span class="function">FileStream[] (<span class="params">IEnumerable&lt;FileStream&gt;, ICollection&lt;FileStream&gt;, IList&lt;FileStream&gt;</span>)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">.</span></span><br><span class="line"><span class="function">.(<span class="params">其他引用类型数组</span>)</span></span><br><span class="line"><span class="function">.</span></span><br></pre></td></tr></table></figure><p>另外，如果是值类型数组，就只会为值类型数组本身实现这3个泛型接口，其父类不会再自动实现了，和引用类型数组是不一样的。</p><h3 id="数组的传递和返回"><a href="#数组的传递和返回" class="headerlink" title="数组的传递和返回"></a>数组的传递和返回</h3><p>要理清楚，数组是引用类型，数组的元素类型可能是堆上分配的值/引用类型。</p><p>所以，数组作为参数，传的一定是地址。<br>但是数组元素作为参数，传的可能是地址可能是逐位复制的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">int</span>[] b = a;<span class="comment">// 传数组</span></span><br><span class="line"><span class="built_in">int</span>[] c = <span class="keyword">new</span> <span class="built_in">int</span>[a.Length];</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">333</span>;</span><br><span class="line">Array.Copy(a, c, a.Length);<span class="comment">//传元素</span></span><br><span class="line">c[<span class="number">2</span>] = <span class="number">444</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行完打印, a[2]=333,b[2]=333,c[2]=444</span></span><br></pre></td></tr></table></figure><h3 id="创建下限非0的数组"><a href="#创建下限非0的数组" class="headerlink" title="创建下限非0的数组"></a>创建下限非0的数组</h3><p>用静态方法 Array.CreatInstance(Type type, int[] lengths, int[] lowerBounds) 来实现。</p><p>该方法为数组分配内存，将参数信息保存到数组的内存块开销(overhead)部分。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下实现了创建二维数组：Decimal[2005...2009][1...4]</span></span><br><span class="line"><span class="built_in">int</span>[] lowerBounds = &#123;<span class="number">2005</span>, <span class="number">1</span>&#125;;<span class="comment">// 指定下标下限</span></span><br><span class="line"><span class="built_in">int</span>[] lengths = &#123;<span class="number">5</span>, <span class="number">4</span>&#125;;<span class="comment">// 指定数组长度</span></span><br><span class="line">Decimal[,] decimalArr = (Decimal[,]) Array.CreatInstance(<span class="keyword">typeof</span>(Decimal), lengths, lowerBounds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下用于获取数组x维下标的上限下限值</span></span><br><span class="line"><span class="built_in">int</span> firstYear = decimalArr.GetLowerBound(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">int</span> lastYear = decimalArr.GetUpperBound(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">int</span> firstNum = decimalArr.GetLowerBound(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">int</span> lastNum = decimalArr.GetUpperBound(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="数组循环的内部检查"><a href="#数组循环的内部检查" class="headerlink" title="数组循环的内部检查"></a>数组循环的内部检查</h3><p><strong>数组循环</strong></p><p>用例子解释，执行以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> index=<span class="number">0</span>; index&lt;a.Length; index++)&#123;</span><br><span class="line"><span class="comment">// 对a[index]操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>a.Length检查：只做一次</strong></p><p>对于上述循环操作，只会执行一次a.Length属性获取到数组的实际长度，再将其放到一个临时变量中，后续的循环迭代检查都是用这个临时变量了。</p><p><strong>index检查：为什么0基一维更快？</strong></p><p>对于索引值index，JIT也会进行检查。</p><p>JIT编译器知道for循环要访问0到Length-1的数组元素，所以它会生成代码在运行时测试所有数组元素的访问都在数组有效范围内：<strong>检查是否 <code>(0 &gt;= Get.LowerBound(0)) &amp;&amp; ((Length-1) &gt;= a.GetUpperBound(0))</code></strong>，这个检查在循环之前发生。如果在数组有效范围内，JIT不会再循环内部生成代码验证每一次数组访问是否有效。</p><p>但是对于非0基一维数组（多维数组和非0基一维数组）的循环迭代，JIT就没法这么信任，它必须在循环内部进行越界检查，并且它还需要从指定索引中减去数组下限，所以很影响性能。</p><p>对于这种情况，推荐用0基一维数组构成的多维数组，也就是交错数组<code>int[][]</code>代替矩形数组。</p><p><strong>unsafe访问数组：关闭检查</strong></p><p>使用unsafe关键字，可以关闭索引上下限检查，但是要慎用：它直接访问内存，越界不会抛出异常，但是会损坏内存中的数据，破坏类型安全性制造安全漏洞。</p><p>写法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> my_length = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">SafeArrAccess</span>(<span class="params"><span class="built_in">int</span>[,] a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; my_length; x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; my_length; y++)&#123;</span><br><span class="line">sum += a[x,y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;转换为unsafe版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">unsafe</span> <span class="built_in">int</span> <span class="title">SafeArrAccess</span>(<span class="params"><span class="built_in">int</span>[,] a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">fixed</span> (<span class="built_in">int</span>* pi = a)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; my_length; x++)&#123;</span><br><span class="line"><span class="built_in">int</span> baseOfDim = x * my_length;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; my_length; y++)&#123;</span><br><span class="line">sum += pi[baseOfDim + y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不安全的数组访问和固定大小的数组"><a href="#不安全的数组访问和固定大小的数组" class="headerlink" title="不安全的数组访问和固定大小的数组"></a>不安全的数组访问和固定大小的数组</h3><p><strong>unsafe数组</strong></p><p>unsafe数组访问非常强大，它允许访问：</p><ul><li>托管堆上的数组中的元素（上面的就是）。</li><li>非托管堆上的数组中的元素（比如用Marshal.SecureStringToCoTaskMemUnicode方法返回一个数组，并用不安全的数组访问）。</li><li>线程栈上的数组中的元素，利用stackalloc，下面介绍。</li></ul><p><strong>线程栈上的数组</strong></p><p>通常结构体内写数组也只是持有数组的引用，但是可以如下将数组嵌入结构实现在栈上分配数组的内存。</p><p>在结构体中嵌入数组需要满足以下条件：</p><ul><li>类型必须是结构（值类型），不能在类（引用类型）中嵌入固定大小缓冲区字段（栈上数组）。</li><li>字段或其定义结构必须用unsafe关键字标记。</li><li>数组字段必须用fixed关键字标记。</li><li>数组必须是一维0基数组。</li><li>数组的元素类型必须是：Boolen，Char，SByte，Byte，Int16，Int32，Int64，UInt16，UInt32，UInt64，Single，Double。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">StackallocDemo();</span><br><span class="line">InlineArrayDemo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StackallocDemo</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> width = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">char</span>* pc = <span class="keyword">stackalloc</span> <span class="built_in">char</span>[width];<span class="comment">// 栈上分配数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;Jeffrey Richter&quot;</span>;<span class="comment">// 15个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">&#123;</span><br><span class="line">pc[width - i - <span class="number">1</span>] = (i &lt; s.Length) ? s[i] : <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="keyword">new</span> <span class="built_in">string</span>(pc, <span class="number">0</span>, width));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InlineArrayDemo</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line">CharArray ca;<span class="comment">// 栈上分配数组</span></span><br><span class="line"><span class="built_in">int</span> widthInBytes = <span class="keyword">sizeof</span>(CharArray);</span><br><span class="line"><span class="built_in">int</span> width = widthInBytes / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;Jeffrey Richter&quot;</span>;<span class="comment">// 15个字符 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">&#123;</span><br><span class="line">ca.Characters[width - i - <span class="number">1</span>] = (i &lt; s.Length) ? s[i] : <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="keyword">new</span> <span class="built_in">string</span>(ca.Characters, <span class="number">0</span>, width));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">//.....rethciR yerffeJ</span></span><br><span class="line"><span class="comment">//.....rethciR yerffeJ</span></span><br></pre></td></tr></table></figure><h1 id="大章17：委托"><a href="#大章17：委托" class="headerlink" title="大章17：委托"></a><center>大章17：委托</center></h1><h3 id="初识委托"><a href="#初识委托" class="headerlink" title="初识委托"></a>初识委托</h3><p><strong>委托是什么？</strong></p><p>得先提到<strong>回调函数</strong>，回调函数是一个非常重要的机制，在C/C++中通过qsort函数获取指向一个回调函数的指针，而在.NET中，使用委托来实现回调函数。</p><p>委托比C/C++的回调函数强在它能确保<strong>类型安全</strong>、且提供更多更强大的功能。</p><p><strong>如何使用委托</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.声明委托，它的实例引用一个方法。该方法签名：获取一个int参数，返回void</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.实例方法可以委托</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method_A</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.静态方法也可以委托</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method_B</span>(<span class="params"><span class="built_in">int</span> val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用委托</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// a.声明委托，其实给null后可以直接 += method()，也不会报错空引用，可能是编译器重写了委托的+=</span></span><br><span class="line">    FeedBack delegateList = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// b.给与委托变量一个实例</span></span><br><span class="line">delegateList = <span class="keyword">new</span> FeedBack(Method_A);</span><br><span class="line">    <span class="comment">// c.下面3个行为结果相同</span></span><br><span class="line">delegateList += Method_B;</span><br><span class="line">delegateList += <span class="keyword">new</span> FeedBack(Method_B);<span class="comment">// FeedBack是委托的方法包装器(wapper)</span></span><br><span class="line">delegateList = (FeedBack)Delegate.Combine(delegateList, <span class="keyword">new</span> FeedBack(Method_B));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="委托类型揭秘"><a href="#委托类型揭秘" class="headerlink" title="委托类型揭秘"></a>委托类型揭秘</h3><p><strong>委托就是类</strong></p><p>声明一个委托，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Feedback</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br></pre></td></tr></table></figure><p>这一行代码，C#编译器会这么定义一个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Feedback</span> : <span class="title">System.MulticastDelegate</span> &#123;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Feedback</span>(<span class="params">Object @<span class="built_in">object</span>, IntPtr method</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IAsyncResult <span class="title">BeginInvoke</span>(<span class="params"><span class="built_in">int</span> val, AsyncCallback callback, Object @<span class="built_in">object</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndInvoke</span>(<span class="params">IAsyncResult result</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可见委托其实就是个类，所以委托能定义到类中，也能定义到类外。只要能定义类的地方就能定义委托，可见性随声明委托时用的可见性一样。</li><li>所有的委托都继承自System.MulticastDelegate。</li></ol><p><strong>委托构造器</strong></p><p>上面已经知道委托都继承自System.MulticastDelegate类，那么要构造一个委托肯定离不开这个类，先展示一下这个类内的<strong>重要成员</strong>：</p><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_target</td><td>System.Object</td><td>这个字段引用的是回调方法要操作的对象。当委托对象包装静态方法时，这个字段返回null；当委托对象包装实例方法时，这个字段引用回调方法要操作的对象。</td></tr><tr><td>_methodPtr</td><td>System.IntPtr</td><td>一个内部的整数值，CLR用它标识要回调的方法</td></tr><tr><td>_invocationList</td><td>System.Object</td><td>通常为null。构造委托链时它引用一个委托数组（详见下节）</td></tr></tbody></table><p>再聊<strong>构造器</strong>，所有委托都有一个构造器，它获取2个参数：一个是对象引用，另一个是引用了回调方法的整数。</p><ol><li><p>  C#编译器知道要构造的是委托，在传入诸如<code>new FeedBack(Method_B) </code>这样的参数时，会分析源代码来确定引用的是哪个对象和方法。</p></li><li><p>  对象引用被传给构造器的object参数，标识了方法的一个特殊IntPtr值被传给构造器的method参数。对于静态方法，会给object参数传递null值。构造器方法体内部将这两个实参分别存在_target、_methodPtr这两个私有字段里。</p></li><li><p>  最后将_invocationList字段设置为null，这个字段后面讨论。</p></li></ol><p>所以，每个委托对象实际都是一个**包装器(wapper)**，其中包装了一个方法和调用该方法时要操作的对象。结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211210173655.png"></p><h3 id="委托使用揭秘"><a href="#委托使用揭秘" class="headerlink" title="委托使用揭秘"></a>委托使用揭秘</h3><p><strong>委托调用</strong></p><p>C#编译器会自动将委托的调用转换为Invoke：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FeedBack fb = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">fb(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 在C#编译器眼里，上面的调用自动转换为：</span></span><br><span class="line">fb.Invoke(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>可以查看IL代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IL_0009:callvirt instance void Feedback::Invoke(int32)</span><br></pre></td></tr></table></figure><p><strong>委托链</strong></p><p>委托链，也就是用委托回调多个方法。<br>下面制造一个委托链并调用，堆流程刨析：</p><p>1.初始化委托链(委托)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line">...</span><br><span class="line">FeedBack fbChain = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>2.将委托添加到链中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbChain = (Feedback) Delegate.Combine(fbChain, fb1);</span><br></pre></td></tr></table></figure><p>此时Combine方法内部，发现fbChain是null，所以直接返回fb1中的值。</p><p>3.再将委托添加到链中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbChain = (Feedback) Delegate.Combine(fbChain, fb2);</span><br></pre></td></tr></table></figure><p>此时Combine方法内部，发现fbChain内部已经包含了一个委托(fb1)，所以会构造一个新的委托对象。初始化这个新委托对象时，**_invocationList字段**被初始化为引用一个委托对象数组。</p><p>数组的第一个元素(索引0)被初始化为重包装了fbChain内部方法的委托，数组的第二个元素(索引1)被初始化为重包装了fb2内部方法的委。</p><p>最后，fbChain被设为引用新建的委托对象。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211213095622.png"></p><p>后续如果继续向委托链+=新委托，每次都会新建一个委托数组放入**_invocationList字段<strong>中，让原先的数组进入GC，我称之为</strong>委托链的不可变性**。至于为什么要新建而不是扩容，我估计是因为数组长度不可变，比起扩容，new比较省事安全吧。</p><p>4.对委托链进行调用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbChain(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>首先知道，fbChain会被转换为 fbChain.Invoke。</p><p>Invoke时发现内部字段_invocationList不为null，就能判断为一个委托链，对其进行循环遍历数组并依次调用各个委托中的方法。</p><p>5.对委托链进行Remove</p><p>倒序循环遍历_invocationList数组，匹配_target和_methodPtr字段相同的元素进行删除，只删除一个元素。</p><p><strong>显式调用委托链</strong></p><p>起因是委托链遍历调用，返回值只能有一个，且某一元素出错会导致后续的委托都出错，就很不健壮。</p><p>所以MulticastDelegate类提供了<strong>实例方法GetInvocationList</strong>，用于显式调用链中的每一个委托：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstarct clas MulticastDelegate : Delegate &#123;</span><br><span class="line">    <span class="comment">// 创建一个委托数组，其中每个元素都指向委托链的一个委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> Delegate[] <span class="title">GetInvocationList</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个方法，就可以自己显式调用每一个委托，加上诸如 try catch 的定制化处理。</p><h3 id="C-泛型委托"><a href="#C-泛型委托" class="headerlink" title="C#泛型委托"></a>C#泛型委托</h3><p><strong>尽量少定义委托</strong></p><p>主要是就定义的太多了，比如微软定义的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TryCode</span>(<span class="params">Object userData</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">WaitCallback</span>(<span class="params">Object state</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object state</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>压根就是重复的签名，根本没必要定义的这么杂乱，所以推荐用泛型委托。</p><p><strong>Action和Func</strong></p><p>微软定义好的泛型委托就是Action和Func，Action有16个Func有17个。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span>;<span class="comment">// 这个不是泛型，所以不算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">TResult</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">TResult</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>, <span class="title">TResult</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br></pre></td></tr></table></figure><h3 id="C-委托语法糖"><a href="#C-委托语法糖" class="headerlink" title="C#委托语法糖"></a>C#委托语法糖</h3><p><strong>不必新建委托对象</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义签名以及调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params">FeedBack fb</span>)</span> &#123; &#125;</span><br><span class="line">...</span><br><span class="line">SomeMethod(<span class="keyword">new</span> FeedBack(Method_A));</span><br><span class="line"><span class="comment">// 可以简化为直接传方法名</span></span><br><span class="line">SomeMethod(Method_A);</span><br></pre></td></tr></table></figure><p>省去new，当然IL代码还是会一样生成的。</p><p><strong>不必定义方法(lambda)</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SomeMethod(num =&gt; &#123;</span><br><span class="line">    <span class="comment">//do sth </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实就是匿名函数，IL代码也一样会生成一个同签名的方法，不过方法名不确定(编译时才知道)且为private。</p><p><strong>直接使用局部变量(lambda)</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OtherMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    FeedBack fb = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">3</span>;</span><br><span class="line">    fb += (num =&gt; &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在IL的生成代码里看，这个匿名方法之所以能直接用局部变量、实例变量，是因为它定义为一个方法内的嵌套类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OtherMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    FeedBack fb = <span class="literal">null</span>;<span class="comment">// 伪代码</span></span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">3</span>;<span class="comment">// 伪代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造辅助类实例并初始化</span></span><br><span class="line">    &lt;&gt;c__DisplayClass1 class1 = <span class="keyword">new</span> c__DisplayClass1();</span><br><span class="line">    class1.x = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定委托</span></span><br><span class="line">    fb = <span class="keyword">new</span> FeedBack(class1.&lt;OtherMethod&gt;b__0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IL代码</span></span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span>&lt;&gt;<span class="title">c__DisplayClass1</span> : <span class="title">Object</span>&#123;</span><br><span class="line"><span class="comment">// 回调函数要使用的每个局部变量都有一个对应的公共字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line"><span class="comment">// 公共无参构造器</span></span><br><span class="line"><span class="keyword">public</span> &lt;&gt;c__DisplayClass1 &#123; &#125;</span><br><span class="line"><span class="comment">// 公共实例方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> &lt;OtherMethod&gt;b__0(<span class="built_in">int</span> num)&#123;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>+=和-=操作符</strong></p><p>被重载了，分别是Delegate.Combine、Delegate.Remove。IL代码完全一致。</p><h3 id="委托和反射"><a href="#委托和反射" class="headerlink" title="委托和反射"></a>委托和反射</h3><ol><li>  获取委托，使用<code>MethodInfo.CreateDelegate(委托Type, 实例对象Object)</code>方法。</li><li>  调用委托，使用<code>Delegate.DynamicInvoke</code>方法。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FeedBack</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MethodInfo mi = <span class="keyword">typeof</span>(Person).GetMethod(<span class="string">&quot;TellAge&quot;</span>, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line"><span class="keyword">var</span> instance = Activator.CreateInstance(<span class="keyword">typeof</span>(Person)) <span class="keyword">as</span> Person;</span><br><span class="line">Delegate d = mi.CreateDelegate(<span class="keyword">typeof</span>(FeedBack), instance);</span><br><span class="line">d.DynamicInvoke(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">TellAge</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;我&#123;0&#125;岁了&quot;</span>,age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="大章18：定制特性"><a href="#大章18：定制特性" class="headerlink" title="大章18：定制特性"></a><center>大章18：定制特性</center></h1><h3 id="定制特性-custom-attribute"><a href="#定制特性-custom-attribute" class="headerlink" title="定制特性(custom attribute)"></a>定制特性(custom attribute)</h3><p><strong>什么是特性</strong></p><p>比如public、private、static这些就算是特性。</p><p>但是如果能定义自己的特性，比如定义一个类型，指出该类型能够通过序列化来进行远程处理。</p><p><strong>什么是定制特性</strong></p><p>定制特性其实是一个类型的实例。它必须从类<strong>System.Attribute</strong>派生。</p><p><strong>如何使用特性</strong></p><p>1.使用特性的语法和构造方法非常相似，是因为其实就是对Attribute类进行实例化。但也有点不同，构造器用到的参数叫**定位参数(positional parameter)<strong>，用于设置字段或属性的参数成为</strong>命名参数(named parameter)**。</p><p>比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;Kernel32&quot;</span>, CharSet = CharSet.Auto, SetLastError = true)</span>]</span><br></pre></td></tr></table></figure><p>这一句里，”Kernel32”是构造器需要的参数，也就是定位参数，它是必要的；“CharSet”和“SetLastError”是设置内部属性的，也就是命名参数，是非必要的。</p><p>2.此外，特性写法也很多种，Attribute后缀可以写可以不写，以下4条是等效的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>][Flags]</span><br><span class="line">[<span class="meta">Serializable, Flags</span>]</span><br><span class="line">[<span class="meta">FlagsAttribute, SerializableAttribute</span>]</span><br><span class="line">[<span class="meta">Serializable()</span>][FlagsAttribute()]</span><br></pre></td></tr></table></figure><p><strong>定制特性例子</strong></p><p>.NET类库定义了几百个定制特性，可将他们应用于自己源代码中：</p><ul><li>DllImport特性应用于方法，告诉CLR该方法的实现位于指定dll的非托管代码中。</li><li>Serializable特性应用于类型，告诉序列化格式化器一个实例的字段可以序列化和反序列化。</li><li>AssemblyVersion特性应用于程序集，设置程序集的版本号。</li><li>Flags特性应用于枚举类型，枚举类型就成了位标志(bit flag)集合。</li></ul><p><strong>特性应用范围</strong></p><p>CLR允许将特性应用于可在文件的元数据中表示的几乎任何东西。比如：</p><ul><li>  TypeDef 类、结构、枚举、接口和委托</li><li>  MethodDef 构造器、方法</li><li>  ParamDef 参数</li><li>  …</li></ul><h3 id="定义自己的特性类"><a href="#定义自己的特性类" class="headerlink" title="定义自己的特性类"></a>定义自己的特性类</h3><p><strong>1.定义一个Attribute类</strong></p><p>模仿写一个FlagsAttribute位标识特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlagsAttribute</span> : <span class="title">System.Attribute</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlagsAttribute</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.限制特性的应用范围</strong></p><p>希望特性只能用于枚举类型，需要用到System.AttributeUsage类的实例，该类是微软定义的用于限制特性定义范围的特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeUsage.Enum, Inherited = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlagsAttribute</span> : <span class="title">System.Attribute</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlagsAttribute</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.5.了解一下System.AttributeUsage</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类大致定义</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class, Inherited = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AttributeUsageAttribute</span> : <span class="title">Attribute</span> &#123;</span><br><span class="line">    <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> AttributeUsageAttribute Default = <span class="keyword">new</span> AttributeUsageAttribute(AttrubuteTargets.All);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 属性(这里简写为字段了)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">bool</span> AllowMultiple = <span class="literal">false</span>;<span class="comment">// 是否可以让该特性实例多次应用于同一个目标</span></span><br><span class="line">    <span class="keyword">internal</span> AttributeTargets AttributeTarget = AttributeTargets.All;<span class="comment">// 特性应用范围</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">bool</span> Inherited = <span class="literal">true</span>;<span class="comment">// 特性是否可被继承</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AttributeUsageAttribute</span>(<span class="params">AttributeTargets validOn</span>)</span> &#123;</span><br><span class="line">        AttributeTarget = validOn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AttributeUsageAttribute</span>(<span class="params">AttributeTargets validOn, <span class="built_in">bool</span> allowMulit, <span class="built_in">bool</span> inherited</span>)</span> &#123;</span><br><span class="line">        AttributeTarget = validOn;</span><br><span class="line">        AllowMultiple = allowMulit;</span><br><span class="line">        Inherited = inherited;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AttributeTargets枚举类</span></span><br><span class="line">[<span class="meta">Flags, Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AttributeTargets &#123;</span><br><span class="line">    Assembly,</span><br><span class="line">    Module,</span><br><span class="line">    Class,</span><br><span class="line">    Struct,</span><br><span class="line">    Enum,</span><br><span class="line">    Construector,</span><br><span class="line">    Method,</span><br><span class="line">    Property,</span><br><span class="line">    Field,</span><br><span class="line">    Event,</span><br><span class="line">    Interface,</span><br><span class="line">    Parameter,</span><br><span class="line">    Delegate,</span><br><span class="line">    ReturnValue,</span><br><span class="line">    GenericParamter,<span class="comment">// 泛型参数</span></span><br><span class="line">    All</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = true)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">TastyAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Tasty</span>][Serializable]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">BaseType</span> &#123;</span><br><span class="line">    [<span class="meta">Tasty</span>] <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">DerivedType</span> : <span class="title">BaseType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用例，稍微讲一下：</p><p>DerivedType类 和它的 DoSomething方法 都被视为 [Tasty]，因为他们都在应用范围内且<code>Inherited = true</code>，意味着可被继承。但是Serializable设置为不可被继承，所以DerivedType没有继承到父类的[Serializable]。</p><p><strong>3.构造器</strong></p><p>一般来说特性类就当正常类定义就行了，不过构造器比较特殊：</p><p>a.特性类<strong>构造器的入参</strong>可供选择的数据类型并不多：bool，char，byte，SByte，Int16，UInt16，Int32，UInt32，Int64，UInt64，Single，Double，String，Type，Object或枚举类型。以及上述类型的一维0基数组。如果不遵守，是通不过编译的 “不是有效的特性参数类型”。</p><p>b.特性类构造器有2种参数，一种是构造方法定义的指定参数，还有一种是<strong>增强型构造器语法</strong>所指定的值。当然无论哪种都得遵守1中的要求，演示如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">TastyAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line"><span class="keyword">public</span> Test Z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TastyAttribute</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">X = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Tasty(10, Y = 100)</span>] <span class="comment">// 可见可以直接指定Y，但是Z无法指定！会报错 “不是有效的特性参数类型”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>c.我们怎么理解定制特性？它是类的实例，被序列化成驻留在元数据中的字节流。运行时可对元数据中的字节进行反序列化，从而构造出类的实例。真实情况中的元数据会稍微复杂点，构造器的参数会序列化成 “字段1 字段1类型ID 字段2 字段2类型ID…” 这样的字符串。</p><h3 id="运用自己的特性类"><a href="#运用自己的特性类" class="headerlink" title="运用自己的特性类"></a>运用自己的特性类</h3><p><strong>光应用特性类没用</strong></p><p>仅仅定义+应用自制的特性类没有用，只能在元数据中生成一堆额外数据罢了。</p><p>那怎么有用呢？比如特性[Flags]用于枚举类型，之所以能让ToString的方法产生行为变化，是因为ToString方法会在运行时检查自己操作的枚举类型是否关联了[Flags]特性元数据。</p><p>所以，方法会在运行时检查操作的数据是否关联了特性元数据，至于检测用的是<strong>反射</strong>技术。</p><p><strong>检测定制特性</strong></p><p>微软在反射插件<code>System.Reflection.CustomAttributeExtensions</code>提供了3个静态拓展方法来<strong>扫描</strong>托管模块的元数据，执行字符串比较来定位指定的定制特性类的位置：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>IsDefined</td><td>如果至少有一个指定的Attribute派生类的实例与目标关联就返回true。效率很高因为不需要反序列化构造特性类的实例。</td></tr><tr><td>GetCustomAttributes</td><td>返回应用于目标的指定特性实例的集合；如果没有，就返回null。一般该方法用于AllowMultiple为true的特性。</td></tr><tr><td>GetCustomAttribute</td><td>返回应用于目标的指定特性的实例。实例使用编译时指定的参数、字段和属性，反序列化元数据获得并构造；如果没有，就返回null；如果有目标应用指定特性的多个实例，就抛出System.Reflection.AmbiguousMatchException异常。一般该方法用于AllowMultiple为false的特性。</td></tr></tbody></table><p>在<code>System.Reflection</code>命名空间提供了很多类允许检查模块的元数据（也就是上述方法），包括Assembly、Module、ParameterInfo、MemberInfo、Type、MethodInfo、ConstructorInfo、FieldInfo、EventInfo、PropertyInfo及其各自的*Builder类。</p><p><strong>用起特性类</strong></p><p>了解前面理论之后，特性[Flags]的用法大概就会这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum的ToString实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> String <span class="title">ToString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.GetType().IsDefined(<span class="keyword">typeof</span>(FlagAttribute), <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果是，就当作一个位标志枚举类型</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果不是，就当作一个普通枚举类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比较特性类</strong></p><p>特性类之间的比较通过<strong>Equals和Match两个虚方法</strong>。</p><p>System.Attribute重写了Object的Equals方法，Match默认实现就是直接调用Equals，具体比较逻辑如下：</p><ol><li>  先比较两个实例的类型，不一致返回false。</li><li>  再用反射比较两个特性实例中的字段值（为每个字段都调用Equals），所有字段匹配返回true；否则false。</li></ol><p>但是既然是虚方法，自然可以重写自定义，这里重写一个Match的实现为判断是否是子集。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特性用标志位枚举类</span></span><br><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="built_in">enum</span> Accounts &#123;</span><br><span class="line">    Saving = <span class="number">0x0001</span>,</span><br><span class="line">    Checking = <span class="number">0x0002</span>,</span><br><span class="line">    Brokerage = <span class="number">0x0004</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义特性</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AccountsAttribute</span> : <span class="title">Attribute</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Accounts accounts;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountsAttribute</span>(<span class="params">Accounts accounts</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Boolean <span class="title">Match</span>(<span class="params">Object obj</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果父类实现了Match if(!base.Match(obj)) return false</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 确保不为null</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.GetType() != obj.GetType()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 确保类型一致</span></span><br><span class="line">        AccountsAttribute other = (AccountsAttribute)obj; <span class="comment">// 既然类型一致转型必成功</span></span><br><span class="line">        <span class="keyword">if</span>((other.accounts &amp; accounts) != accounts)&#123;</span><br><span class="line">            <span class="comment">// 如果不是子集</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">[<span class="meta">Accounts(Accounts.Saving)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ChildAccount</span> &#123; &#125;</span><br><span class="line">[<span class="meta">Accounts(Accounts.Saving | Accounts.Checking | Accounts.Brokerage)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AdultAccount</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> child = <span class="keyword">new</span> ChildAccount();</span><br><span class="line"><span class="keyword">var</span> adult = <span class="keyword">new</span> AdultAccount();</span><br><span class="line">    Attribute checking = <span class="keyword">new</span> AccountsAttribute(Accounts.Checking); <span class="comment">// 指定Accounts.Checking来测试Match方法</span></span><br><span class="line">    </span><br><span class="line">    Attribute validChildAccounts = Attribute.GetCustomAttribute(child.GetType(),<span class="keyword">typeof</span>(AccountsAttribute),<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (validChildAccounts != <span class="literal">null</span> &amp;&amp; checking.Match(validChildAccounts))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;child matched!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Attribute validAdultAccounts = Attribute.GetCustomAttribute(adult.GetType(), <span class="keyword">typeof</span>(AccountsAttribute), <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (validAdultAccounts != <span class="literal">null</span> &amp;&amp; checking.Match(validAdultAccounts))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;adult matched!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: adult matched!</span></span><br></pre></td></tr></table></figure><h3 id="不创建实例的检测定制特性方法"><a href="#不创建实例的检测定制特性方法" class="headerlink" title="不创建实例的检测定制特性方法"></a>不创建实例的检测定制特性方法</h3><p>前面是调用了<code>Attribute.GetCustomAttributes</code>方法，这些方法会在内部调用特性类的构造器并set属性。</p><p>利用CustomAttributeData类，比如<code>CustomAttributeData.GetCustomAttributes</code>方法，可以不实际调用构造器与set属性，来安全获得预想状态的实例属性等，而实际上并没有真的创建实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Accounts(Accounts.Saving | Accounts.Checking | Accounts.Brokerage, age=33)</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AdultAccount</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> adult = <span class="keyword">new</span> AdultAccount();</span><br><span class="line"><span class="keyword">var</span> attributeDatas = CustomAttributeData.GetCustomAttributes(adult.GetType());</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> attributeData <span class="keyword">in</span> attributeDatas)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// AttributeType 属性的类型, Constructor 表示应已初始化自定义属性的构造函数</span></span><br><span class="line">Console.WriteLine(attributeData.AttributeType);</span><br><span class="line">Console.WriteLine(attributeData.Constructor.DeclaringType);</span><br><span class="line"><span class="comment">// output1: ConsoleApp5.AccountsAttribute</span></span><br><span class="line"><span class="comment">// output2: ConsoleApp5.AccountsAttribute</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// attributeData.ConstructorArguments 表示特性实例指定的位置参数列表</span></span><br><span class="line">         <span class="comment">// output3: constructorArgs:ConsoleApp5.Accounts 7</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> conArg <span class="keyword">in</span> attributeData.ConstructorArguments)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;constructorArgs:&quot;</span> + conArg.ArgumentType + <span class="string">&quot; &quot;</span> + conArg.Value);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// attributeData.NamedArguments 表示的特性实例指定的命名参数列表</span></span><br><span class="line">         <span class="comment">// output4: namedArgs:Int32 age age (Int32)33 True</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> conArg <span class="keyword">in</span> attributeData.NamedArguments)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;namedArgs:&quot;</span> + conArg.MemberInfo + <span class="string">&quot; &quot;</span> + conArg.MemberName + <span class="string">&quot; &quot;</span> + conArg.TypedValue +<span class="string">&quot; &quot;</span>+ conArg.IsField);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍一下<code>GetCustomAttributes</code>方法，它返回包裹了所有特性数据的列表，特性用类<code>CustomAttributeData</code>来包裹，它的属性：</p><ul><li>  AttributeType：该特性的类型</li><li>  Constructor：已初始化过的自定义属性的构造函数</li><li>  ConstructorArguments：所使用 构造器 中的参数们（注意无法获取参数名字）</li><li>  NamedArguments：所使用 特性增强构造器 的参数们（就是命名指定的那些参数，可以获取到参数名字）</li></ul><h3 id="条件特性类"><a href="#条件特性类" class="headerlink" title="条件特性类"></a>条件特性类</h3><p><strong>ConditionalAttribute</strong></p><p>条件特性类，说的就是特性<code>System.Disgnostics.ConditionalAttribute</code>。将此特性应用于自定义的定制特性，该定制特性就能根据环境宏来判断是否真正应用特性类并生成其元数据。当然不止是运用于定制特性，应用于方法等也是一样有效的。使用起来有点类似于**#if**。</p><p>调用方法是，<strong>宏定义 或者 #define</strong>，两者是一样的含义，都是在定义编译时常量。</p><p>#define方法展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CodingCodingK</span></span><br><span class="line"><span class="comment">// 上面启用了Test()和Test2()两个方法，当然宏定义也是一样的</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    Test();</span><br><span class="line">    Test2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;CodingCodingK&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;I can do that !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上作用类似于</span></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;CodingCodingK&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CodingCodingK</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;I can do that !&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏定义方法展示：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211215154042.png"></p><p>最后，网上有篇文章说ConditionalAttribute和#if方法使用只是类似而不是完全一致，是因为方法定义和方法调用如果在2个不同的程序集内，那么就点不同了：ConditionalAttribute是根据调用地点的程序集内有没有定义宏来选择生成代码的，而#if像上面这样写是根据方法定义地点的程序集内有没有定义宏来判断的。</p><p>我个人是觉得…其实也可以把#if写到调用方法的地方，那样两者使用的效果可以说一样了。嘛…</p><h1 id="大章19：可null值类型"><a href="#大章19：可null值类型" class="headerlink" title="大章19：可null值类型"></a><center>大章19：可null值类型</center></h1><h3 id="可null值类型-结构"><a href="#可null值类型-结构" class="headerlink" title="可null值类型 结构"></a>可null值类型 结构</h3><p><strong>问题由来</strong></p><p>由于各类系统或软件之间定义的类型并不能一一配对，比如java中的java.util.Date类是引用类型，所以该类型的变量能为null；但CLR的System.DateTime是值类型，永远不能为null。</p><p>为了解决这个问题，微软在CLR中引入了可空值类型的概念，先看一下<code>System.Nullable&lt;T&gt;</code>结构来理解。</p><p><strong>System.Nullable<T></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable, StructLayout(LayoutKind.Sequential)</span>]</span><br><span class="line"><span class="comment">// Nullable约束为struct，T也约束为struct，所以实例仍然是在栈上的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Nullable&lt;T&gt; <span class="keyword">where</span> T : <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这两个字段表示状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> hasValue; <span class="comment">// 假定null</span></span><br><span class="line"><span class="keyword">internal</span> T <span class="keyword">value</span>; <span class="comment">// 假定所有位都为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Nullable</span>(<span class="params">T val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">value</span> = val;</span><br><span class="line"><span class="keyword">this</span>.hasValue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> HasValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> hasValue; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T Value</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!hasValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Nullable object must have a value.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetValueOrDefault</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="keyword">value</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetValueOrDefault</span>(<span class="params">T defaultValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> defaultValue;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面重写 Equals、GetHashCode、ToString，避免报值类型的错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> (other == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (other == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>.Equals(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>.GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!HasValue) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 值类型=&gt;可null值类型 隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Nullable</span>&lt;<span class="title">T</span>&gt;(<span class="params">T val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Nullable&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 可null值类型=&gt;值类型 隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">T</span>(<span class="params">Nullable&lt;T&gt; val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> val.Value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">main <span class="title">void</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Nullable&lt;<span class="built_in">int</span>&gt; a = <span class="number">1</span>; <span class="comment">// 模仿 int? a = 1;</span></span><br><span class="line">    <span class="comment">// 最尴尬的来了，按照书里的敲，下面的这个是编译不过的：无法将null转换为“Nullable&lt;int&gt;”，因为后者是不可以为null的值类型</span></span><br><span class="line">Nullable&lt;<span class="built_in">int</span>&gt; b = <span class="literal">null</span>; <span class="comment">// 模仿 int? b = null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段用来理解是够了，看.NET源码也确实是这么写的，自己实例化却发现null不了，很尴尬。TODO 估计是哪里漏了理解，以后再补上。</p><h3 id="C-对可空值类型的支持"><a href="#C-对可空值类型的支持" class="headerlink" title="C#对可空值类型的支持"></a>C#对可空值类型的支持</h3><p><strong>语法简化</strong></p><p>C#允许使用<code>T?</code>来等价替代<code>Nullable&lt;T&gt;</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? x = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 完全等价于</span></span><br><span class="line">Nullable&lt;<span class="built_in">int</span>&gt; y = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><strong>操作符</strong></p><p>基本上有一个操作数是null，就直接返回null。如果操作数都不为null，那操作符计算方式与非null值类型相同。</p><h3 id="CLR对可null类型的特殊处理"><a href="#CLR对可null类型的特殊处理" class="headerlink" title="CLR对可null类型的特殊处理"></a>CLR对可null类型的特殊处理</h3><p><strong>可null类型的装箱</strong></p><p><code>Nullable&lt;T&gt;</code>毕竟还是值类型，所以将其传给一个接收Object的方法时就得为其装箱。但是其为null时为一个null装箱很奇怪。所以CLR对可null类型的装箱多作了些手段：</p><ol><li>  判断是否是null，如果是，就不装箱直接返回null。</li><li>  如果不是null，就取出值，并装箱返回。</li></ol><p><strong>可null类型的拆箱</strong></p><p>如果已装箱值类型的引用是null，那么CLR会将<code>Nullable&lt;T&gt;</code>的值设为null。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="number">5</span>; <span class="comment">// 创建已装箱的int</span></span><br><span class="line">o = <span class="literal">null</span>;</span><br><span class="line">int32? a = (int32?) o; <span class="comment">// 拆箱，a = null</span></span><br></pre></td></tr></table></figure><p><strong>Nullable.GetType</strong></p><p>对<code>Nullable&lt;T&gt;</code>执行<code>GetType()</code>，CLR会“撒谎”说类型是T，而不是<code>Nullable&lt;T&gt;</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int32? x = <span class="number">6</span>;</span><br><span class="line">Console.WriteLine(x.GetType()); <span class="comment">// output:&quot;System.Int32&quot;</span></span><br></pre></td></tr></table></figure><p><strong>调用接口方法</strong></p><p>编译器提供了更简洁的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果CLR没有提供，写起来很繁琐</span></span><br><span class="line"><span class="built_in">int</span> result1 = ((IComparable) (<span class="built_in">int</span>) n).CompareTo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLR提供特殊支持后的简便写法</span></span><br><span class="line"><span class="built_in">int</span> result2 = ((IComparable) n).CompareTo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="其他：空接合操作符"><a href="#其他：空接合操作符" class="headerlink" title="其他：空接合操作符"></a>其他：空接合操作符</h3><p><strong>null-coalescing operator</strong></p><p>空接合操作符(null-coalescing operator)，即**??操作符**。它要获取两个操作数，如果左边的操作数不为null，就返回左，否则就返回右。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大章14：字符、字符串和文本处理&quot;&gt;&lt;a href=&quot;#大章14：字符、字符串和文本处理&quot; class=&quot;headerlink&quot; title=&quot;大章14：字符、字符串和文本处理&quot;&gt;&lt;/a&gt;&lt;center&gt;大章14：字符、字符串和文本处理&lt;/center&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="CLR via C#" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/"/>
    
    <category term="第三章 基本类型" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="可访问性" scheme="https://codingcodingk.github.io/tags/%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/"/>
    
    <category term="基本类型" scheme="https://codingcodingk.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 技能篇</title>
    <link href="https://codingcodingk.github.io/2021/12/18/Project/Unity/Moba/HOK/skill/"/>
    <id>https://codingcodingk.github.io/2021/12/18/Project/Unity/Moba/HOK/skill/</id>
    <published>2021-12-18T06:56:08.410Z</published>
    <updated>2022-01-15T11:50:39.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技能机制"><a href="#技能机制" class="headerlink" title="技能机制"></a><Center>技能机制<Center/></h1><h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211206214406.png"></p><h2 id="技能分析"><a href="#技能分析" class="headerlink" title="技能分析"></a>技能分析</h2><p>目标 = 指向；弹道 = 借助bullet；无前摇 = 瞬发型。</p><table><thead><tr><th>英雄</th><th>亚瑟</th><th>后羿</th></tr></thead><tbody><tr><td>普攻</td><td>目标技能 + 非弹道、有前摇</td><td>目标技能 + 弹道、延迟</td></tr><tr><td>技能1</td><td>非目标技能  buff替换普攻Cfg + 非弹道、无前摇</td><td></td></tr><tr><td>技能2</td><td>非目标技能 + 非弹道、无前摇</td><td></td></tr><tr><td>技能3</td><td>目标技能 + 非弹道、有前摇</td><td></td></tr></tbody></table><h2 id="非目标技能（非指向）"><a href="#非目标技能（非指向）" class="headerlink" title="非目标技能（非指向）"></a>非目标技能（非指向）</h2><h3 id="1-buff替换普攻Cfg技能实现（亚瑟一技能）"><a href="#1-buff替换普攻Cfg技能实现（亚瑟一技能）" class="headerlink" title="1.buff替换普攻Cfg技能实现（亚瑟一技能）"></a>1.buff替换普攻Cfg技能实现（亚瑟一技能）</h3><p>亚瑟技能1有许多buff附加到下一个普攻上，直接修改普攻得buffArr使其变更数据会让代码复杂，所以直接采用技能替换普攻的方法，将其作为一个技能。</p><p>之后每1次普攻，其实就相当于在释放1次技能了，所以技能的buff 也会随着每一次普攻而重新Create。</p><p>直到时间结束或者攻击次数用完，技能被替换回原先的普攻。</p><h3 id="2-后裔三技能实现"><a href="#2-后裔三技能实现" class="headerlink" title="2.后裔三技能实现"></a>2.后裔三技能实现</h3><h2 id="目标技能（指向）"><a href="#目标技能（指向）" class="headerlink" title="目标技能（指向）"></a>目标技能（指向）</h2><h3 id="通用的寻找目标实现"><a href="#通用的寻找目标实现" class="headerlink" title="通用的寻找目标实现"></a>通用的寻找目标实现</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211206220958.png"></p><ol><li>根据配置，查找到所有活着的可作为目标的单位(比如红队的英雄)</li><li>根据技能配置规则，确定最终目标单位(比如最近的单个英雄)</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------1.中的配置规则----------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 施法目标阵营</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> TargetTeamEnum</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于动态选择目标，通常是方向指向或位置指向技能，在施法成功后通过buff选择目标</span></span><br><span class="line">    Dynamic,</span><br><span class="line">    Friend,</span><br><span class="line">    Enemy</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> 施法目标类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UnitTypeEnum</span><br><span class="line">&#123;</span><br><span class="line">    Hero,</span><br><span class="line">    Soldier,</span><br><span class="line">    Tower,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------2.中的技能配置规则----------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SelectRuleEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单个目标选择规则</span></span><br><span class="line">    </span><br><span class="line">    MinHpValue,<span class="comment">// 血量最小</span></span><br><span class="line">    MinHpPercent,<span class="comment">// 血量百分比最小</span></span><br><span class="line">    TargetClosestSingle,<span class="comment">// 最近的单个</span></span><br><span class="line">    PositionClosestSingle,<span class="comment">// 靠近某个位置的单个选择</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多个目标选择规则</span></span><br><span class="line">    </span><br><span class="line">    TargetClosestMulti,<span class="comment">// 最近的多个（范围选择）</span></span><br><span class="line">    PositionClosestMulti,<span class="comment">// 靠近某个位置的多个选择（范围选择）</span></span><br><span class="line">    </span><br><span class="line">    Hero,<span class="comment">// 所有英雄单位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让我们看一下2中实现目标查找的关键部分代码，找最近单体目标的核心代码。其他的实现比如查找符合目标的群体算法，核心部分逻辑也是一样的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------核心，查找规则----------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> MainLogicUnit <span class="title">FindMinDisTarget</span>(<span class="params">MainLogicUnit self,List&lt;MainLogicUnit&gt; targetList, PEInt range</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetList == <span class="literal">null</span> || targetList.Count &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MainLogicUnit target = <span class="literal">null</span>;</span><br><span class="line">    PEVector3 selfPos = self.LogicPos;</span><br><span class="line">    PEInt len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; targetList.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PEInt sumRaius = targetList[i].ud.unitCfg.colliCfg.mRadius + self.ud.unitCfg.colliCfg.mRadius;</span><br><span class="line">        <span class="comment">// 要剔除掉半径，因为某单位半径可能因为体型变大而变得非常大，结果就看上去更近了，应该打这个看上去更近的</span></span><br><span class="line">        <span class="comment">// 可以优化一下 =&gt; 模magnitude 用 平方根sqrMagnitude替代，比较的时候与(range + sumRaius)*(range + sumRaius)比较即可，不等式是一样的，但可以省去一次开根号。</span></span><br><span class="line">        PEInt tmpLen = (targetList[i].LogicPos - selfPos).magnitude - sumRaius;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span> || tmpLen &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            len = tmpLen;</span><br><span class="line">            target = targetList[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将上面找到的最近目标与range比较，如果还是超过range就返回null</span></span><br><span class="line">    <span class="keyword">return</span> len &lt; range ? target : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-亚瑟普攻实现"><a href="#1-亚瑟普攻实现" class="headerlink" title="1.亚瑟普攻实现"></a>1.亚瑟普攻实现</h3><ol><li>寻找目标</li><li>切换技能状态到<code>SKillState.SpellStart</code></li><li>播放音效</li><li>修改朝向：修改为<code>lockTarget.LogicPos - owner.LogicPos</code>的PEVector3向量。</li><li>播放动画：先取消移动，再播放攻击动画。</li></ol><h3 id="2-后裔普攻实现"><a href="#2-后裔普攻实现" class="headerlink" title="2.后裔普攻实现"></a>2.后裔普攻实现</h3><h1 id="技能构造"><a href="#技能构造" class="headerlink" title="技能构造"></a><Center>技能构造<Center/></h1><h2 id="技能Config"><a href="#技能Config" class="headerlink" title="技能Config"></a>技能Config</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="血条和伤害UI"><a href="#血条和伤害UI" class="headerlink" title="血条和伤害UI"></a><Center>血条和伤害UI<Center/></h1><h2 id="血条-数据结构"><a href="#血条-数据结构" class="headerlink" title="血条 数据结构"></a>血条 数据结构</h2><p><strong>个体状态枚举类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 血条上显示的状态</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StateEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Silenced,<span class="comment">//沉默</span></span><br><span class="line">    Knockup,<span class="comment">//击飞</span></span><br><span class="line">    Stunned,<span class="comment">//眩晕</span></span><br><span class="line">    </span><br><span class="line">    Invincible,<span class="comment">//无敌</span></span><br><span class="line">    Restricted,<span class="comment">//禁锢</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象血条类结构</strong></p><p>继承关系：公用抽象血条类 =&gt; 塔 ； 公用抽象血条类 =&gt; 小兵 =&gt; 英雄 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RectTransform rect;</span><br><span class="line"><span class="keyword">public</span> Image imgPrg;<span class="comment">// 进度</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">bool</span> isFriend;<span class="comment">//是否是友军，用来显示不同颜色的血条UI</span></span><br><span class="line"><span class="keyword">protected</span> Transform rootTrans;<span class="comment">//目标血条，即需要映射的物体的位置，比如英雄头顶上的位置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">int</span> hpVal;</span><br></pre></td></tr></table></figure><h2 id="UI映射"><a href="#UI映射" class="headerlink" title="UI映射"></a>UI映射</h2><p><strong>血条</strong></p><p><strong>血条映射</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (rootTrans)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 标准高度：自适应高度，取出比例</span></span><br><span class="line">         <span class="built_in">float</span> scaleRate = <span class="number">1.0f</span> * ClientConfig.ScreenStandardHeight / Screen.height;</span><br><span class="line">         <span class="keyword">var</span> screenPos = Camera.main.WorldToScreenPoint(rootTrans.position);</span><br><span class="line">         rect.anchoredPosition = screenPos * scaleRate;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="伤害飘字-数据结构"><a href="#伤害飘字-数据结构" class="headerlink" title="伤害飘字 数据结构"></a>伤害飘字 数据结构</h2><p><strong>缓存池</strong></p><p>需要用到伤害飘字的单位比较多，频繁销毁创建会消耗性能，所以首先建立一个缓存池，限制个数为50，用到的时候从池中取出播放动画。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**跳字类型枚举类**</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> JumpTypeEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    SkillDamage,</span><br><span class="line">    BuffDamage,</span><br><span class="line">    Cure,<span class="comment">// 治疗</span></span><br><span class="line">    SlowSpeed,<span class="comment">// 减速</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>跳字动画枚举类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> JumpAniEnum</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    LeftCurve,<span class="comment">// 左曲线飘出</span></span><br><span class="line">    RightCurve,<span class="comment">// 右曲线飘出</span></span><br><span class="line">    CenterUp,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>飘字预制体脚本 结构</strong></p><p>全部公开，方便在unity面板内调参</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JumpNum</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> RectTransform rect;</span><br><span class="line">    <span class="keyword">public</span> Animator ani;</span><br><span class="line">    <span class="keyword">public</span> Text txt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxFont;<span class="comment">// 最大字体，比如60</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MinFont;<span class="comment">// 最小字体，比如40</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxFontValue;<span class="comment">// 将伤害转化为字体大小的计算值x，举例：伤害刚好=x，字体大小就取50</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Color skillDamageColor;</span><br><span class="line">    <span class="keyword">public</span> Color buffDamageColor;</span><br><span class="line">    <span class="keyword">public</span> Color cureDamageColor;</span><br><span class="line">    <span class="keyword">public</span> Color slowDamageColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通用技能定时器"><a href="#通用技能定时器" class="headerlink" title="通用技能定时器"></a><Center>通用技能定时器<Center/></h1><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>用于CD计时器。一共分3个部分：延迟、回调函数(循环)执行、结束回调(1次or不)执行。</p><h2 id="定时器代码"><a href="#定时器代码" class="headerlink" title="定时器代码"></a>定时器代码</h2><p>只展示<strong>重要成员</strong>和使用的<strong>接口</strong>，内部直接看代码（在github开源了）。</p><p>回调函数和3个部分的回调签名：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.回调函数，用于显示次数进度。参数：loopCounter</span></span><br><span class="line"><span class="keyword">private</span> Action&lt;<span class="built_in">int</span>&gt; cbAction;</span><br><span class="line"><span class="comment">// 循环累计次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> loopCounter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.回调函数，用于显示百分比进度。参数：是不是延迟的部分,prgLoopRate,prgAllRate</span></span><br><span class="line"><span class="keyword">private</span> Action&lt;<span class="built_in">bool</span>, <span class="built_in">float</span>, <span class="built_in">float</span>&gt; prgAction;</span><br><span class="line"><span class="comment">// 当前阶段(延迟or回调执行)进度</span></span><br><span class="line"><span class="built_in">float</span> prgLoopRate = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计时器总体进度</span></span><br><span class="line"><span class="built_in">float</span> prgAllRate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.结束后回调函数</span></span><br><span class="line"><span class="keyword">private</span> Action endAction;</span><br></pre></td></tr></table></figure><p>对外接口（构造器）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MonoTimer</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    Action&lt;<span class="built_in">int</span>&gt; cbAction,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">float</span> intervalTime,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> loopCount = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    Action&lt;<span class="built_in">bool</span>, <span class="built_in">float</span>, <span class="built_in">float</span>&gt; prgAction = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    Action endAction = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">float</span> delayTime = <span class="number">0</span></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.IsActive = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.prgAllTime = delayTime + intervalTime * loopCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时器测试示例"><a href="#定时器测试示例" class="headerlink" title="定时器测试示例"></a>定时器测试示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClickTestBtn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    SetText(txtTime, <span class="number">5</span>);</span><br><span class="line">    testTimer?.DisableTimer();</span><br><span class="line">    testTimer = CreateMonoTimer(</span><br><span class="line">        (loopCount) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.ColorLog(LogColor.Green, <span class="string">&quot;Loop:&quot;</span> + loopCount);</span><br><span class="line">            SetText(txtTime, <span class="number">5</span> - loopCount);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="number">1000</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        (isDelay, loopPrg, allPrg) =&gt; &#123;</span><br><span class="line">            SetActive(imgPrgLoop);</span><br><span class="line">            <span class="keyword">if</span>(isDelay) &#123;</span><br><span class="line">                SetActive(txtTime, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                SetActive(txtTime);</span><br><span class="line">            &#125;</span><br><span class="line">            imgPrgLoop.fillAmount = <span class="number">1</span> - loopPrg;</span><br><span class="line">            imgPrgAll.fillAmount = allPrg;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            SetActive(imgPrgLoop, <span class="literal">false</span>);</span><br><span class="line">            imgPrgAll.fillAmount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.ColorLog(LogColor.Green, <span class="string">&quot;Loop End&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="number">3000</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211229204847.png"></p><p>延迟圈转完后进行倒计时轮转，下面的进度条prg= 已过时长 / (延迟时长+回调时长)。</p><h2 id="逻辑定时器"><a href="#逻辑定时器" class="headerlink" title="逻辑定时器"></a>逻辑定时器</h2><p>逻辑定时器(基于定点数)，可以跑在服务器上，不依赖于Mono。</p><p>在本项目中，由 NetSvc.GetServiceMessageAndHandle(GameMsg msg) &gt; BattleSys.NotifyOpKey(GameMsg msg) &gt; FightMgr.Tick() &gt; MainLogicUnit.LogicTick() &gt; MainLogicUnit.TickSkill() &gt; <strong>LogicTimer.Tick()</strong> 驱动。</p><p>下面贴<strong>重要成员</strong>和使用的<strong>接口</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对外接口(构造器)：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LogicTimer</span>(<span class="params">Action cb, PEInt delayTime, <span class="built_in">int</span> loopTime = <span class="number">0</span></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    delta = Configs.ServerLogicFrameIntervelMs;</span><br><span class="line">    IsActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要成员：</span></span><br><span class="line"><span class="comment">// 服务端每一帧的时间(66ms)</span></span><br><span class="line">PEInt delta;</span><br><span class="line"><span class="comment">// 延迟时长</span></span><br><span class="line">PEInt delayTime;</span><br><span class="line"><span class="comment">// 循环周期时长</span></span><br><span class="line">PEInt loopTime;</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line">Action cb;</span><br></pre></td></tr></table></figure><h1 id="Buff"><a href="#Buff" class="headerlink" title="Buff"></a><Center>Buff<Center/></h1><p>贴一下核心属性和对应的Enum类。</p><h2 id="SubLogicUnit类：辅助类逻辑单元基类"><a href="#SubLogicUnit类：辅助类逻辑单元基类" class="headerlink" title="SubLogicUnit类：辅助类逻辑单元基类"></a>SubLogicUnit类：辅助类逻辑单元基类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 状态阶段</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SubUnitState</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Delay,</span><br><span class="line">    Start,</span><br><span class="line">    Tick,</span><br><span class="line">    End</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 辅助类逻辑单元基类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Buff and Bullet</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">SubLogicUnit</span> : <span class="title">LogicUnit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//---------------1.核心属性：---------------</span></span><br><span class="line">    <span class="comment">// 来源角色</span></span><br><span class="line">    <span class="keyword">public</span> MainLogicUnit source;</span><br><span class="line">    <span class="comment">// 所属技能</span></span><br><span class="line">    <span class="keyword">protected</span> Skill skill;</span><br><span class="line">    <span class="comment">// 延迟生效时间</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> delayTime;</span><br><span class="line">    <span class="comment">// 辅助单元状态</span></span><br><span class="line">    <span class="keyword">public</span> SubUnitState unitState;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//---------------2.核心事件：---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if delayTime == 0 切换状态为Start</span></span><br><span class="line">        <span class="comment">// else 切换状态为Delay</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicTick</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (unitState)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.Delay:</span><br><span class="line">                <span class="comment">// Delay完切换状态为Start</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.End:</span><br><span class="line">                End();</span><br><span class="line">                unitState = SubUnitState.None;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.None:</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUnInit</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Tick</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BuffCfg类"><a href="#BuffCfg类" class="headerlink" title="BuffCfg类"></a>BuffCfg类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buff类型，用来创建不同类型的buff</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BuffTypeEnum &#123;</span><br><span class="line">    None,</span><br><span class="line">    ModifySkill,</span><br><span class="line">    MoveSpeed_Single,<span class="comment">//单体加速buff</span></span><br><span class="line">    Silense,<span class="comment">//沉默</span></span><br><span class="line">    ArthurMark,<span class="comment">//Arthur1技能的标记伤害Buff</span></span><br><span class="line">    HPCure,<span class="comment">//治疗</span></span><br><span class="line">    MoveSpeed_DynamicGroup,<span class="comment">//Arthur1技能的动态群体移速Buff</span></span><br><span class="line">    MoveAttack,<span class="comment">//移动攻击</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buff位置确定方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> StaticPosTypeEnum &#123;</span><br><span class="line">    None,</span><br><span class="line">    SkillCasterPos,<span class="comment">//Buff所属技能施放者的位置</span></span><br><span class="line">    SkillLockTargetPos,<span class="comment">//Buff所属技能锁定目标的位置</span></span><br><span class="line">    BulletHitTargetPos,<span class="comment">//子弹命中目标的位置</span></span><br><span class="line">    UIInputPos,<span class="comment">//UI输入位置信息，比如后裔2技能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buff附着目标</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AttachTypeEnum &#123;</span><br><span class="line">    None,</span><br><span class="line">    Caster,<span class="comment">//由施术者自己确定：给自己，Arthur的1技能加速buff</span></span><br><span class="line">    Indie,<span class="comment">//由施术者自己确定：区域，Arthur大招(位置固定)产生的持续范围伤害</span></span><br><span class="line">    </span><br><span class="line">    Target,<span class="comment">//由受击者确定：给目标，Arthur的1技能沉默buff</span></span><br><span class="line">    Bullet,<span class="comment">//由受击者确定：Houyi大招命中(位置动态)目标时产生的范围伤害</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BuffCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ------------属性------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffId;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐buff类型，用来创建不同类型的buff</span></span><br><span class="line">    <span class="keyword">public</span> BuffTypeEnum buffType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐buff附着目标</span></span><br><span class="line">    <span class="keyword">public</span> AttachTypeEnum attacher;</span><br><span class="line">    <span class="keyword">public</span> StaticPosTypeEnum staticPosType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buff作用目标，如果为null默认影响附着对象</span></span><br><span class="line">    <span class="keyword">public</span> TargetCfg impacter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------效果相关------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffDelay;</span><br><span class="line">    <span class="comment">// ⭐buff效果触发频率(比如持续1秒1次) </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffInterval;</span><br><span class="line">    <span class="comment">// ⭐buff持续时间（不包含delay）0：生效1次，-1：永久生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> buffDuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------配置------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffAudio;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffEffect;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> hitTickAudio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Buff类"><a href="#Buff类" class="headerlink" title="Buff类"></a>Buff类</h2><p>使用关系：</p><p>正常一种类得buff有 <code>xxBuff类 and xxBuffCfg类</code>，xxBuffCfg拥有该buff特有的属性，xxBuff会包含xxBuffCfg在初期化通过ResSvc加载获取它。</p><p>继承关系：</p><ul><li>xxBuff &lt; Buff &lt; SubLogicUnit &lt; LogicUnit</li><li>xxBuffCfg &lt; BuffCfg</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Buff</span> : <span class="title">SubLogicUnit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff附着单位</span></span><br><span class="line">    <span class="keyword">public</span> MainLogicUnit owner;</span><br><span class="line">    <span class="keyword">public</span> BuffCfg cfg;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> buffId;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">object</span>[] args;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 群体buff作用目标列表</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;MainLogicUnit&gt; targetList;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        cfg = ResSvc.Instance().GetBuffConfigById(buffId);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">base</span>.LogicInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicTick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.LogicTick();</span><br><span class="line">        <span class="keyword">switch</span>(unitState) &#123;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.Start:</span><br><span class="line">                Start();</span><br><span class="line">                <span class="comment">// buffDuration: buff持续时间（不包含delay）0：生效1次，-1：永久生效</span></span><br><span class="line">                <span class="comment">// 根据buffDuration来切换状态，永久or循环的切换到Tick，生效1次得直接进入End状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SubUnitState.Tick:</span><br><span class="line">                <span class="comment">// 频率触发型buff需要按照频率来Tick，比如点燃</span></span><br><span class="line">                <span class="keyword">if</span>(cfg.buffInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tickCount += Configs.ServerLogicFrameIntervelMs;</span><br><span class="line">                    <span class="keyword">if</span>(tickCount &gt;= cfg.buffInterval) &#123;</span><br><span class="line">                        tickCount -= cfg.buffInterval;</span><br><span class="line">                        Tick();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// 根据服务器所规定得逻辑帧得时长，来进行每一次循环得时长计算</span></span><br><span class="line">                durationCount += Configs.ServerLogicFrameIntervelMs;</span><br><span class="line">                <span class="keyword">if</span>(durationCount &gt;= buffDuration &amp;&amp; buffDuration != <span class="number">-1</span>) &#123;</span><br><span class="line">                    unitState = SubUnitState.End;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Tick</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用于替换技能的特别buff"><a href="#用于替换技能的特别buff" class="headerlink" title="用于替换技能的特别buff"></a>用于替换技能的特别buff</h2><p>前面提到的亚瑟技能1实现得具体buff，进行技能之间的替换</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommonModifySkillBuffCfg</span> : <span class="title">BuffCfg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> originalID;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> replaceID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommonModifySkillBuff</span> : <span class="title">Buff</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> originalID;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> replaceID;</span><br><span class="line">    <span class="keyword">private</span> Skill modifySkill;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.LogicInit();</span><br><span class="line">        <span class="comment">// Cfg给originalID、replaceID赋值，owner.SkillArr找到对应技能给modifySkill赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        <span class="comment">// 开始时替换</span></span><br><span class="line">        modifySkill.ReplaceSkillCfg(replaceID);</span><br><span class="line">        modifySkill.SpellSuccCallback += ReplaceSkillReleaseDone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReplaceSkillReleaseDone</span>(<span class="params">Skill skillReleased</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(skillReleased.cfg.isNormalAttack) &#123;</span><br><span class="line">            unitState = SubUnitState.End;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1.如果上次成功释放普攻就会被Skill.SpellSuccCallback()调用到这里</span></span><br><span class="line">    <span class="comment">// 情况2.如果buff时间过了，会在Buff.LogicTick()中得计时结束进入End状态被调用到这里</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.End();</span><br><span class="line">        <span class="comment">// 结束时替换回来</span></span><br><span class="line">        modifySkill.ReplaceSkillCfg(originalID);</span><br><span class="line">        modifySkill.SpellSuccCallback -= ReplaceSkillReleaseDone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技能替换得接口：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skill</span>&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 技能替换，其实就是把Skill构造时做的事重做一遍</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReplaceSkillCfg</span>(<span class="params"><span class="built_in">int</span> replaceId</span>)</span> &#123;</span><br><span class="line">        skillCfg = ResSvc.Instance().GetSkillConfigById(replaceId);</span><br><span class="line">        spellTime = skillCfg.spellTime;</span><br><span class="line">        skillTime = skillCfg.skillTime;</span><br><span class="line">        <span class="keyword">if</span>(skillCfg.isNormalAttack) &#123;</span><br><span class="line">            owner.InitAttackSpeedRate(<span class="number">1000</span> / skillTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="人物状态：沉默、眩晕、击飞"><a href="#人物状态：沉默、眩晕、击飞" class="headerlink" title="人物状态：沉默、眩晕、击飞"></a>人物状态：沉默、眩晕、击飞</h2><p>比如亚瑟1技能的沉默，技能是附加了沉默buff，buff那块只要对 英雄/小兵 脚本的对应字段进行改变就行了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单体沉默buff：亚瑟技能1附带的buff</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SilenseBuff_Single</span>: <span class="title">Buff</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        owner.SilenceCount += <span class="number">1</span>;<span class="comment">//1秒沉默</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.End();</span><br><span class="line">        owner.SilenceCount -= <span class="number">1</span>;<span class="comment">//buff.duration字段设置了为1秒，所以1秒后会执行这句，沉默期结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 英雄/小兵 的接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> MainLogicAttributes</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainLogicUnit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -------------沉默：沉默时无法施放技能-------------</span></span><br><span class="line">    <span class="built_in">int</span> silenceCount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SilenceCount &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> silenceCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            silenceCount = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">if</span>(IsSilenced()) &#123;</span><br><span class="line">                <span class="comment">// 1.进入沉默状态并触发OnStateChange</span></span><br><span class="line">                OnStateChange?.Invoke(StateEnum.Silenced, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                OnStateChange?.Invoke(StateEnum.Silenced, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">IsSilenced</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> silenceCount != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的接口是 OnStateChange += UpdateState，看下UpdateState代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainViewUnit</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateState</span>(<span class="params">StateEnum state, <span class="built_in">bool</span> show</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(state == StateEnum.Knockup</span><br><span class="line">           || state == StateEnum.Silenced</span><br><span class="line">           || state == StateEnum.Silenced) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mainLogicUnit.IsPlayerSelf() &amp;&amp; show) &#123;</span><br><span class="line">                playWindow.SetAllSkillForbidState();<span class="comment">// 禁止所有技能的点击</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hpWindow.SetStateInfo(mainLogicUnit, state, show);<span class="comment">// 在ui血条上显示状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为目标标记上受击标记"><a href="#为目标标记上受击标记" class="headerlink" title="为目标标记上受击标记"></a>为目标标记上受击标记</h2><p>其实就是MarkBuff，类似于亚瑟技能1的标记buff：标记目标，持续5秒，技能和普攻会对标记目标可额外造成目标最大生命1%的伤害。</p><p>使用对<strong>Onhurt事件</strong>委托链添加委托实现。</p><p>调用回溯：from serive &gt; InputKey() &gt; MainLogicSkill.InputSkillKey() &gt;Skill.ReleaseSkill() &gt; Skill.CalcSkillAttack() &gt; Skill.HitTarget() &gt;target.CreateSkillBuff() &gt; ArthurMarkBuff new()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArthurMarkBuffCfg</span> : <span class="title">BuffCfg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damagePct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArthurMarkBuff</span> : <span class="title">Buff</span></span><br><span class="line">&#123;</span><br><span class="line">    PEInt damagePct;</span><br><span class="line">    MainLogicUnit target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.LogicInit();</span><br><span class="line"></span><br><span class="line">        ArthurMarkBuffCfg ambc = cfg <span class="keyword">as</span> ArthurMarkBuffCfg;</span><br><span class="line">        damagePct = ambc.damagePct;</span><br><span class="line">        target = skill.lockTarget; <span class="comment">// 为target赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        target.OnHurt += GetHurt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetHurt</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        target.GetDamageByBuff(damagePct / <span class="number">100</span> * target.ud.unitCfg.hp, <span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.End();</span><br><span class="line">        target.OnHurt -= GetHurt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为目标标记一个立场标记，友军群体加速"><a href="#为目标标记一个立场标记，友军群体加速" class="headerlink" title="为目标标记一个立场标记，友军群体加速"></a>为目标标记一个立场标记，友军群体加速</h2><p>亚瑟技能1标记，会让附近 range&lt;5f 的友军会增加10%的移速。这像是一个立场，需要按照服务端的逻辑帧逐帧计算敌人是否在范围内从而为其加速。</p><p>核心是维护一个targetList：使用类似于前面写的<strong>通用的寻找目标实现</strong>查找算法，逐帧计算附近 range&lt;5f 的对象，将其加入到targetList队列中。</p><p>下面对Buff整体生命流程中，仅对于核心targetList的处理与使用进行展示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveSpeedBuff_DynamicGroup</span>: <span class="title">Buff</span> &#123;</span><br><span class="line">    <span class="comment">// 设定的buff加速量，亚瑟技能1标记buff为10%</span></span><br><span class="line">    <span class="keyword">private</span> PEInt speedOffset;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        targetList = <span class="keyword">new</span> List&lt;MainLogicUnit&gt;();</span><br><span class="line">        targetList.AddRange(CalcRule.FindMulipleTargetByRule(owner, cfg.impacter, skill.skillArgs)); <span class="comment">// 开始时计算目标队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ModifyTargetsMoveSpeed(speedOffset, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ModifyTargetsMoveSpeed(-speedOffset);</span><br><span class="line"></span><br><span class="line">        targetList.Clear();</span><br><span class="line">        targetList.AddRange(CalcRule.FindMulipleTargetByRule(owner, cfg.impacter, PEVector3.zero)); <span class="comment">// 逐帧计算目标队列</span></span><br><span class="line">        ModifyTargetsMoveSpeed(speedOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">End</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ModifyTargetsMoveSpeed(-speedOffset);</span><br><span class="line">        targetList.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyTargetsMoveSpeed</span>(<span class="params">PEInt <span class="keyword">value</span>, <span class="built_in">bool</span> showJump = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// targetList =&gt; Move speed up</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动寻找目标攻击的通用buff"><a href="#自动寻找目标攻击的通用buff" class="headerlink" title="自动寻找目标攻击的通用buff"></a>自动寻找目标攻击的通用buff</h2><p>实现功能示意图：</p><p><img src="C:\Users\YAN\AppData\Roaming\Typora\typora-user-images\image-20220104233959056.png" alt="image-20220104233959056"></p><p>部分代码演示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buff配置</span></span><br><span class="line"><span class="keyword">var</span> MoveAttackBuff = <span class="keyword">new</span> BuffCfg()  &#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通用buff属性</span></span><br><span class="line">    buffId = <span class="number">999999</span>,</span><br><span class="line">    buffName = <span class="string">&quot;移动攻击&quot;</span>,</span><br><span class="line">    buffType = BuffTypeEnum.MoveAttack,</span><br><span class="line"></span><br><span class="line">    attacher = AttachTypeEnum.Caster,<span class="comment">// buff附着给自己</span></span><br><span class="line">    impacter = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    buffDelay = <span class="number">0</span>,</span><br><span class="line">    buffInterval = <span class="number">66</span>,<span class="comment">// 1帧检测1次</span></span><br><span class="line">    buffDuration = <span class="number">5000</span>,<span class="comment">// 单次持续时间</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Buff逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveAttackBuff</span>: <span class="title">Buff</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找算法示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220104231802.png"></p><h2 id="后裔的被动技能"><a href="#后裔的被动技能" class="headerlink" title="后裔的被动技能"></a>后裔的被动技能</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112225127.png"></p><h3 id="普攻成功后增加攻速"><a href="#普攻成功后增加攻速" class="headerlink" title="普攻成功后增加攻速"></a>普攻成功后增加攻速</h3><p>后裔被动，每次平砍增加5%攻速，最高3次，持续3秒。如果释放2、3技能（1技能强化普攻可以）就直接失效。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HouyiPasvAttackSpeedBuffCfg</span> : <span class="title">BuffCfg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> overCount;<span class="comment">// 叠加层数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> speedAddtion;<span class="comment">// 加成百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> resetTime;<span class="comment">// 重置周期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buff代码就不贴了，具体逻辑是 buff类 给技能释放成功的回调注册一个事件，事件实现技能效果。</p><h3 id="普攻3次后变成3连击"><a href="#普攻3次后变成3连击" class="headerlink" title="普攻3次后变成3连击"></a>普攻3次后变成3连击</h3><p>由于技能会跳转（如图），所以不能使用前面制作的替换技能buff，那个太简单了。</p><h1 id="Bullet"><a href="#Bullet" class="headerlink" title="Bullet"></a><Center>Bullet<Center/></h1><h2 id="SweepVolume-体积扫描检测"><a href="#SweepVolume-体积扫描检测" class="headerlink" title="SweepVolume 体积扫描检测"></a>SweepVolume 体积扫描检测</h2><p>用于逻辑帧计算子弹是否命中用的。记录上一帧的位置，与这一帧的位置连线，它的轨迹是一个矩形（粉色），查看矩形是否穿过目标碰撞体（蓝色），也就是矩形与圆形求相交的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220111220103.png"></p><ol><li>计算 AB中点位置 = (LogicPos + lastPos) / 2</li><li>计算 向量A-&gt;B = LogicPos - lastPos</li><li>由1与2模拟出 矩形碰撞体PEBoxCollider</li><li>由3创建出的矩形，与目标的 圆形碰撞体PECylinderCollider 进行</li></ol><p>具体怎么创建碰撞体，是自制的定点数物理碰撞计算库，在其他文章中详解。</p><h3 id="Debug-弹道显示方案"><a href="#Debug-弹道显示方案" class="headerlink" title="Debug 弹道显示方案"></a>Debug 弹道显示方案</h3><p>想要debug看到弹道规矩，可以在每一个Tick里创建一个Cube模拟矩形，也就是子弹轨迹。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112000119.png"></p><h2 id="子弹Config"><a href="#子弹Config" class="headerlink" title="子弹Config"></a>子弹Config</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BulletCfg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> BulletTypeEnum bulletType;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> bulletName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> resPath;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletSpeed;<span class="comment">//运算时转换为PEInt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletHeight;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bulletOffset;<span class="comment">//画面表现用的偏移值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> bulletDelay;<span class="comment">//释放延迟 ms</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> canBlock;<span class="comment">//技能是否不能穿透</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TargetCfg impacter;<span class="comment">//目标类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> bulletDuration;<span class="comment">//持续时间(不含bulletDelay)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BulletTypeEnum &#123;</span><br><span class="line">    UIDirection,<span class="comment">//ui指定方向</span></span><br><span class="line">    UIPosition,<span class="comment">//ui指定位置</span></span><br><span class="line">    SkillTarget,<span class="comment">//当前技能目标(锁定目标技能)</span></span><br><span class="line">    BuffSearch,<span class="comment">//靠近物体自动寻找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现子弹曲线"><a href="#实现子弹曲线" class="headerlink" title="实现子弹曲线"></a><Center>实现子弹曲线<Center/></h1><h2 id="图像分解"><a href="#图像分解" class="headerlink" title="图像分解"></a>图像分解</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220115100853.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220115101025.png"></p><p>![image-20220115105710617](C:\Users\YAN JUNJIE\AppData\Roaming\Typora\typora-user-images\image-20220115105710617.png)</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>我 -&gt; 目标 连线的向量，是最初的弹道向量，也就是一开始的红色向量。</p><p>对 最初的弹道向量 + 我的中心点，可以取出一个唯一的<strong>垂直平面</strong>，对这个垂直平面上，以我的中心点为起始点，任取一个<strong>模（偏移量）</strong>数值随机的向量，作为偏移向量，也就是绿箭头。</p><p>绿箭头的模确定后就不再改变，持续施加，称作<strong>固定值影响向量</strong>。</p><p>而红色向量始终指向目标，所以会不停改变方向，称作<strong>方向矫正向量</strong>。</p><p>最终，使用 固定值影响向量、方向矫正向量 的向量之和，也就是某个时间点下<strong>子弹的方向向量</strong>了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实际就并不取用这么复杂过程了。</p><h3 id="①-固定值影响向量"><a href="#①-固定值影响向量" class="headerlink" title="① 固定值影响向量"></a>① 固定值影响向量</h3><p>取 我-&gt;目标 的向量 + 我的up方向向量 的叉乘<strong>Cross</strong>向量，然后规格化，就得到了准确的方向向量。</p><p>想要往上，只要对结果添加up方向上的向量就可以。当然，这需要一个随机数。</p><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>因为同步问题，不能只使用随机，所以通过<strong>传播随机种子</strong>来确定性地随机，让多个端末都能正确计算出同样的效果。</p><p>然后再偷个懒，种子也不传播了，固定666。</p><h1 id="Bug-amp-QA"><a href="#Bug-amp-QA" class="headerlink" title="Bug &amp; QA"></a><Center>Bug &amp; QA<Center/></h1><h2 id="移动攻击Bugs"><a href="#移动攻击Bugs" class="headerlink" title="移动攻击Bugs"></a>移动攻击Bugs</h2><p>1.<strong>攻击动画没播放</strong>是因为移动攻击时方向变更，导致动画状态立即恢复“free”从而导致攻击动画被跳过了。</p><p>解决方案是方向变更时，将<strong>是否在技能前摇</strong>flag一起加入判定条件，来决定是否变化动画。</p><p>2.<strong>人物朝向没变化</strong>也是因为方向被UI输入朝向重制了，关键是看ViewUnit.viewTargetDir属性。</p><p>解决方案一样，将<strong>是否在技能前摇</strong>flag作为判定条件来决定是否根据UI改变朝向。</p><p>3.<strong>移动攻击时会滑动</strong>是因为UI输入方向被服务端传来的最新UI移动请求给覆盖了，关键看MainLogic.InputDir属性。</p><p>解决方案是在接收到服务端传来的最新UI移动请求时，进行<strong>是否在技能前摇、是否被控制</strong>flag作为判定条件来决定是否改变InputDir。</p><p>4.<strong>移动攻击完会僵直平移一段距离</strong>是因为技能前摇时有一个定时器，根据技能总时长来将角色设回“free”动画。</p><p>解决方案是在收到服务器逻辑方向改变请求改变LogicUnit.LogicDir属性时，将过去的定时器动画Callback都清除掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;技能机制&quot;&gt;&lt;a href=&quot;#技能机制&quot; class=&quot;headerlink&quot; title=&quot;技能机制&quot;&gt;&lt;/a&gt;&lt;Center&gt;技能机制&lt;Center/&gt;&lt;/h1&gt;&lt;h2 id=&quot;总览图&quot;&gt;&lt;a href=&quot;#总览图&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 堆栈篇</title>
    <link href="https://codingcodingk.github.io/2021/11/27/Tech/CSharp/Essence/stack/"/>
    <id>https://codingcodingk.github.io/2021/11/27/Tech/CSharp/Essence/stack/</id>
    <published>2021-11-27T06:30:29.516Z</published>
    <updated>2021-11-27T06:30:29.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-精要：堆栈"><a href="#C-精要：堆栈" class="headerlink" title="C#精要：堆栈"></a><center>C#精要：堆栈</center></h1><p><a href="https://www.cnblogs.com/xiaodongy/p/7989711.html">https://www.cnblogs.com/xiaodongy/p/7989711.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-精要：堆栈&quot;&gt;&lt;a href=&quot;#C-精要：堆栈&quot; class=&quot;headerlink&quot; title=&quot;C#精要：堆栈&quot;&gt;&lt;/a&gt;&lt;center&gt;C#精要：堆栈&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 同步异步、多线程篇</title>
    <link href="https://codingcodingk.github.io/2021/11/27/Tech/CSharp/Essence/tongbuyibu/"/>
    <id>https://codingcodingk.github.io/2021/11/27/Tech/CSharp/Essence/tongbuyibu/</id>
    <published>2021-11-27T06:30:29.516Z</published>
    <updated>2022-01-22T07:20:06.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零-为什么我会理解错"><a href="#零-为什么我会理解错" class="headerlink" title="零.为什么我会理解错"></a>零.为什么我会理解错</h1><p>在看完clr之前，我曾对异步同步探究看了十几篇文章，但很可惜，没有完全理解，只知道了一大堆概念：IRP、异步要借用多线程…</p><p>在看完之后，我理解并甚至尝试实现一个简单的异步的时候才明白，之前无法理解是因为我不懂：</p><p><strong>异步编程 和 异步函数 是不同的东西。也就是说，异步函数async/await 只是异步编程的一种罢了，你大可以利用ContinueWith或ThreadPool等来实现异步。</strong></p><p>很多博客混淆了这两个概念，我不知道他们是否真正理解了，但是这会导致我这种代码先行基础后补的菜b无法理解。</p><h1 id="一-同步与异步"><a href="#一-同步与异步" class="headerlink" title="一.同步与异步"></a>一.同步与异步</h1><p>  项目中每天都在接触，但是对这俩概念比较模糊。看《CLR via C#》刚好提到了，就去网上找到几篇好文，理解写篇自己的笔记。首先得说明的是，这一节讨论的只是概念，都是单纯的、不考虑多线程处理的同步与异步区别。</p><h3 id="IO-概念区分"><a href="#IO-概念区分" class="headerlink" title="IO 概念区分"></a>IO 概念区分</h3><ul><li><p>同步（Synchronous）</p></li><li><p>异步( Asynchronous)</p></li><li><p>阻塞( Blocking )</p></li><li><p>非阻塞( Nonblocking)</p></li></ul><p>那首先，要弄清楚同步异步、阻塞非阻塞之间的关系。</p><ul><li><p>同步异步 指的是在客户端，<br>同步意味着 客户端提出了一个请求以后，在回应之前只能等待。<br>异步意味着 客户端提出一个请求以后，还可以继续提其他请求。</p></li><li><p>阻塞非阻塞 指的是服务器端，<br>阻塞意味着 服务器接受一个请求后，在返回结果以前不能接受其他请求。<br>非阻塞意味着 服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求。</p></li></ul><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><ol><li>同步与异步意图<br>这个层级的还是很好理解，它们的核心是消息通信机制。</li></ol><ul><li>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。也就是说，代码执行会等着它，卡在那不动，直到执行结束把返回值给我才继续。</li><li>异步则是相反，调用在发出之后，这个调用就直接返回了，没有返回结果，我记得如果还没返回就去拿的话好像是null。也就是说，代码执行不会等它，你管你运行，返回值我不需要所以我继续往下跑，你运行完执行你自己的回调函数就行。用途有点类似于子线程。</li></ul><ol start="2"><li>阻塞与非阻塞意图<br>区分是调用结果返回之前，是否将调用的线程挂起，暂时不理其他请求。</li></ol><h3 id="不同模型的理解"><a href="#不同模型的理解" class="headerlink" title="不同模型的理解"></a>不同模型的理解</h3><p>直接把别人博客的图整理下拿过来了，<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211104120820.png"></p><ol><li>说的是单线程普通情况下，是这么执行的。按顺序一个个，等A有返回值回来了再B，B有返回值回来了再C。</li><li>说的是多线程同步的情况，并行运行，不展开，图简单，但实际交互非常复杂，通道、共享内存啥的。这里提这个是为了体现异步的作用。</li><li>说的是单线程异步执行，看得到ABC这运行，理论上是没有什么执行顺序可言的（项目经验告诉我，实际上这句话不对，但是概念上这么理解就够了，毕竟不可靠），属于是把程序执行顺序直接丢了。看上去事件花销和1的同步一样，那为什么要引入这个概念呢？看4。</li><li>可以看到，其实3还是比同步的情况下省了很多时间，这个waiting可能是方法里人工delay，也可能是在等待磁盘坑长的I/O操作返回结果，所以如果异步，灰色的部分就省下来了。由此也可知，异步唯一存在的阻塞情况，是无方法可执行的时候（ABC都在灰色段等着I/O给结果）。</li></ol><p>以上用于理解概念是够了，但是实际应用会多很多（比如异步有很多方法可以实现，每种方法可控性等不同）。</p><p>搞懂最基本的同步异步之后，开始结合c#的用法，看下怎么用。</p><h1 id="二-Async-and-Await"><a href="#二-Async-and-Await" class="headerlink" title="二.Async and Await"></a>二.Async and Await</h1><p>  一篇不错的文章，虽然是2012年（也就是Async/Await语法糖出来的时候）的还是英文，但是把两者分析的非常透彻。刚好作为实际应用的补充。</p><h3 id="先来介绍一下这两个C-关键字"><a href="#先来介绍一下这两个C-关键字" class="headerlink" title="先来介绍一下这两个C#关键字"></a>先来介绍一下这两个C#关键字</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoSomethingAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// In the Real World, we would actually do something...</span></span><br><span class="line">  <span class="comment">// For this example, we&#x27;re just going to (asynchronously) wait 100ms.</span></span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <font color='red'>async </font>只有2个作用。一是是允许await这个关键字的使用，二是改变了方法结果的处理方式。async在执行开始时，是和同步运行一样的。也就是说在遇到await之前，它是同步的。</p><p>  <font color='red'>await </font>是异步操作的启动器。它会持续监视一个<font color='red'>异步操作 </font>（asynchronous operation）的执行，<br>  如果这个异步操作已经完成了，那他就会继续跑后续代码；<br>  如果这个异步操作未完成，就开始真正的<font color='red'>异步</font>：调用者会将这个async任务暂时挂起，直到await监视的异步操作处理完后，才继续执行后续代码。注意了，这个处理完后的执行，是会根据遇到await之前捕捉下来的<font color='red'>上下文（Context） </font>环境来继续运行。u1s1，这听着很像unity的协程好吧。<br>  通过上面知道了，async方法体里遇到个await、且await后面跟了个需要时间去处理的方法（上面叫异步操作，举个例子比如I/O操作吧），这个时候这个async方法会被阻塞住，但是整个线程并不会被阻塞住，而是在做其他的异步方法了，直到其他方法也卡住。</p><h3 id="Asynchronous-Operation"><a href="#Asynchronous-Operation" class="headerlink" title="Asynchronous Operation"></a>Asynchronous Operation</h3><p>  上面提到的异步操作。从上可知，你只需要提供<font color='red'>异步操作</font>就可以实现一个异步。你可以直接用微软提供支持的Task或者<code>Task&lt;T&gt;</code>，或者将各种方法转换成一个异步操作，或者是Task.Yield会返回不是Tasks的异步操作。<br>  关于异步操作的一个要点是:异步操作，指的不是async关键词修饰的就是异步操作，而是他是一个可以异步操作的类型。换句话说，你可以await一个类型为Task的async method，这是因为方法返回Task，而不是因为它是async的。所以你也可以await一个返回Task的非async方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">NewStuffAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use await and have fun with the new stuff.</span></span><br><span class="line">  <span class="keyword">await</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">MyOldTaskParallelLibraryCode</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 最开始就说的，因为这个方法没有async关键词修饰，所里方法体里不能用await关键词</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ComposeAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// We can await Tasks, regardless of where they come from.</span></span><br><span class="line">  <span class="keyword">await</span> NewStuffAsync();</span><br><span class="line">  <span class="keyword">await</span> MyOldTaskParallelLibraryCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Return-Types"><a href="#Return-Types" class="headerlink" title="Return Types"></a>Return Types</h3><p>  Async方法可以返回<code>Task&lt;T&gt;</code>、Task以及void，但是在大部分情况我们都会选择前两个而不是void，因为<code>Task&lt;T&gt;</code>、Task是可以等待的，而void不行。<br>  那什么时候用void呢？原文是这么说的：</p><blockquote><p>You have to return void when you have async event handlers.</p></blockquote><h3 id="Returning-Values"><a href="#Returning-Values" class="headerlink" title="Returning Values"></a>Returning Values</h3><p>  这个和上面不同，这个是返回值。Task和void一样都没有返回值，但是<code>Task&lt;T&gt;</code>有T类型的返回值。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>  上下文。上面提到过，当await的异步操作结束后，将会根据遇到await之前捕捉下来的上下文环境继续执行代码。上下文是什么？简单来说：</p><ul><li>如果你在一个UI线程上，那么就是个UI Context</li><li>如果你在一个ASP.NET请求上，那么就是个ASP.NET request context</li><li>否则，通常会是一个线程池环境（a thread pool context）。<br>好嘛，听君一席话。那么复杂点说呢？</li><li>如果<font color='red'>SynchronizationContext.Current</font>不是null的，那么SynchronizationContext.Current就是它的上下文（UI、ASP.NET）</li><li>其他情况，就是当前的<font color='red'>TaskScheduler</font><br>这两个名词暂时先不展开了。<br>下面看一个示例。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinForms 例子 (当然wpf也一样).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当这个异步方法DownloadFileAsync在await的时候，UI线程并不会被阻塞。</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASP.NET 例子</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">MyButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await之后，ASP.NET线程并不会因此被阻塞</span></span><br><span class="line">  <span class="comment">// 这使得这个线程仍然可以接受其他的request</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(...);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复ASP.NET Context，然后就可以连接到当前请求了</span></span><br><span class="line">  <span class="comment">// 也许结束那一瞬间，我们在其他的线程上，但是也能拥有同样的ASP.NET Context</span></span><br><span class="line">  Response.Write(<span class="string">&quot;File downloaded!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Avoiding-Context"><a href="#Avoiding-Context" class="headerlink" title="Avoiding Context"></a>Avoiding Context</h3><p>  上下文有个大概的概念了，关键词还是await。那么，有的时候不需要去抓取整个main的上下文，比如下面的例子，一个Task中并不需要UI的上下文。<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadFileAsync</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这一个调用http api的下载任务</span></span><br><span class="line">  <span class="keyword">var</span> fileContents = <span class="keyword">await</span> DownloadFileContentsAsync(fileName).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为上面设置了ConfigureAwait(false),我们不在原来的上下文中</span></span><br><span class="line">  <span class="comment">// 那我们在什么上下文中？在线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将文件数据写入磁盘</span></span><br><span class="line">  <span class="keyword">await</span> WriteToDiskAsync(fileName,fileContents).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WinForms、Wpf例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await后，UI线程并没有被这个下载任务所阻塞</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上述例子还需要注意的是，每个层级的async方法都有自己的上下文。<code>DownloadFileButton_Click</code>方法中是由UI上下文启动的，随后进入<code>DownloadFileAsync</code>也是由UI上下文启动的，但是随着<code>ConfigureAwait(false)</code>的设置，又会跳出UI上下文，转到线程池上下文中继续运行。最后，当<code>DownloadFileAsync</code>方法执行结束回到<code>DownloadFileButton_Click</code>方法后，又会回到UI上下文继续。<br>  所以有一个优化方法就是，设置不需要UI上下文的异步方法<code>ConfigureAwait(false)</code>。</p><h3 id="Async-Composition"><a href="#Async-Composition" class="headerlink" title="Async Composition"></a>Async Composition</h3>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoOperationsConcurrentlyAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Task[] tasks = <span class="keyword">new</span> Task[<span class="number">3</span>];</span><br><span class="line">  tasks[<span class="number">0</span>] = DoOperation0Async();</span><br><span class="line">  tasks[<span class="number">1</span>] = DoOperation1Async();</span><br><span class="line">  tasks[<span class="number">2</span>] = DoOperation2Async();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个时间点，所有任务都在并行执行</span></span><br><span class="line">  <span class="comment">// 我们对所有任务都进行等待</span></span><br><span class="line">  <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetFirstToRespondAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Call two web services; take the first response.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt;[] tasks = <span class="keyword">new</span>[] &#123; WebService1Async(), WebService2Async() &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Await for the first one to respond.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt; firstTask = <span class="keyword">await</span> Task.WhenAny(tasks);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the result.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> firstTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-非常重要，暂停一下"><a href="#三-非常重要，暂停一下" class="headerlink" title="三.非常重要，暂停一下"></a>三.非常重要，暂停一下</h1><p>  从上可知，异步和同步大概是什么了。根据上两篇去理解，异步就是为了去解决I/O阻塞画面线程问题而推出的技术，而在C#里就是<code>async await Task</code>这三个关键词组合去实现的。执行起来是你做A遇到了子任务B，结果子任务B里有I/O卡壳了，你就立刻回头去做A剩下的直到B结束了会做B这样，看上去就是主线程自己的事。那么实际上呢？直接实践一下：<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Chinese Output</span></span><br><span class="line">Console.OutputEncoding = Encoding.GetEncoding(<span class="number">936</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;头部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">CallerWithAsync(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;尾部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Test Wait</span></span><br><span class="line">Console.Read();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallerWithAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;异步调用头部执行，当前线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> result = <span class="keyword">await</span> SayHiAsync(name);</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">SayHiAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点1，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点2，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">$&quot;Hello,<span class="subst">&#123;name&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211109113849.png"></p><p>  可以看到“测试断点2，此刻线程为: 4”，并不是主线程1，所以说C#的异步实践并不是和第一篇里说的一样，并不是在一个线程上解决的！！！当然还有很多其他方法，这个就不拓展了，只讨论最常用最简洁的实践方案。<br>  原因是什么呢？最直接地说，是因为第一篇的文章是基于单线程的最简单情况去理解同步与异步的，而C#实现不是，毕竟考虑到性能后的实现是很复杂的。而且，你要把一个任务挂起等执行完毕，那总得有线程去处理它对吧。<br>  为了明白这是什么意思，需要理解一下多线程与异步之间的关系。<br>  异步同步，其实和多线程还是单线程并不是一个维度的概念。我的理解是异步是一种程序运行的优化机制、是运行过程最终目的，而多线程还是单线程是一种可供你选择的条件，你可以单线程异步也可以多线程异步。</p><p>  传统异步（第一篇里诉说的）：遇到await时，将目前线程挂起，去做其他的事，不停调度。<br>  实际上基于多线程的异步编程（C#异步实现方法之一）：<font color='red'>遇到<code>Task.Run()</code>的多开线程指令或者真正需要异步挂起某任务时</font>，会从线程池取一个新线程（如果不够用就开新的），然后把这个线程拿来处理挂起的任务，主线程则是返回到方法体外去执行剩下的代码。<font color='red'>注意了，新开线程（也就是真正开始异步）的情况，并不是遇到await那一刻，就像图中的log那样，直到断点1都还是同步的，但是Task.Delay就会开始真正的异步。</font><br>  总结：C#中的异步可以简单的用async 和 await 配合来实现，使用异步的函数，在没有调用await前，还是按顺序单线程执行的，当运行到await的时候，系统才会异步调用其他的方法来运行，如果没有await, 函数就是同步按顺序的运行。所以，await才是异步中的关键部分，在await 范围内的代码，是多线程方式运行的（当然没有Task就不会取线程），可以将需要异步处理的代码放在await中运行，或者简单的用一个Task.Delay来延时，以达到异步切换代码运行的效果。await 后面接的是一个Task, 每一个Task在运行时，由系统的Task池来分配，以实现异步的功能。<br>这里再来说说用aysnc和直接用thread的区别，其实简单来讲，就是效率的问题，async用的线程池，在await中运行的代码是由线程池分配的线程，根据系统的任务，自动分配和释放，而用 new thread的方法，通常是需要手动控制的。很显然，在处理一些短时间，且对运行的时间性和稳定性不是特别严格的问题时，用async会很有优势，但是对于一些在后台需要长时间稳定运行的程序，用thread会更好，可以保证它在运行的过程中，不过有别的代码来插队。</p><h1 id="四-I-O操作时，没有线程在执行"><a href="#四-I-O操作时，没有线程在执行" class="headerlink" title="四.I/O操作时，没有线程在执行"></a>四.I/O操作时，没有线程在执行</h1><p>  <a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">There is no thread</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">微软Docs：异步编程</a> ，两篇文章大意是，当遇到await进行I/O操作时，因为现在的磁盘很牛逼，支持Direct Memory Access (DMA)操作，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。所以程序遇到I/O异步时，只是从线程池里拿了个线程，进行一次CPU操作命令之后这个线程就没事了，他不负责执行I/O、也不实时监视I/O的运行情况、更不会被阻塞。它理论来说直接送回线程池了，然后可以去处理其他操作，此时硬件自己和内存交换数据。I/O完成之后，硬件会触发一个中断来通知操作完成。</p><p>  以下来自微软官方文档：</p><blockquote><p>调用系统 API 后，请求位于内核空间，一路来到操作系统的网络子系统（例如 Linux 内核中的 <code>/net</code>）。 此处操作系统将对网络请求进行异步 处理。 所用操作系统不同，细节可能有所不同（可能会将设备驱动程序调用安排为发送回运行时的信号，或者会执行设备驱动程序调用然后 有一个信号发送回来），但最终都会通知运行时网络请求正在进行中。 此时，设备驱动程序工作处于已计划、正在进行或是已完成（请求已“通过网络”发出），但由于这些均为异步进行，设备驱动程序可立即着手处理其他事项！</p><p>例如，在 Windows 中操作系统线程调用网络设备驱动程序并要求它通过表示操作的中断请求数据包 (IRP) 执行网络操作。 设备驱动程序接收 IRP，调用网络，将 IRP 标记为“待定”，并返回到操作系统。 由于现在操作系统线程了解到 IRP 为“待定”，因此无需再为此作业进行进一步操作，将其“返回”，这样它就可用于完成其他工作。</p><p>请求完成且数据通过设备驱动程序返回后，会经由中断通知 CPU 新接收到的数据。 处理中断的方式因操作系统不同而有所不同，但最终都会通过操作系统将数据传递到系统互操作调用（例如，Linux 中的中断处理程序将安排 IRQ 的下半部分通过操作系统异步向上传递数据）。 这也是异步发生的！ 在下一个可用线程能执行异步方法且“解包”已完成任务的结果前，结果会排入队列。</p></blockquote><h1 id="五-思考"><a href="#五-思考" class="headerlink" title="五.思考"></a>五.思考</h1><p>  看了十几篇文章之后，对异步稍微是理解进了一小步。在此留下我的最简短理解：<br><font color='red'>  异步，就是为了让单个线程不会因为某个长时间I/O操作而卡死自己，从而达到压榨线程剩余价值的目的。（特别是UI主线程对于客户端来说的剩余价值特别大）</font></p><p>  关于应用上，整理了一下工作会用到的：</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>  当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。<br>  而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。工作中用到过的：</p><p> <code>大数据量Collection.AsParallel.ForEach(Task.Run(你的任务))</code>　　</p><h3 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h3><table><thead><tr><th>使用以下方式…</th><th>而不是…</th><th>若要执行此操作…</th></tr></thead><tbody><tr><td>await</td><td>Task.Wait 或 Task.Result</td><td>检索后台任务的结果</td></tr><tr><td>await Task.WhenAny</td><td>Task.WaitAny</td><td>等待任何任务完成</td></tr><tr><td>await Task.WhenAll</td><td>Task.WaitAll</td><td>等待所有任务完成</td></tr><tr><td>await Task.Delay</td><td>Thread.Sleep</td><td>等待一段时间</td></tr></tbody></table><p>补充：</p><p>再深入的话，可能要自己尝试实现一下线程池+异步I/O。以后再补吧。</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</a></p><p>ref:</p><p><a href="https://blog.csdn.net/qq_36936155/article/details/78991050">https://blog.csdn.net/qq_36936155/article/details/78991050</a></p><p><a href="https://blog.stephencleary.com/2012/02/async-and-await.html">https://blog.stephencleary.com/2012/02/async-and-await.html</a></p><p><a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">https://blog.stephencleary.com/2013/11/there-is-no-thread.html</a></p><p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">https://docs.microsoft.com/zh-cn/dotnet/csharp/async</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth">https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零-为什么我会理解错&quot;&gt;&lt;a href=&quot;#零-为什么我会理解错&quot; class=&quot;headerlink&quot; title=&quot;零.为什么我会理解错&quot;&gt;&lt;/a&gt;零.为什么我会理解错&lt;/h1&gt;&lt;p&gt;在看完clr之前，我曾对异步同步探究看了十几篇文章，但很可惜，没有完全理解，</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
</feed>
