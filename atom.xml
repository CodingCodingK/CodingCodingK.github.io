<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2023-06-19T16:16:58.410Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>书籍笔记 - 程序是怎样跑起来的（硬件软件交互理解）</title>
    <link href="https://codingcodingk.github.io/Tech/BookNote/bookNote_howProgramRun/"/>
    <id>https://codingcodingk.github.io/Tech/BookNote/bookNote_howProgramRun/</id>
    <published>2023-06-19T16:16:58.410Z</published>
    <updated>2023-06-19T16:16:58.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="CPU可直接执行的“机器码”，到底能处理什么？"><a href="#CPU可直接执行的“机器码”，到底能处理什么？" class="headerlink" title="CPU可直接执行的“机器码”，到底能处理什么？"></a>CPU可直接执行的“机器码”，到底能处理什么？</h2><p>简单来说分为4种，</p><p>数据传送指令：用于寄存器、内存、外围设备之间进行数据读写的操作。也就是<strong>读写操作</strong>。</p><p>运算指令：用累加寄存器执行<strong>算术运算、逻辑运算、比较运算和位移运算</strong>。</p><p>跳转指令：实现条件分支、循环、强制跳转等。其实就是个<strong>goto</strong>。</p><p>call/return指令：函数的调用 / 返回调用前的地址。和c#的函数<strong>栈桢</strong>展开是类似的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221026103246.png"></p><h1 id="二进制数"><a href="#二进制数" class="headerlink" title="二进制数"></a>二进制数</h1><h2 id="如何在硬件层面理解二进制、bit、byte？"><a href="#如何在硬件层面理解二进制、bit、byte？" class="headerlink" title="如何在硬件层面理解二进制、bit、byte？"></a>如何在硬件层面理解二进制、bit、byte？</h2><p>像计算机的CPU和内存都是IC的一种，IC就是有很多引脚的集成电路，而每一个引脚的状态只有直流电压0V和5V，这两种。因此计算机的信息只能转化成二进制。</p><p>而**位(bit)**这个数据结构，就刚好对应了这个规律。</p><p>**字节(byte)**则是8个bit，因为内存和磁盘都是用字节为最小单位来存储、读写数据的，所以用位bit不能直接读写数据，所以都会在高位补0实现bit转byte。</p><p>而一个CPU有32位，就意味着它有32个引脚来处理信息的输入和输出，也就是说一次可以处理32位的二进制数信息。</p><h2 id="为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）"><a href="#为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）" class="headerlink" title="为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）"></a>为什么计算机内用补码来存数？（比如-1是11111111而不是10000001）</h2><p>为了实现通过相加来实现减法。</p><p>补码是取反+1的结果，同样的这个结果和无符号位的原码相加结果为0。</p><h1 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h1><h2 id="什么是浮点数？它是怎么表示小数的？"><a href="#什么是浮点数？它是怎么表示小数的？" class="headerlink" title="什么是浮点数？它是怎么表示小数的？"></a>什么是浮点数？它是怎么表示小数的？</h2><p><strong>什么是浮点数？</strong>是使用<strong>符号、尾数、基数、指数</strong>这四个部分来表示小数的，形式为<font color= "red"><code>± m * n的e次方</code></font >。符号就是±，基数n因为计算机二进制所以是2。而至于尾数m和指数n，就是根据具体数字来的，但也并不是毫无参照。</p><p><strong>它是怎么表示小数的？</strong></p><p>首先，分为单、双精度浮点数，它们表示范围不同，根据最为普遍的IEEE标准，单精浮点（32位）有1位符号部分、8位指数部分、23位尾数部分；双精浮点（64位）有1位符号部分、11位指数部分、52位尾数部分。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221018103720.png"></p><p>其次，对于尾数m，就像科学计数法一样，浮点数也有一种表示规则来限制诸如<code>0.75 * 10^0</code>、<code>7.5 * 10^-1</code>这种同一个数字，表示方式却不同的情况。在二进制数中，用的是<strong>“将小数点前面的值固定为1的正则表达式”</strong>。</p><p>比如<code>1011.0011</code> =&gt; <code>0001.0110011</code> =&gt;第一位固定1所以可以去掉，多表示1位 <code>0110011000...(省略0，补齐23/52位)</code></p><p>最后，对于指数e，用的是<strong>EXCESS系统</strong>来表示它的正负。比如单精指数部分只有8位的情况下，最大值<code>11111111</code>=255，用它的一半<code>01111111</code>=127来记作0，比它大的是正数，比它小的是负数。指数e的表示范围从0<del>255变为-127</del>128。</p><h2 id="浮点数会不准确"><a href="#浮点数会不准确" class="headerlink" title="浮点数会不准确"></a>浮点数会不准确</h2><p><strong>为什么浮点数会不准确？</strong>计算机用浮点数无法处理0.1这种转换为二进制会无尽的小数。所以会导致0.1打印输出会变成0.10000002之类的。</p><p><strong>如何解决？</strong>一般可以不解决，因为科学近似精度已经足够高了。但如果是一些严格要求准确的领域，</p><p>方法1.可以把小数倍乘成整数来计算，计算完后再除回去。</p><p>方法2.可以使用BCD(Binary Coded Decimal)表示法，就是用4位来表示0~9的1位数字。</p><h2 id="浮点数c-实践"><a href="#浮点数c-实践" class="headerlink" title="浮点数c#实践"></a>浮点数c#实践</h2><p>在c#中尝试把一个float用二进制输出出来，比如<code>0.75f</code>，输出的值确实是按照1-8-23划分的：<code>0-01111110-10000000000000000000000</code>。但是结果是反过来的，不清楚为什么，书中用的c++是正序的。另外就是，用<code>BitConverter.GetBytes</code>接口转的是byte，也就是8位2进制转成10进制读得的数值，所以还需要再转回8位2进制数。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="如何理解内存硬件"><a href="#如何理解内存硬件" class="headerlink" title="如何理解内存硬件"></a>如何理解内存硬件</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221020085834.png"></p><p>比如一个内存，其实就是一堆引脚。VCC、GND引脚是接电源的，DR、WR是控制信号用来操控读、写。</p><p>A0-A9的引脚用来表示地址，所以可以表示1024个地址；D0-D7表示数据，8位2进制，也就是1个字节B。所以这个内存的容量为1KB。</p><p>一个内存内部有大量空间去存储这些8位数据，通过地址引脚指定的地址来读写这些数据。</p><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>1个地址指向1个字节（内存的最小单位）；</p><p>32位系统一次可以读4个字节，等于其最高可表示2^32个地址数。</p><p>所以32位系统，内存上限为4GB。</p><h1 id="内存与磁盘"><a href="#内存与磁盘" class="headerlink" title="内存与磁盘"></a>内存与磁盘</h1><h2 id="CPU、内存、磁盘"><a href="#CPU、内存、磁盘" class="headerlink" title="CPU、内存、磁盘"></a>CPU、内存、磁盘</h2><p>1.程序保存在存储设备中，通过有序地被读出来实现运行。</p><p>2.CPU只能执行已经加载到内存中的程序。</p><h2 id="如何理解磁盘硬件"><a href="#如何理解磁盘硬件" class="headerlink" title="如何理解磁盘硬件"></a>如何理解磁盘硬件</h2><p>磁盘是用扇区作为读写最小物理单位的，一个扇区为512字节。但是Windows在逻辑方面对磁盘进行读写的单位是<strong>簇</strong>，1簇可以设置为扇区整数倍，比如可以1簇=1扇区（512字节）、也可以1簇=2扇区（1KB）等等。</p><p>无论是多么小的文件，都会占用至少1簇。</p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>磁盘访问速度 &lt; 内存访问速度，所以会用内存映射一段磁盘数据作为缓存，如果下一次还用到的磁盘数据刚好被内存加载过，那就直接去速度更快的内存里拿数据。这叫<strong>缓存</strong>。到win98时代，由于磁盘访问速度越来越快，这种技术的提升就不是很显著了，但是这个思想也用于Web把远端服务器加载下来的数据存入磁盘中。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>正好与磁盘缓存相对的概念，就是说划分一块磁盘区域作为假想的内存来使用。但CPU只能执行已经加载到内存中的程序，所以实际上是在把内存和磁盘中的内容不停进行置换，保持当前正在运行的程序部分有在物理内存中。而置换就涉及一个最小单位，Windows是用<strong>页</strong>为单位（一般4KB）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221020142308.png"></p><h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><p>就只列举一些常见的压缩算法。</p><p>文本文件：RLE压缩（文本 x 次数 的形式）、哈夫曼（权重画树、编码）压缩</p><p>图像文件：可逆压缩、不可逆压缩。</p><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><h2 id="虚拟机是什么"><a href="#虚拟机是什么" class="headerlink" title="虚拟机是什么"></a>虚拟机是什么</h2><p>因为应用是针对操作系统OS的，所以Windows应用只能在Windows系统上运行。而虚拟机就是在其他OS上，模拟Windows运行环境，来实现跨平台。</p><h2 id="其他跨平台方式"><a href="#其他跨平台方式" class="headerlink" title="其他跨平台方式"></a>其他跨平台方式</h2><p>除了虚拟机之外，还有两个方式。一个是<strong>Ports机制</strong>，是移植的意思。该机制能够结合当前运行的硬件环境来编译应用的源代码。</p><p>另一个是Java虚拟机，它其实是一种运行环境。Java在编译之后生成的不是机器码而是<strong>字节代码</strong>，然后字节代码在不同平台实现的Java虚拟机上运行，转换成本机代码。和c#一样。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="从程序到机器码-编译器"><a href="#从程序到机器码-编译器" class="headerlink" title="从程序到机器码 - 编译器"></a>从程序到机器码 - 编译器</h2><p><strong>编译器</strong>把源代码转换成本地代码（本机代码），它内部仿佛有一个 源代码-本机码 的对应表，但实际上读入的源代码还需要经过<strong>语法解析、句法解析、语义解析</strong>等，才能生成本地代码。</p><p>编译器本身也是一个程序，所以也需要<strong>运行环境</strong>（比如Windows）。根据<strong>输出的目标CPU类型、输入的高级语言</strong>的不同，编译器也不同（比如Windows可用的x86系CPU的C编译器）。</p><h2 id="生成EXE-链接器"><a href="#生成EXE-链接器" class="headerlink" title="生成EXE - 链接器"></a>生成EXE - 链接器</h2><p>编译后的机器代码是一个obj文件（里面都是2进制数），并不能直接运行。还需要把代码中的引用其他文件的部分、和obj文件结合，生成出一个EXE文件。这就是<strong>链接</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221025144538.png"></p><h2 id="EXE启动-分配内存"><a href="#EXE启动-分配内存" class="headerlink" title="EXE启动 - 分配内存"></a>EXE启动 - 分配内存</h2><p>一个程序经过编译+链接后，生成了可执行文件EXE，但是程序源码里对函数、变量的调用都是指向内存地址的，但一个EXE文件并没有给它分配内存地址，怎么办呢？</p><p>其实，EXE文件中给变量、函数分配了虚拟的内存地址，当EXE运行时会把虚拟的内存地址转换成实际的内存地址。链接器在EXE文件的开头，追加转换内存地址所需的必要信息，这个叫做<strong>再配置信息</strong>。</p><p>当EXE运行时，还会分配额外的2块连续内存，一个是栈、一个是堆。栈用来存储函数内部临时变量，堆用来存储运行时数据以及对象。栈的内存管理代码是编译器自动生成的，而堆的内存管理是需要人为编写的，c++中用new申请、delete来释放。这就是GC。</p><h2 id="常见编译问题"><a href="#常见编译问题" class="headerlink" title="常见编译问题"></a>常见编译问题</h2><h3 id="什么是编译器、什么是解释器？"><a href="#什么是编译器、什么是解释器？" class="headerlink" title="什么是编译器、什么是解释器？"></a>什么是编译器、什么是解释器？</h3><p>两者都是把高级语言转化为机器语言的程序。编译器再运行前把源码转换成二进制可执行文件，而解释器逐条读取源码转换成机器码。</p><h3 id="Build是什么意思？"><a href="#Build是什么意思？" class="headerlink" title="Build是什么意思？"></a>Build是什么意思？</h3><p>编译+链接</p><h3 id="DLL可以不用链接就调用到吗？"><a href="#DLL可以不用链接就调用到吗？" class="headerlink" title="DLL可以不用链接就调用到吗？"></a>DLL可以不用链接就调用到吗？</h3><p>可以，通过<code>LoadLibrary()</code>、<code>GetProcAddress()</code>这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。</p><h1 id="通过汇编理解程序"><a href="#通过汇编理解程序" class="headerlink" title="通过汇编理解程序"></a>通过汇编理解程序</h1><h2 id="什么是汇编语言？"><a href="#什么是汇编语言？" class="headerlink" title="什么是汇编语言？"></a>什么是汇编语言？</h2><p>汇编语言和本地代码是一一对应的。汇编语言是本地代码（二进制）的助记符。</p><h2 id="汇编语言怎么看？"><a href="#汇编语言怎么看？" class="headerlink" title="汇编语言怎么看？"></a>汇编语言怎么看？</h2><p><strong>伪指令</strong>：负责把程序的构造以及汇编的方法指示给汇编器。伪指令<code>proc</code>和<code>endp</code>围起来的部分，表示的是函数的范围，里面的是函数执行过程。</p><p><strong>语法结构</strong>：操作码+操作数，比如<code>mov</code>+内存地址</p><p>以下是x86的部分操作码、主要寄存器：</p><table><thead><tr><th>操作码</th><th>操作数</th><th>功能</th></tr></thead><tbody><tr><td>mov</td><td>A、B</td><td>把B的值赋给A</td></tr><tr><td>and</td><td>A、B</td><td>把A同B的值相加，并将结果赋给A</td></tr><tr><td>push</td><td>A</td><td>把A的值存储在栈中</td></tr><tr><td>pop</td><td>A</td><td>从栈中读取出值，并将其赋给A</td></tr><tr><td>call</td><td>A</td><td>调用函数A，<font color="red">调用时自动获取栈上对应数量的入参</font></td></tr><tr><td>ret</td><td>无</td><td>将处理返回到函数的调用源</td></tr></tbody></table><p><strong>调用函数流程</strong>：</p><p>1.先把ebp寄存器（数据领域基址寄存器）的值入栈，再把函数的入参push入栈。</p><p>//注意，栈的高位地址在下面，低位地址在上面。</p><p>2.使用<code>call</code>指令 + 函数名（函数指针），调用时自动获取栈上对应数量的入参。</p><p>3.清理栈，把入参销毁掉。具体是把esp的寄存器值（栈顶指针寄存器）add上 4 * 入参数。</p><p>//至于为什么是4字节，因为堆栈进行数值的输入输出时，数值的单位是4字节。</p><p>4.<code>pop</code>读出此时栈顶的数值，也就是1中存储的ebp寄存器值，存入ebp寄存器。执行<code>ret</code>返回。</p><p>//为什么把edp寄存器的值原地倒腾了一遍？因为这是c语言的规定，确保函数调用前后edp不变。</p><p><strong>此外.函数的参数是通过栈来传递，返回值是通过寄存器返回的。</strong></p><h2 id="汇编实现功能"><a href="#汇编实现功能" class="headerlink" title="汇编实现功能"></a>汇编实现功能</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>使用标记 + goto标记 的 思路去做，具体助记符就不记了（先cmp再jmp）。</p><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><p>一样是标记 + go标记去实现的。</p><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>写2个把全局变量x2的相同的函数，再多线程分别调用1次，可能遇到结果为2倍而不是2x2倍的情况。原因如图。解决方案是用c语言中的锁定方法。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027090224.png"></p><h1 id="硬件控制"><a href="#硬件控制" class="headerlink" title="硬件控制"></a>硬件控制</h1><h2 id="外围设备硬件和软件是如何实现通信的？"><a href="#外围设备硬件和软件是如何实现通信的？" class="headerlink" title="外围设备硬件和软件是如何实现通信的？"></a>外围设备硬件和软件是如何实现通信的？</h2><p><strong>首先，应用与硬件无关：</strong>Windows系统下的硬件是由系统全权负责的，应用层只能通过API来通过系统调用。</p><p><strong>其次，硬件们是通过I/O控制器来实现和操作系统通信的：</strong>计算机有着USB等和外围设备交互的连接器，因为外围设备的电压不同、用的也是模拟信号，所以无法和硬件直接连接，需要用I/O控制器。</p><p><strong>什么是端口：</strong>I/O控制器中由用于临时保存输入输出数据的内存，这个内存叫端口。端口是内存，也有自己的地址，叫<strong>端口号</strong>或者<strong>I/O地址</strong>。</p><p><strong>汇编语言的IN/OUT指令，是通过端口和寄存器之间数据互换实现的：</strong>汇编中的IN/OUT助记符是实现和硬件交互的，IN指令把端口数据存储在CPU寄存器中，OUT把CPU寄存器数据存储在端口中。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027100225.png"></p><h2 id="外围设备硬件的中断操作IRQ"><a href="#外围设备硬件的中断操作IRQ" class="headerlink" title="外围设备硬件的中断操作IRQ"></a>外围设备硬件的中断操作IRQ</h2><p>IRQ（Interrupt Request）是<strong>中断请求</strong>的意思，对应的值是0x06。</p><p>它负责把当前正在运行的主程序中断（同时把CPU所有寄存器的数值保存到栈中），然后跳转到外围设备的输入输出运行，等运行完后返回中断程序（同时恢复所有寄存器的值），继续执行。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027103320.png"></p><p>遇到诸如打印机这种操作比CPU慢很多的设备，就可以等中断请求发生时再输出数据即可；而对于实时性比较高的比如鼠标等，就可以不停轮询。</p><h2 id="外围设备直接和内存通信DMA"><a href="#外围设备直接和内存通信DMA" class="headerlink" title="外围设备直接和内存通信DMA"></a>外围设备直接和内存通信DMA</h2><p>像IRQ的中断，本质上还是要和CPU交互的。但是DMA（Direct Memory Access）可以不通过CPU，外围设备直接和主内存进行数据传送。这样更快。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027104221.png"></p><h2 id="计算机图形的内存VRAM"><a href="#计算机图形的内存VRAM" class="headerlink" title="计算机图形的内存VRAM"></a>计算机图形的内存VRAM</h2><p>显示器中显示的数据，一直存储在内存总，这个内存叫<strong>VRAM</strong>（Video RAM）。在程序中，只要往VRAM中写入数据，该数据就会在显示其中显示出来，此功能由操作系统或BIOS提供。</p><p>在DOS系统时代，VRAM是主内存的一部分，图形颜色只能用16种是因为这块内存太小了。而如今，显卡配有独立的VRAM内存。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027104612.png"></p><h1 id="计算机的随机数"><a href="#计算机的随机数" class="headerlink" title="计算机的随机数"></a>计算机的随机数</h1><h2 id="线性同余法实现伪随机"><a href="#线性同余法实现伪随机" class="headerlink" title="线性同余法实现伪随机"></a>线性同余法实现伪随机</h2><p>很多伪随机其实就是用线性同余法的递推公式<img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027110424.png"></p><p>实现的。</p><p>指定了a、b、c之后，就会生成0 ~ c（不包括c）的随机数。其中Ri、a、b、c就是随机数的种子。</p><p>那这样为什么叫伪随机呢？因为指定好a、b、c之后的数，不停递推生成的结果是有<strong>周期性</strong>的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221027110819.png"></p><h1 id="C入门"><a href="#C入门" class="headerlink" title="C入门"></a>C入门</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>名称</th><th>长度（位长）</th><th>精度</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>-128，+127</td></tr><tr><td>short</td><td>16</td><td>-32768，32767</td></tr><tr><td>int（或者long）</td><td>32</td><td>-2147483648，2147483647</td></tr><tr><td>float</td><td>32</td><td>略</td></tr><tr><td>double</td><td>64</td><td>略</td></tr></tbody></table><h2 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20221028110814.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h1&gt;&lt;h2 id=&quot;CPU可直接执行的“机器码”，到底能处理什么？&quot;&gt;&lt;a href=&quot;#CPU可直接执行的“机器码”，到底能处理什么？&quot; c</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://codingcodingk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术类" scheme="https://codingcodingk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"/>
    
    
    <category term="硬件" scheme="https://codingcodingk.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="软件" scheme="https://codingcodingk.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>AB包基础</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/assetbundleInit/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/assetbundleInit/</id>
    <published>2023-04-28T09:40:50.908Z</published>
    <updated>2023-06-19T16:16:58.418Z</updated>
    
    <content type="html"><![CDATA[<p>2023年6月更新：已完成学习并实现huatuo+yooasset+uniTask的demo，下一步是接入自己的ui框架并迭代，地址：<a href="https://github.com/CodingCodingK/CodingK_SutureFramework">https://github.com/CodingCodingK/CodingK_SutureFramework</a></p><p>=================================================================================</p><p>学习计划：（我感觉用脑图好像比md更适合这种架构的学习和复习）</p><p>什么是热更 <a href="https://www.bilibili.com/video/BV1Np4y1e7DX/">https://www.bilibili.com/video/BV1Np4y1e7DX/</a></p><p>AB入门 <a href="https://www.bilibili.com/video/BV1LD4y1m7kF">https://www.bilibili.com/video/BV1LD4y1m7kF</a></p><p>AB实战 <a href="https://www.bilibili.com/video/BV1VP411G7w2/">https://www.bilibili.com/video/BV1VP411G7w2/</a></p><p>AA包 <a href="https://blog.csdn.net/u011366226/article/details/104506802">https://blog.csdn.net/u011366226/article/details/104506802</a></p><p>UniTask <a href="https://www.lfzxb.top/unitask_reademe_cn/">https://www.lfzxb.top/unitask_reademe_cn/</a></p><p>做出自己的学习版demo，服务器上跑一下，测试后上传github。</p><p>后面开始学习yooasset+huatuo方案，学习整合成自己能用的插件。如果资源管理不完整或者太难理解可以再参考gf。</p><p>等做完对资源有划分理解后，我们再开始做战斗，学习结点吧。</p><p>如果实现完还有时间，就用xLua重写c#热更项目。</p><h1 id="AB包入门"><a href="#AB包入门" class="headerlink" title="AB包入门"></a>AB包入门</h1><p>什么是AB包：资产压缩包，资产包括：模型、贴图、预设体、音效、材质球等。</p><p>AB包和Resources区别：Resources打包时定死，只读，无法修改。所以AB包的优势就是可压缩资源、可热更新。</p><p>热更基本规则：双端都带有一个资源对比文件，客户端检查热更就是检查资源对比文件。</p><p>可生成AB包资源文件的资源管理系统：</p><p>1.可以自定义打包工具，AB包的话gf和yooasset都是不错的开源插件。</p><p>2.官方在过去提供的AB包管理系统插件，叫Asset Bundle Browser，但在如今已经弃用了。</p><p>3.官方现在推崇的是Addressables了，它可以打AA包也可以打AB包。</p><p>AB包和AA包的区别：</p><ul><li>Addressable Asset Bundle可以自动加载相关依赖包，而AssetBundle是需要编程实现的；</li><li>Addressable Asset Bundle加载到内存中的bundle有引用计数，而AssetBundle加载到内存中的bundle需要自己进行管理</li></ul><h1 id="yooAsset"><a href="#yooAsset" class="headerlink" title="yooAsset"></a>yooAsset</h1><p>手册：<a href="https://www.yooasset.com/docs">https://www.yooasset.com/docs</a></p><p>教程：<a href="https://www.bilibili.com/video/BV1do4y1v7Pb/">https://www.bilibili.com/video/BV1do4y1v7Pb/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年6月更新：已完成学习并实现huatuo+yooasset+uniTask的demo，下一步是接入自己的ui框架并迭代，地址：&lt;a href=&quot;https://github.com/CodingCodingK/CodingK_SutureFramework&quot;&gt;htt</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="网络库" scheme="https://codingcodingk.github.io/tags/%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - 合批规则</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_batch/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_batch/</id>
    <published>2023-04-27T09:32:14.928Z</published>
    <updated>2023-04-27T09:33:24.112Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.抛开UGUI的概念，什么是drawcall？什么是批处理？他俩有啥关系？</strong></p><p>CPU告诉GPU“可以渲染这个模型”的过程或者说这个命令叫做Draw Call（我们在Stats面板上看到的Batches其实就是Draw Call的调用次数）。在NGUI里甚至有UIDrawCall这个具体的类去抽象一次drawcall。</p><p>批处理（UGUI里类似的行为叫合批）就是把渲染时使用相同材质(Shader)、相同贴图的3D模型的网格合并在一起，成为一个大网格，然后再调用一次Draw Call，直接渲染这一个大网格。</p><p>关系就是，批处理是降低CPU发起drawcall次数的手段。</p><p><strong>2.Unity中我怎么直观的去检查它？</strong></p><p>frame debugger可以查看一帧整体的绘制流程，从而观察到UGUI层调了多少次Draw Mesh、每次是怎么样的。</p><p>profiler可以更直接的看到一个Canvas下的batch 0、batch 1…</p><p><strong>3.基础的UGUI合批规则</strong></p><p>无论是UGUI还是NGUI，都以一个基础的合批规则：当前渲染的UI组件与上一个UI组件的material+shader（也就是材质球）、texture（贴图）都需要一致。满足了这个最基本要求才能合批。</p><p><strong>4.进阶的UGUI合批规则</strong></p><p>首先我们要明确UGUI中Canvas下可以嵌套子Canvas，但是合批是以Canvas(不包含子Canvas)为单位的(子Canvas会是另外一个批次了)。除此之外，合批的操作是在子线程完成的。这段的理解要结合图，<a href="https://blog.csdn.net/sinat_25415095/article/details/112388638">详见</a>。<br>① 既然合批是以Canvas为单位，第一步自然就是把所有Canvas给找出来，然后剔除掉不必渲染的Canvas(透明度为0，长宽为0，在RectMask2D控件下，且在RectMask2D的区域外)<br>② 然后计算Canvas下各UI控件的深度值Depth(需要注意的是Image的属性里面也有个depth，两者不是同一个东西)</p><p>③Depth的计算规则如下：</p><p>按照Hierarchy中从上往下的顺序依次遍历Canvas下所有UI元素<br>对于当前的UI元素CurrentUI<br>i.如果CurrentUI不渲染，则Depth = -1<br>ii.如果CurrentUI要渲染，但CurrentUI下面没有其他UI元素与其相交，则Depth = 0<br>iii.如果CurrentUI要渲染，下面只有一个UI元素(LowerUI)与其相交，且CurrentUI与LowerUI可以合批(材质和贴图完全相同)，则CurrentUI.Depth = LowerUI.Depth；如果两者不能合批，CurrentUI.Depth= LowerUI.Depth + 1<br>iv.如果CurrentUI要渲染，下面有n个元素与其相交，则按照步骤iii，分别计算出n个Depth(Depth_1、Depth_2、Depth_3…)，然后CurrentUI.Depth取其最大值，即CurrentUI.Depth = max(Depth_1, Depth_2, Depth_3，…)<br>上面步骤中的“下面”和“相交”要明确下意思，这两个概念很重要。<br>CurrentUI下面的UI，指Hierarchy面板中，在CurrentUI之上的元素。</p><p>在计算相交时，由于要遍历所有UI元素和已计算的底层UI元素（平方复杂度），源码中使用<strong>分组计算包围盒矩形的方法加快计算，即16个UI元素为一组计算Group 网格Rect</strong>，检查是否与底层UI元素相交时，先计算是否与底层Group相交，如果相交再与Group中的元素做判定。<br>④各个UI的Depth计算完毕后，依次按照Depth、material ID、texture ID、RendererOrder（即UI层级队列顺序，即Hierarchy面板上的顺序）排序（条件的优先级依次递减，且均为从小到大排序）。然后剔除Depth = -1的UI元素，得到Batch前的UI 元素队列，这个队列被称之为VisiableList。<br>⑤得到VisiableList之后，判断VisiableList中相邻的元素是否能够合批(相同的材质和贴图)。需要注意这里不再考虑Depth是否相同，只要两个元素相邻然后材质和贴图相同，即使两个元素的Depth不相同，这两个元素也能合批。然后一个批次一个批次的合并网格，提交GPU进行渲染。</p><p>除此之外，需要注意的是，合批是将同一Canvas下多个UI的网格合并在一起，如果其中任何一个元素的材质、网格顶点、位置(Transform)甚至颜色或者在该Canvas下动态创建或删除UI元素都将导致该Canvas重新计算合批(需要注意的是仅仅会影响这一个Canvas，子Canvas或父Canvas以及其他Canvas不会重新计算)，重新生成新的网格，这个重新计算生成网格的过程被称为rebuild。所以，这也是为什么做UI提倡动静分离(动态部分和静态部分分别用不同的Canvas)，层级尽量减少(层级多了，重新计算更耗时)的原因。</p><p><strong>5.总结合批规则</strong></p><p>合批是自己Canvas内部的规则，排序规则：计算得到的Depth &gt; material ID &gt; texture ID &gt; RendererOrder。计算Depth时会16个UI元素为一组最为包围盒检测，计算Depth和Mesh（UGUI本质）是否相交也有关。会剔除透明度为0、长宽为0、在RectMask2D下在Mask外的UI组件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.抛开UGUI的概念，什么是drawcall？什么是批处理？他俩有啥关系？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU告诉GPU“可以渲染这个模型”的过程或者说这个命令叫做Draw Call（我们在Stats面板上看到的Batches其实就是Draw Call</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Spine安装和简单了解、导入unity</title>
    <link href="https://codingcodingk.github.io/Project/Unity/RPG/himegami/spineInit/"/>
    <id>https://codingcodingk.github.io/Project/Unity/RPG/himegami/spineInit/</id>
    <published>2023-04-25T18:30:21.536Z</published>
    <updated>2023-04-25T19:01:53.754Z</updated>
    
    <content type="html"><![CDATA[<p>1.首先简单了解下spine导出的东西是什么。spine导出的文件会有3个：png图集、atlas图集切分文件、记录骨骼、动画的一个二进制skel文件 或者 一个json文件。</p><p>2.要把spine导出的文件导入进unity，只要事先在<a href="https://zh.esotericsoftware.com/spine-unity-download">spine-unity页面</a>下载好对应的 spine-runtime unitypackage就可以。注意这个版本卡的特别死，unity版本和spine导出版本是必须严格遵照要求的，具体看页面。<strong>安装好对应的package之后，需要先把atlas后缀加上.txt，再给二进制文件skel加上.bytes，json就不用改了，然后直接复制粘贴文件到unity里就会自动转换。</strong></p><p>3.<strong>在这里记录一个大坑</strong>，众所周知 Spine3.8.75 这个版本是网上能找到的破解版本。所以Spine直接在自己的 3.8版本unity runtime里，特别在2个地方写了一行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;3.8.75&quot;</span> == skeletonData.version)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unsupported skeleton data, please export with a newer version of Spine.&quot;</span>);</span><br></pre></td></tr></table></figure><p>这会直接导致你的转换文件生成失败。我一开始以为是自己资源的版本导出有问题，研究了很久，最后感觉哪都跑通了就这个离奇，就直接查代码了，结果才发现这行特殊的代码。</p><p>实在是666。</p><p>解决方法是直接全局搜索到<code>&quot;3.8.75&quot;</code>，然后注释掉就完事了。</p><p>4.一个简单的优化，就是spine的文件选择skel二进制而不是json文件。json文件的读取，那可真的是慢到爆炸了…其他的话应该还可以在战斗开始前就把所有可能用到的人物bytes全部加载好一起进，这个具体怎么操作还没看估计得小改一下spine的加载部分。</p><p>5.途径的有用链接</p><p>Spine-Unity 官网页面：<a href="http://zh.esotericsoftware.com/spine-unity-download/">http://zh.esotericsoftware.com/spine-unity-download/</a></p><p>一个日本老哥做的 skel转json：<a href="https://naganeko.pages.dev/chibi-gif/">https://naganeko.pages.dev/chibi-gif/</a></p><p>6.总得来说还是第3点最离谱，网上看到很多有同样问题的却只有人回答说要把json文件里的版本号改成3.8这种方法去解决。说回来如果Spine真的想玩一手盗版用户，为什么还要抛出而不是直接在这里return掉呢，那样我估计可以自我怀疑到天荒地老了。总之不会做商用仅作学习，搞了一晚上总算可以开始用spine了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.首先简单了解下spine导出的东西是什么。spine导出的文件会有3个：png图集、atlas图集切分文件、记录骨骼、动画的一个二进制skel文件 或者 一个json文件。&lt;/p&gt;
&lt;p&gt;2.要把spine导出的文件导入进unity，只要事先在&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="ひめがみ絵巻" scheme="https://codingcodingk.github.io/tags/%E3%81%B2%E3%82%81%E3%81%8C%E3%81%BF%E7%B5%B5%E5%B7%BB/"/>
    
  </entry>
  
  <entry>
    <title>GameFramework个人手册</title>
    <link href="https://codingcodingk.github.io/Project/Unity/RPG/himegami/gf/"/>
    <id>https://codingcodingk.github.io/Project/Unity/RPG/himegami/gf/</id>
    <published>2023-04-19T14:27:48.106Z</published>
    <updated>2023-04-19T15:45:42.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程-Procedure"><a href="#流程-Procedure" class="headerlink" title="流程    Procedure"></a>流程    Procedure</h1><p>游戏可以按照业务切分成各种流程，比如<code>Loading</code>、<code>Menu</code>、<code>CheckResources</code>、<code>UpdateResources</code>等等。它是继承自<code>abstract class ProcedureBase : FsmState&lt;IProcedureManager&gt;</code>的。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>Procedure</code>在内部<code>OnUpdate</code>中检测是否完成本流程，进入下一流程<code>ChangeState&lt;ProcedureNext&gt;</code>。</p><p>内部一般有个callback，在<code>OnEnter</code>流程的时候通过调用<code>GameEntry.Event.Subscribe(GameEventArgs派生类.EventId, callback)</code>放入事件中心，且这个callback可能带有一个bool值，这个bool值正是上一句中<code>OnUpdate</code>检测的东西。</p><h1 id="引用池-ReferencePool"><a href="#引用池-ReferencePool" class="headerlink" title="引用池    ReferencePool"></a>引用池    ReferencePool</h1><p>用字段管理回收C#层级的内存使用，以达到复用目的。</p><h2 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h2><p>静态类，<code>ReferencePool</code></p><p>​        字典<code>Dictionary&lt;Type, ReferenceCollection&gt;</code></p><p>内部类，<code>ReferenceCollection</code></p><p>​        队列<code>Queue&lt;IReference&gt;</code></p><p>接口，<code>IReference</code></p><p>​        方法<code>void Clear()</code></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>外部调用<code>ReferencePool</code>管理类的对外方法即可，比如获取<code>Acquire&lt;T&gt;()</code>和释放<code>Release(IReference ref)</code>。</p><p>引用对象要实现<code>IReference</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;流程-Procedure&quot;&gt;&lt;a href=&quot;#流程-Procedure&quot; class=&quot;headerlink&quot; title=&quot;流程    Procedure&quot;&gt;&lt;/a&gt;流程    Procedure&lt;/h1&gt;&lt;p&gt;游戏可以按照业务切分成各种流程，比如&lt;code&gt;</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="ひめがみ絵巻" scheme="https://codingcodingk.github.io/tags/%E3%81%B2%E3%82%81%E3%81%8C%E3%81%BF%E7%B5%B5%E5%B7%BB/"/>
    
  </entry>
  
  <entry>
    <title>战斗同步思考（未完）</title>
    <link href="https://codingcodingk.github.io/Project/Unity/RPG/himegami/battle/"/>
    <id>https://codingcodingk.github.io/Project/Unity/RPG/himegami/battle/</id>
    <published>2023-04-17T11:10:56.126Z</published>
    <updated>2023-06-19T16:16:58.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求拆解"><a href="#需求拆解" class="headerlink" title="需求拆解"></a>需求拆解</h1><h2 id="战斗同步"><a href="#战斗同步" class="headerlink" title="战斗同步"></a>战斗同步</h2><p>1.战斗同步有2种模式，一种是离线验证模式，在本地记录操作帧和随机种子，发送到服务端，再重新演算战斗逻辑；另一种是同步模式，客户端只转发操作帧，由服务端下发真实操作帧。<strong>服务器成本原因，优先实现第一种。</strong></p><p>2.结果验证</p><p>3.掉落验证</p><h2 id="战斗流程"><a href="#战斗流程" class="headerlink" title="战斗流程"></a>战斗流程</h2><p>1.实现战前匹配（可以是玩家也可以是Boss）、匹配成功后在服务端对所有玩家建立房间，下发开始。房间用状态机管理。进入房间后，启动倒计时，超过设定的最长战斗时长（10分钟）就判定失败，战斗视为失败，服务器回收资源。</p><p>2.从第一回合到最终回合，每一个回合的内部，进行回合触发时机的执行、行动优先级的判定、技能逻辑的执行、存活死亡的结算、战斗胜负的判定这几个程序步骤。</p><h1 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h1><h2 id="伪随机"><a href="#伪随机" class="headerlink" title="伪随机"></a>伪随机</h2><p>1.PRD算法</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20230413152135.png"></p><p>这是伪随机在游戏中最常见的用法，因此直接就被玩家用Pseudo Random Distribution的缩写PRD来指代了。</p><p>在WAR3中，一个暴击率20%的英雄，并不是每一刀都20%暴击率的。而是以5.57%作为初始暴率，如果第一刀不暴，则第二刀的暴率增加到初始值的2倍：11.14%；如果还是不暴，就继续增加到初始值的3倍：16.71%，以此类推。</p><p>而如果在这个过程中任何一次攻击打出了暴击，就会把暴击率重置到5.57%。</p><p>因此可以把所有游戏中可能出现的暴击概率（比如0-100的整数%） 和 公式计算出的初始值 做成一张映射表，就不需要随机了。</p><p>2.洗牌算法</p><p>类似于音乐播放器，在一开始就把所有可能的结果列出并洗成乱序，然后从第一个开始取。那么具体怎么洗的话，就是比如30个按顺序排列的不重复数字，先从下标0-29里random一个，放到29，再从0-28里random一个，放到28…每次放到数组最后的就是洗好的，这样可以避免每次random的时候随到重复下标。</p><p>3.组合随机</p><p>其实就是保底机制，用于抽卡。品质值不随机（固定SR、SSR），只随机具体物品值。</p><h1 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h1><h2 id="掉落"><a href="#掉落" class="headerlink" title="掉落"></a>掉落</h2><p><a href="https://www.jianshu.com/p/f9c37c46c03c">https://www.jianshu.com/p/f9c37c46c03c</a></p><h2 id="战斗序列"><a href="#战斗序列" class="headerlink" title="战斗序列"></a>战斗序列</h2><p>使用行动队列的方式，通过将每一个行动定义为一个行动节点（操作帧），按照队列中节点的顺序依次执行。不管是回合初就确定了行动顺序，还是回合中每完成一个行动都需要重新计算行动优先级的方案，都适用上述的方式，区别只在于对技能逻辑中衍生的行动节点，是添加到队列的末端还是插入到队列的头部。</p><p>另外为了打破技能循环（比如暴击后再攻击一次），还需要定义出行动节点的类型，由战斗回合产生的行动节点称为原始行动节点，由技能触发的行动节点则称为衍生行动节点，所有的反制行动、追加行动都应该归属于衍生行动节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;需求拆解&quot;&gt;&lt;a href=&quot;#需求拆解&quot; class=&quot;headerlink&quot; title=&quot;需求拆解&quot;&gt;&lt;/a&gt;需求拆解&lt;/h1&gt;&lt;h2 id=&quot;战斗同步&quot;&gt;&lt;a href=&quot;#战斗同步&quot; class=&quot;headerlink&quot; title=&quot;战斗同步&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="ひめがみ絵巻" scheme="https://codingcodingk.github.io/tags/%E3%81%B2%E3%82%81%E3%81%8C%E3%81%BF%E7%B5%B5%E5%B7%BB/"/>
    
  </entry>
  
  <entry>
    <title>我用向日葵打开unity编辑器怎么白屏了？</title>
    <link href="https://codingcodingk.github.io/Project/Unity/RPG/himegami/remoteUnityBug/"/>
    <id>https://codingcodingk.github.io/Project/Unity/RPG/himegami/remoteUnityBug/</id>
    <published>2023-04-16T06:54:12.756Z</published>
    <updated>2023-04-16T07:02:02.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>根据网上搜索的结果，大致有两个原因：</p><p>台式机没有外接显示器，或显示器处于关闭状态。<br>笔记本合上了盖子。</p><p>根据以上原因，个人猜测主要是因为没有检测到显示器，电脑显卡自动切换到某种低负载模式，这将导致一些使用显卡硬件加速的软件出现无法显示的问题。</p><p>没错，所以unity编辑器肯定是用了硬件加速或者根据硬件情况切换负载模式这种策略。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决思路：既然软件无法正常显示，是由于显卡模式的切换，导致依赖显卡硬件加速的应用无法显示，那么解决方法主要有两种：</p><p>方法一： 让显卡能检测到显示器。可以通过外接显示器并通电、让笔记本打开盖子、外接虚拟HDMI之类的负载（让显卡误以为我们外接了显示器）。<br>方法二： 若某个软件时因为依赖显卡硬件加速而导致无法显示，那么禁用该软件的显卡硬件加速功能即可。禁用显卡硬件加速方法又有两种思路：<br>禁用手段一：百度，不同软件有不同的禁用方法。（可能有的软件没提供禁用选项）<br>禁用手段二：在NVIDIA控制面板里指定禁用某个软件（个人猜测，没试过）</p><h1 id="其他解决方法"><a href="#其他解决方法" class="headerlink" title="其他解决方法"></a>其他解决方法</h1><p>搜索的时候还遇到过别人有其他情况，一一列举，</p><p>1.清除cache</p><p>2.重装对应版本unity（前提是就个别版本unity白屏）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;p&gt;根据网上搜索的结果，大致有两个原因：&lt;/p&gt;
&lt;p&gt;台式机没有外接显示器，或显示器处于关闭状态。&lt;br&gt;笔记本合上了盖子。&lt;/p&gt;
&lt;p&gt;根</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="ひめがみ絵巻" scheme="https://codingcodingk.github.io/tags/%E3%81%B2%E3%82%81%E3%81%8C%E3%81%BF%E7%B5%B5%E5%B7%BB/"/>
    
  </entry>
  
  <entry>
    <title>2D游戏中，角色预制体Image和Sprite怎么选择？</title>
    <link href="https://codingcodingk.github.io/Project/Unity/RPG/himegami/spriteOrImgFor2D/"/>
    <id>https://codingcodingk.github.io/Project/Unity/RPG/himegami/spriteOrImgFor2D/</id>
    <published>2023-04-10T14:54:00.921Z</published>
    <updated>2023-04-16T06:56:00.690Z</updated>
    
    <content type="html"><![CDATA[<p>选型的时候搜了一下，Sprite更优，本来决定用Image的这样方便UI血条什么跟随不需要自己单独写代码了，但是发现Image对于帧动画支持并不好，需要手动SetNativeSize，感觉不如Sprite。以下是抄来的：</p><p>1.首先分析下两者的异同。</p><p>使用上，两者区别不大，都是使用一个Sprite源进行渲染，而Image需要位于某个Canvas下才能显示出来。场景中的Sprite可以像普通的3D游戏物体一样对待，通过Transform组件进行移动等操作，而Image则使用RectTransform进行布局，以便通过Canvas统一管理。由于RectTransform可以设置大小、对齐方式等，Image可以说更加方便一点，这也是很多人选择使用Image的原因。</p><p>渲染上，Sprite使用SpriteRenderer组件渲染，而Image则由CanvasRenderer组件渲染。两者在视觉上没有任何区别（都使用默认材质时）。它们默认的渲染也都是在Transparent Geometry队列中。</p><p>而在引擎的处理上，两者则有很大的不同。将Wireframe选项打开然后在场景中观察，就可以清楚地发现，Image会老老实实地为一个矩形的Sprite生成两个三角形拼成的矩形几何体，而Sprite则会根据显示内容，裁剪掉元素中的大部分透明区域，最终生成的几何体可能会有比较复杂的顶点结构。</p><p>image</p><p>那么这种不同会造成什么结果呢？在继续之前，我们先回顾一下游戏中每帧的渲染过程。对任何物体的渲染，我们需要先准备好相关数据（顶点、UV、贴图数据和shader参数等等），然后调用GPU的渲染接口进行绘制，这个过程称作Draw Call。GPU接收到DrawCall指令后，通过一系列流程生成最终要显示的内容并进行渲染，其中大致的步骤包括：</p><p>CPU发送Draw Call指令给GPU；</p><p>GPU读取必要的数据到自己的显存；</p><p>GPU通过顶点着色器（vertex shader）等步骤将输入的几何体信息转化为像素点数据；</p><p>每个像素都通过片段着色器（fragment shader）处理后写入帧缓存；</p><p>当全部计算完成后，GPU将帧缓存内容显示在屏幕上。</p><p>通过上面的认知，我们可以推断：</p><p>Sprite由于顶点数据更加复杂，在第1/2步时会比Image效率更低；</p><p>Sprite会比Image执行较多的顶点着色器运算；</p><p>Image会比Sprite执行更多的片段着色器运算；</p><p>看起来似乎Image比Sprite有更大的好处，然而事实上，由于片段着色器是针对每个像素运算，Sprite通过增加顶点而裁剪掉的部分减少了相当多的运算次数，在绝大多数情况下，反而比Image拥有更好的效率 —— 尤其是场景中有大量的2D精灵时。</p><p><strong>总结一下，SpriteRenderer会创建额外的几何体来裁剪掉多余的透明像素区域，从而减少了大量的片段着色器运算，并降低了overdraw；而Image则会创建简单的矩形几何体。随着2D元素数量的增加，这种差别会慢慢明显起来。</strong></p><p>可以看出，SpriteRenderer确实是经过优化以显示更多的元素的。所以在2D游戏开发中，游戏场景中的元素，应该尽量使用它去渲染。而Image应该仅用于UI显示（实际上即使不考虑性能原因，由于屏幕分辨率的变化，Image可能会被Canvas改变显示位置和实际大小，如果用于游戏内元素的显示，可能会造成跟预期设计不一致的显示结果，也应该避免使用）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;选型的时候搜了一下，Sprite更优，本来决定用Image的这样方便UI血条什么跟随不需要自己单独写代码了，但是发现Image对于帧动画支持并不好，需要手动SetNativeSize，感觉不如Sprite。以下是抄来的：&lt;/p&gt;
&lt;p&gt;1.首先分析下两者的异同。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="ひめがみ絵巻" scheme="https://codingcodingk.github.io/tags/%E3%81%B2%E3%82%81%E3%81%8C%E3%81%BF%E7%B5%B5%E5%B7%BB/"/>
    
  </entry>
  
  <entry>
    <title>Unity中如何把RGB图和Alpha图分离的图片还原</title>
    <link href="https://codingcodingk.github.io/Project/Unity/RPG/himegami/himegami_before/"/>
    <id>https://codingcodingk.github.io/Project/Unity/RPG/himegami/himegami_before/</id>
    <published>2023-04-09T06:30:40.412Z</published>
    <updated>2023-04-10T14:54:51.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity中如何把RGB图和Alpha图分离的图片还原"><a href="#Unity中如何把RGB图和Alpha图分离的图片还原" class="headerlink" title="Unity中如何把RGB图和Alpha图分离的图片还原"></a>Unity中如何把RGB图和Alpha图分离的图片还原</h1><h2 id="一-RGB图、Alpha图简述"><a href="#一-RGB图、Alpha图简述" class="headerlink" title="一.RGB图、Alpha图简述"></a>一.RGB图、Alpha图简述</h2><h3 id="RGB图"><a href="#RGB图" class="headerlink" title="RGB图"></a>RGB图</h3><p>RGB图是指由红、绿、蓝三个基本色光按不同比例合成的图像，是最常见的彩色图像。RGB图像的每个像素点由三个通道的颜色值组成，通常用三元组（R,G,B）表示，其中R表示红色通道，G表示绿色通道，B表示蓝色通道，三个通道的值均为0-255之间的整数。</p><h3 id="Alpha图"><a href="#Alpha图" class="headerlink" title="Alpha图"></a>Alpha图</h3><p>Alpha图是指一种用于描述图像透明度的图像格式，通常用于PNG格式的图像中。Alpha图像的每个像素点也由一个通道的值表示，通常用A表示，取值范围为0-255，0表示完全透明，255表示完全不透明。</p><h2 id="二-为什么需要拆成2种图打包？"><a href="#二-为什么需要拆成2种图打包？" class="headerlink" title="二.为什么需要拆成2种图打包？"></a>二.为什么需要拆成2种图打包？</h2><h3 id="1-ETC不支持透明通道"><a href="#1-ETC不支持透明通道" class="headerlink" title="1.ETC不支持透明通道"></a>1.ETC不支持透明通道</h3><p>ETC是一种Unity支持的贴图压缩格式，用于安卓设备，不过目前不支持ETC2的已经少到可以忽略了。</p><ul><li>ETC：不支持透明通道，被所有 android 设备支持</li><li>ETC2：支持透明通道，Android 设备的 GPU 必须支持 OpenGL es 3.0 才可以使用，对于不支持的设备，会以未压缩的形式存在内存中，占用更多内存</li><li>PVRTC：所有苹果设备都可以使用，要求压缩纹理长宽相等，且是 2 的幂次（POT，Power of 2）</li><li>ASTC：高质量低内存占用，未来可能普遍使用的压缩格式，现在有一部分机型不支持</li></ul><h3 id="2-对ios机上内存占用与素材清晰度之间的平衡问题的一种优解"><a href="#2-对ios机上内存占用与素材清晰度之间的平衡问题的一种优解" class="headerlink" title="2.对ios机上内存占用与素材清晰度之间的平衡问题的一种优解"></a>2.对ios机上内存占用与素材清晰度之间的平衡问题的一种优解</h3><p>一般来说，目前 Unity 的手机游戏 android 上非透明贴图会使用 RGB Compressed ETC 4bits，透明贴图可以使用 RGBA Compressed ETC2 8bit，iOS 非透明贴图使用 RGB Compressed PVRTC 4bits，透明贴图使用 RGBA Compressed PVRTC 4bits。</p><p>这里的 bits 概念的意思为：每个像素占用的比特数，举个例子，RGB Compressed PVRTC 4bits 格式的 1024x1024 的贴图，其在内存中占用的大小 = 1024x1024x4 (比特) = 4M (比特) = 0.5M (字节)。</p><p>我们可以看到，在 iOS 上，非透明贴图和透明贴图都是 4bpp（4bits per pixel）的，多了透明通道还是一样的大小，自然 4bpp 的透明贴图压缩出来效果就会变差，而实机上看确实也是惨不忍睹。这是第一个问题的答案。</p><p>要解决上面图片模糊的问题，可以有这些做法：</p><ul><li>透明贴图不压缩，内存占用 32bpp</li><li>分离 alpha 通道，内存占用 4bpp+4bpp（或 4bpp+8bpp）</li></ul><p>显然第一种是不靠谱的， 32bpp 的内存消耗对于手机来说过大了。所以就需要拆分。</p><h2 id="三-如何还原"><a href="#三-如何还原" class="headerlink" title="三.如何还原"></a>三.如何还原</h2><p>我现在通过解包拿到的就是2张图，一张rpg图，一张alpha通道的图，带梯度（并不是01非黑即白图）。还原有2种方式，1是可以<a href="https://blog.csdn.net/qq_39738178/article/details/120023891">ps之类的将图片遮罩还原</a>，2是可以通过写shader，采样rgb图的rgb数值和aplha图的a数值，作为最终输出。这里只介绍第二种，我用的shader graph。</p><p>1.导入2张png，转成sprite，alpha图的 Alpha Source 设置为 From Gray Scale 。</p><p>2.写shader，并将shader绑到material上，注意 Surface Type 要选择 Transparent 模式，不然会被当做01图用。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20230409145504.png"></p><p>3.新建一个sprite2D，给配上材质就ok了，效果还是不错的</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20230409151528.png"></p><h2 id="四-如何拆分打包"><a href="#四-如何拆分打包" class="headerlink" title="四.如何拆分打包"></a>四.如何拆分打包</h2><p>如何拆分打包：<a href="https://www.gameres.com/872788.html">https://www.gameres.com/872788.html</a></p><h2 id="五-如何通过PS还原"><a href="#五-如何通过PS还原" class="headerlink" title="五.如何通过PS还原"></a>五.如何通过PS还原</h2><p>又回来补PS版本的了…因为解包下来游戏内容上千张图集，很多都甚至需要手动拆分成散图，实在是不想自己干，还是用PS还原png透明图交给别人吧。</p><p>1.把RGB图扔到ps里，点击“添加蒙版”。</p><p>2.在图层中选中“蒙版”，保持选中的状态下，点击“通道”，可以看到有“图层 蒙版”这个图层，把前面的眼睛点开。</p><p>3.去复制alpha图，粘贴到这个蒙版图层里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity中如何把RGB图和Alpha图分离的图片还原&quot;&gt;&lt;a href=&quot;#Unity中如何把RGB图和Alpha图分离的图片还原&quot; class=&quot;headerlink&quot; title=&quot;Unity中如何把RGB图和Alpha图分离的图片还原&quot;&gt;&lt;/a&gt;Unity</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="ひめがみ絵巻" scheme="https://codingcodingk.github.io/tags/%E3%81%B2%E3%82%81%E3%81%8C%E3%81%BF%E7%B5%B5%E5%B7%BB/"/>
    
  </entry>
  
  <entry>
    <title>TCP、UDP的区别</title>
    <link href="https://codingcodingk.github.io/Tech/Net/tcp_udp/"/>
    <id>https://codingcodingk.github.io/Tech/Net/tcp_udp/</id>
    <published>2022-08-12T13:40:36.334Z</published>
    <updated>2022-08-12T13:40:36.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是TCP、UDP"><a href="#什么是TCP、UDP" class="headerlink" title="什么是TCP、UDP"></a>什么是TCP、UDP</h1><p>协议，他们都只工作在传输层。</p><h1 id="什么是TCP的挥手、握手"><a href="#什么是TCP的挥手、握手" class="headerlink" title="什么是TCP的挥手、握手"></a>什么是TCP的挥手、握手</h1><p>三次握手、传输确认、四次挥手。</p><p><strong>三次握手：</strong>建立连接用的。客户端发起请求给服务端，服务端返回消息给客户端发番号，客户端再发送请求给服务端，完成连接的建立。</p><p>为什么需要第三步？为了<strong>解决网络信道不可靠问题</strong>。第一个请求包阻塞了，所以客户端重新再做了第一步成功建立了连接，此时之前的那个阻塞包又恢复了，此时如果没有第三步服务端就会成功建立第二个连接。</p><p><strong>传输确认：</strong>一包数据可能拆成多包发送，如何处理丢包问题？这些包的到达顺序不一定，如何处理乱序问题？答案是通过回复确认包。</p><p>这个根据下图模型理解。首先TCP会在建立连接之后，会创建如下的发送缓冲区。每次发送报文时，除了数据内容，还会在TCP协议头中附带本次数据内容的序列号（起始下标）+长度。接收端收到这个包后，会进行回复确认，内容为序列号+长度，也就是下一包的其实序列号。这样做是为了能够<strong>把整个包根据序列号和长度重组</strong>，中间遇到丢包的情况申请重发即可。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220811083837.png"></p><p><strong>四次挥手：</strong>结束连接用的。</p><p>一、二挥手：客户端发送结束包给服务端；服务端返回一个包表示自己进入终止等待状态。这前两次挥手完之后，服务端还可以给客户端发送之前未发完的数据，此时客户端还可以接收。也就是说这前两次是为了发送之前未发完数据。</p><p>三、四挥手：服务端发送完未完数据后，给客户端发送结束包，服务端进入最后确认状态；客户端收到后回复服务端一个确认包，客户端进入超时等待状态，超时后自动关闭连接。这最后一段等待是为了第四次挥手的确认包万一服务端没收到，服务端要求重发时客户端这还能响应。</p><h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><p>基于连接 与 基于非连接。</p><p>UDP不像TCP握手、确认、挥手，它是直接把数据包发过去的，所以占用资源少、速度快。</p><p>因此TCP稳定可靠，UDP速度快实时性强。</p><p>隧道网络：VPN等。// TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是TCP、UDP&quot;&gt;&lt;a href=&quot;#什么是TCP、UDP&quot; class=&quot;headerlink&quot; title=&quot;什么是TCP、UDP&quot;&gt;&lt;/a&gt;什么是TCP、UDP&lt;/h1&gt;&lt;p&gt;协议，他们都只工作在传输层。&lt;/p&gt;
&lt;h1 id=&quot;什么是TCP的挥手、握</summary>
      
    
    
    
    <category term="网络" scheme="https://codingcodingk.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="网络" scheme="https://codingcodingk.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：代码热更新</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/wolong_study/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/wolong_study/</id>
    <published>2022-08-12T13:40:36.330Z</published>
    <updated>2022-08-12T13:40:36.330Z</updated>
    
    <content type="html"><![CDATA[<p>非常感谢 HybridCLR(代号wolong) 的作者walon大佬。</p><h1 id="初识HybridCLR"><a href="#初识HybridCLR" class="headerlink" title="初识HybridCLR"></a>初识HybridCLR</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>能够不写lua，简直就是神。</p><p>HybridCLR ： <a href="https://github.com/focus-creative-games/hybridclr">github</a></p><p>HybridCLR li2cpp plus ： <a href="https://github.com/focus-creative-games/il2cpp_plus">github</a></p><p>HybridCLR示例项目 ： <a href="https://github.com/focus-creative-games/hybridclr_trial">github</a></p><p>手册：<a href="https://focus-creative-games.github.io/hybridclr">github.io</a></p><blockquote><p>HybridCLR 由两部分构成 <a href="https://github.com/focus-creative-games/il2cpp_plus">il2cpp_plus 仓库 (opens new window)</a>和 <a href="https://github.com/focus-creative-games/hybridclr">HybridCLR 仓库 (opens new window)</a>。il2cpp_plus 仓库基于 unity 原始 il2cpp 作了少量修改（几百行），使得它可以支持动态注册元数据，进行可以动态加载 dll。HybridCLR 仓库是 HybridCLR 的核心源代码。</p><p>HybridCLR的安装基于这两部分，安装有一定的<strong>版本规则</strong>。具体见<a href="https://focus-creative-games.github.io/hybridclr/support_versions/">支持的 Unity 版本</a>文档。</p></blockquote><h1 id="配置第一个Unity项目"><a href="#配置第一个Unity项目" class="headerlink" title="配置第一个Unity项目"></a>配置第一个Unity项目</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>Unity版本2020.3.7</p><ol><li>  拷贝<a href="https://github.com/focus-creative-games/il2cpp_plus">HybridCLR li2cpp plus</a>项目中的libil2cpp文件夹 到对应版本Editor的<code>Editor\Data\il2cpp</code>文件夹下，替换原先的libil2cpp文件夹。</li><li>  拷贝<a href="https://github.com/focus-creative-games/hybridclr">HybridCLR</a>中的huatuo文件夹 到对应版本Editor的<code>Editor\Data\il2cpp\libil2cpp</code>文件夹下。</li></ol><p>上面是老版本的安装方法，现在上面2步在示例中已经可以通过修改li2cpp的path来实现了，按照说明<strong>修改.bat、运行.bat</strong>即可自动从远端仓库拉取huatuo。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;非常感谢 HybridCLR(代号wolong) 的作者walon大佬。&lt;/p&gt;
&lt;h1 id=&quot;初识HybridCLR&quot;&gt;&lt;a href=&quot;#初识HybridCLR&quot; class=&quot;headerlink&quot; title=&quot;初识HybridCLR&quot;&gt;&lt;/a&gt;初识HybridC</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="热更新" scheme="https://codingcodingk.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法：查找与搜索</title>
    <link href="https://codingcodingk.github.io/Tech/Algorithm/search/"/>
    <id>https://codingcodingk.github.io/Tech/Algorithm/search/</id>
    <published>2022-06-29T12:18:40.296Z</published>
    <updated>2022-06-29T12:18:40.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p><strong>1.顺序查找</strong><br>        顺序遍历。</p><p><strong>2.二分查找</strong><br>        折半查找、二分查找，一个东西。对数据有要求，必须是按照关键字进行排序的。</p><p><strong>3.插值查找</strong><br>        在二分查找上做的优化。其实就是计算mid值不再是除以2，而是根据线性插值求出一个接近的数。对数据更高要求，不但得是顺序，还必须满足数值分布均匀。</p><p><strong>4.斐波那契查找</strong><br>        想在非均匀分布的数据中优化二分查找，就需要用到了。原理与黄金分割有关，从没见过暂时不看。</p><p><strong>5.分块查找</strong><br>        这个就是类似桶排序的行为，把数据分成多个区间块来查找。</p><p><strong>6.哈希查找</strong><br>        其实就是散列表。选一种哈希函数f，把数据的存储位置x和关键字y形成一种映射，然后查找关键字y时求出下标x即可（当然会有哈希碰撞问题要解决）。</p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深度优先-DFS"><a href="#深度优先-DFS" class="headerlink" title="深度优先 DFS"></a>深度优先 DFS</h2><p>属于图算法一种，是一个针对图和树的遍历算法。是盲目搜索算法。一般用堆+栈数据结构来辅助进行遍历，堆是要遍历的对象、栈内是路径结果。</p><p>搜索前先定义是先找左下子结点还是右下子结点。探索时会不停往下找，直到下方结点没有了，就开始往上一级。遍历期间，将遇到的结点入栈，如果遇到往上一级的情况，就把栈顶结点进行出栈。最后栈内会得到一条路径。</p><p>但注意，DFS终究是一种盲目搜索算法，并不是真正用来寻路的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220629121222.png"></p><h2 id="广度优先-BFS"><a href="#广度优先-BFS" class="headerlink" title="广度优先 BFS"></a>广度优先 BFS</h2><p>连通图的一种遍历算法。是盲目搜索算法。</p><p>一般用队列来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220629144906.png"></p><h2 id="爬山法-Hill-Climbing"><a href="#爬山法-Hill-Climbing" class="headerlink" title="爬山法 Hill Climbing"></a>爬山法 Hill Climbing</h2><p><a href="https://blog.csdn.net/qq_43285351/article/details/90926784">https://blog.csdn.net/qq_43285351/article/details/90926784</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://codingcodingk.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：常见排序</title>
    <link href="https://codingcodingk.github.io/Tech/Algorithm/sort/"/>
    <id>https://codingcodingk.github.io/Tech/Algorithm/sort/</id>
    <published>2022-06-28T15:23:18.461Z</published>
    <updated>2022-06-28T15:23:18.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>精简归纳：<a href="https://www.drflower.top/posts/6a923688/">https://www.drflower.top/posts/6a923688/</a></p><p>入门图解：</p><p><a href="https://blog.csdn.net/weixin_50651363/article/details/120070517">https://blog.csdn.net/weixin_50651363/article/details/120070517</a></p><p><a href="https://blog.csdn.net/kexuanxiu1163/article/details/103051357">https://blog.csdn.net/kexuanxiu1163/article/details/103051357</a></p><h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>我们先固定队尾。进行多次遍历，每一次遍历途中两两比较、两两交换，直到确定到最后1位。下一次还是从头开始遍历，但是之确定到倒数第2位…直到第1位为止。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bbsort.gif"></p><p>可以优化，如果某次遍历产生了0次交换，那么可以提前结束遍历。比如排序有序数组时，一次遍历就结束了。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>我们先固定队头。将队列分为2个部分，前面是排序完的部分、后面是待排序部分，每一次遍历都是去找待排序部分的最小值，放到排序完部分的队尾。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/xuanze_sort.gif"></p><p>Q:冒泡排序与选择排序哪个效率高？<br>A:两者时间复杂度都时候O(n)，但冒泡排序在内存循环交换，选择排序在外循环交换，一般而言选择排序效率更高。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>我们先固定队头。将队列分为2个部分，前面是即刻排序完的部分、后面是待排序部分，每一次遍历都是去待排序部分取第一个数字，保持插入后仍然有序地插入到前面的部分中。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/insertsort.gif"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的改进。选定一个整数增量序列：{a1,a2,…,1}，其中最大的a1&lt;=list.Count()，最小为1。</p><p>这里为了理解选取好1/2序列，也就是{count/2,count/4,…,1}。然后每隔count/2的数为一组进行排序，会分割成很多个内部不相邻的队列，分别对他们进行插入排序。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/shellsort.gif"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分治思想。简单来说就是，两两分组+指针。</p><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4.重复步骤 3 直到某一指针达到序列尾。</p><p>按上面的操作，进行递归，两两分组直至每一组都是1个数，不能再分为止。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/gbsort.gif"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>也是分治思想。简单来说就是，基准值+2个指针，让L指针左侧的数永远小于基准值、让R指针右侧的数永远大于基准值。</p><p>1.先选定一个基准值povit，然后放2个指针Left和Right到最左和最右。</p><p>2.对比L指针的值和povit，如果L小就是合理的，L指针右移，直至大于povit再停止；</p><p>3.当L指针停止后，开始移动R指针，如果R指向的值大就是合理的，R指针左移，直至小于povit再停止。</p><p>4.如果L和R都停止了，那么就将L、R指向的值互换，之后重启第2步继续右移L。</p><p>5.在2、3步中，如果发现L指针已经和R指针重合了，那么就证明本次分治下的排序结束。之后把L指针的值和povit的值进行交换就可以。</p><p>在上述完成后，最终结果会变成povit放在某个确定位置，而这个位置左侧的元素都小于povit，右边的元素都大于povit。所以这其实是在确定povit的最终位置。之后继续同样操作来排序povit左侧和右侧的2个队列，直至无可划分。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/quicksort.gif"></p><p>优化：1.想办法让povit取到中值（三数中值法）</p><p><a href="https://zhuanlan.zhihu.com/p/57436476">更细的步骤拆分和优化点</a></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>这个排序本身很简单，难点在于将堆用数组表现出来。所以分2部分说。</p><h3 id="用数组表示堆"><a href="#用数组表示堆" class="headerlink" title="用数组表示堆"></a>用数组表示堆</h3><ol><li>  堆：一个完全二叉树。完全二叉树就是从上到下、从左到右，直到最后一个结点为止，没有一个结点是空着的二叉树。</li><li>  大顶堆：一个堆，每个节点都能保证 父&gt;子。      小顶堆：一个堆，每个节点都能保证 父&lt;子。</li><li>  shift_down(结点k)：一个用来确定结点位置的方法。将结点k和它的2个孩子中的最大值做位置交换，然后让它继续和孩子比较，直至它比2个孩子都大。</li></ol><p>从堆的概念可以直到，你可以对堆从上到下、从左到右进行编号，编成0,1,2,…,n。这刚好对应着下标。而<strong>某个结点k的2个孩子，刚好对应结点2k+1、2k+2</strong>。</p><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>对数组化后的堆<code>H[0……n-1]</code>进行操作。</p><p>1.排出一个大顶堆；</p><p>2.把堆顶和堆尾交换，然后调用<code>shift_down(0)</code>来确保这还是一个大顶堆；</p><p>3.再把换到堆尾（也就是最大数）的那个数移除出堆，放到一个临时队列的尾部。堆结点数量-1。</p><p>重复1-3直至最后一个结点被移除。这个临时队列就是最终的排序结果。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/heapsort.gif"></p><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>外部排序是指内存中无法直接完成的大数据排序。是一种分治思想，当分到能在内存中排序的大小之后，再对其用内部排序。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>把数组遍历一遍，取出min和max值，将其范围划分为n个桶。桶内用内部排序排完之后，再把每个桶按顺序串起来。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bucketsort.gif"></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出序列中最大值和最小值，开辟Max-Min+1的辅助空间。<br>2.最小的数对应下标为0的位置，遇到一个数就给对应下标处的值+1。<br>3.遍历一遍辅助空间，就可以得到有序的一组序列。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/countsort.gif"></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>排序先把所有数字位数统一，不够的在前面用0补齐。</p><p>然后从后往前，一位一位的排，直至第一位。注意，放的时候先放，拿的时候也先拿，这样才能保持顺序，具体看动画吧。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/basesort.gif"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/O_1.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/O_2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;精简归纳：&lt;a href=&quot;https://www.drflower.top/posts/6a923688/&quot;&gt;https://www.dr</summary>
      
    
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://codingcodingk.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础：图论</title>
    <link href="https://codingcodingk.github.io/Tech/Algorithm/graph-1/"/>
    <id>https://codingcodingk.github.io/Tech/Algorithm/graph-1/</id>
    <published>2022-06-28T15:23:18.456Z</published>
    <updated>2022-06-28T15:23:18.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法基础" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="算法基础" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="图论" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 渲染管线、Shader、Texture</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-7/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-7/</id>
    <published>2022-06-25T05:13:48.938Z</published>
    <updated>2022-06-27T12:17:57.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h1><p>图形渲染管线 Graphics (Real-time Rendering) Pipeline</p><h2 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h2><p>前面学的流程串起来，就是下图。里面还涉及到了 <strong>Shader 和 Texture Mapping</strong> 的时机。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623160112.png"></p><h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><p>一般指 Shader Programs ，是一个程序，会<strong>对一个像素点/片段进行处理、着色</strong>。可以用OpenGL的语言写，也就是<strong>GLSL</strong>。</p><p>在线shader测试：<a href="http://shadertoy.com/view/ld3Gz2">http://shadertoy.com/view/ld3Gz2</a></p><p>shader展示：<a href="https://youtu.be/XuSnLbB1j6E">https://youtu.be/XuSnLbB1j6E</a></p><h1 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射 Texture Mapping"></a>纹理映射 Texture Mapping</h1><p>前面已经知道，每个像素点的漫反射系数kd乘以光照强度，会得到该像素点最终的颜色。显然，每个像素点的漫反射系数是由物体本身的<strong>颜色属性</strong>来决定的，而这个像素点的颜色属性我们会通过一张<strong>材质图</strong>来确定。这就是贴图。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623175805.png"></p><h2 id="uv"><a href="#uv" class="headerlink" title="uv"></a>uv</h2><p>uv坐标是指纹理展开后，纹理上的坐标。u和v的范围，都定义在0-1之内。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623182239.png"></p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>前面已经学了，三角面内进行插值着色，是用重心坐标来计算出任一个点对应的uv贴图坐标的（也就是决定漫反射系数k）。那么会出现什么问题？</p><h2 id="纹理拉伸-纹理图过小"><a href="#纹理拉伸-纹理图过小" class="headerlink" title="纹理拉伸(纹理图过小)"></a>纹理拉伸(纹理图过小)</h2><p>当纹理贴图太小了，多个像素点会映射到一个纹理点上去，看上去就像是拉伸了。纹理拉伸现象，可以通过**双线性插值 ** 来优化处理。</p><p><strong>双线性插值 Bilinear Interpolation</strong>：当一个像素点映射到uv贴图上后，取出相邻的3个uv贴图点，进行2次水平、1次竖直方向上的插值，求出这个点在4个uv贴图点中的插值平滑结果（漫反射系数）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220626224605.png"></p><h2 id="纹理拉伸-纹理图过大"><a href="#纹理拉伸-纹理图过大" class="headerlink" title="纹理拉伸(纹理图过大)"></a>纹理拉伸(纹理图过大)</h2><p>纹理图过大时，一个像素点的映射区域会覆盖很大的范围，但是一个像素点只能映射一个颜色。最终会走样，产生大量摩尔纹和锯齿。</p><p>如果不考虑性能，可以考虑超采样来获取平均值。但是考虑到性能，我们可以用<strong>MipMap</strong>。</p><p><strong>MipMaps</strong>：只能做近似的、正方形的 范围查询。</p><p>先将原图进行一半分辨率的裁剪（比如32x32=&gt;16x16），直到1x1。所有Mipmap大小之和为的原图1/3。</p><p><strong>1.如何计算需要的数量</strong>：映射出像素点对应uv的范围是几x几。</p><p><strong>2.如何查询某个中间值</strong>（比如1.8x1.8）：三线性插值。比如1.8x1.8，就是把2x2和1x1的2张mipmap结果值，再进行一次线性插值，求出1.8的值作为最终结果。</p><p>通过上面2步完成一个正确的Mipmap处理，最终可以得到一个像素点映射连续变化的uv贴图（也就是色彩会平滑、渐变过度）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220627113118.png"></p><p>上面说了只能做正方形的范围查询，那如果面对不同长宽比的情况（矩形）该怎么做来避免Overblur？</p><p><strong>各向异性过滤 Ripmaps</strong>：水平和竖直方向上的表现各不相同，不是1：1时，生成长宽拉伸后的图以提供矩形查询，处理长宽比不同的情况。最终额外的贴图大小是原图的3倍。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220627120903.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图形渲染管线&quot;&gt;&lt;a href=&quot;#图形渲染管线&quot; class=&quot;headerlink&quot; title=&quot;图形渲染管线&quot;&gt;&lt;/a&gt;图形渲染管线&lt;/h1&gt;&lt;p&gt;图形渲染管线 Graphics (Real-time Rendering) Pipeline&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 着色</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-6/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-6/</id>
    <published>2022-06-22T14:32:28.598Z</published>
    <updated>2022-06-26T14:22:00.553Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目前为止我们学会了什么？</strong></p><p>相机和物体 -&gt; 变换坐标到原点 -&gt; 拉伸后映射成2D图像 -&gt; 对2D图像进行光栅化：滤波、采样、后处理，最终变成屏幕上的像素点</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622162501.png"></p><p>现在我们引入<strong>着色</strong>。</p><h1 id="着色-Shading"><a href="#着色-Shading" class="headerlink" title="着色 Shading"></a>着色 Shading</h1><h2 id="什么是着色？"><a href="#什么是着色？" class="headerlink" title="什么是着色？"></a>什么是着色？</h2><p>着色在普世意义上，是对明暗、颜色进行绘制。</p><p>而在图形学中，<strong>着色是一个对物体应用材质的过程</strong>，正是材质的不同才导致颜色不同。</p><h2 id="理解一个简单的着色模型"><a href="#理解一个简单的着色模型" class="headerlink" title="理解一个简单的着色模型"></a>理解一个简单的着色模型</h2><p><strong>Blinn-Phong Reflectance Model</strong> 是一个常用参考的光照反射模型，它分为以下：</p><p><strong>高光 Specular highlights</strong>：一根光线打到光滑平面（比如镜面）上，会往镜面反射附近去反射。</p><p><strong>漫反射 Diffuse reflections</strong>：一根光线打到粗糙平面（比如墙面）上，被反射到各个地方的情况。图中茶杯从浅黄到深黄的变化。</p><p><strong>环境光照 Ambient lighting</strong>：是由间接光源组成的光源统称。图中光线并没有直接打到箭头处，而是打到桌面上被反射，反射光再打到了箭头处。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622163914.png"></p><h2 id="开始前先定义一个“着色点”-shading-point"><a href="#开始前先定义一个“着色点”-shading-point" class="headerlink" title="开始前先定义一个“着色点” shading point"></a>开始前先定义一个“着色点” shading point</h2><p>虽然反射到的面有曲面、有直面，但我们只观察一个最小的反射点，那么曲面的极小也可以当作<strong>直面</strong>。这个被观察的点我们叫做 <strong>shading point</strong> ，同时再定义几个其他的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622170625.png"></p><p>单位向量 v：和相机的连线。</p><p>单位向量 n：反射面的法线。</p><p>单位向量 l：光照方向。</p><p>表面参数：颜色 color、反射强度 shininess、…</p><p><strong>着色的局部性 shading is local：我们着色只关注光线照过来这个点该怎么着色。</strong>比如因为遮挡产生的阴影，着色器是不考虑的。</p><p>接下来我们根据定义好的观测点 shading point，来分析上面提到的3种反射情况。</p><h2 id="漫反射-Diffuse-reflections"><a href="#漫反射-Diffuse-reflections" class="headerlink" title="漫反射 Diffuse reflections"></a>漫反射 Diffuse reflections</h2><p>一根光线打到一个点上时，会被均匀反射到四周。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622173813.png"></p><p>通过观察就可以知道，着色点的法线n和光照打来的方向l的夹角θ，会和这个着色点接收到的光照能量成反比。而这个反比有一个推导，叫 <strong>朗伯余弦定理 Lambert’s cosine law</strong>。</p><p>朗伯余弦定理的推导中，将点光源发出的光的轨迹视作一个个圆球体，而根据能量守恒，只要在真空中传播没有发生损耗，这些圆球体上某点的能量和圆球体表面积（也就是半径平方r）成正比。</p><p>最终公式如下：<img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622182248.png"></p><p>从上面也能得知一件事，就是<strong>漫反射与观测方向v无关</strong> =&gt; 通俗点说就是某点被漫反射了，即使你在不同的位置看它，它的着色情况也是不变的。</p><p>公式里还有个系数kd，这是颜色系数，乘以漫反射光的强度（右边的值），得到最终显示的颜色。</p><h2 id="高光-Specular-Term"><a href="#高光-Specular-Term" class="headerlink" title="高光 Specular Term"></a>高光 Specular Term</h2><p><strong>高光与v有关。</strong>当你的观测角度v，和反射光的方向R一致或者接近的时候，你才能看到高光。</p><p>而观测角度v和反射光R的夹角有多大，又可以转化为更简单的计算：求l和v的中间向量，然后和法线n求夹角。 这一个计算转化算是优化了，计算R和v夹角的方式叫做Phong模型，而我们这种优化的方式叫做<strong>Blinn-Phong模型</strong>，推导过程和最终公式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623001727.png"></p><p>公式里还有一个问题，就是为什么要有一个<strong>P次方</strong>去处理cosα？原因是cos函数的容忍度太大了，导致非常大的夹角仍然能保持高光，这是不合理的，所以需要人为控制一下，一般P会采用256甚至以上，让夹角控制在3°以内。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623003907.png"></p><h2 id="环境光照-Ambient-Term"><a href="#环境光照-Ambient-Term" class="headerlink" title="环境光照 Ambient Term"></a>环境光照 Ambient Term</h2><p>环境光来自四面八方，与光照方向l和观测方向v都没有关系，是一个常数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623101513.png"></p><h2 id="最终3种光照"><a href="#最终3种光照" class="headerlink" title="最终3种光照"></a>最终3种光照</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623102155.png"></p><h1 id="着色频率-Shading-Frequencies"><a href="#着色频率-Shading-Frequencies" class="headerlink" title="着色频率 Shading Frequencies"></a>着色频率 Shading Frequencies</h1><p>下面介绍3种着色方式，对应着不同的着色频率。</p><h2 id="逐三角面着色-flat-shading"><a href="#逐三角面着色-flat-shading" class="headerlink" title="逐三角面着色 flat shading"></a>逐三角面着色 flat shading</h2><p>每个三角面着一次色。</p><h2 id="逐顶点着色-Gouraud-shading"><a href="#逐顶点着色-Gouraud-shading" class="headerlink" title="逐顶点着色 Gouraud shading"></a>逐顶点着色 Gouraud shading</h2><p>每个三角面的3个顶点进行着色，着色完后三角面进行内部<strong>插值</strong>着色。顶点的法线方向，是通过这个顶点周围所有的面的法线平均或者加权平均算出来的。</p><p>插值可以用<strong>重心坐标插值</strong>，但是需要用投影前的重心坐标，而不是投影拉伸到屏幕后的，因为深度不同。取到重心坐标之后可以转换为uv坐标，这样就能取到对应的着色系数了。之后再把系数带入漫反射公式，算出光照下该像素的最终颜色。</p><h2 id="逐像素着色-Phong-shading"><a href="#逐像素着色-Phong-shading" class="headerlink" title="逐像素着色 Phong shading"></a>逐像素着色 Phong shading</h2><p>在顶点插值完之后，对每个像素都进行单独计算着色。</p><h2 id="并不是频率越高越好"><a href="#并不是频率越高越好" class="headerlink" title="并不是频率越高越好"></a>并不是频率越高越好</h2><p>当面数比较多的时候，哪怕是逐三角面着色也会有很好的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623121534.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;目前为止我们学会了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相机和物体 -&amp;gt; 变换坐标到原点 -&amp;gt; 拉伸后映射成2D图像 -&amp;gt; 对2D图像进行光栅化：滤波、采样、后处理，最终变成屏幕上的像素点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:/</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 遮挡与深度</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-5/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-5/</id>
    <published>2022-06-22T14:32:28.594Z</published>
    <updated>2022-06-22T14:32:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>之前几节课学了怎么映射一个三角面到画面上，这节学多个三角面之间的遮挡关系处理，谁在前谁在后，也就是<strong>可见性</strong>怎么处理。</p><h1 id="实现遮挡关系"><a href="#实现遮挡关系" class="headerlink" title="实现遮挡关系"></a>实现遮挡关系</h1><h2 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h2><p>由远及近依次画（光栅化）。近的物体覆盖远的物体，就可以实现遮挡关系。</p><p>但是画家算法也存在一些问题，比如存在一些不可依赖深度排序解决的问题。所以不会直接用画家算法。</p><h2 id="深度缓存-Z-Buffer"><a href="#深度缓存-Z-Buffer" class="headerlink" title="深度缓存 Z-Buffer"></a>深度缓存 Z-Buffer</h2><p>这是工业界采用的算法。这里的z不是z轴，而是深度 depth，是摄像机位置到所求点的距离。</p><p>最后，只渲染每个像素上depth最浅的那个颜色。当物体发生运动后，会同步更新深度，有更小值出现就重新赋色。</p><p>深度缓存的复杂度是O(n)，而不是排序的O(nlogn)，因为深度缓存并不排序只求最小值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前几节课学了怎么映射一个三角面到画面上，这节学多个三角面之间的遮挡关系处理，谁在前谁在后，也就是&lt;strong&gt;可见性&lt;/strong&gt;怎么处理。&lt;/p&gt;
&lt;h1 id=&quot;实现遮挡关系&quot;&gt;&lt;a href=&quot;#实现遮挡关系&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 光栅化</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-4/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-4/</id>
    <published>2022-06-22T14:32:28.591Z</published>
    <updated>2022-06-22T14:32:28.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学之前你必须知道"><a href="#学之前你必须知道" class="headerlink" title="学之前你必须知道"></a>学之前你必须知道</h1><h2 id="视锥"><a href="#视锥" class="headerlink" title="视锥"></a>视锥</h2><p>这是透视相机的概念，用来衡量视距的大小。一般用2种属性来描述一个视锥：</p><ol><li>  near面的宽高比</li><li>  垂直视角 Vertical Field of View</li></ol><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621104507.png"></p><p>有了上面2个确定值，然后再自己定义一个near的值（近平面与相机的距离），就能确定成像了，视锥完成。</p><h2 id="屏幕上的概念"><a href="#屏幕上的概念" class="headerlink" title="屏幕上的概念"></a>屏幕上的概念</h2><p><strong>分辨率</strong>，也就是1080p、2k等，就是像素的多少。</p><p><strong>屏幕 Raster</strong>，德语中的屏幕的意思，而屏幕是一个光栅成像设备。</p><p><strong>光栅化 Rasterize</strong>，把东西画在屏幕上的过程。</p><p><strong>像素 Pixel</strong>，全名picture element，是最小单位的小正方形，它的颜色由Red、Green、Blue三个色(0~255)来混和成。</p><h2 id="屏幕发展过程"><a href="#屏幕发展过程" class="headerlink" title="屏幕发展过程"></a>屏幕发展过程</h2><p><strong>过去方式</strong></p><ol><li>  示波器</li><li>  阴极射线管 Cathode Ray Tube：和示波器原理相同，用很多电子打在屏幕上。通过扫描一样的方式，一条一条画横线，组成图像。</li></ol><p>隔行扫描 Raster Scan：上面的画横线，优化的话还会在一帧只画1、3、5…奇数行，下一帧再只画偶数行。这样省去了一半的工作量，也能一定程度欺骗到肉眼。</p><p><strong>现代方式</strong></p><ol><li>  液晶显示器 LCD（Liquid Crystal Display）：通过液晶扭曲光的方向，让其可以通过对应的光栅。</li><li>  控制发光二极管的显示器 LED（Light Emitting diode array）</li><li>  电墨水：通过电子控制只有黑、白像素的电墨水，实现电纸书的页面刷新。</li></ol><p>帧缓存技术 Frame Buffer（Memory for a Raster Display）：将显卡中的一块内存区域中，存储的内容反映到屏幕上。</p><h1 id="光栅化一个Cube"><a href="#光栅化一个Cube" class="headerlink" title="光栅化一个Cube"></a>光栅化一个Cube</h1><h2 id="视口变换-Viewport"><a href="#视口变换-Viewport" class="headerlink" title="视口变换 Viewport"></a>视口变换 Viewport</h2><p>光栅化之前要做的事。将一个 <code>[-1,1] x [-1,1]</code> 的2维平面，转换成<code>[width,0] x [0,height]</code>的笛卡尔坐标系内来表示。这叫做视口变换，看下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621115856.png"></p><p>最后算出，变换矩阵如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621121741.png"></p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>我们将原图形分解成很多个三角面，投影到屏幕的像素点上。</p><h3 id="首先，怎么判断一个像素点与三角形的位置关系？"><a href="#首先，怎么判断一个像素点与三角形的位置关系？" class="headerlink" title="首先，怎么判断一个像素点与三角形的位置关系？"></a>首先，怎么判断一个像素点与三角形的位置关系？</h3><p>靠前面的知识，已经可以做到任何一个点都确定性地投影到屏幕上了。</p><p>那么如果想判断一个像素点是否在一个三角面内呢？也就是问，<strong>如何确定这个像素的着色？</strong></p><p>可以通过判断这个像素点的中心点与三角形的位置关系来确定，为了方便，就定义一个判断函数<code>Inside()</code>。而这个函数就是进行3次叉积。</p><h3 id="然后，哪些像素点需要判断呢？"><a href="#然后，哪些像素点需要判断呢？" class="headerlink" title="然后，哪些像素点需要判断呢？"></a>然后，哪些像素点需要判断呢？</h3><p>如果需要把整个屏幕的点都进行一次<code>Inside()</code>判断，实在是没有必要，那么哪些需要、哪些不需要，这就涉及到<strong>包围盒</strong>了。</p><p>简单介绍一个AABB包围盒，它就是取三角面3个顶点的<code>Min(x), Min(y), Max(x), Max(y),</code>作为他的盒子。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621151747.png"></p><h3 id="最后，成像完有锯齿-Jaggies-怎么解决？"><a href="#最后，成像完有锯齿-Jaggies-怎么解决？" class="headerlink" title="最后，成像完有锯齿 (Jaggies) 怎么解决？"></a>最后，成像完有锯齿 (Jaggies) 怎么解决？</h3><p>又叫做反走样（Aliasing ）、抗锯齿。</p><p>在解决之前先理解为什么会有这类问题？取哪些像素点来表示这个三角面，叫做<strong>采样（Sample）</strong>。而采样会有3种<strong>瑕疵（Artifacts）</strong></p><ol><li>  锯齿 Jaggies</li><li>  摩尔纹 Moire</li><li>  运动速度过快 Wagon wheel effect</li></ol><p>产生原因是信号变化的速度太快，而采样速度跟不上了。</p><p><strong>那么怎么抗锯齿？</strong></p><p>可以对三角面做预处理，比如滤波、模糊，之后再进行采样。</p><h1 id="抗锯齿-Anti-Aliasing"><a href="#抗锯齿-Anti-Aliasing" class="headerlink" title="抗锯齿 Anti-Aliasing"></a>抗锯齿 Anti-Aliasing</h1><p>前面了解了为什么会产生锯齿，以及大致的抗锯齿技术（滤波、模糊）。这里细说。</p><p><strong>频域 Frequency Domain</strong>：描述信号在频率方面特性时用到的一种坐标系。想象一下cos2Π的图。</p><p><strong>滤波 Filtering</strong>：把某个时段内，特殊的频率给过滤掉。</p><p><strong>傅里叶变换</strong>：变幻的具体内容不要深究，只要知道，可以通过傅里叶变换把一张图变换为频域图，这样就能知道哪些地方的信号量多、少。中心定义为低频、周围定义为高频。最后，得到的频域图，是可逆的！</p><p>// TODO 下面的都只简单理解，更为深入要去学习 数字图像处理</p><h2 id="先傅里叶变换，再过滤一张图-FFP"><a href="#先傅里叶变换，再过滤一张图-FFP" class="headerlink" title="先傅里叶变换，再过滤一张图 FFP"></a>先傅里叶变换，再过滤一张图 FFP</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621180700.png"></p><p>中心定义为低频、周围定义为高频。当颜色变化差异巨大的时候（比如人物边缘），会产生高频信息。</p><p>为什么会有十字线？没有学过信号学不能看懂这张频谱图，只能理解为傅里叶变换前会把这一张图复制很多份拼起来，来取样。拼起来之后每张图的4个边的边界之间的信息差异巨大，就有巨大的高频信息，而这十字线的高亮就是边界的映射。</p><h3 id="高通率波"><a href="#高通率波" class="headerlink" title="高通率波"></a>高通率波</h3><p>High-pass，就是只有高频能通过，低频直接忽略的滤波方式。可以看到，逆变换回来的图几乎只保留了边界信息（人物描边），这是因为<strong>边界处的信号量差异很大，这就是高频的信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182236.png"></p><h3 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h3><p>滤掉高频，也就是滤掉边界信息，那么就会像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182524.png"></p><h3 id="高低滤波"><a href="#高低滤波" class="headerlink" title="高低滤波"></a>高低滤波</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622105657.png"></p><h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><p>只简单概述结论：</p><p>在空间域中，对一张图进行卷积滤波 = 对一张图进行傅里叶变换、再对其乘以卷积核的傅里叶变换、最后逆傅里叶变换回去</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622111008.png"></p><h1 id="采样-Sample"><a href="#采样-Sample" class="headerlink" title="采样 Sample"></a>采样 Sample</h1><p>稀疏采样会产生更多混叠，导致走样；密集采样更少混叠，所以映射结果更好一些。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622114336.png"></p><h2 id="怎么较少走样，也就是如何反走样？"><a href="#怎么较少走样，也就是如何反走样？" class="headerlink" title="怎么较少走样，也就是如何反走样？"></a>怎么较少走样，也就是如何反走样？</h2><p>本质上，就是想办法增大傅里叶副本之间的距离来减少混叠。</p><p><strong>1.增加采样率</strong>（更高分辨率的屏幕）</p><p><strong>2.抗锯齿</strong>，通过对图像模糊预处理（使用傅里叶来低通滤波）再采样</p><h2 id="常规采样流程"><a href="#常规采样流程" class="headerlink" title="常规采样流程"></a>常规采样流程</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622115530.png"></p><p>先用低通滤波器模糊原图，然后再采样。</p><h3 id="抗锯齿：模糊操作"><a href="#抗锯齿：模糊操作" class="headerlink" title="抗锯齿：模糊操作"></a>抗锯齿：模糊操作</h3><p>取像素颜色时，根据三角面的在该像素块中覆盖的面积，来设置灰度。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622120331.png"></p><p>这个理论很简单，但是实现比较困难，于是采用一种类似的方法，对一个像素块再进行划分、进行更多的采样，也就是**多重采样抗锯齿 MSAA (MultiSampling Anti-Aliasing) **来实现。</p><p>下图就是一个MSAA的例子：把一个像素格分成了2x2，来确定0%、25%、50%、75%、100%。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622121659.png"></p><p>工业界会优化，想要2x2的效果不会这么单纯的分割成4个正方形，而是一些其他不规则图形，甚至可能多个像素块复用一个点，这么做都是为了减少需要检测的点数量。</p><h3 id="其他抗锯齿方法"><a href="#其他抗锯齿方法" class="headerlink" title="其他抗锯齿方法"></a>其他抗锯齿方法</h3><p>FXAA（Fast Approximate AA）：快速近似抗锯齿，是一种后处理，会对有锯齿的地方进行修正。</p><p>TAA（Temporal AA）：利用时间而不是空间采样，对于静止的连续帧，上一帧有效的采样点才继续采样。</p><p>DLSS（DeepLearning SuperSimple）：当低分辨率拉伸成高分辨率时，会有很多锯齿，此时用深度学习来猜测描绘。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学之前你必须知道&quot;&gt;&lt;a href=&quot;#学之前你必须知道&quot; class=&quot;headerlink&quot; title=&quot;学之前你必须知道&quot;&gt;&lt;/a&gt;学之前你必须知道&lt;/h1&gt;&lt;h2 id=&quot;视锥&quot;&gt;&lt;a href=&quot;#视锥&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - MVP变换</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-3/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-3/</id>
    <published>2022-06-17T01:51:05.738Z</published>
    <updated>2022-06-22T14:32:28.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从三维旋转到欧拉角"><a href="#从三维旋转到欧拉角" class="headerlink" title="从三维旋转到欧拉角"></a>从三维旋转到欧拉角</h1><p>首先三维旋转绕某个轴旋转，已经知道是这样的了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p><p>那么就可以通过对3个轴的旋转分别描述，来实现复杂的旋转角。这3个旋转角就叫做欧拉角。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620123437.png"></p><h1 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h1><p>一个公式，来实现绕轴n旋转α角度。轴n的定义为起点为原点，方向为n。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620141702.png"></p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>// TODO</p><h1 id="四元数的引入"><a href="#四元数的引入" class="headerlink" title="四元数的引入"></a>四元数的引入</h1><p>由于用旋转矩阵来做<strong>平滑插值</strong>并不合理（旋转20°矩阵 和 旋转50°矩阵 的平均值并不是旋转35°），并且存在<strong>万向锁</strong>问题，所以引入四元数。games101不展开。</p><h1 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h1><p>Model-View-Projection 模型-视图-投影变换：将3D的模型（Model）投影到2D的屏幕（View）上。</p><p>先定义相机的 <strong>位置 Position、朝向 Look-at、向上方向 Up direction</strong>（与朝向垂直，用于确定相机本身的旋转角）。</p><p>视图结果是相对不变的，当物体和相机的移动方式完全一致、没有相对运动时，成像不变。</p><h2 id="标准相机"><a href="#标准相机" class="headerlink" title="标准相机"></a>标准相机</h2><p>我们定义一个Position在 原点，Look-at在 -Z，Up direction在 Y的相机作为默认相机。</p><p>以后就可以将其他相机移成标准相机、然后再做变换、最后移回就实现了相机旋转。</p><h2 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影 Projection"></a>投影 Projection</h2><p>投影是说3D转到2D屏幕的过程。首先分2种，<strong>正交投影</strong>和<strong>透视投影 Perspective</strong>。</p><p>正交不会有近大远小、每个平行边也不会有交点，但透视都会有。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620161157.png"></p><h2 id="正交投影-Orthographic"><a href="#正交投影-Orthographic" class="headerlink" title="正交投影 Orthographic"></a>正交投影 Orthographic</h2><p>定义6个点，就可以描述一个3维的长方体：</p><p>x轴：left =&gt; right ；y轴：buttom =&gt; top ；<font color="red">z轴：fear =&gt; near</font> 。</p><p>注意z轴，因为上面所有的<code>=&gt;</code>指的都是右手坐标系的负=&gt;正，near离我们更近、被定义为正值。</p><p>OpenGL用的是左手坐标系，全部相反。</p><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620182401.png"></p><p>上图的过程就是标准化，也就是将一个长方体变成一个中心点为原点，6个点为-1、1的正方体。标准化的好处是能够更好做正交相机的投影。</p><p>标准化的变换矩阵如下，将长度定为2是为了满足(-1,1)。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620184611.png"></p><h2 id="透视投影-Perspective"><a href="#透视投影-Perspective" class="headerlink" title="透视投影 Perspective"></a>透视投影 Perspective</h2><p>近大远小、平行线会相交。这是因为不同平面内的线投影到一个平面，会有交点。</p><h3 id="齐次坐标性质"><a href="#齐次坐标性质" class="headerlink" title="齐次坐标性质"></a>齐次坐标性质</h3><p>(x,y,z,1) 和 (kx,ky,kz,k) 表示的是同一个点。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620190109.png"></p><h3 id="透视投影拆分⭐"><a href="#透视投影拆分⭐" class="headerlink" title="透视投影拆分⭐"></a>透视投影拆分⭐</h3><p>要实现一个透视投影变换，拆成2步：1.将透视投影相机视锥，挤成一个长方体（正交相机视锥）；2.将得到的长方体进行正交投影。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620225451.png"></p><p>第二步的做法已经在正交投影里写了，那么关键就是第一步怎么做，其实就是乘以一个 <strong>透视=&gt;正交 的拉伸矩阵M</strong>。</p><p>这个矩阵M（4x4）的推导如下：</p><p>1.近似三角形可推导出除了第三行以外的所有矩阵</p><p>2.性质：近平面点挤压后，点坐标的x,y,z都不变（相机的近平面，就是最终2d屏幕的大小）</p><p>3.性质：远平面点挤压后，点坐标的z不变（z轴是深度，想象一下拉伸后，远平面的深度不会变）</p><p>4.根据性质2、3可以推导出矩阵的第三行</p><p>具体推导看第四章的PPT p29-36吧，这里把主要的近似三角形概念图放下来，结合上面的拉伸概念图可以自己推导了：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620235549.png"></p><p>最后4x4的透视=&gt;正交 的拉伸矩阵M：</p><p>n    0    0    0<br>0    n    0    0<br>0    0    n+f    -nf<br>0    0    1    0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从三维旋转到欧拉角&quot;&gt;&lt;a href=&quot;#从三维旋转到欧拉角&quot; class=&quot;headerlink&quot; title=&quot;从三维旋转到欧拉角&quot;&gt;&lt;/a&gt;从三维旋转到欧拉角&lt;/h1&gt;&lt;p&gt;首先三维旋转绕某个轴旋转，已经知道是这样的了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 矩阵变换入门</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-2/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-2/</id>
    <published>2022-06-17T01:51:05.735Z</published>
    <updated>2022-06-22T15:51:07.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量 Vector"></a>向量 Vector</h1><h2 id="小概念"><a href="#小概念" class="headerlink" title="小概念"></a>小概念</h2><p>数学上叫做向量，物理上喜欢称作矢量。</p><p>向量的模 Magnitude。</p><p>向量的归一化，意味着求单位向量 unit Vector。</p><h2 id="向量矩阵"><a href="#向量矩阵" class="headerlink" title="向量矩阵"></a>向量矩阵</h2><p>下面是在表示笛卡尔坐标系x-y下的某个向量，可以用矩阵来表示向量。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220615180557.png"></p><h2 id="点乘-Dot"><a href="#点乘-Dot" class="headerlink" title="点乘 Dot"></a>点乘 Dot</h2><p>满足交换律、结合律、分配律。</p><p>结果是一个数值，可以用来检测2个向量的夹角，&lt;90度为正，90度为0，90~180度为负。</p><h2 id="叉乘-Cross"><a href="#叉乘-Cross" class="headerlink" title="叉乘 Cross"></a>叉乘 Cross</h2><p>不满足交换律！向量A x 向量B = -向量B x 向量A</p><p>结果是一个向量，这个向量是与A、B向量所组成平面的垂直向量，也就是说A、B、C向量构成一个右手直角坐标系。<strong>而法线的方向，满足右手螺旋。注意a在前所以a是食指</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620122459.png"></p><p><strong>图形学上，</strong>用来检测某个点是否在一个多边形（比如三角形）内。</p><p>因为 向量AB x 向量AP 的结果大于0则说明P在AB左侧，小于0则说明P在AB右侧。</p><p>所以一个三角面ABC和一个点P，只要通过3次叉乘的结果（都大于0或者都小于0），就能判断出点P在三角面ABC中。这是光栅化的基础，用于着色判断。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616105243.png"></p><h1 id="矩阵变换：线性变换"><a href="#矩阵变换：线性变换" class="headerlink" title="矩阵变换：线性变换"></a>矩阵变换：线性变换</h1><p>关键是，要找出变换前后每一个点之间的变化关系式。矩阵的乘法是不满足交换律的。</p><h2 id="缩放-Sacle"><a href="#缩放-Sacle" class="headerlink" title="缩放 Sacle"></a>缩放 Sacle</h2><p>可以使用对角阵*向量来进行缩放，这个对角阵叫缩放矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616114924.png"></p><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h2><p>用于翻折的单位矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616115506.png"></p><h2 id="切变-Shear"><a href="#切变-Shear" class="headerlink" title="切变 Shear"></a>切变 Shear</h2><p>要找出每一个点之间的变化关系式。</p><p>比如下图情况，只是水平方向的点发生了变化，竖直方向的不变。水平方向上的每个点发生了a / 1 * y的平移。那么久可以很容易写出切变矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616120005.png"></p><h2 id="旋转-Rotate"><a href="#旋转-Rotate" class="headerlink" title="旋转 Rotate"></a>旋转 Rotate</h2><p>二维情况下，逆时针旋转θ角：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151759.png"></p><p>推导过程（只展示A、C。B、D的话由点0,1可以推出）如下，其实只是展开了点(1,0)的偏移等式。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151646.png"></p><p>再进一步探究可知，<strong>逆旋转矩阵 = 将原旋转矩阵转置</strong>。这意味着想要旋转一个负角度，只要求出正角度的旋转矩阵再转置就可以得到旋转矩阵了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620113534.png"></p><h2 id="统称：线性变换"><a href="#统称：线性变换" class="headerlink" title="统称：线性变换"></a>统称：线性变换</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616165650.png"></p><h1 id="矩阵变换：非线性变换"><a href="#矩阵变换：非线性变换" class="headerlink" title="矩阵变换：非线性变换"></a>矩阵变换：非线性变换</h1><h2 id="平移-Translation"><a href="#平移-Translation" class="headerlink" title="平移 Translation"></a>平移 Translation</h2><p>平移比较特殊，它不能通过2阶矩阵<strong>线性变换</strong>（矩阵乘法）得出。因为矩阵乘法你只能得到ax+by的结果，没法出现常数c，所以只能靠加法。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616170433.png"></p><h2 id="平移解决方案：更高1阶的矩阵"><a href="#平移解决方案：更高1阶的矩阵" class="headerlink" title="平移解决方案：更高1阶的矩阵"></a>平移解决方案：更高1阶的矩阵</h2><p>平移必须涉及到同阶矩阵的加法，没法直接用线性变换了。为了在这种情况下也能只使用矩阵乘法就达到变换的目的，可以使用2+1阶的矩阵。多出来的矩阵值，点是1、向量是0。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616175212.png"></p><p><strong>将二维的点，最后一个矩阵值写为1。</strong>如果不是1，那么就看作x =&gt; x/w、y =&gt; y/w。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616184017.png"></p><p>那么最后，给出2维 向量、点 的变化矩阵：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616185009.png"></p><h2 id="逆变换-Inverse"><a href="#逆变换-Inverse" class="headerlink" title="逆变换 Inverse"></a>逆变换 Inverse</h2><p>通过使用逆矩阵，可以撤回变换。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616190117.png"></p><h1 id="组合的矩阵变换"><a href="#组合的矩阵变换" class="headerlink" title="组合的矩阵变换"></a>组合的矩阵变换</h1><p>先旋转，后平移。否则会出错，因为矩阵乘法没有交换律！</p><p>那么通过矩阵乘法表示线性变换、矩阵平移的时候，就是从右到左一个个乘。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620101520.png"></p><p><strong>虽然没有交换律，但是有结合律</strong>，可以让前面的变换矩阵合成为一个：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102212.png"></p><h1 id="分解复杂的矩阵变换"><a href="#分解复杂的矩阵变换" class="headerlink" title="分解复杂的矩阵变换"></a>分解复杂的矩阵变换</h1><p>对于一个复杂的矩阵变换（线性变换+平移变换），需要分解为几步，才能通过矩阵乘法来实现。</p><h2 id="绕某点旋转"><a href="#绕某点旋转" class="headerlink" title="绕某点旋转"></a>绕某点旋转</h2><p>将c移到原点 =&gt; 绕原点旋转 =&gt; 移回原来</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102642.png"></p><h1 id="由二维引申到三维"><a href="#由二维引申到三维" class="headerlink" title="由二维引申到三维"></a>由二维引申到三维</h1><p>上面讨论的都是二维，转到三维空间，其实也是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620103459.png"></p><h2 id="三维缩放、平移"><a href="#三维缩放、平移" class="headerlink" title="三维缩放、平移"></a>三维缩放、平移</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115450.png"></p><h2 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h2><p>绕某个轴旋转，该轴上的点位置不变。</p><p>至于为什么y和x、z轴旋转不一样，详细参考叉乘的<strong>右手螺旋定则</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;向量-Vector&quot;&gt;&lt;a href=&quot;#向量-Vector&quot; class=&quot;headerlink&quot; title=&quot;向量 Vector&quot;&gt;&lt;/a&gt;向量 Vector&lt;/h1&gt;&lt;h2 id=&quot;小概念&quot;&gt;&lt;a href=&quot;#小概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
</feed>
