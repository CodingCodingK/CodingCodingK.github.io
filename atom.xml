<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2022-03-29T06:06:33.516Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UGUI学习 - Graphic</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_5/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_5/</id>
    <published>2022-03-28T14:28:54.982Z</published>
    <updated>2022-03-29T06:06:33.516Z</updated>
    
    <content type="html"><![CDATA[<p>学习博客：<br><a href="https://blog.csdn.net/qq_28820675/article/details/106245195">https://blog.csdn.net/qq_28820675/article/details/106245195</a></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220329134659.png"></p><h1 id="Graphic"><a href="#Graphic" class="headerlink" title="Graphic"></a>Graphic</h1><p>图形组件的基类，基础中的基础组件</p><p>Graphic 作为图像组件的基类，主要实现了网格与图像的生成/刷新方法。<br><strong>层级/颜色/材质</strong>改变时都会进行相应的刷新（重建）。重建过程主要通过 CanvasUpdateSystem 最终被Canvas所重新渲染。</p><p>重建主要分为两个部分：<strong>顶点重建（UpdateGeometry）与 材质重建（UpdateMaterial）</strong>。更新完成的结果会设置进CanvasRenderer，从而被渲染形成图像。</p><h2 id="重建流程"><a href="#重建流程" class="headerlink" title="重建流程"></a>重建流程</h2><p>GraphicRegistry管理同Canvas下的所有Graphic对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;Canvas, IndexedSet&lt;Graphic&gt;&gt; m_Graphics;</span><br></pre></td></tr></table></figure><p>Graphic 初始化时（Enable）会寻找其最近根节点的<strong>Canvas</strong>组件，并以此为key存储在<strong>GraphicRegistry</strong>中。</p><h3 id="1-顶点（网格）更新与生成"><a href="#1-顶点（网格）更新与生成" class="headerlink" title="1.顶点（网格）更新与生成"></a>1.顶点（网格）更新与生成</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习博客：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/106245195&quot;&gt;https://blog.csdn.net/qq_28820675/article/details/10624519</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - LayoutSystem布局系统</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_4/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_4/</id>
    <published>2022-03-25T12:02:18.563Z</published>
    <updated>2022-03-29T05:44:10.095Z</updated>
    
    <content type="html"><![CDATA[<p>学习博客：<br><a href="https://blog.csdn.net/qq_28820675/article/details/106245195">https://blog.csdn.net/qq_28820675/article/details/106245195</a></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328144810.png"></p><blockquote><p> CanvasUpdateSystem中更新布局的具体实现系统。</p></blockquote><h1 id="布局-LayoutSystem"><a href="#布局-LayoutSystem" class="headerlink" title="布局 LayoutSystem"></a>布局 LayoutSystem</h1><p>也就是上一篇中说的 Canvas刷新系统 中，重建得2个数组之一<strong>Layout数组</strong>是怎么来的、又是怎么重建得。</p><h2 id="什么时候标记"><a href="#什么时候标记" class="headerlink" title="什么时候标记"></a>什么时候标记</h2><p>也是用脏标记。时机一般为尺寸改变时（RectTransform Dimensions）。</p><h2 id="标记后干什么"><a href="#标记后干什么" class="headerlink" title="标记后干什么"></a>标记后干什么</h2><p>UGUI组件（如Graphic、ScrollRect…）在需要布局处理时（也就是被标记或OnDisable时），会把自身的RectTransform组件用LayoutRebuilder对象包装，之后加入<strong>Layout数组</strong>。</p><h2 id="重建布局"><a href="#重建布局" class="headerlink" title="重建布局"></a>重建布局</h2><p>这个的执行时机，在画布刷新系统那篇里有细写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CanvasUpdateSystem触发重建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (executing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.Layout:</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputHorizontal());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutHorizontal());</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputVertical());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutVertical());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="布局组件-LayoutGroup"><a href="#布局组件-LayoutGroup" class="headerlink" title="布局组件 LayoutGroup"></a>布局组件 LayoutGroup</h1><p>经过对LayoutSystem、LayoutRebuilder的分析，布局接口的触发规则已经被摸清楚了。</p><p>虽然UGUI组件中有一些组件都继承了ILayoutElement接口（例如：Image,Text,ScrollRect,InputField），但它们并不会涉及对接口方法的实现。这是因为这些组件主要是布局操作的接收方，只需要通过该接口被布局实施方所发现即可。而UGUI中负责这些接收物体的布局设置功能主要是由LayoutGroup衍生的子类组件来完成。</p><blockquote><p><strong>LayoutGroup</strong>，是布局组件的基类（GridLayoutGroup、HorizontalOrVerticalLayoutGroup）。先对纵横布局组件（HorizontalLayoutGroup、VerticalLayoutGroup）进行分析。</p></blockquote><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328212851.png"></p><p>Padding：内部边距，调整实际用于布局区域的大小<br>Spacing ：子物体直接的间隔<br>Child Alignment ：子物体对齐方式<br>Child Controls Size ：组件控制子物体尺寸开关，开启时组件可以更改物体尺寸。<br>Child Force Expand ：组件控制子物体填充区域开关，若可以修改尺寸则会改变子物体尺寸填充区域，若不可以修改尺寸，则根据区域大小均衡分布子物体。</p><h2 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h2><p>以HorizontalLayoutGroup为例。</p><p>1.对该GameObject下所有子物体（只做一次GetChild）进行遍历，获取其子节点下所有没有被标记<strong>ignoreLayout</strong>的物体。放到一个List中。</p><p>2.对List中的每一个Cell都进行尺寸与位置的计算。然后设置其属性。</p><h1 id="ContentSizeFitter"><a href="#ContentSizeFitter" class="headerlink" title="ContentSizeFitter"></a>ContentSizeFitter</h1><p>布局系统中尺寸调节组件。</p><p><strong>ContentSizeFitter</strong>，是用于调整组件区域使其自适的组件，一般用于与ScrollRect滑动列表以及纵横布局组件搭配，实现动态数量的滑动列表效果，以及与Text组件一起使用，可以根据文字长短进行区域尺寸的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习博客：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/106245195&quot;&gt;https://blog.csdn.net/qq_28820675/article/details/10624519</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - 画布刷新系统</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_3/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_3/</id>
    <published>2022-03-25T12:02:18.562Z</published>
    <updated>2022-03-28T13:02:49.251Z</updated>
    
    <content type="html"><![CDATA[<p>学习博客：</p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105746002">https://blog.csdn.net/qq_28820675/article/details/105746002</a></p><p><a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">https://blog.csdn.net/gaojinjingg/article/details/103565840</a></p><p><img src="https://img-blog.csdnimg.cn/20200425104339184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODIwNjc1,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>由Canvas控制，通过 ICanvasElement 接口，使用脏标记方法来统一更新CanvasElement</p></blockquote><h1 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h1><p>摘自<a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">大佬博客</a>。</p><ul><li>   <strong>Canvas</strong>， 是Unity渲染系统给层状几何体( layered geometry )提供的可以被画入、被放在上面或者放在世界空间的底层Unity组件。Canvas负责将它包含的几何体组合成batch，生成合适的渲染命令发送给Unity图形系统。这个过程在底层的C++代码中完成，这个过程被称为一次rebatch或者一次batch build。当一个Canvas被标记为包含需要rebatch的几何体时，这个Canvas被认为是dirty的。</li><li>   <strong>layered geometry</strong> , 由Canvas Renderer组件提供给Canvas。[ Canvas 负责进行渲染, Canvas Renderer负责采集/接收. ]</li><li>   **动静隔离 **, 一个子Canvas仅仅是一个嵌套在父Canvas中的组件，子Canvas将它的子物体和它的父Canvas隔离，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild，反之亦然。（这些在某些特殊情况下是不确定的，比如说改变父Canvas的大小导致子Canvas的大小改变。）</li><li>   <strong>Graphic</strong> , 是UGUI的C#库提供的一个基类。它是UGUI所有类的基类，给所有的UGUI类提供可以画在Canvas系统上的几何图形。大多数Unity内置的继承Graphic的类都是通过继承一个叫MaskableGraphic的子类来实现，这使得他们可以通过IMaskable接口来被隐藏。Drawable类的子类主要是image和text，已经提供了同名的组件。</li><li>  <strong>Layout</strong> , 组件控制着RectTransform的大小和位置，经常被用于要生成具有相似的大小和位置关系内容的复杂布局。它只依靠RectTransform，只影响与其相关的RectTransform的属性。这些layout组件不依赖于Graphic类，可以独立于UGUI的Graphic组件之外使用。</li><li>  <strong>CanvasUpdateRegistry</strong> , Graphic和Layout组件都依赖于CanvasUpdateRegistry类，它不会在Unity编辑器的界面中显示。这个类追踪那些Graphic和Layout组件必须被更新的时候，还有与其对应的Canvas触发了willRenderCanvases事件的时候。更新Graphic类和Layout类叫做rebuild。</li><li> <strong>Rebuild</strong> , 过程是指Layout和UGUI的C#的Graphic组件的网格被重新计算，这是在CanvasUpdateRegistry类中执行的。这是一个C＃类，它的源码可以在Unity的Bitbucket上找到。<br>   <strong>CanvasUpdateRegistry</strong> , 类中，PerformUpdate方法，当一个Canvas组件触发它的WillRenderCanvases事件时，这个方法就会被执行。这个事件每帧调用一次。<br>   <strong>PerformUpdate</strong> , 函数运行的三个步骤：<br>   1- 通过ICanvasElement.Rebuild函数，请求rebuild被Dirty的Layout组件。<br>   2- 所有被注册的裁剪组件（例如Mask），对需要被裁剪的组件进行剔除。这在ClippingRegistry.Cull中执行。<br>   3- dirty的Graphic组件被要求rebuild其图形元素。</li><li>   <strong>Layout Rebuild</strong> , 要重新计算一个或者多个Layout组件所包含的UI组件的适当位置（以及可能的大小），有必要对Layout应用层次的排序。在GameObject的hierarchy中靠近root的Layout可能会影响改变嵌套在它里面的其他Layout的位置和大小，所以必须首先计算。 </li><li>   <strong>Graphic Rebuild</strong> , 当Graphic组件被rebuild的时候，UGUI将控制传递给ICanvasElement接口的Rebuild方法。Graphic执行了这一步，并在rebuild过程中的PreRender阶段运行了两个不同的rebuild步骤：1.如果顶点数据已经被标为Dirty（例如组件的<strong>RectTransform</strong>已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的<strong>material或者texture</strong>已经被改变），则关联的Canvas Renderer的材质将被更新。Graphic的Rebuild不会按照Graphic组件的特殊顺序进行，也不会进行任何的排序操作。</li></ul><h1 id="代码运行流程"><a href="#代码运行流程" class="headerlink" title="代码运行流程"></a>代码运行流程</h1><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>Canvas在<strong>渲染前</strong>会调用willRenderCanvases，也就是Registry的PerformUpdate方法。</p><h2 id="CanvasUpdateRegistry"><a href="#CanvasUpdateRegistry" class="headerlink" title="CanvasUpdateRegistry"></a>CanvasUpdateRegistry</h2><p>画面刷新的注册工具类，在它的构造函数中会给Canvas注册回调：<code>Canvas.willRenderCanvases += PerformUpdate;</code></p><p>内部维护2个队列（都是 ICanvasElement类型 的）：</p><ul><li>  LayoutRebuildQueue：布局重建队列</li><li>  GraphicRebuildQueue：图像重建队列</li></ul><p>从此可以看到，<strong>Rebuild分两种，一种是布局重建，一种是图像重建。</strong></p><h1 id="顺序枚举"><a href="#顺序枚举" class="headerlink" title="顺序枚举"></a>顺序枚举</h1><p>CanvasUpdate，一个枚举类，很核心，代表着Canvas对Layout、Render的处理顺序：</p><ol start="0"><li>  Prelayout：Called before layout.</li><li>  Layout</li><li>  PostLayout：Called after layout.</li><li>  PreRender：Called before rendering.</li><li>  LatePreRender：Called late, before render.</li><li>  MaxUpdateValue：Max enum value. Always last.</li></ol><h1 id="一整轮重建：PerformUpdate方法"><a href="#一整轮重建：PerformUpdate方法" class="headerlink" title="一整轮重建：PerformUpdate方法"></a>一整轮重建：PerformUpdate方法</h1><p>1.在布局重建队列、图像重建队列中，<strong>剔除已销毁对象</strong>。</p><p>2.<strong>更新布局</strong>。根据父节点数量排序，先深后浅。更新类型依次为 Prelayout 、Layout 、PostLayout。详细见ugui_4。</p><p>3.执行<code>LayoutComplete</code>回调，也就是通知LayoutRebuild队列的所有元素，<strong>通知布局已完成</strong>。</p><p>4.布局完成，可以<strong>对UI（IClipper）进行裁剪</strong>了，显示不到的就不渲染</p><p>5.<strong>更新图像</strong>。依次 PreRender、LatePreRender、MaxUpdateValue：1.如果顶点数据已经被标为Dirty（例如组件的RectTransform已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的material或者texture已经被改变），则关联的Canvas Renderer的材质将被更新。</p><p>6.执行<code>GraphicUpdateComplete</code>回调，<strong>通知图像更新完成</strong>。</p><h1 id="脏标记"><a href="#脏标记" class="headerlink" title="脏标记"></a>脏标记</h1><p>这里用脏标记，就是将重建的行为延迟到用户需要这个物体的时候才执行，一种优化重新渲染的手段。</p><p>在Graphic 中存在三种脏标记分别代表三种等待重建</p><ul><li><p>  尺寸改变时（RectTransformDimensions）：LayoutRebuild 布局重建</p></li><li><p>  尺寸、颜色改变时：Vertices to GraphicRebuild 图像重建</p></li><li><p>  材质改变时：Material to GraphicRebuild 图像重建</p></li></ul><p>层级改变、应用动画属性（DidApplyAnimationProperties） ：All to Rebuild 重建所有</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/105746002&quot;&gt;https://blog.csdn.net/qq_28820675/article/details/1057</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 展示</title>
    <link href="https://codingcodingk.github.io/Intro/display/"/>
    <id>https://codingcodingk.github.io/Intro/display/</id>
    <published>2022-03-25T12:02:18.559Z</published>
    <updated>2022-03-25T12:02:18.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Demo简介"><a href="#Demo简介" class="headerlink" title="Demo简介"></a>Demo简介</h1><p>个人Demo项目，所有代码都已在github开源。// <strong>个人博客</strong>：CodingCodingK.top    <strong>github首页</strong>：github.com/CodingCodingK</p><p>使用Unity客户端、.net core服务端实现类王者荣耀帧同步Moba手游。系统方面主要实现了背包系统；战斗方面，实现了主要游戏流程、实现了3个人物及其技能：亚瑟、后裔、金克斯(lol)。</p><ul><li>使用UDP通信、Protobuf协议实现帧同步网络通信库</li><li>使用Odin、xNode实现自定义可视化编辑器，且保持数据一致</li><li>使用Luban实现本地Excel数据配置导表方案</li><li>使用对象池、虚拟列表等进行背包系统优化</li><li>使用定点数实现碰撞环境生成、确定性物理碰撞检测</li><li>实现基于客户端负责计算的帧同步Moba战斗系统</li><li>不同客户端独立计算的显示结果统一与运动平滑</li><li>逻辑层与显示层分离，复用技能、Buff、子弹逻辑代码的战斗系统</li><li>业务内容上，大致实现了登陆系统、大厅主城、背包系统、匹配系统、选角系统、加载系统、战斗系统。</li></ul><h1 id="Demo演示视频⭐"><a href="#Demo演示视频⭐" class="headerlink" title="Demo演示视频⭐"></a>Demo演示视频⭐</h1><p>1P 游戏内容展示：登录客户端1 =&gt; 大厅、背包系统展示 =&gt; 登录客户端2 =&gt; 匹配、选人、加载读条系统展示 =&gt; 整个战斗流程展示 =&gt; 结束返回大厅。</p><p>2P 开发环境展示：Excel配置、自定义编辑器、服务器数据库等。</p><h2 id="视频地址-↓↓↓"><a href="#视频地址-↓↓↓" class="headerlink" title="视频地址 ↓↓↓"></a>视频地址 ↓↓↓</h2><p><a href="https://www.bilibili.com/video/BV1ML4y177hc">https://www.bilibili.com/video/BV1ML4y177hc</a></p><h2 id="Demo演示环境"><a href="#Demo演示环境" class="headerlink" title="Demo演示环境"></a>Demo演示环境</h2><p>服务器：使用腾讯云，配置 4核 8G 带宽10M 微型个人服务器。</p><p>真机测试：华为P40手机 鸿蒙OS。</p><h1 id="Demo源码"><a href="#Demo源码" class="headerlink" title="Demo源码"></a>Demo源码</h1><p>apk下载地址（可连远端服务器，支持安卓实机）：<a href="https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ">https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ</a> 提取码：1234 </p><p>MobaDemo（双端）源码地址：<a href="https://github.com/CodingCodingK/UnityMobaDemo">https://github.com/CodingCodingK/UnityMobaDemo</a></p><h1 id="Demo实现细节展示"><a href="#Demo实现细节展示" class="headerlink" title="Demo实现细节展示"></a>Demo实现细节展示</h1><p>限于篇幅以及可观赏性，很多东西没办法通过视频的形式呈现，</p><p>每个模块的demo代码以及个人笔记地址。</p><h2 id="项目实现细节"><a href="#项目实现细节" class="headerlink" title="项目实现细节"></a>项目实现细节</h2><p>技能系统、物理碰撞模拟等在项目中的运用：<a href="https://codingcodingk.top/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/">王者荣耀复刻项目 笔记目录</a></p><h2 id="使用Protobuf协议的UDP简易网络通信库"><a href="#使用Protobuf协议的UDP简易网络通信库" class="headerlink" title="使用Protobuf协议的UDP简易网络通信库"></a>使用Protobuf协议的UDP简易网络通信库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingK_Session">https://github.com/CodingCodingK/CodingK_Session</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/protobuf/">工具篇：protobuf序列化</a>    <a href="https://codingcodingk.top/Tech/Game/tools/CodingK_Session/">工具篇：帧同步网络库</a></p><h2 id="常用定时器"><a href="#常用定时器" class="headerlink" title="常用定时器"></a>常用定时器</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKTimer">https://github.com/CodingCodingK/CodingKTimer</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKTimer/">工具篇：定时系统</a></p><h2 id="自用定点数数学库"><a href="#自用定点数数学库" class="headerlink" title="自用定点数数学库"></a>自用定点数数学库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKMath">https://github.com/CodingCodingK/CodingKMath</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKMath/">工具篇：定点数运算数学库</a></p><h2 id="自用定点数物理碰撞模拟"><a href="#自用定点数物理碰撞模拟" class="headerlink" title="自用定点数物理碰撞模拟"></a>自用定点数物理碰撞模拟</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKPhysx">https://github.com/CodingCodingK/CodingKPhysx</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKPhysx/">工具篇：定点数物理碰撞库</a></p><h2 id="基于Luban实现的Excel配置方案"><a href="#基于Luban实现的Excel配置方案" class="headerlink" title="基于Luban实现的Excel配置方案"></a>基于Luban实现的Excel配置方案</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/luban_study/">工具篇：本地配置</a></p><h2 id="Odin、xNode自定义编辑器"><a href="#Odin、xNode自定义编辑器" class="headerlink" title="Odin、xNode自定义编辑器"></a>Odin、xNode自定义编辑器</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/odin_study/">工具篇：Odin 可视化编辑器</a>    <a href="https://codingcodingk.top/Project/Unity/Moba/HOK/skilleditor/">王者荣耀复刻项目 技能配置编辑器篇</a></p><h1 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h1><p>其实在开始这个Demo之前，为了能够学习游戏开发，在业余时间我也在各类网课学习了<a href="https://github.com/CodingCodingK/Unity_Studys">很多简单的游戏案例</a>，尝试理解一些框架诸如GameFramework、UGUI的源码。从2021年4月起学习Unity官方游戏案例Ruby，到如今正式求职一份Unity工作已经过去了一年。我还有很多想学习的，想做出更接近商业级的东西。</p><p>非常感谢也许是面试官也许是hr的您，能够看到这里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Demo简介&quot;&gt;&lt;a href=&quot;#Demo简介&quot; class=&quot;headerlink&quot; title=&quot;Demo简介&quot;&gt;&lt;/a&gt;Demo简介&lt;/h1&gt;&lt;p&gt;个人Demo项目，所有代码都已在github开源。// &lt;strong&gt;个人博客&lt;/strong&gt;：Codi</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
  <entry>
    <title>什么叫“二进制”配置方案？</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/serialize/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/serialize/</id>
    <published>2022-03-18T13:18:05.707Z</published>
    <updated>2022-03-18T13:18:05.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的很懵，刚好自己的demo有用，挖一下。</p><h1 id="先说二进制式存储"><a href="#先说二进制式存储" class="headerlink" title="先说二进制式存储"></a>先说二进制式存储</h1><p>要理解为什么二进制更优，先明白什么是二进制式存储。</p><h2 id="什么是二进制文件？"><a href="#什么是二进制文件？" class="headerlink" title="什么是二进制文件？"></a>什么是二进制文件？</h2><p>所有对计算机有所了解的人肯定都知道计算机的存储在物理上是二进制（01）形式的。所以文本文件与二进制文件的区别并不是物理上，而是逻辑上的。其本质是两者在编码层次上的差异。简单的来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据应用的具体情况自定义自己的编码。</p><p>从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。</p><h2 id="文本文件是怎么读取的？"><a href="#文本文件是怎么读取的？" class="headerlink" title="文本文件是怎么读取的？"></a>文本文件是怎么读取的？</h2><p>文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。</p><p>比如选取ASCII码形式（ASCII码的一个字符是8个比特），它就会8个比特地来解释这个文件流：”01000000 01000001 01000010 01000011”用ASCII码解析出来是“ABCD”，显示在文本编辑器上。</p><h2 id="二进制文件vs文本文件"><a href="#二进制文件vs文本文件" class="headerlink" title="二进制文件vs文本文件"></a>二进制文件vs文本文件</h2><p><strong>译码难度</strong>：一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。</p><p><strong>文件大小</strong>：关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。</p><h1 id="再聊二进制配置"><a href="#再聊二进制配置" class="headerlink" title="再聊二进制配置"></a>再聊二进制配置</h1><h2 id="二进制和json的关系"><a href="#二进制和json的关系" class="headerlink" title="二进制和json的关系"></a>二进制和json的关系</h2><p>要存储一个json文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot; = 133,</span><br><span class="line">  &quot;color&quot; = [233, 0, 0],</span><br><span class="line">  &quot;pos&quot; = [34, 22]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>json一般以utf-8格式保存成文本</strong>，utf-8是unicode编码的一种实现形式。也就是说，像程序中的数字类型133，233，22等，一个uint8就能存储下了，可是133在json中却占了3个字节，要是存个12.432312等数据要占用更多的空间。而本文所说的二进制配置，直接存133等的uint8二进制编码0x85，这样便减少了一部分文件大小。<strong>编码与解码可以商量好自己的规则</strong>，比如time，编解码都以t代替，又可以节省一部分空间，甚至可以不存储time，color，pos等key，直接顺序在配置中写value，解码时直接读value（为了说的清楚，后面的例子保留了key）这样又可以减少配置文件的大小。</p><h2 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h2><blockquote><p>  序列化是将对象or对象图(比如数组)转换成字节流的过程，反序列化是将字节流转换回对象图的过程。</p></blockquote><p>上面这段来自我clr笔记的定义，就可以明白大佬们说的“二进制来做”，做的是序列化反序列化。</p><p>不通过这种常规读取方式：</p><p>读取utf-8的.json文件 =&gt; 将utf-8读取成二进制流byte[] =&gt; 此时byte[]是json字符串，也就是json序列化后的产物，我们再通过反射(至少我常用的库是反射)反序列化 =&gt; 反序列化完成，返回一个对象。</p><p>那如果加入“二进制来做”的读取方式：</p><p>读取.bin文件 =&gt; 二进制文件更小读取很快，获取到二进制流byte[]，然后根据自己定好的的规则去读流(比如按顺序获取定长比特来读取)，反序列化 =&gt; 反序列化完成，返回一个对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大佬们说的“二进制来做”，其实想指的是一个解决方案而不是指最终存的文件是二进制式的这么简单。</p><p>你可以<strong>可以自己写规则</strong>，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Custom_MemoryStream</span> : <span class="title">MemoryStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReadInt</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">base</span>.Read(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = BitConverter.GetBytes(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">base</span>.Write(arr, <span class="number">0</span>, arr.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 类似的还有很多比如string，这里略了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entity <span class="title">MakeEntity</span>(<span class="params">MemoryStream ms</span>)</span>&#123;</span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity();</span><br><span class="line">    entity.Id = ms.ReadInt();</span><br><span class="line">    entity.Name = ms.ReadString();</span><br><span class="line">    entity.Path = ms.ReadString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用现成的解决方案比如protobuf、FlatBuffers，他们的最终文件也都是<strong>二进制式的而不是文本格式，且读取的时候读二进制流直接按长度转换成字段</strong>。</p><p>最后，接上导表工具，就算成了。</p><p>可能对于定义上还是有一点点误解，以后会来改。但是我相信，无论怎样，目的都是为了更快、更小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="优化" scheme="https://codingcodingk.github.io/categories/Game/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：定点数物理碰撞库</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/CodingKPhysx/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/CodingKPhysx/</id>
    <published>2022-03-18T13:18:05.703Z</published>
    <updated>2022-03-25T12:02:18.564Z</updated>
    
    <content type="html"><![CDATA[<p>定点数基于《工具篇：定点数运算数学库》的定点数库。</p><h1 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h1><p>1.读取配置：初始化碰撞环境</p><p>2.读取配置：初始化玩家碰撞体</p><p>3.FixedUpdate（具体看《Unity生命流程》）：固定帧率检测碰撞发生</p><h1 id="碰撞配置"><a href="#碰撞配置" class="headerlink" title="碰撞配置"></a>碰撞配置</h1><p>ColldierConfig。</p><p>长方体类型：位置、长宽高、轴向。</p><p>圆柱体类型：位置、半径。</p><h1 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h1><h2 id="逻辑-视图分离"><a href="#逻辑-视图分离" class="headerlink" title="逻辑-视图分离"></a>逻辑-视图分离</h2><p>只维护逻辑值，视图则根据定点数逻辑值转换成浮点数来进行更新。但是，视图层更新后并不参与任何运算，只显示。</p><h1 id="碰撞环境"><a href="#碰撞环境" class="headerlink" title="碰撞环境"></a>碰撞环境</h1><p>环境初始化的前提是根据固定方式制作地图：<strong>只用 BoxCollider 和 CapsuleCollider 两种碰撞体，且全部放在一个EnvRoot结点下</strong>。</p><p>初始化时，遍历这个根节点，将所有的BoxCollider转化为定点数长方体形碰撞体，将所有的CapsuleCollider转化为定点数圆柱体形碰撞体。</p><p>生成下来，放到一个List中保存。</p><h1 id="碰撞检测-矫正计算（一对一）"><a href="#碰撞检测-矫正计算（一对一）" class="headerlink" title="碰撞检测+矫正计算（一对一）"></a>碰撞检测+矫正计算（一对一）</h1><h2 id="Cylinder碰到Box"><a href="#Cylinder碰到Box" class="headerlink" title="Cylinder碰到Box"></a>Cylinder碰到Box</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309232208.png"></p><p>1.求出 向量OK = Cylinder.Pos - Box.Pos。</p><p>2.求出 向量OK 分别在 Box.X方向向量、Box.Z方向向量 上的投影的长度：</p><p>使用点乘即可。具体推导是<a href="https://blog.csdn.net/liushao1031177/article/details/119776495">线代问题</a>，简单公式推导如下（向量v必须是方向向量也就是模为1）：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220308235857.png"></p><p>3.对上面求出的2段投影的长度进行钳制，让他们的范围小于的Box的半长和半宽。</p><p>4.由3的两断钳制后的投影距离 + Box.Pos ，简单计算出P点（表面最近的接触点）位置。</p><p>5.判断P点是否在Cylinder内部，不在就不需要矫正直接返回；在就需要矫正，往PO方向<strong>矫正距离</strong> Cylinder半径 - PO长度 即可。</p><p>6.如果需要矫正距离，那同时需要<strong>矫正速度方向</strong>，这可以利用向量的和来求出。求出 向量OV 在 向量PO 上的投影OT，和图中情况一致的话应该是个负数，用它可以求出 向量OT = 投影OT * 向量PO的单位向量。最后使用 向量OV - 向量OT ，得出向量TV，这就是修正后的方向向量。</p><h2 id="Cylinder碰到Cylinder"><a href="#Cylinder碰到Cylinder" class="headerlink" title="Cylinder碰到Cylinder"></a>Cylinder碰到Cylinder</h2><p>两个圆求是否相撞，直接用 两者半径之和 与 两者圆心距离 比较即可。</p><p>至于计算<strong>矫正距离</strong>就比较简单了，公式我在图中给出了。最后计算<strong>矫正速度方向</strong>，方法和上面的6是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309213302.png"></p><h1 id="碰撞检测-矫正计算（一对多）"><a href="#碰撞检测-矫正计算（一对多）" class="headerlink" title="碰撞检测+矫正计算（一对多）"></a>碰撞检测+矫正计算（一对多）</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220311014107.png"></p><p>碰撞检测如图。</p><p>目前采用一个有微小误差的办法：<br>检测速度向量OV和向量和OB的夹角：角VOB，<br>与Max(角AOB,角COB)进行比较，</p><p>如果角VOB更小，那么就当作不需要矫正；<br>如果角VOB更大，那么就当作需要矫正。</p><p>如果不需要矫正，就当作墙体的反作用力完美抵消了速度V，撤销本次预执行的位置更新，方向修正为Vector.zero。<br>如果需要矫正，使用之前的方法（步骤6）求出 速度V 与 与法线夹角最大的那个向量的法线向量（AO）情况下的 修正方向。而矫正位置就很好算了，直接取所有碰撞点（一对一）的位置矫正之和。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定点数基于《工具篇：定点数运算数学库》的定点数库。&lt;/p&gt;
&lt;h1 id=&quot;处理流程&quot;&gt;&lt;a href=&quot;#处理流程&quot; class=&quot;headerlink&quot; title=&quot;处理流程&quot;&gt;&lt;/a&gt;处理流程&lt;/h1&gt;&lt;p&gt;1.读取配置：初始化碰撞环境&lt;/p&gt;
&lt;p&gt;2.读取配置：</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="物理碰撞库" scheme="https://codingcodingk.github.io/tags/%E7%89%A9%E7%90%86%E7%A2%B0%E6%92%9E%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Unity编辑器拓展</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_4/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_4/</id>
    <published>2022-03-18T13:18:05.702Z</published>
    <updated>2022-03-18T13:18:05.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识编辑器拓展"><a href="#初识编辑器拓展" class="headerlink" title="初识编辑器拓展"></a>初识编辑器拓展</h1><h2 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h2><ul><li>  菜单栏选项</li><li>  菜单栏窗口</li><li>  面板式编辑器</li><li>  窗口式编辑器</li></ul><p>unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。 用于扩展editor的类需要放到名字为“Editor”的文件夹中，这个文件夹可以直接放到”Assets“文件夹下，也可以是项目目录任何文件夹下的子文件夹，比如”Assets/SkillSystem/Editor”。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>重新绘制画面，主要是通过重写OnGUI、OnInspectorGUI之类的函数来实现的。</p><p>这些函数是生命周期中的一员，具体看Unity生命流程图。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>对上面提出的支持进行简单实践。</p><h2 id="菜单栏选项"><a href="#菜单栏选项" class="headerlink" title="菜单栏选项"></a>菜单栏选项</h2><p>菜单栏里添加“Tools &gt; 打包工具”项。点击执行方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;Tools/打包工具&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputAB</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单栏窗口"><a href="#菜单栏窗口" class="headerlink" title="菜单栏窗口"></a>菜单栏窗口</h2><p>菜单栏里添加“Example &gt; 打包工具”项。点击跳出制作的窗口以及控件。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121155.png"></p><p>使用方法：</p><ol><li>  继承ScriptableWizard</li><li>  调用ScriptableWizard.DisplayWizard函数可以快速创建这个向导窗口。这个向导窗口只支持小于或等于两个按钮的定制（即提供的消息响应函数只有两个按钮的）。显示的按钮名字通过ScriptableWizard.DisplayWizard函数传入。</li></ol><p>ScriptableWizard的API中的消息响应函数：（当满足某些条件下执行这些函数）</p><p>OnWizardCreate ：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”createButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardOtherButton：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”otherButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardUpdate：当向导窗口打开时或者用户改变窗口内容时都会被调用。一般会在这里显示帮助文字和进行内容有效性验证。也可以动态改变按钮状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptableWizardButton</span> : <span class="title">ScriptableWizard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firstObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform secondObject = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Example/Show OnWizardOtherButton Usage&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard(<span class="string">&quot;Click info to know the distance between the objects&quot;</span>, <span class="keyword">typeof</span>(ScriptableWizardButton), <span class="string">&quot;Finish!&quot;</span>, <span class="string">&quot;Info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstObject == <span class="literal">null</span> || secondObject == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">false</span>;</span><br><span class="line">            errorString = <span class="string">&quot;Select the objects you want to measure&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">true</span>;</span><br><span class="line">            errorString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Info&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardOtherButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> distanceObjs = Vector3.Distance(firstObject.position, secondObject.position);</span><br><span class="line">        EditorUtility.DisplayDialog(</span><br><span class="line">            <span class="string">&quot;The distance between the objects is: &quot;</span> + distanceObjs + <span class="string">&quot; Units&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Finish!&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorUtility.DisplayDialog(<span class="string">&quot;OnWizardCreate &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口式编辑器"><a href="#窗口式编辑器" class="headerlink" title="窗口式编辑器"></a>窗口式编辑器</h2><p>菜单栏里添加“Window &gt; MyEditorWnd”。点击打开窗口式面板。</p><p>使用方法：继承EditorWindow，重写“OnGUI”函数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121422.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEditorWnd</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">bool</span> groupEnabled;</span><br><span class="line">    <span class="built_in">bool</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">float</span> myFloat = <span class="number">1.23f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add menu named &quot;My Window&quot; to the Window menu</span></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Window/MyEditorWnd&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get existing open window or if none, make a new one:</span></span><br><span class="line">        MyEditorWnd window = (MyEditorWnd)EditorWindow.GetWindow(<span class="keyword">typeof</span>(MyEditorWnd));</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Base Settings&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        myString = EditorGUILayout.TextField(<span class="string">&quot;Text Field&quot;</span>, myString);</span><br><span class="line">        groupEnabled = EditorGUILayout.BeginToggleGroup(<span class="string">&quot;Optional Settings&quot;</span>, groupEnabled);</span><br><span class="line">        myBool = EditorGUILayout.Toggle(<span class="string">&quot;Toggle&quot;</span>, myBool);</span><br><span class="line">        myFloat = EditorGUILayout.Slider(<span class="string">&quot;Slider&quot;</span>, myFloat, <span class="number">-3</span>, <span class="number">3</span>);</span><br><span class="line">        EditorGUILayout.EndToggleGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面板式编辑器"><a href="#面板式编辑器" class="headerlink" title="面板式编辑器"></a>面板式编辑器</h1><p>对于上面提到所有拓展方式中，第三种“面板式编辑器”是最常用的一种，单独开篇。</p><h2 id="是在做什么？"><a href="#是在做什么？" class="headerlink" title="是在做什么？"></a>是在做什么？</h2><p>是在将 EditorGUI 拓展在 Inspector 面板上。</p><p>EditorGUI 和 GUI 的用法几乎完全一致，目前来说前者多用于编辑器开发，后者多用于发布后调试编辑器。总之，它们都是起辅助作用的。 EditorGUI 提供的组件非常丰富，常用的绘制元素包括文本、按钮、图片和滚动框等。做一个好的编辑器，是离不开 EditorGUI 的。</p><p>至于EditorGUI 和 数据的交互，是借由一个继承了MonoBehaviour的脚本的数据字段实现的。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>常规使用方法：</p><ol><li>  首先得有一个MonoBehaviour常规脚本，我们取名为“Show.cs”，可以在内自定义一些字段比如Sprite、List之类的。</li><li>  新建脚本，继承Editor类，标上[CustomEditor(typeof(Show))]标签当挂Showt脚本时就会显示这个编辑器，用来让编辑器和脚本互通。</li><li>  对2中新建的脚本重写”OnInspectorGUI”函数，对自己扩展的组件的编辑界面进行定制。</li></ol><p>以上示例代码见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><p>见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识编辑器拓展&quot;&gt;&lt;a href=&quot;#初识编辑器拓展&quot; class=&quot;headerlink&quot; title=&quot;初识编辑器拓展&quot;&gt;&lt;/a&gt;初识编辑器拓展&lt;/h1&gt;&lt;h2 id=&quot;支持&quot;&gt;&lt;a href=&quot;#支持&quot; class=&quot;headerlink&quot; title=&quot;支</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity协程原理</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_5/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_5/</id>
    <published>2022-03-18T13:18:05.702Z</published>
    <updated>2022-03-18T13:18:05.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开启一个协程发生了什么"><a href="#开启一个协程发生了什么" class="headerlink" title="开启一个协程发生了什么"></a>开启一个协程发生了什么</h1><p>分析如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ShowLog());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">IEnumerator <span class="title">ShowLog</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(i);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先描述一下里面用到的方法和类：</p><h2 id="StartCoroutine"><a href="#StartCoroutine" class="headerlink" title="StartCoroutine"></a>StartCoroutine</h2><p>StartCoroutine是 Monobehavior类的函数，有3个重载函数</p><blockquote><p>  public Coroutine StartCoroutine(string methodName);<br>  public Coroutine StartCoroutine(IEnumerator routine);<br>  public Coroutine StartCoroutine(string methodName, [DefaultValue(“null”)] object value);</p></blockquote><p>StartCoroutine的第一个和第三个methodName ，都是一个返回类型是IEnumerator的方法。</p><p>所以入参全是<strong>IEnumerator迭代器方法</strong>。返回类型全是<strong>Coroutine</strong>类。</p><h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>协同程序。继承自<strong>YieldInstruction</strong>类。</p><p><a href="https://docs.unity3d.com/cn/current/ScriptReference/MonoBehaviour.StartCoroutine.html">StartCoroutine函数</a> 返回 Coroutine。协同程序是一个可以暂停执行 (yield) 的函数，直到给定的 <a href="https://docs.unity3d.com/cn/current/ScriptReference/YieldInstruction.html">YieldInstruction</a> 完成。</p><h2 id="YieldInstruction"><a href="#YieldInstruction" class="headerlink" title="YieldInstruction"></a>YieldInstruction</h2><p>yield return后面可以是值，也可以是一个类型为继承自<strong>YieldInstruction的类</strong>。</p><p>如果yield return的是YieldInstruction的派生类，Unity就会将其理解为“持续等待”。比如WaitForEndOfFrame、WaitForFixedUpdate、WaitForSeconds、WWW、Coroutine（StartCoroutine的返回值），它们都是。</p><h2 id="yield-return"><a href="#yield-return" class="headerlink" title="yield return"></a>yield return</h2><p>yield return后面可以跟的表达式：</p><p>​        所有非YieldInstruction派生类（包括null）：协程将会在下一帧恢复，继续后续代码。</p><p>​        WaitForEndOfFrame：协程将会在这一帧结束之后（所有渲染、GUI）恢复，继续后续代码。</p><p>​        WaitForFixedUpdate：所有物理引擎计算完成之后恢复，继续后续代码。</p><p>​        WaitForSeconds：等待x秒后（以Unity内的计时系统为基准）恢复，继续后续代码。</p><p>​        WWW：等待一个web request结束后恢复，继续后续代码。</p><p>​        Coroutine 其他协程（协程嵌套）：等子协程Coroutine执行完后恢复，继续后续代码。如果子协程内有yield中断，那父协程会一直暂停，直到子协程运行完毕。</p><h2 id="CustomYieldInstruction"><a href="#CustomYieldInstruction" class="headerlink" title="CustomYieldInstruction"></a>CustomYieldInstruction</h2><p>想实现自定义和<code>YieldInstruction</code>一样，拥有“持续等待”逻辑的协程，就用这个。继承自<code>IEnumerator</code>类。</p><p>重写<code>keepWaiting</code>函数即可。要使协同程序保持暂停，则返回<code>true</code>；要使协同程序继续执行， 则返回<code>false</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Left mouse button up&quot;</span>);</span><br><span class="line">            StartCoroutine(waitForMouseDown());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">waitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Right mouse button pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaitForMouseDown</span> : <span class="title">CustomYieldInstruction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> keepWaiting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !Input.GetMouseButtonDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Waiting for Mouse right button down&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程原理"><a href="#协程原理" class="headerlink" title="协程原理"></a>协程原理</h1><p>如果代码中对<code>gameObject.SetActive(false)</code>，协程就会失效，即使再次激活，也不能继续执行。原因是协程是在StartCoroutine时被注册到的GameObject上，他的生命期受限于GameObject的生命期，因此受GameObject是否active的影响。</p><p><strong>不难得出，协程和Update一样是在每一帧被调用执行的。经过测试，一般是在LastUpdate之后执行的。</strong></p><p>而具体怎么执行，是利用了<strong>迭代器</strong>：每一帧检测yield的返回情况（想想StartCoroutine估计就是<code>while(MoveNext)</code>）。也就是<strong>每一帧都执行MoveNext</strong>，如果为true下一帧就继续执行MoveNext，如果为false就结束协程将其从协程队列中剔除。</p><h1 id="自己实现携程"><a href="#自己实现携程" class="headerlink" title="自己实现携程"></a>自己实现携程</h1><p>// 当然也可以考虑用async-await替代协程，ETTask就是这样的。具体以后再看，粗看应该是最后将回调放到<code>同步上下文.Post</code>里做了。</p><p>找到一个不错的实践，<a href="https://www.cnblogs.com/zblade/p/9857808.html">转载</a>一下。可以手动控制携程顺序、执行片长。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Profiling;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QuotaCoroutine</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每帧的额度时间，全局共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">float</span> frameQuotaSec = <span class="number">0.001f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">LinkedList</span>&lt;<span class="title">IEnumerator</span>&gt; s_tasks</span> = <span class="keyword">new</span> LinkedList&lt;IEnumerator&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartQuotaCoroutine(Task(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleTask();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartQuotaCoroutine</span>(<span class="params">IEnumerator task</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        s_tasks.AddLast(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ScheduleTask</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> timeStart = Time.realtimeSinceStartup;</span><br><span class="line">        <span class="keyword">while</span> (s_tasks.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> t = s_tasks.First.Value;</span><br><span class="line">            <span class="built_in">bool</span> taskFinish = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (Time.realtimeSinceStartup - timeStart &lt; frameQuotaSec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 执行任务的一步, 后续没步骤就是任务完成</span></span><br><span class="line">                Profiler.BeginSample(<span class="built_in">string</span>.Format(<span class="string">&quot;QuotaTaskStep, f:&#123;0&#125;&quot;</span>, Time.frameCount));</span><br><span class="line">                taskFinish = !t.MoveNext();</span><br><span class="line">                Profiler.EndSample();</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (taskFinish)</span><br><span class="line">                &#123;</span><br><span class="line">                    s_tasks.RemoveFirst();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 任务没结束执行到这里就是没时间额度了</span></span><br><span class="line">            <span class="keyword">if</span> (!taskFinish)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">IEnumerator <span class="title">Task</span>(<span class="params"><span class="built_in">int</span> taskId, <span class="built_in">int</span> stepCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; stepCount)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;, frame:&#123;2&#125;&quot;</span>, taskId, i, Time.frameCount);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开启一个协程发生了什么&quot;&gt;&lt;a href=&quot;#开启一个协程发生了什么&quot; class=&quot;headerlink&quot; title=&quot;开启一个协程发生了什么&quot;&gt;&lt;/a&gt;开启一个协程发生了什么&lt;/h1&gt;&lt;p&gt;分析如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UI屏幕自适应</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_1/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_1/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-18T13:18:05.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="面板基本"><a href="#面板基本" class="headerlink" title="面板基本"></a>面板基本</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217103517.png"></p><p>当我们点击一个GUI物体是它具有的属性为：</p><p><strong>Rect Transform</strong>：继承自Transform组件，它表示的是控件的Location位置，和一些基本的属性。这个控件的参数类型会随着锚点情况而改变，具体在下一节展示。</p><p><strong>Pivot</strong>：设置轴心（不是蓝色的，那个叫中心锚点）的位置，中心点的位置【0,0】表示的是控件的左下角的位置，【1,1】表示的是右上角的位置，【0.5,0.5】表示的是图像中心的位置。</p><p><strong>Anchors</strong>：它的取值和Pivot一个逻辑，也是0~1之间。Min点和Max点是2个点，2个点可以沿着x、y方向，确定出一个矩形。而这个矩形的4个点就是4个锚点。我们也可以直接拖动画面的锚点来快捷设置。</p><h2 id="Pivot-和-Center"><a href="#Pivot-和-Center" class="headerlink" title="Pivot 和 Center"></a>Pivot 和 Center</h2><p>Pivot上面说了，是轴心，可以自己在Rect Transform的面板里设置；</p><p>Center是中心，是在Unity中根据模型的mesh信息计算得到的中心位置，是所有物体共同的中心，如果同时选中了多个物体，则坐标是所有模型共同参与计算出来的坐标。</p><p>Center是由Unity计算出来的而不是设置出来的。Pivot在锚点重合情况下，代表着PosX和PosY画出来的的点。</p><h2 id="锚点、纽扣和中心点-Center"><a href="#锚点、纽扣和中心点-Center" class="headerlink" title="锚点、纽扣和中心点(Center)"></a>锚点、纽扣和中心点(Center)</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217104252.png"></p><p>这里先对3个点下定义，下面一节进行讨论。</p><p>单击图形显示着的的小篮圈，到底表示的是Pivot还是Center，是在Unity里设置的，两者完全不是一个东西。设置的话，在Global边上的选项里选择即可。</p><p>正常的二维UI，中心点总是在正中间，而轴心就可以自己设置了。</p><h1 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h1><h2 id="情况一：两个锚点重合"><a href="#情况一：两个锚点重合" class="headerlink" title="情况一：两个锚点重合"></a>情况一：两个锚点重合</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>两个锚点重合的情况，Image UI（也就是红色Image）的锚点和Pivot连成一条线，这条线会永远保持（也就是两点的距离会永远保持）。<strong>在这种情况下调整画面，Image UI不会变形，只会根据Pivot点到Anchor点的距离一致的原则调整位置。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120309.png"></p><p>一个值得关注的点是，此时Image UI的Rect Transform控件是Pos + Width,Height的组合。这个PosX和Y，指的是Anchor和Pivot之间的相对位置。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120631.png"></p><h3 id="示例动图"><a href="#示例动图" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored1.gif"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored2.gif"></p><h2 id="情况二：锚框"><a href="#情况二：锚框" class="headerlink" title="情况二：锚框"></a>情况二：锚框</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>当两个锚点（AnchorMin和AnchorMax）不重合时，两点就会确定一个矩形，这个矩形就是我们的锚框。<strong>这种情况会保持锚点到纽扣的距离保持不变。</strong></p><p>此时Image UI的Rect Transform控件是Left,Top + Right,Bottom的组合。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217121839.png"></p><p>这四个点什么意思呢？是纽扣的相对位置，相对的是锚点组成的坐标系。看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217134116.png"></p><p>所以明白了，锚点到纽扣的距离保持不变，那就意味着4条（图中2条以及左上右下未画出来的）绿线始终保持不变。同时意味着，代表这4个点相对位置的Rect Transform控件里的Left,Top,Right,Bottom值也都不变。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217135538.png"></p><h3 id="示例动图-1"><a href="#示例动图-1" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored3.gif"></p><h2 id="anchoredPosition属性"><a href="#anchoredPosition属性" class="headerlink" title="anchoredPosition属性"></a>anchoredPosition属性</h2><p>他本身是一个点，如果在AnchorMin和AnchorMax是重合的场合（情况一）下，anchoredPosition就是表示锚点到Pivot的位置。</p><p>但是如果AnchorMin和AnchorMax不重合的时候（情况二），anchoredPosition就比较复杂了，在这种情况下，Unity会根据Pivot、AnchorMin和AnchorMax计算出一个锚点，然后在通过Pivot和锚点来得出anchoredPosition的位置。</p><h2 id="offsetMin和offsetMax详解"><a href="#offsetMin和offsetMax详解" class="headerlink" title="offsetMin和offsetMax详解"></a>offsetMin和offsetMax详解</h2><p>offsetMin和offsetMax这两个属性。其中offsetMin表示物体（本文中的红框）左下角相对AnchorMin的偏移，offsetMax表示物体右上角相对AnchorMax的偏移。</p><p>情况一 anchor(0, 0)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151909.png"></p><p>情况二 anchorMin(0,0) anchorMax(1,1)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151935.png"></p><h2 id="sizeDelta详解"><a href="#sizeDelta详解" class="headerlink" title="sizeDelta详解"></a>sizeDelta详解</h2><p>sizeDelta就是offsetMax - offsetMin的值，即物体左下角到右上角的变量：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152058.png"></p><h1 id="画布缩放器-Canvas-Scaler"><a href="#画布缩放器-Canvas-Scaler" class="headerlink" title="画布缩放器 Canvas Scaler"></a>画布缩放器 Canvas Scaler</h1><p>Canvas新建时自带的脚本，专门解决屏幕适配问题的脚本，负责伸缩所有UI对象。以下内容主要取自<a href="https://docs.unity3d.com/cn/current/Manual/script-CanvasScaler.html">Unity中文手册</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152713.png"></p><p>三种模式：</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>UI Scale Mode</strong></td><td align="left">确定画布中的 UI 元素的缩放方式。</td></tr><tr><td align="left"><strong>Constant Pixel Size</strong></td><td align="left">无论屏幕大小如何，UI 元素都保持相同的像素大小。</td></tr><tr><td align="left"><strong>Scale With Screen Size</strong></td><td align="left">屏幕越大，UI 元素越大。</td></tr><tr><td align="left"><strong>Constant Physical Size</strong></td><td align="left">无论屏幕大小和分辨率如何，UI 元素都保持相同的物理大小。</td></tr></tbody></table><p>一般来说的配置方案是：<br>Canvas Scaler 选择 Scale With Screen Size<br>Screen Match Mode 选择 Match Width Or Height，</p><p>横屏游戏比例设为1，即只和高度进行适配；</p><p>竖屏游戏比例设为0，即只和宽度进行适配。</p><h2 id="1、Constant-Pixel-Size"><a href="#1、Constant-Pixel-Size" class="headerlink" title="1、Constant Pixel Size"></a>1、Constant Pixel Size</h2><p>一般美术拿它来做缩放图片，因为不同Size不失真。</p><p>使用 Constant Pixel Size 模式时，可在屏幕上按像素指定 UI 元素的位置和大小。这也是画布在未附加任何画布缩放器时的默认功能。但是，借助画布缩放器中的“Scale Factor”设置，可以向画布中的所有 UI 元素应用常量缩放。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Scale Factor</strong></td><td align="left">按此系数缩放画布中的所有 UI 元素。画布的缩放比例。默认况下为1，表示正常大小。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。每单位代表的像素量。</td></tr></tbody></table><h2 id="2、Scale-With-Screen-Size"><a href="#2、Scale-With-Screen-Size" class="headerlink" title="2、Scale With Screen Size"></a>2、Scale With Screen Size</h2><p>使用 Scale With Screen Size 模式时，可以根据指定参考分辨率的像素来指定位置和大小。如果当前屏幕分辨率大于参考分辨率，则画布会保持只具有参考分辨率的分辨率，但是会放大以便适应屏幕。如果当前屏幕分辨率小于参考分辨率，则画布会相应缩小以适应屏幕。</p><p>如果当前屏幕分辨率的宽高比与参考分辨率不同，则单独缩放每个轴以适应屏幕会形成非一致缩放，通常不希望发生这种情况。相反，ReferenceResolution 组件会使画布分辨率偏离参考分辨率，以便遵循屏幕的宽高比。可以使用 Screen Match Mode 设置控制此偏离的行为方式。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Reference Resolution</strong></td><td align="left">UI 布局设计的目标分辨率。如果屏幕分辨率较大，则 UI 会放大，如果较小，则 UI 会缩小。</td></tr><tr><td align="left"><strong>Screen Match Mode</strong></td><td align="left">在当前分辨率的宽高比不适应参考分辨率时，用于缩放画布区域的模式。</td></tr><tr><td align="left"><strong>Match Width or Height</strong>⭐常用</td><td align="left">以宽度、高度或二者的某种平均值作为参考来缩放画布区域。</td></tr><tr><td align="left"><strong>Expand</strong></td><td align="left">水平或垂直扩展画布区域，使画布不会小于参考。</td></tr><tr><td align="left"><strong>Shrink</strong></td><td align="left">水平或垂直裁剪画布区域，使画布不会大于参考。</td></tr><tr><td align="left"><strong>Match</strong></td><td align="left">确定是否以宽度、高度或二者的某种平均值作为参考进行缩放。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。</td></tr></tbody></table><h2 id="3、Constant-Physical-Size"><a href="#3、Constant-Physical-Size" class="headerlink" title="3、Constant Physical Size"></a>3、Constant Physical Size</h2><p>使用 Constant Physical Size 模式时，可按物理单位（如毫米、点或派卡）指定 UI 元素的位置和大小。此模式要求设备正确报告其屏幕 DPI。对于不报告 DPI 的设备，可以指定回退 DPI。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Physical Unit</strong></td><td align="left">用于指定位置和大小的物理单位。</td></tr><tr><td align="left"><strong>Fallback Screen DPI</strong></td><td align="left">在屏幕 DPI 未知时采用的 DPI。</td></tr><tr><td align="left"><strong>Default Sprite DPI</strong></td><td align="left">用于精灵的每英寸像素，使其“Pixels Per Unit”设置与“Reference Pixels Per Unit”设置匹配。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则其 DPI 将与“Default Sprite DPI”设置匹配。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;h2 id=&quot;面板基本&quot;&gt;&lt;a href=&quot;#面板基本&quot; class=&quot;headerlink&quot; title=&quot;面板基本&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UI常见优化</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_2/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_2/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-27T07:12:08.732Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。</p><h1 id="Unity性能优化"><a href="#Unity性能优化" class="headerlink" title="Unity性能优化"></a>Unity性能优化</h1><h2 id="优化关键"><a href="#优化关键" class="headerlink" title="优化关键"></a>优化关键</h2><p>先找到性能瓶颈。影响图形性能的关键因素主要有一下几个方面。</p><ol><li> GPU填充率和存储器带宽。</li><li> CPU经常是渲染物体的数量（也就是常常大家说的Draw Calls）。</li><li> 系统内存容量也是优化的一个关键指标。</li></ol><h2 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h2><p>GPU优化主要有下面几点：</p><ol><li>  减少三角形的使用数量（去掉不必要的三角形面）。</li><li>  尽量避免使用实时光照，能使用Static Lighting就使用烘焙光照，只计算一次。</li><li>  压缩纹理和多重纹理-minmaps（这样可以提高加载速度和降低内存占用），也极大提高渲染的性能。</li><li>  LOD（多细节层次），不同距离使用不同精度的模型。</li><li>  编写高性能着色器，将能能处理的逻辑放在定点着色器里面处理，减少片段着色器的计算量。</li></ol><h2 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h2><p>CPU主要开销在，显卡在渲染一个对象之前，CPU需要计算一些着色器和灯光影响，然后想显卡驱动发送绘制指令，单物体来说，不会太影响性能，累计就会产生性能问题。这里优化点主要从以下几个方面讨论，这里只是说出优化常用的方案，后面如果在下在项目里面遇到更加好的方案，或者是方法，我将会在这里补充出来。也欢迎大家指出错误，或者是更好的CPU优化方案。</p><ol><li> 合并材质球相同的对象，进而减少绘制指令的发送。合并的方式有，手工合并或者是使用Unity内置的选项合并，或者是使用自制脚本合并模型对象，但是注意的是:非相同材质对象，合并不会对性能有任何的提高。</li><li> 在对象或场景中使用更少的材质。可以将独立的纹理合并成一个更大的纹理图集，但是合并时注意，合并要以方便开发，节省资源为基础。</li><li> 避免使用物体被渲染多次的效果，这里主要体现在（反射，阴影，像素光照等）。</li><li> 优化游戏代码，也是优化CPU的一个关键点。</li></ol><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>性能优化最后一点，就是内存的优化，要优化Unity的内存资源，就首先必须了解内存的资源管理模式，以及Unity资源加载的方式，Unity资源动态加载主要有下面两种方式：</p><ol><li> Resource方式资源加载。</li><li> AssetBundle资源加载方式。</li></ol><p>这两种资源加载方式都提供同步和异步加载API。资源加载到内存里面的规范到底是什么样的，观察下面的图就一目了然。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210105112.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。&lt;/p&gt;
&lt;h1 id=&quot;Unity性能优化&quot;&gt;&lt;a href=&quot;#Unity性能优化&quot; class=&quot;headerlink&quot; title=&quot;Unity性能优化&quot;&gt;&lt;/a&gt;Unity性能优化&lt;/h</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity生命流程</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_3/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_3/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-18T13:18:05.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命流程图"><a href="#生命流程图" class="headerlink" title="生命流程图"></a>生命流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221094846.png"></p><h1 id="FixedUpdate"><a href="#FixedUpdate" class="headerlink" title="FixedUpdate"></a>FixedUpdate</h1><p>1、和Update主帧循环不同，Unity的刚体系统通过固定的时间来驱动也就是FixedUpdate。在刚体系统运算开始前，<strong>Unity会根据上一次刚体运算完成的时间再加上Fixed Timestep的所设置的值来作为这一次刚体运算时间的限定范围</strong>。然后刚体系统会开始计算，直到达到这个时间限制临界点。</p><p>2、FixedUpdate与Update的不同在于，Update在每帧被调用，但是调用时间不确定，所以我们要实现一个物体匀速运动是，是无法通过Update准确实现的，但是我们可以在FixedUpdate中实现，因为它在确定的时间间隔中被调用。FixedUpdate有可能在Update之前调用多次。FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。</p><p>3、FixedUpdate的频率可以自己设置，如果频率过高，导致一次Update的时间片内执行了多次FixedUpdate进行物理运算，那对CPU就是一种浪费（因为根本不显示出来）；而适当的低频率FixedUpdate，虽然偶尔会造成人物有顿感，但是往往是可以接受的。</p><p>4、FixedUpdate的最高值也是可以设置的。Time Manager中的Maximum Allowed Timestep就是给处理物体运算的FixedUpdate加上一个限制。如果某一帧的物理运算时间超过了这个值，物理引擎就会立即停止运算，以便让主循环Update可以追上,一旦这一帧主循环Update运行完成，物理引擎就会从它暂停的地方恢复计算就像它从来没有停止过一样。</p><h1 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate"></a>LateUpdate</h1><p>3、LateUpdate它会在所有update被调用后调用，这个函数可以在我们编写ai时被使用，因为我们要当所有物体和怪物移动过后再判断物体的一些策略，比如开枪等，这个时候就可以在LateUpdate中编写，因为LateUpdate基本可以保证所有物体在本帧的移动等操作均已经完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生命流程图&quot;&gt;&lt;a href=&quot;#生命流程图&quot; class=&quot;headerlink&quot; title=&quot;生命流程图&quot;&gt;&lt;/a&gt;生命流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/CodingCodingK/Coding</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity常见UI基础问题手册</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/Guide_UnityUI/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/Guide_UnityUI/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<p>仅作个人笔记用途。</p><h1 id="UI顶层显示"><a href="#UI顶层显示" class="headerlink" title="UI顶层显示"></a>UI顶层显示</h1><h2 id="方法一-做一个新的UI摄像机"><a href="#方法一-做一个新的UI摄像机" class="headerlink" title="方法一.做一个新的UI摄像机"></a>方法一.做一个新的UI摄像机</h2><p>① Canvas的Render Mode设置为<strong>Screen Space - Camera</strong></p><p>② 新建摄像机（后面称之为UI摄像机），放到原先摄像机的下面</p><p>③ 拖拽UI摄像机到Canvas的Render Camera</p><p>④ UI摄像机的 Clear Flags 设置为 <strong>Depth only</strong>，用来去掉背景；Culling Mask设置为 <strong>UI</strong>。</p><p>⑤ 确保 UI摄像机的Depth &gt; 其他摄像机的Depth （值小的会先渲染，所以值大的会在前面）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1dK4y1b7be?spm_id_from=333.999.0.0">超级细致的调试教学视频</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅作个人笔记用途。&lt;/p&gt;
&lt;h1 id=&quot;UI顶层显示&quot;&gt;&lt;a href=&quot;#UI顶层显示&quot; class=&quot;headerlink&quot; title=&quot;UI顶层显示&quot;&gt;&lt;/a&gt;UI顶层显示&lt;/h1&gt;&lt;h2 id=&quot;方法一-做一个新的UI摄像机&quot;&gt;&lt;a href=&quot;#方法一-做一</summary>
      
    
    
    
    <category term="Unity个人积累" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - Base篇</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_1/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_1/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><a href="https://github.com/Unity-Technologies/uGUI">源码地址</a></p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105619250">学习博客</a></p><p>GF源码看了，UGUI自适应用了，自定义编辑器写了，但是对于UGUI却一直是纯黑盒使用。想体系化学习一遍UGUI。</p><p>学习目的：按照博客阅读源码，理解后整理成自己的笔记，方便回忆。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h1><p>好图，转自大佬<a href="https://blog.csdn.net/qq_28820675/article/details/105619250">博客</a>！</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220316142853.png"></p><h1 id="UIBehaviour"><a href="#UIBehaviour" class="headerlink" title="UIBehaviour"></a>UIBehaviour</h1><blockquote><p>  namespace UnityEngine.EventSystems :</p><p>  public abstract class UIBehaviour : MonoBehaviour</p></blockquote><p>是一个抽象类，里面提供了一系列虚方法：</p><ul><li>  生命周期（Awake,OnEnable,Start,OnDisable,OnDestroy）</li><li>  UnityEditor 辅助方法</li><li>  UGUI 通用方法（IsActive,OnValidate,OnRectTransformDimensionsChange等锚点相关）</li></ul><p>和一个非虚方法 IsDestroyed：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsDestroyed</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Unity-Technologies/uGUI&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity渲染原理</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/Rendering/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/Rendering/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<p>渲染原理学习。// TODO</p><h1 id="Rending面板"><a href="#Rending面板" class="headerlink" title="Rending面板"></a>Rending面板</h1><h2 id="Color-Space"><a href="#Color-Space" class="headerlink" title="Color Space"></a>Color Space</h2><p>以前的阴极射线管电视，需要更强烈的色彩来弥补差设备显示，但现在硬件提升已经不需要了。</p><p>这就是为什么把Rendering的Color Space从Gamma切到Linear。</p><h3 id="阴极-真空管-电视"><a href="#阴极-真空管-电视" class="headerlink" title="阴极 真空管 电视"></a>阴极 真空管 电视</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118131229.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染原理学习。// TODO&lt;/p&gt;
&lt;h1 id=&quot;Rending面板&quot;&gt;&lt;a href=&quot;#Rending面板&quot; class=&quot;headerlink&quot; title=&quot;Rending面板&quot;&gt;&lt;/a&gt;Rending面板&lt;/h1&gt;&lt;h2 id=&quot;Color-Space&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/categories/Unity/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - 事件系统、射线检测</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_2/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_2/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-25T12:02:18.562Z</updated>
    
    <content type="html"><![CDATA[<p>图片转自<a href="https://blog.csdn.net/qq_28820675/article/details/105619356">大佬博客</a></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220321175024.png"></p><h1 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h1><p>总的来说事件系统分为3个大组件：</p><p>EventSystem组件 负责管理 所有的输入检测模块（InputModule）并在Update中每帧调用Module的执行（Process）。</p><p>InputModule组件 负责输入（点击、拖拽、选中等），调用Raycaster获得返回值PointerEventData，最后通过ExecuteEvents触发事件（IPointerClickHandler 等）。</p><p>Raycaster组件 负责确定目标对象，返回结果PointerEventData给InputModule组件。</p><h2 id="管理者-EventSystem"><a href="#管理者-EventSystem" class="headerlink" title="管理者 EventSystem"></a>管理者 EventSystem</h2><ul><li>  平时新建一个Canvas时，会创建EventSystem组件，这个组件所挂载的脚本就是EventSystem和InputModule。</li></ul><p>EventSystem组件主要负责<strong>处理输入、射线投射以及发送事件</strong>，一个场景中只能有一个EventSystem组件。</p><h2 id="输入-InputModule"><a href="#输入-InputModule" class="headerlink" title="输入 InputModule"></a>输入 InputModule</h2><ul><li>平时新建一个Canvas时，会创建EventSystem组件，这个组件所挂载的脚本就是EventSystem和InputModule。</li></ul><p>BaseInputModule基类，负责发送输入事件（点击、拖拽、选中等）到具体对象，可以自己派生实现输入模块而官方提供2个：</p><ul><li>  标准输入模块（StandaloneInputModule）</li><li>  触摸输入模块（TouchInputModule， 现在已经不需要了它整合进StandaloneInputModule中了！）</li></ul><p>这2个官方提供的模块会检测一些输入操作，以事件的方式（message系统）通知目标对象，所以给摇杆的mono脚本实现接口（IPointerClickHandler 等）就可以触发事件 。</p><h2 id="射线-Raycaster"><a href="#射线-Raycaster" class="headerlink" title="射线 Raycaster"></a>射线 Raycaster</h2><ul><li>  对于UI对象，在平时新建一个Canvas时，如果Canvas的渲染模式是SceenSpace-Overlay，Canvas会挂载GraphRaycaster脚本。</li><li>  场景中的非UI对象，如果想要接收输入模块的事件，也需要给摄像机挂上一个射线检测组件（3D是PhysicsRaycaster、2D是Physics2Draycaster）。然后需要给想被检测到的物体添加collider脚本，否则检测不到。</li></ul><h2 id="事件执行器-ExecuteEvents"><a href="#事件执行器-ExecuteEvents" class="headerlink" title="事件执行器 ExecuteEvents"></a>事件执行器 ExecuteEvents</h2><p>事件执行器，InputModule在通过射线确定了最近的命中物体后，会用ExecuteEvents触发Click等事件。</p><p>Execute方法：获取物体上所有包含IEventSystemHandler且可用的组件，根据情况调用执行接口方法，传入PointerEventData参数。</p><h1 id="射线检测流程"><a href="#射线检测流程" class="headerlink" title="射线检测流程"></a>射线检测流程</h1><p>0.在EventSystem的Update中，每帧调用InputModule.Process，进行点击/触击检测。</p><p>1.如果InputModule检测到了点击/触击，就会向EventSystem请求发射射线。 <code>eventSystem.RaycastAll(pointerData, m_RaycastResultCache);</code></p><p>2.将屏幕触击点投影到相机切面(near)上的位置，生成一条射线，将射线所有命中的物体保存到 hitDistance击中点数组 和 <strong>RaycastResult被命中物体数组</strong> 中。具体射线怎么计算命中的，是<code>UnityEngine.Physics</code>内的接口，没开源。</p><p>3.遍历所有Graphic，获取可接收射线广播的Graphic信息。</p><p>4.取出RaycastResult数组中，距离最近的那个物体作为射线检测的结果返回。</p><p>5.射线检测结果PointerEventData 返回到了InputModule中，对其触发那些事件接口（IPointerClickHandler之类的）并传入PointerEventData参数。</p><p>// 2中具体还会记录射线起点到相机渲染终点的切面(far)之间的距离。这个具体看<a href="https://www.cnblogs.com/w-wfy/p/7243459.html">下图</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220321164508.png"></p><h1 id="UI穿透"><a href="#UI穿透" class="headerlink" title="UI穿透"></a>UI穿透</h1><p>现象就是射线检测到了后面的物体。</p><p>解决1.一般新窗口和底层窗口之间，都会有一个暗灰色的透明背景，可以把这个透明背景的Raycast Target勾选上，这样就终止了射线检测到后面的窗口。</p><p>解决2.自己实现一个简单的射线检测，射线使用graphicRaycaster射线，这是针对UI检测的射线。</p><p>ps.针对UI检测的射线：其实每个组件在创建的时候已经被添加进了一个公共列表（我们使用的UGUI中的每个组件都是继承自Graphic或者依赖一个继承自Graphic的组件）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;图片转自&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/105619356&quot;&gt;大佬博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/CodingCod</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 同步异步、多线程篇</title>
    <link href="https://codingcodingk.github.io/Tech/CSharp/Essence/tongbuyibu_obsolete/"/>
    <id>https://codingcodingk.github.io/Tech/CSharp/Essence/tongbuyibu_obsolete/</id>
    <published>2022-03-18T13:18:05.699Z</published>
    <updated>2022-03-18T13:18:05.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零-为什么我会理解错"><a href="#零-为什么我会理解错" class="headerlink" title="零.为什么我会理解错"></a>零.为什么我会理解错</h1><p>在看完clr之前，我曾对异步同步探究看了十几篇文章，但很可惜，没有完全理解，只知道了一大堆概念：IRP、异步要借用多线程…</p><p>在看完之后，我理解并甚至尝试实现一个简单的异步的时候才明白，之前无法理解是因为我不懂：</p><p><strong>异步编程 和 异步函数 是不同的东西。也就是说，异步函数async/await 只是异步编程的一种罢了，你大可以利用ContinueWith或ThreadPool等来实现异步。</strong></p><p>很多博客混淆了这两个概念，我不知道他们是否真正理解了，但是这会导致我这种代码先行基础后补的菜b无法理解。</p><p>所以这篇文章的理解是片面的，等有空了我再整理一下。</p><h1 id="一-同步与异步"><a href="#一-同步与异步" class="headerlink" title="一.同步与异步"></a>一.同步与异步</h1><p>  项目中每天都在接触，但是对这俩概念比较模糊。看《CLR via C#》刚好提到了，就去网上找到几篇好文，理解写篇自己的笔记。首先得说明的是，这一节讨论的只是概念，都是单纯的、不考虑多线程处理的同步与异步区别。</p><h3 id="IO-概念区分"><a href="#IO-概念区分" class="headerlink" title="IO 概念区分"></a>IO 概念区分</h3><ul><li><p>同步（Synchronous）</p></li><li><p>异步( Asynchronous)</p></li><li><p>阻塞( Blocking )</p></li><li><p>非阻塞( Nonblocking)</p></li></ul><p>那首先，要弄清楚同步异步、阻塞非阻塞之间的关系。</p><ul><li><p>同步异步 指的是在客户端，<br>同步意味着 客户端提出了一个请求以后，在回应之前只能等待。<br>异步意味着 客户端提出一个请求以后，还可以继续提其他请求。</p></li><li><p>阻塞非阻塞 指的是服务器端，<br>阻塞意味着 服务器接受一个请求后，在返回结果以前不能接受其他请求。<br>非阻塞意味着 服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求。</p></li></ul><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><ol><li>同步与异步意图<br>这个层级的还是很好理解，它们的核心是消息通信机制。</li></ol><ul><li>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。也就是说，代码执行会等着它，卡在那不动，直到执行结束把返回值给我才继续。</li><li>异步则是相反，调用在发出之后，这个调用就直接返回了，没有返回结果，我记得如果还没返回就去拿的话好像是null。也就是说，代码执行不会等它，你管你运行，返回值我不需要所以我继续往下跑，你运行完执行你自己的回调函数就行。用途有点类似于子线程。</li></ul><ol start="2"><li>阻塞与非阻塞意图<br>区分是调用结果返回之前，是否将调用的线程挂起，暂时不理其他请求。</li></ol><h3 id="不同模型的理解"><a href="#不同模型的理解" class="headerlink" title="不同模型的理解"></a>不同模型的理解</h3><p>直接把别人博客的图整理下拿过来了，<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211104120820.png"></p><ol><li>说的是单线程普通情况下，是这么执行的。按顺序一个个，等A有返回值回来了再B，B有返回值回来了再C。</li><li>说的是多线程同步的情况，并行运行，不展开，图简单，但实际交互非常复杂，通道、共享内存啥的。这里提这个是为了体现异步的作用。</li><li>说的是单线程异步执行，看得到ABC这运行，理论上是没有什么执行顺序可言的（项目经验告诉我，实际上这句话不对，但是概念上这么理解就够了，毕竟不可靠），属于是把程序执行顺序直接丢了。看上去事件花销和1的同步一样，那为什么要引入这个概念呢？看4。</li><li>可以看到，其实3还是比同步的情况下省了很多时间，这个waiting可能是方法里人工delay，也可能是在等待磁盘坑长的I/O操作返回结果，所以如果异步，灰色的部分就省下来了。由此也可知，异步唯一存在的阻塞情况，是无方法可执行的时候（ABC都在灰色段等着I/O给结果）。</li></ol><p>以上用于理解概念是够了，但是实际应用会多很多（比如异步有很多方法可以实现，每种方法可控性等不同）。</p><p>搞懂最基本的同步异步之后，开始结合c#的用法，看下怎么用。</p><h1 id="二-Async-and-Await"><a href="#二-Async-and-Await" class="headerlink" title="二.Async and Await"></a>二.Async and Await</h1><p>  一篇不错的文章，虽然是2012年（也就是Async/Await语法糖出来的时候）的还是英文，但是把两者分析的非常透彻。刚好作为实际应用的补充。</p><h3 id="先来介绍一下这两个C-关键字"><a href="#先来介绍一下这两个C-关键字" class="headerlink" title="先来介绍一下这两个C#关键字"></a>先来介绍一下这两个C#关键字</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoSomethingAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// In the Real World, we would actually do something...</span></span><br><span class="line">  <span class="comment">// For this example, we&#x27;re just going to (asynchronously) wait 100ms.</span></span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <font color='red'>async </font>只有2个作用。一是是允许await这个关键字的使用，二是改变了方法结果的处理方式。async在执行开始时，是和同步运行一样的。也就是说在遇到await之前，它是同步的。</p><p>  <font color='red'>await </font>是异步操作的启动器。它会持续监视一个<font color='red'>异步操作 </font>（asynchronous operation）的执行，<br>  如果这个异步操作已经完成了，那他就会继续跑后续代码；<br>  如果这个异步操作未完成，就开始真正的<font color='red'>异步</font>：调用者会将这个async任务暂时挂起，直到await监视的异步操作处理完后，才继续执行后续代码。注意了，这个处理完后的执行，是会根据遇到await之前捕捉下来的<font color='red'>上下文（Context） </font>环境来继续运行。u1s1，这听着很像unity的协程好吧。<br>  通过上面知道了，async方法体里遇到个await、且await后面跟了个需要时间去处理的方法（上面叫异步操作，举个例子比如I/O操作吧），这个时候这个async方法会被阻塞住，但是整个线程并不会被阻塞住，而是在做其他的异步方法了，直到其他方法也卡住。</p><h3 id="Asynchronous-Operation"><a href="#Asynchronous-Operation" class="headerlink" title="Asynchronous Operation"></a>Asynchronous Operation</h3><p>  上面提到的异步操作。从上可知，你只需要提供<font color='red'>异步操作</font>就可以实现一个异步。你可以直接用微软提供支持的Task或者<code>Task&lt;T&gt;</code>，或者将各种方法转换成一个异步操作，或者是Task.Yield会返回不是Tasks的异步操作。<br>  关于异步操作的一个要点是:异步操作，指的不是async关键词修饰的就是异步操作，而是他是一个可以异步操作的类型。换句话说，你可以await一个类型为Task的async method，这是因为方法返回Task，而不是因为它是async的。所以你也可以await一个返回Task的非async方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">NewStuffAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use await and have fun with the new stuff.</span></span><br><span class="line">  <span class="keyword">await</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">MyOldTaskParallelLibraryCode</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 最开始就说的，因为这个方法没有async关键词修饰，所里方法体里不能用await关键词</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ComposeAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// We can await Tasks, regardless of where they come from.</span></span><br><span class="line">  <span class="keyword">await</span> NewStuffAsync();</span><br><span class="line">  <span class="keyword">await</span> MyOldTaskParallelLibraryCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Return-Types"><a href="#Return-Types" class="headerlink" title="Return Types"></a>Return Types</h3><p>  Async方法可以返回<code>Task&lt;T&gt;</code>、Task以及void，但是在大部分情况我们都会选择前两个而不是void，因为<code>Task&lt;T&gt;</code>、Task是可以等待的，而void不行。<br>  那什么时候用void呢？原文是这么说的：</p><blockquote><p>You have to return void when you have async event handlers.</p></blockquote><h3 id="Returning-Values"><a href="#Returning-Values" class="headerlink" title="Returning Values"></a>Returning Values</h3><p>  这个和上面不同，这个是返回值。Task和void一样都没有返回值，但是<code>Task&lt;T&gt;</code>有T类型的返回值。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>  上下文。上面提到过，当await的异步操作结束后，将会根据遇到await之前捕捉下来的上下文环境继续执行代码。上下文是什么？简单来说：</p><ul><li>如果你在一个UI线程上，那么就是个UI Context</li><li>如果你在一个ASP.NET请求上，那么就是个ASP.NET request context</li><li>否则，通常会是一个线程池环境（a thread pool context）。<br>好嘛，听君一席话。那么复杂点说呢？</li><li>如果<font color='red'>SynchronizationContext.Current</font>不是null的，那么SynchronizationContext.Current就是它的上下文（UI、ASP.NET）</li><li>其他情况，就是当前的<font color='red'>TaskScheduler</font><br>这两个名词暂时先不展开了。<br>下面看一个示例。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinForms 例子 (当然wpf也一样).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当这个异步方法DownloadFileAsync在await的时候，UI线程并不会被阻塞。</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASP.NET 例子</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">MyButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await之后，ASP.NET线程并不会因此被阻塞</span></span><br><span class="line">  <span class="comment">// 这使得这个线程仍然可以接受其他的request</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(...);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复ASP.NET Context，然后就可以连接到当前请求了</span></span><br><span class="line">  <span class="comment">// 也许结束那一瞬间，我们在其他的线程上，但是也能拥有同样的ASP.NET Context</span></span><br><span class="line">  Response.Write(<span class="string">&quot;File downloaded!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Avoiding-Context"><a href="#Avoiding-Context" class="headerlink" title="Avoiding Context"></a>Avoiding Context</h3><p>  上下文有个大概的概念了，关键词还是await。那么，有的时候不需要去抓取整个main的上下文，比如下面的例子，一个Task中并不需要UI的上下文。<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadFileAsync</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这一个调用http api的下载任务</span></span><br><span class="line">  <span class="keyword">var</span> fileContents = <span class="keyword">await</span> DownloadFileContentsAsync(fileName).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为上面设置了ConfigureAwait(false),我们不在原来的上下文中</span></span><br><span class="line">  <span class="comment">// 那我们在什么上下文中？在线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将文件数据写入磁盘</span></span><br><span class="line">  <span class="keyword">await</span> WriteToDiskAsync(fileName,fileContents).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WinForms、Wpf例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await后，UI线程并没有被这个下载任务所阻塞</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上述例子还需要注意的是，每个层级的async方法都有自己的上下文。<code>DownloadFileButton_Click</code>方法中是由UI上下文启动的，随后进入<code>DownloadFileAsync</code>也是由UI上下文启动的，但是随着<code>ConfigureAwait(false)</code>的设置，又会跳出UI上下文，转到线程池上下文中继续运行。最后，当<code>DownloadFileAsync</code>方法执行结束回到<code>DownloadFileButton_Click</code>方法后，又会回到UI上下文继续。<br>  所以有一个优化方法就是，设置不需要UI上下文的异步方法<code>ConfigureAwait(false)</code>。</p><h3 id="Async-Composition"><a href="#Async-Composition" class="headerlink" title="Async Composition"></a>Async Composition</h3>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoOperationsConcurrentlyAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Task[] tasks = <span class="keyword">new</span> Task[<span class="number">3</span>];</span><br><span class="line">  tasks[<span class="number">0</span>] = DoOperation0Async();</span><br><span class="line">  tasks[<span class="number">1</span>] = DoOperation1Async();</span><br><span class="line">  tasks[<span class="number">2</span>] = DoOperation2Async();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个时间点，所有任务都在并行执行</span></span><br><span class="line">  <span class="comment">// 我们对所有任务都进行等待</span></span><br><span class="line">  <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetFirstToRespondAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Call two web services; take the first response.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt;[] tasks = <span class="keyword">new</span>[] &#123; WebService1Async(), WebService2Async() &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Await for the first one to respond.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt; firstTask = <span class="keyword">await</span> Task.WhenAny(tasks);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the result.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> firstTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-非常重要，暂停一下"><a href="#三-非常重要，暂停一下" class="headerlink" title="三.非常重要，暂停一下"></a>三.非常重要，暂停一下</h1><p>  从上可知，异步和同步大概是什么了。根据上两篇去理解，异步就是为了去解决I/O阻塞画面线程问题而推出的技术，而在C#里就是<code>async await Task</code>这三个关键词组合去实现的。执行起来是你做A遇到了子任务B，结果子任务B里有I/O卡壳了，你就立刻回头去做A剩下的直到B结束了会做B这样，看上去就是主线程自己的事。那么实际上呢？直接实践一下：<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Chinese Output</span></span><br><span class="line">Console.OutputEncoding = Encoding.GetEncoding(<span class="number">936</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;头部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">CallerWithAsync(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;尾部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Test Wait</span></span><br><span class="line">Console.Read();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallerWithAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;异步调用头部执行，当前线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> result = <span class="keyword">await</span> SayHiAsync(name);</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">SayHiAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点1，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点2，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">$&quot;Hello,<span class="subst">&#123;name&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211109113849.png"></p><p>  可以看到“测试断点2，此刻线程为: 4”，并不是主线程1，所以说C#的异步实践并不是和第一篇里说的一样，并不是在一个线程上解决的！！！当然还有很多其他方法，这个就不拓展了，只讨论最常用最简洁的实践方案。<br>  原因是什么呢？最直接地说，是因为第一篇的文章是基于单线程的最简单情况去理解同步与异步的，而C#实现不是，毕竟考虑到性能后的实现是很复杂的。而且，你要把一个任务挂起等执行完毕，那总得有线程去处理它对吧。<br>  为了明白这是什么意思，需要理解一下多线程与异步之间的关系。<br>  异步同步，其实和多线程还是单线程并不是一个维度的概念。我的理解是异步是一种程序运行的优化机制、是运行过程最终目的，而多线程还是单线程是一种可供你选择的条件，你可以单线程异步也可以多线程异步。</p><p>  传统异步（第一篇里诉说的）：遇到await时，将目前线程挂起，去做其他的事，不停调度。<br>  实际上基于多线程的异步编程（C#异步实现方法之一）：<font color='red'>遇到<code>Task.Run()</code>的多开线程指令或者真正需要异步挂起某任务时</font>，会从线程池取一个新线程（如果不够用就开新的），然后把这个线程拿来处理挂起的任务，主线程则是返回到方法体外去执行剩下的代码。<font color='red'>注意了，新开线程（也就是真正开始异步）的情况，并不是遇到await那一刻，就像图中的log那样，直到断点1都还是同步的，但是Task.Delay就会开始真正的异步。</font><br>  总结：C#中的异步可以简单的用async 和 await 配合来实现，使用异步的函数，在没有调用await前，还是按顺序单线程执行的，当运行到await的时候，系统才会异步调用其他的方法来运行，如果没有await, 函数就是同步按顺序的运行。所以，await才是异步中的关键部分，在await 范围内的代码，是多线程方式运行的（当然没有Task就不会取线程），可以将需要异步处理的代码放在await中运行，或者简单的用一个Task.Delay来延时，以达到异步切换代码运行的效果。await 后面接的是一个Task, 每一个Task在运行时，由系统的Task池来分配，以实现异步的功能。<br>这里再来说说用aysnc和直接用thread的区别，其实简单来讲，就是效率的问题，async用的线程池，在await中运行的代码是由线程池分配的线程，根据系统的任务，自动分配和释放，而用 new thread的方法，通常是需要手动控制的。很显然，在处理一些短时间，且对运行的时间性和稳定性不是特别严格的问题时，用async会很有优势，但是对于一些在后台需要长时间稳定运行的程序，用thread会更好，可以保证它在运行的过程中，不过有别的代码来插队。</p><h1 id="四-I-O操作时，没有线程在执行"><a href="#四-I-O操作时，没有线程在执行" class="headerlink" title="四.I/O操作时，没有线程在执行"></a>四.I/O操作时，没有线程在执行</h1><p>  <a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">There is no thread</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">微软Docs：异步编程</a> ，两篇文章大意是，当遇到await进行I/O操作时，因为现在的磁盘很牛逼，支持Direct Memory Access (DMA)操作，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。所以程序遇到I/O异步时，只是从线程池里拿了个线程，进行一次CPU操作命令之后这个线程就没事了，他不负责执行I/O、也不实时监视I/O的运行情况、更不会被阻塞。它理论来说直接送回线程池了，然后可以去处理其他操作，此时硬件自己和内存交换数据。I/O完成之后，硬件会触发一个中断来通知操作完成。</p><p>  以下来自微软官方文档：</p><blockquote><p>调用系统 API 后，请求位于内核空间，一路来到操作系统的网络子系统（例如 Linux 内核中的 <code>/net</code>）。 此处操作系统将对网络请求进行异步 处理。 所用操作系统不同，细节可能有所不同（可能会将设备驱动程序调用安排为发送回运行时的信号，或者会执行设备驱动程序调用然后 有一个信号发送回来），但最终都会通知运行时网络请求正在进行中。 此时，设备驱动程序工作处于已计划、正在进行或是已完成（请求已“通过网络”发出），但由于这些均为异步进行，设备驱动程序可立即着手处理其他事项！</p><p>例如，在 Windows 中操作系统线程调用网络设备驱动程序并要求它通过表示操作的中断请求数据包 (IRP) 执行网络操作。 设备驱动程序接收 IRP，调用网络，将 IRP 标记为“待定”，并返回到操作系统。 由于现在操作系统线程了解到 IRP 为“待定”，因此无需再为此作业进行进一步操作，将其“返回”，这样它就可用于完成其他工作。</p><p>请求完成且数据通过设备驱动程序返回后，会经由中断通知 CPU 新接收到的数据。 处理中断的方式因操作系统不同而有所不同，但最终都会通过操作系统将数据传递到系统互操作调用（例如，Linux 中的中断处理程序将安排 IRQ 的下半部分通过操作系统异步向上传递数据）。 这也是异步发生的！ 在下一个可用线程能执行异步方法且“解包”已完成任务的结果前，结果会排入队列。</p></blockquote><h1 id="五-思考"><a href="#五-思考" class="headerlink" title="五.思考"></a>五.思考</h1><p>  看了十几篇文章之后，对异步稍微是理解进了一小步。在此留下我的最简短理解：<br><font color='red'>  异步，就是为了让单个线程不会因为某个长时间I/O操作而卡死自己，从而达到压榨线程剩余价值的目的。（特别是UI主线程对于客户端来说的剩余价值特别大）</font></p><p>  关于应用上，整理了一下工作会用到的：</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>  当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。<br>  而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。工作中用到过的：</p><p> <code>大数据量Collection.AsParallel.ForEach(Task.Run(你的任务))</code>　　</p><h3 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h3><table><thead><tr><th>使用以下方式…</th><th>而不是…</th><th>若要执行此操作…</th></tr></thead><tbody><tr><td>await</td><td>Task.Wait 或 Task.Result</td><td>检索后台任务的结果</td></tr><tr><td>await Task.WhenAny</td><td>Task.WaitAny</td><td>等待任何任务完成</td></tr><tr><td>await Task.WhenAll</td><td>Task.WaitAll</td><td>等待所有任务完成</td></tr><tr><td>await Task.Delay</td><td>Thread.Sleep</td><td>等待一段时间</td></tr></tbody></table><p>补充：</p><p>再深入的话，可能要自己尝试实现一下线程池+异步I/O。以后再补吧。</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</a></p><p>ref:</p><p><a href="https://blog.csdn.net/qq_36936155/article/details/78991050">https://blog.csdn.net/qq_36936155/article/details/78991050</a></p><p><a href="https://blog.stephencleary.com/2012/02/async-and-await.html">https://blog.stephencleary.com/2012/02/async-and-await.html</a></p><p><a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">https://blog.stephencleary.com/2013/11/there-is-no-thread.html</a></p><p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">https://docs.microsoft.com/zh-cn/dotnet/csharp/async</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth">https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零-为什么我会理解错&quot;&gt;&lt;a href=&quot;#零-为什么我会理解错&quot; class=&quot;headerlink&quot; title=&quot;零.为什么我会理解错&quot;&gt;&lt;/a&gt;零.为什么我会理解错&lt;/h1&gt;&lt;p&gt;在看完clr之前，我曾对异步同步探究看了十几篇文章，但很可惜，没有完全理解，</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - Mono篇</title>
    <link href="https://codingcodingk.github.io/Tech/CSharp/Essence/mono/"/>
    <id>https://codingcodingk.github.io/Tech/CSharp/Essence/mono/</id>
    <published>2022-03-18T13:18:05.697Z</published>
    <updated>2022-03-18T13:18:05.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IL是什么？"><a href="#IL是什么？" class="headerlink" title="IL是什么？"></a>IL是什么？</h1><p>IL的全称是 Intermediate Language，是一种中间语言。它是一种属于通用语言架构和.NET框架的低阶（lowest-level）的人类可读的编程语言。目标为.NET框架的语言被编译成IL代码，然后汇编成字节码。</p><p>具体过程是：C#或者VB这样遵循CLI规范的高级语言，被先被各自的编译器编译成中间语言IL。等到需要真正执行的时候，这些IL会被加载到运行时库，也就是CLR中，由CLR动态编译（JIT）成汇编代码然后在执行。</p><h1 id="JIT是什么？"><a href="#JIT是什么？" class="headerlink" title="JIT是什么？"></a>JIT是什么？</h1><p>just-in-time compiler，即时编译器。它将IL翻译成汇编语言，它自身会对运行环境做出许多假定，从而进行自己的优化方案。</p><p>比如第一次调用一个方法时，JIT会把遇到的IL代码进行验证+编译，最后放进内存中。方法仅在首次调用时才会有一些性能损失，以后对该方法的所有调用都以本机代码的形式全速运行。</p><h1 id="Mono是什么？"><a href="#Mono是什么？" class="headerlink" title="Mono是什么？"></a>Mono是什么？</h1><p>是支持.net跨平台的一种方式。因为.net本身不支持跨平台只能运行在Windows上，所以需要一个<strong>跨平台的第三方.net库，这就是Mono</strong>。</p><p>mono作为一个中间层将IL代码的处理分出好多个分支，分别对应不同的平台。Mono其实和.net framework 是同一个东西，只不过Mono支持更多的平台，但.net的运行效率更高。<br>Unity打包时会将mono一同打包进来，同时Unity将脚本编译为IL代码打包，这样只要是Mono支持的平台，都可以在Mono中编译成平台本地代码。</p><h1 id="IL2CPP是什么？"><a href="#IL2CPP是什么？" class="headerlink" title="IL2CPP是什么？"></a>IL2CPP是什么？</h1><p>把IL中间语言转换成CPP文件。</p><p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p><p>但是GC还是C#方式来处理。</p><h1 id="为什么有了Mono还需要IL2CPP？"><a href="#为什么有了Mono还需要IL2CPP？" class="headerlink" title="为什么有了Mono还需要IL2CPP？"></a>为什么有了Mono还需要IL2CPP？</h1><p>主要是2点。</p><p>1.Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成。Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，非常耗时耗力。</p><p>2.根据官方的实验数据，Mono换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p><h1 id="工作中怎么涉及到Mono呢"><a href="#工作中怎么涉及到Mono呢" class="headerlink" title="工作中怎么涉及到Mono呢"></a>工作中怎么涉及到Mono呢</h1><p>可以在Unity工程打包得选项中，选择是用Mono还是IL2CPP方式输出。</p><p>IL2CPP能把IL中间码转为C++代码，然后交给各平台的C++编译器处理，有自己的代码裁剪规则。是一种目前效率更高的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IL是什么？&quot;&gt;&lt;a href=&quot;#IL是什么？&quot; class=&quot;headerlink&quot; title=&quot;IL是什么？&quot;&gt;&lt;/a&gt;IL是什么？&lt;/h1&gt;&lt;p&gt;IL的全称是 Intermediate Language，是一种中间语言。它是一种属于通用语言架构和.NET</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 反射篇</title>
    <link href="https://codingcodingk.github.io/Tech/CSharp/Essence/reflection/"/>
    <id>https://codingcodingk.github.io/Tech/CSharp/Essence/reflection/</id>
    <published>2022-03-18T13:18:05.697Z</published>
    <updated>2022-03-18T13:18:05.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射提供了封装程序集、模块和类型的对象（Type 类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性。如果代码中使用了属性，可以利用反射对它们进行访问。</p><p>Assembly类可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并创建该类型的实例。</p><p>Type类可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性等等，通过Type类可以得到这些要素的信息，并且调用之。</p><p>MethodInfo包含方法的信息，通过这个类可以得到方法的名称、参数、返回值等，并且可以调用之。</p><p>反射：反射提供了封装程序集，模块和类型对象，可以用反射动态地创建类型的实例，将类型绑定到现有对象，或者从现有对象类型里获取类型，然后调用类型的方法或访问字段和属性。</p><p>序列化：将对象转换为另一种媒介传输的格式过程。如，序列化一个对象，用Http通过internet在客户端和服务器之间传递该对象，在另一端用反序列化从该流中重新得到对象。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;p&gt;反射提供了封装程序集、模块和类型的对象（Type 类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 委托与事件篇</title>
    <link href="https://codingcodingk.github.io/Tech/CSharp/Essence/delegate/"/>
    <id>https://codingcodingk.github.io/Tech/CSharp/Essence/delegate/</id>
    <published>2022-03-18T13:18:05.696Z</published>
    <updated>2022-03-18T13:18:05.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="委托和事件的区别是什么？"><a href="#委托和事件的区别是什么？" class="headerlink" title="委托和事件的区别是什么？"></a>委托和事件的区别是什么？</h1><p>委托本质是一个继承自System.MulticastDelegate的类；而事件是一个类型成员，是对委托的封装，就和属性是对字段的封装一样。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>通过event关键词来定义。是对委托的封装。</p><h2 id="为什么封装？"><a href="#为什么封装？" class="headerlink" title="为什么封装？"></a>为什么封装？</h2><p>为了让委托链的意义，从一个方法执行队列变成一个可订阅、可通知（触发）的中介。</p><h2 id="怎么封装的？"><a href="#怎么封装的？" class="headerlink" title="怎么封装的？"></a>怎么封装的？</h2><p>随便在类内定义一个public事件，再查看IL代码多帮我们做了什么：</p><p>1.生成一个私有的委托字段（没错还是委托链实现的）</p><p>2.生成add和remove方法，内部处理是对生成的委托字段进行Delegate.Combine、Delegate.Remove。</p><h2 id="怎么设计？"><a href="#怎么设计？" class="headerlink" title="怎么设计？"></a>怎么设计？</h2><p>举个例子的话，WPF的画面交互事件用的EventHandler其实就是一个sender加一个args参数，自定义可以如下的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params">EventSender sender,MyEventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托本质是一个继承自System.MulticastDelegate的类，所以像类一样使用即可。</p><h2 id="新建一个委托发生了什么？"><a href="#新建一个委托发生了什么？" class="headerlink" title="新建一个委托发生了什么？"></a>新建一个委托发生了什么？</h2><p>当你写delegate的时候，编译器就视为你继承了System.MulticastDelegate类，且生成以下几个字段：</p><p>1.构造器</p><p><strong>它获取2个参数：一个是对象引用，另一个是引用了回调方法的整数</strong>。类似于<code>public MyDelegate(Object @object, IntPtr method)</code>。但是我们new的时候，不需要这么复杂的参数，直接<code>new MyDelegate(MyMethod)</code>就可以了，编译器会分析。</p><p>最后这2个参数会作为MulticastDelegate的2个重要字段！</p><p>2.Invoke方法</p><p>用于调用。<code>myDelegate(1);</code>其实编译器内部就会变成<code>myDelegate.Invoke(1);</code></p><p>3.BeginInvoke、EndInvoke方法</p><p>用于异步回调。</p><h2 id="MulticastDelegate类是什么？"><a href="#MulticastDelegate类是什么？" class="headerlink" title="MulticastDelegate类是什么？"></a>MulticastDelegate类是什么？</h2><p>又称多播委托，是所有委托的父类。</p><p>它的内部有3个重要字段和1个内部机制来实现委托链。</p><h3 id="3个重要字段"><a href="#3个重要字段" class="headerlink" title="3个重要字段"></a>3个重要字段</h3><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_target</td><td>System.Object</td><td>这个字段引用的是回调方法要操作的对象。当委托对象包装静态方法时，这个字段返回null；当委托对象包装实例方法时，这个字段引用回调方法要操作的对象。在委托构造器中将对象引用作为参数获取、赋值给_target。</td></tr><tr><td>_methodPtr</td><td>System.IntPtr</td><td>一个内部的整数值，CLR用它标识要回调的方法。在委托构造器中将回调方法IntPtr作为参数获取、赋值给_methodPtr。</td></tr><tr><td>_invocationList</td><td>System.Object</td><td>只有单个委托时为null。构造委托链时它引用一个委托数组。</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211210173655.png"></p><h3 id="1个机制"><a href="#1个机制" class="headerlink" title="1个机制"></a>1个机制</h3><p>从外部新建一个委托的整个生命流程来理解：</p><p>1.申明一个委托实例fbChain，为null。</p><p>2.对其进行 += 操作（Delegate.Combine语法糖），Combine方法内部发现fbChain是null，所以直接返回一个_invocationList为null的委托。</p><p>3.对其再进行 += 操作，Combine方法内部发现fbChain内部已经包含了一个委托,就会构造一个新的委托对象，这个新委托对象的_invocationList字段引用了一个委托对象数组，里面按顺序包含着之前的所有委托。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211213095622.png"></p><p>4.对委托实例fbChain进行调用，实际就是对整个委托链传入参数，依次遍历进行Invoke。</p><p>5.对委托实例fbChain进行 -= 操作（Delegate.Remove语法糖），Remove方法内部倒序循环遍历_invocationList数组，匹配_target和_methodPtr字段相同的元素进行删除，只删除一个元素。</p><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p><strong>Action和Func</strong></p><p>微软定义好的泛型委托就是Action和Func，Action有16个Func有17个。为啥Action少一个？看下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span>;<span class="comment">// 这个不是泛型，所以不算，少在这了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">TResult</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">TResult</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>, <span class="title">TResult</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;委托和事件的区别是什么？&quot;&gt;&lt;a href=&quot;#委托和事件的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;委托和事件的区别是什么？&quot;&gt;&lt;/a&gt;委托和事件的区别是什么？&lt;/h1&gt;&lt;p&gt;委托本质是一个继承自System.MulticastDele</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 常用数据结构篇</title>
    <link href="https://codingcodingk.github.io/Tech/CSharp/Essence/arrary_list_dic/"/>
    <id>https://codingcodingk.github.io/Tech/CSharp/Essence/arrary_list_dic/</id>
    <published>2022-03-18T13:18:05.695Z</published>
    <updated>2022-03-18T13:18:05.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>最基本的数组类型。</p><h2 id="真实类型"><a href="#真实类型" class="headerlink" title="真实类型"></a>真实类型</h2><p>所有数组类型都隐式从<strong>System.Array抽象类</strong>派生，System.Array又从Object派生，所以数组都是<strong>引用类型</strong>。Array实现了IEnumerable、ICollection、IList接口。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>在内存中是连续存储的，所以它的索引速度非常快。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在new的时候，就必须指定它的Length大小。</p><p>数组单个元素的类型：</p><p>如果是值类型比如Int32，就会在托管堆上分配100个未装箱Int32所需的内存块，并给每个Int32实例都附上default值0；<br>如果是引用类型比如Control，就会在托管堆上分配50个Control引用的内存块，并给每个引用都附上null。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>无法动态扩容，只能手动调用接口<code>Array.Resize (ref T[] array, int newSize)</code>。</p><p>内部创建新数组，使用<code>Array.Copy</code>将原数组拷贝到新数组中，再修改传入指针指向新数组。如果新Length还不如原数组Length大，会采用新Length，多的直接截断不要了。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>接口<code>Array.Find (T[] array, Predicate&lt;T&gt; match)</code>。传进去的match是一个签名为“参数为T返回值为bool”的委托，也就是一个比较器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; array.Length; ++index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (match(array[index])) <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话很麻烦，还不如自己遍历。</p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>在数组的基础上加入了动态扩容的概念，因此插入数据更方便了。</p><h2 id="真实类型-1"><a href="#真实类型-1" class="headerlink" title="真实类型"></a>真实类型</h2><p>实现了接口 IList、ICollection、IEnumerable、ICloneable。</p><p>而<strong>内部的数据其实还是用一个object[ ]来装</strong>，字段名是items。没错可以理解ArrayList为对Array的包装。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>虽然比数组多了很多快捷操作接口，但是内部用object[ ]，这导致会频繁发生拆装箱、且类型非常不安全导致你可以塞各种类型到一个ArrayList里。</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>在<code>new ArrayList()</code>中可以指定容量大小，也可以不指定。</p><p>如果不指定，那就将内部items数组设置为<code>ArrayList.emptyArray</code>，一个定义好的定数，实际就是 <code>new object[0]</code>。</p><p>如果指定，那就是<code>new object[capacity]</code>。</p><h2 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h2><p>引入动态扩容，调用接口<code>ArrayList.Add (object val)</code>即可。</p><p>先说结论，如果容量为0则设置为4，否则一旦触发扩容就翻倍，也就是<strong>二倍扩容</strong>。扩容方式就是新建数组替换items。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnsureCapacity</span>(<span class="params"><span class="built_in">int</span> min</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._items.Length &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">int</span> num = <span class="keyword">this</span>._items.Length == <span class="number">0</span> ? <span class="number">4</span> : <span class="keyword">this</span>._items.Length * <span class="number">2</span>; <span class="comment">// num起始值为4，后续只会2倍2倍扩容，因此永远是2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">uint</span>) num &gt; <span class="number">2146435071U</span>)</span><br><span class="line">        num = <span class="number">2146435071</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; min)</span><br><span class="line">        num = min;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.Capacity = num; <span class="comment">// 扩容代码写在 属性Capacity 的set里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Capacity&#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="comment">// 只看核心部分，防错的if判断都被我删了</span></span><br><span class="line">        <span class="built_in">object</span>[] objArray = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="keyword">value</span>];</span><br><span class="line">        Array.Copy((Array) <span class="keyword">this</span>._items, <span class="number">0</span>, (Array) objArray, <span class="number">0</span>, <span class="keyword">this</span>._size);</span><br><span class="line">        <span class="keyword">this</span>._items = objArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>接口<code>ArrayList.Insert (int index, object val)</code></p><p>也就是判断一下 size+1 是否触发动态扩容，然后把index之后的数组值用<code>Array.Copy</code>拷贝到index+1起始位置，然后更新数组index的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.Copy((Array) <span class="keyword">this</span>._items, index, (Array) <span class="keyword">this</span>._items, index + <span class="number">1</span>, <span class="keyword">this</span>._size - index);</span><br><span class="line"><span class="keyword">this</span>._items[index] = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>接口<code>ArrayList.IndexOf (object value)</code></p><p>全遍历。内部for循环遍历，通过<code>obj.Equals(value)</code>比对罢了。</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>接口<code>ArrayList.Remove (object obj)</code></p><p>先用<code>ArrayList.IndexOf</code>查找到index，然后调用<code>ArrayList.RemoveAt</code>。</p><p>RemoveAt内部用了<code>Array.Copy</code>，把 index+1 之后的数组值拷贝到index起始位置，那么原来位于index的值就没了，且数组最后一位会是一个废数据，给它赋null。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.Copy((Array) <span class="keyword">this</span>._items, index + <span class="number">1</span>, (Array) <span class="keyword">this</span>._items, index, <span class="keyword">this</span>._size - index);</span><br><span class="line"><span class="keyword">this</span>._items[<span class="keyword">this</span>._size] = (<span class="built_in">object</span>) <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>在ArrayList的基础上，加入了泛型的概念。类型是<code>List&lt;T&gt;</code>，又叫泛型List。</p><h2 id="真实类型-2"><a href="#真实类型-2" class="headerlink" title="真实类型"></a>真实类型</h2><p>实现接口：IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>。</p><p><strong>内部维持的是一个泛型数组</strong>，<code>T[] _items;</code>。</p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>使用泛型，完美解决了ArrayList的拆装箱问题。</p><h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><p>和ArrayList一样，可以指定可以不指定，不指定就给item赋值<code>new T[0]</code>。</p><h2 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h2><p>和ArrayList一摸一样的<strong>初始为4，后续二倍扩容</strong>。</p><h2 id="插入、查找、移除"><a href="#插入、查找、移除" class="headerlink" title="插入、查找、移除"></a>插入、查找、移除</h2><p>没啥好看的，和前面一样，没有优化。</p><p>接口<code>public T Find (Predicate&lt;T&gt; match)</code>就是传入bool比较器，和Array的一样。接口<code>IndexOf</code>也是直接调用了Array自己的IndexOf，找不到就返回-1。</p><h2 id="linq"><a href="#linq" class="headerlink" title="linq"></a>linq</h2><p>linq拓展方法接口<code>FirstOrDefault</code>内部利用迭代器foreach遍历+bool比较器。</p><p>linq拓展方法接口<code>Where</code>内部利用迭代器，返回一个新的List指针（浅拷贝）。</p><h1 id="散列表、哈希"><a href="#散列表、哈希" class="headerlink" title="散列表、哈希"></a>散列表、哈希</h1><p>在看哈希表、字典这两个类型前，必须掌握的基础数据结构。</p><h2 id="在看之前"><a href="#在看之前" class="headerlink" title="在看之前"></a>在看之前</h2><p>在.Net  模仿java 的过程中   抛弃了 HashMap ，所以以后再去面试.Net的时候当别人问你HashTable 和HashMap 的区别的时候，请告诉他，C#.Net 中  没有HashMap。同时C#中也没有Java中的TreeMap和TreeSet（即底层是由红黑树实现的数据结构）。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数是<strong>单向映射</strong>，因为一个Key只可以映射出一个hashCode，但是一个hashCode却可以被多个Key映射到。</p><p>1、直接寻址法：取keyword或者keyword的某个线性函数值为散列地址，即H(key)=key或者H(key)=a·key+b，当中a和b为常数（这样的散列函数叫做自身函数）。这个的应用就是，比如我们世界地图的掩码，直接用坐标x*1000+坐标y，得到key。</p><p>2、数字分析法：找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。分析一组数据，比方一组员工的出生年月日，这时，我们发现出生年月日的前几位数字大体相同，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构造散列地址，则冲突几率就会明显减少。</p><p>3、平方取中法：取keyword平方后的中间几位作为散列地址。</p><p>4、折叠法：将keyword切割成位数同样的几部分，最后一部分分数能够不同，然后取这及部分的叠加和（去除进位）作为散列地址。</p><p>5、随机数法：选择一随机函数，取keyword的随机值作为散列地址，通常适用于keyword长度不同的场合。</p><p>6、除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即H(key)=key MOP p , p&lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算后取模，对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞。</p><h2 id="C-散列表"><a href="#C-散列表" class="headerlink" title="C#散列表"></a>C#散列表</h2><p>建立一个确定的对应关系，使得每个key值都和一个地址一一对应。</p><ul><li>  存储记录时，通过 散列函数+key值 计算记录的散列地址，并用该地址存储记录。</li><li>  查找记录时，通过同样的 散列函数+key值 计算记录的散列地址，并访问该记录。</li></ul><p>上述的只是完美散列表，理论存在。但是 .NET 的 <em>GetHashCode</em> 方法返回的是Int32，也就是一一对应就只能有最多2^32个key值。但实际肯定不止这么点情况（比如key你可以用Int64），那么会出现问题：多个key值通过算法映射出来的HashCode是相同的，这叫做<strong>哈希冲突</strong>。</p><p>如何解决、减少哈希冲突就成了性能瓶颈。</p><h2 id="C-解决哈希冲突"><a href="#C-解决哈希冲突" class="headerlink" title="C#解决哈希冲突"></a>C#解决哈希冲突</h2><p><strong>Hashtable</strong>：开放定址法（尝试的第一个单元被占了，那么就尝试下一个空单元）。</p><p><strong>Dictionary</strong>：拉链法/链地址法（将所有key取哈希码相同的记录存储在同一线性链表）。</p><p>其他：再哈希法（冲突后再用其他哈希函数哈希，直到不冲突）…</p><h2 id="为什么哈希表长要取质数？"><a href="#为什么哈希表长要取质数？" class="headerlink" title="为什么哈希表长要取质数？"></a>为什么哈希表长要取质数？</h2><p>.net解决哈希冲突：扩容、取质数（质数也叫素数）。</p><p>扩容部分在下面哈希表里再阐述，有一个词叫因子。</p><p><strong>那为什么哈希表长要取质数？</strong>因为表长也就是容量是拿来求模的，如果和被取模的数有公因子，会导致同模的数（也就是冲突的数）之间有更多规律（存在公因子），而现实中我们的 数据源、哈希函数 往往就是有一定的关系比如取长运算就是存在公因子2。那么结果就是，冲突很可能更频繁，当然并不是一定的具体得看你的数据源和哈希函数实现。</p><p>举例：</p><p>默认长度设置为6，则2的倍数（这里不提6自己的倍数毕竟质数也一样）的整数将固定散列在0、2、4这几个数内；3的倍数将固定散布在0、3、6这几个数内。 此时，GetHashCode你可能写成取一系列运算之后*2，那么结果是2、4、6、8、10、12…这样的数，他们取模后分别是2、4、0、2、4、0…，这种 GetHashCode + 表长 实现下的哈希散列表，冲突的概率就非常之大。而换成7这样的质数，取模后是2、4、6、1、3、5…有改进了对吧？</p><h2 id="自己避免哈希冲突"><a href="#自己避免哈希冲突" class="headerlink" title="自己避免哈希冲突"></a>自己避免哈希冲突</h2><p>开发者自己想避免哈希冲突，在.net里就是设计更好的散列表也就是设计更好的GetHashCode，使映射出来的int32值尽可能不重合。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>这里只指.net提供的Hashtable类型。又称哈希表、散列表。机制关键字是<strong>2倍质数扩容、装填因子确定装载数、双重散列法（属于开放定址法）</strong>这3个要点。</p><p><a href="https://blog.csdn.net/exiaojiu/article/details/51206024">https://blog.csdn.net/exiaojiu/article/details/51206024</a></p><p><a href="https://www.cnblogs.com/millionsmultiplication/p/9409290.html">https://www.cnblogs.com/millionsmultiplication/p/9409290.html</a></p><h2 id="真实类型-3"><a href="#真实类型-3" class="headerlink" title="真实类型"></a>真实类型</h2><p>内部数据是<strong>哈希桶</strong>，key-value对均为<strong>object类型</strong>，还有一个hash_coll是<strong>哈希码</strong>。</p><p>数据存在数组buckets里。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Hashtable.bucket[] buckets;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> bucket</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> val;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hash_coll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><p>使用双重散列法，查找内存的时间复杂度为<strong>常数级</strong>。key-val类型是object，因此类型并不安全。</p><h2 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h2><p>装填因子（loadFactor）是 装载数/哈希表长。<strong>它决定了装载数。</strong>值越小，表长越大也就是内存损耗更大，但是哈希冲突更少。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.loadsize = (<span class="built_in">int</span>) ((<span class="built_in">double</span>) <span class="keyword">this</span>.loadFactor * (<span class="built_in">double</span>) newsize); <span class="comment">// 装载数 是被 装填因子 所控制的。newsize是由buckets.Length取得的质数。</span></span><br></pre></td></tr></table></figure><p>加载因子是用户可以控制的，范围是0.1f ~ 1，默认是1。在Hashtable的构造函数中可以输入。</p><p>装填因子默认取0.72，是微软认为的最佳性能默认值。</p><p>最后，装填因子 = 加载因子*装填因子的范围是0.072 ~ 0.72，默认是0.72。</p><h2 id="装载数"><a href="#装载数" class="headerlink" title="装载数"></a>装载数</h2><p>装载数loadsize，装载数比桶数小。</p><p>当装满的桶数count超过装载数时会发生扩容，扩容后装载数随之更新（具体看“插入”）。</p><p>更新公式：loadsize = 装填因子 * 桶数bullets.Length（质数）</p><h2 id="双重散列法⭐"><a href="#双重散列法⭐" class="headerlink" title="双重散列法⭐"></a>双重散列法⭐</h2><p>双重散列法是开放地址法中最好的方法之一。</p><p>简单说就是有2个哈希函数，第一个哈希函数算出key的直接映射值(seed)，第二个哈希函数算出冲突时使用的增量(incr)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">uint</span> <span class="title">InitHash</span>(<span class="params">Object key, <span class="built_in">int</span> hashsize, <span class="keyword">out</span> <span class="built_in">uint</span> seed, <span class="keyword">out</span> <span class="built_in">uint</span> incr</span>)</span> &#123;      </span><br><span class="line">    <span class="built_in">uint</span> hashcode = (<span class="built_in">uint</span>) GetHash(key) &amp; <span class="number">0x7FFFFFFF</span>;<span class="comment">//取整数</span></span><br><span class="line">    seed = (<span class="built_in">uint</span>) hashcode;</span><br><span class="line">    </span><br><span class="line">    incr = (<span class="built_in">uint</span>)(<span class="number">1</span> + ((seed * HashPrime) % ((<span class="built_in">uint</span>)hashsize - <span class="number">1</span>))); <span class="comment">// HashPrime是101定数，暂不知道数学意义</span></span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取好了2个seed、incr两个数据之后，<strong>第一次会去找 bucketNumber = seed % buckets.Length 的值</strong>，如果冲突再找 bucketNumber + incr) % buckets.Length的值，直到匹配。</p><p>注意！注意！注意！上面说的 bucketNumber = seed % buckets.Length ，这很重要，这是哈希桶映射的核心，毕竟算出来的hashCode比buckets.Length（桶数）大太常见了，所以需要取模。<strong>这意味着扩容后， buckets.Length发生改变，buckets内部全体都需要重新排列。</strong></p><h2 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h2><p>可以输入加载因子和容量，默认的加载因子是1。</p><p>初始化时，**loadFactor = 0.72f * 加载因子(0.1f ~ 1)**。容量则最小为3（最小质数）。</p><h2 id="扩容-3"><a href="#扩容-3" class="headerlink" title="扩容"></a>扩容</h2><p>首先将冲突数occupancy归零，创建新bullets，然后开始拷贝旧数据。</p><p>1.创建新bullets。那它的数组长度（桶数）怎么确定？</p><p>​    如果是常规扩容（不是因为冲突数超过了预装载量），就会去质数表里找一个最小的、大于等于 bullets长度 * 2 的质数作为新的bullets长度。质数表：HashHelpers里的一个枚举数组，是个并不连续的质数表，从3开始一共有72个。</p><p>​    如果是冲突扩容（冲突数超过了预装载量），就按照目前bullets长度进行拷贝旧数据操作。所以实际并没有扩容，只做了拷贝旧数据操作，应该是因为冲突太多希望重新排列一次数据。</p><p>2.拷贝旧数据。并不是简单的复制粘贴，而是<strong>遍历buckets数组、利用putEntry重新添加元素</strong>。putEntry是Hashtable的内部插值方法，仍然是双重散列法插。为什么不直接复制粘贴？很简单，因为buckets.Length（桶数）变了，那么所有的<code>hashCode % buckets.Length</code>的下标位置都得变。</p><p>大规模的putEntry终究是高时耗的，所以新建hashtable时最好选择一个稍大的容量，避免重复扩容。</p><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>Insert的内部操作分三个步骤：</p><p>1.判断key是否为空，如果空，哈希函数是无法计算地址的。</p><p>2.判断<strong>bullets实际使用条目数count（装满的桶数） 是否大于等于装载数</strong>，如果满足，哈希表需要扩容为原来装载数的2倍以上（从质数表里取）；如果前一条不满足，则继续判断<strong>冲突数是否大于装载数</strong>，如果大于，则扩容。</p><p>3.接着在循环体内按照双重散列法寻找对应键值的桶并为对应键值的桶赋值。</p><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><p>就是双重散列法。</p><h2 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h2><p>核心就是按照双重散列法寻找对应键值的桶后将桶变成空桶，然后count–（实际桶数）。</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p><code>Dictionary&lt;TKey, TValue&gt;</code>泛型字典，解决Hashtable拆装箱。机制关键字是<strong>buckets+entries双数组、拉链法基础上改进、FreeList单链表</strong>这3个要点。</p><p><a href="https://www.cnblogs.com/xiaomowang/">https://www.cnblogs.com/xiaomowang/</a></p><h2 id="真实类型-4"><a href="#真实类型-4" class="headerlink" title="真实类型"></a>真实类型</h2><p>这里哈希桶主要用来进行Hash碰撞（和Hashtable类不一样），Entry数组用来存储字典的内容，并且标识下一个元素的位置。</p><p>Entry数组是一个单链表。</p><p>KeyCollection、ValueCollection内部真实数据就是这个字典本身。然后KeyCollection和ValueCollection实现了一些常用接口，比如GetEnumerator返回的时候帮你把字典的迭代返回类型<code>KeyValuePair&lt;TKey, TValue&gt;</code>转换成<code>TKey / TValue</code>了再返回。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] buckets; <span class="comment">// Hash桶，桶的下标是hashCode，桶内的int值是entries单链表的链下标</span></span><br><span class="line"><span class="keyword">private</span> Entry[] entries; <span class="comment">// Entry数组，存放元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> count; <span class="comment">// 当前entries的index位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> version; <span class="comment">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeList; <span class="comment">// 被删除Entry在entries中的下标index，这个位置是空闲的</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeCount; <span class="comment">// 有多少个被删除的Entry，有多少个空闲的位置</span></span><br><span class="line"><span class="keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer; <span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> KeyCollection keys; <span class="comment">// 存放Key的集合，内部用 Dictionary&lt;TKey, TValue&gt; dictionary</span></span><br><span class="line"><span class="keyword">private</span> ValueCollection values; <span class="comment">// 存放Value的集合，内部用 Dictionary&lt;TKey, TValue&gt; dictionary</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> Entry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hashCode;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> next; <span class="comment">// 证明entries是一个单链表！这样使得哈希冲突得以解决！</span></span><br><span class="line">    <span class="keyword">public</span> TKey key;</span><br><span class="line">    <span class="keyword">public</span> TValue <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><p>字典和哈希表不一样！它内部可不是用双重散列法了。</p><h2 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h2><p>如果不指定capacity，那么就基本什么也不做。内部方法<code>Initialize (capacity)</code>的调用，则会在第一次<code>Add</code>时进行。</p><p>如果指定了capacity，那么就会调用内部方法<code>Initialize (capacity)</code>。</p><p>1.首先，去质数表找一个大于等于capacity的质数（和Hashtable一样），作为哈希桶容量。</p><p>2.new哈希桶，全部赋值-1。</p><p>3.new Entry数组。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> prime = HashHelpers.GetPrime(capacity);</span><br><span class="line">    <span class="keyword">this</span>.buckets = <span class="keyword">new</span> <span class="built_in">int</span>[prime];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; <span class="keyword">this</span>.buckets.Length; ++index)</span><br><span class="line">        <span class="keyword">this</span>.buckets[index] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.entries = <span class="keyword">new</span> Dictionary&lt;TKey, TValue&gt;.Entry[prime];</span><br><span class="line">    <span class="keyword">this</span>.freeList = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容-4"><a href="#扩容-4" class="headerlink" title="扩容"></a>扩容</h2><h3 id="扩容时机"><a href="#扩容时机" class="headerlink" title="扩容时机"></a>扩容时机</h3><p>1.非冲突扩容。触发时机是Entries实际使用 == Entries元素总数。</p><p>2.冲突扩容（其实不是扩容，是重排序，但不用一个一个插入）</p><h3 id="扩容方式"><a href="#扩容方式" class="headerlink" title="扩容方式"></a>扩容方式</h3><p>先建新Buckets、Entries数组。新数组大小没有装填因子的概念，就是二倍扩容找质数罢了。</p><p>再直接拷贝Entries数组，直接<code>Array.Copy</code>（和Hashtable不一样）。</p><p>// 如果是冲突重排序，那么此时还需要把Entries里所有的元素重新计算一遍HashCode（当然我觉得没啥用）。</p><p>最后遍历Entries，对每个元素都进行<strong>重新映射赋值Buckets、重建链表</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> index1 = <span class="number">0</span>; index1 &lt; <span class="keyword">this</span>.count; ++index1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> index2 = entryArray[index1].hashCode % newSize; <span class="comment">// 重新赋值Buckets映射，因为扩容导致Size变了所以需要%newSize！</span></span><br><span class="line">entryArray[index1].next = numArray[index2]; <span class="comment">// 重链</span></span><br><span class="line">numArray[index2] = index1; <span class="comment">// 重链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h2><p><code>Add</code>接口，会直接调用内部方法<code>Insert</code>。</p><p>1.首先检测是不是没有执行初始化（new时没有输入capacity），没的话就执行<code>Initialize (0)</code>。</p><p>2.和下图一样，先<strong>哈希 + 位与intMax + 取模</strong>映射到Buckets下标，</p><p>  如果发现对应的桶内装的是-1，那就是没冲突过的哈希，不用处理；</p><p>  如果发现对应的桶内装的不是-1，那就是冲突了的哈希，就取找对应Entries里的元素，这个元素就是链头，获取它的Next，一直往后找，找到链尾（Next == -1），记录出冲突数num。</p><p>3.有个叫FreeList的单链表，它本身是个int（具体看“移除”节）。总之，会先去FreeList找碎片形式的Entry位，如果FreeList是空的（FreeCount == 0 ）就直接往后找从没用过的Entry位（具体就是用count++）。</p><p>找到新的Entry位后，如果没冲突过就将其Next设置成-1，如果冲突过就将它设置为新的链头。转化为代码很简单，就是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entries[没用过的Entry位].Next = Buckets[hashCode]; <span class="comment">// Buckets[hashCode]默认是-1，否则是链头</span></span><br><span class="line">Buckets[hashCode] = 没用过的Entry位;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220314144040.png"></p><h2 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h2><p>找起来就挺容易的，毕竟处理操作都在插入、移除的时候做好了。简单来说就是<strong>链地址法</strong>。</p><h2 id="移除-2"><a href="#移除-2" class="headerlink" title="移除"></a>移除</h2><p><code>Remove</code>接口。</p><p>分2步，第一步是根据Key算出哈希映射值，找到对应桶中指向的Entry结点。根据清空进行 <strong>更新链头or清空桶 / 更新链表</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (桶内指向的是链头)</span><br><span class="line">     <span class="keyword">this</span>.buckets[index1] = <span class="keyword">this</span>.entries[index3].next; <span class="comment">// 桶内指向新的链头。如果Entry无后续结点（Next是-1），相当于直接把桶也清空了。</span></span><br><span class="line"><span class="keyword">else</span> (桶内指向的是链中的某个结点)</span><br><span class="line">    <span class="keyword">this</span>.entries[index2].next = <span class="keyword">this</span>.entries[index3].next; <span class="comment">// 在链中删除结点</span></span><br></pre></td></tr></table></figure><p>第二步，<strong>把上面去掉的Entry节点清空内容后，作为FreeList的新链头</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.entries[index3].hashCode = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span>.entries[index3].key = <span class="literal">default</span> (TKey);</span><br><span class="line"><span class="keyword">this</span>.entries[index3].<span class="keyword">value</span> = <span class="literal">default</span> (TValue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.entries[index3].next = <span class="keyword">this</span>.freeList;</span><br><span class="line"><span class="keyword">this</span>.freeList = index3;</span><br><span class="line">++<span class="keyword">this</span>.freeCount;</span><br><span class="line">++<span class="keyword">this</span>.version;</span><br></pre></td></tr></table></figure><h1 id="哈希表vs字典"><a href="#哈希表vs字典" class="headerlink" title="哈希表vs字典"></a>哈希表vs字典</h1><p>解决冲突的方法不同。Hashtable用的是基于开放地址法的<strong>双重散列法</strong>；Dictionary用的是<strong>拉链法</strong>。</p><p>桶装的东西不同。内部都用到了桶的概念，但是Hashtable的桶装的是数据实体；Dictionary桶装的是int，存放着实体数组Entries的链头。</p><p>都是二倍质数扩容，但是扩容的时机不同。Hashtable多了<strong>装填因子、装载数</strong>的概念；Dictionary就直接<strong>比对count和Entries.Length</strong>。</p><h1 id="线程安全字典"><a href="#线程安全字典" class="headerlink" title="线程安全字典"></a>线程安全字典</h1><p>ConcurrentDictionary。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConcurrentDictionary&lt;TKey, TValue&gt;.Tables m_tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Tables</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;TKey, TValue&gt;.Node[] m_buckets;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> <span class="built_in">object</span>[] m_locks;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">volatile</span> <span class="built_in">int</span>[] m_countPerLock;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> IEqualityComparer&lt;TKey&gt; m_comparer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上很多对比ConcurrentDictionary和Dictionary+Lock效率的文章，说大规模情况下ConcurrentDictionary读快、Dictionary+Lock写快。所以更多会选择Dictionary+Lock的方案。</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="IEnumerable和IEnumerator区别"><a href="#IEnumerable和IEnumerator区别" class="headerlink" title="IEnumerable和IEnumerator区别"></a>IEnumerable和IEnumerator区别</h2><p>IEnumerable<strong>可迭代的</strong>是一个声明式的接口，声明实现该接口的类就是“可迭代的”，但并没用说明如何实现迭代器(iterator)。</p><p>IEnumerator<strong>迭代器</strong>是一个实现式的接口，它提供了具体怎么实现“可迭代的”。</p><p>我们自己写代码，一般给类实现IEnumerable接口即可。</p><p>IEnumerable：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;<span class="comment">// 返回一个循环访问集合的枚举器/迭代器。用于外部循环访问。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IEnumerator：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IDisposable</span>, <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    T Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach支持"><a href="#foreach支持" class="headerlink" title="foreach支持"></a>foreach支持</h2><p>用foreach遍历，并不需要实现IEnumerable接口，只要显式的实现IEnumerator GetEnumberator 无参方法即可。</p><p>foreach本质也是个语法糖，编译器帮你获取对象迭代器然后<code>while(MoveNext)&#123; Current &#125;</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator enumerator = test.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> current = enumerator.Current;</span><br><span class="line">    <span class="comment">// 下面是自己的代码</span></span><br><span class="line">    Console.WriteLine(current.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield使用"><a href="#yield使用" class="headerlink" title="yield使用"></a>yield使用</h2><p>普通使用迭代器的话，无效代码太多了。下面就是一个我选择最简单实现的例子，可以正常foreach。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Test_Iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Iterator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] datas = <span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> point = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        point++;</span><br><span class="line">        <span class="keyword">return</span> point &lt; datas.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        point = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = point % datas.Length;</span><br><span class="line">            <span class="keyword">return</span> datas[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是c#引入了yield语法糖，实现就容易多了。</p><p>可以在<strong>方法</strong>，<strong>属性</strong> 和 <strong>索引器</strong>中使用 <strong>yield 来</strong>实现<strong>迭代器</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">string</span>[] datas = <span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; datas.Length; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> datas[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yiled解析"><a href="#yiled解析" class="headerlink" title="yiled解析"></a>yiled解析</h2><p>yield语法糖，其实是编译器帮你在你定义的类中，生成了一个新的 IEnumerator实现类。接口需要的<strong>MoveNext、Reset、Current</strong>编译器都帮你用默认方式实现好了。</p><p>而<code> yield return; yield break;</code> 语法糖本身实现的意义，就是在MoveNext里写case。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (&lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="literal">default</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// yield return 3;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             &lt;&gt;<span class="number">2</span>__current = <span class="number">3</span>;</span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// yield return 5;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             &lt;&gt;<span class="number">2</span>__current = <span class="number">5</span>;</span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">2</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// yield break;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>// TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;最基本的数组类型。&lt;/p&gt;
&lt;h2 id=&quot;真实类型&quot;&gt;&lt;a href=&quot;#真实类型&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
</feed>
