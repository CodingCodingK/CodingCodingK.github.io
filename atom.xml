<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2022-06-22T16:40:04.078Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Games101 - 着色</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-6/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-6/</id>
    <published>2022-06-22T14:32:28.598Z</published>
    <updated>2022-06-22T16:40:04.078Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目前为止我们学会了什么？</strong></p><p>相机和物体 -&gt; 变换坐标到原点 -&gt; 拉伸后映射成2D图像 -&gt; 对2D图像进行光栅化：滤波、采样、后处理，最终变成屏幕上的像素点</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622162501.png"></p><p>现在我们引入<strong>着色</strong>。</p><h1 id="着色-Shading"><a href="#着色-Shading" class="headerlink" title="着色 Shading"></a>着色 Shading</h1><h2 id="什么是着色？"><a href="#什么是着色？" class="headerlink" title="什么是着色？"></a>什么是着色？</h2><p>着色在普世意义上，是对明暗、颜色进行绘制。</p><p>而在图形学中，<strong>着色是一个对物体应用材质的过程</strong>，正是材质的不同才导致颜色不同。</p><h2 id="理解一个简单的着色模型"><a href="#理解一个简单的着色模型" class="headerlink" title="理解一个简单的着色模型"></a>理解一个简单的着色模型</h2><p><strong>Blinn-Phong Reflectance Model</strong> 是一个常用参考的光照反射模型，它分为以下：</p><p><strong>高光 Specular highlights</strong>：一根光线打到光滑平面（比如镜面）上，会往镜面反射附近去反射。</p><p><strong>漫反射 Diffuse reflections</strong>：一根光线打到粗糙平面（比如墙面）上，被反射到各个地方的情况。图中茶杯从浅黄到深黄的变化。</p><p><strong>环境光照 Ambient lighting</strong>：是由间接光源组成的光源统称。图中光线并没有直接打到箭头处，而是打到桌面上被反射，反射光再打到了箭头处。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622163914.png"></p><h2 id="开始前先定义一个“着色点”-shading-point"><a href="#开始前先定义一个“着色点”-shading-point" class="headerlink" title="开始前先定义一个“着色点” shading point"></a>开始前先定义一个“着色点” shading point</h2><p>虽然反射到的面有曲面、有直面，但我们只观察一个最小的反射点，那么曲面的极小也可以当作<strong>直面</strong>。这个被观察的点我们叫做 <strong>shading point</strong> ，同时再定义几个其他的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622170625.png"></p><p>单位向量 v：和相机的连线。</p><p>单位向量 n：反射面的法线。</p><p>单位向量 l：光照方向。</p><p>表面参数：颜色 color、反射强度 shininess、…</p><p><strong>着色的局部性 shading is local：我们着色只关注光线照过来这个点该怎么着色。</strong>比如因为遮挡产生的阴影，着色器是不考虑的。</p><p>接下来我们根据定义好的观测点 shading point，来分析上面提到的3种反射情况。</p><h2 id="漫反射-Diffuse-reflections"><a href="#漫反射-Diffuse-reflections" class="headerlink" title="漫反射 Diffuse reflections"></a>漫反射 Diffuse reflections</h2><p>一根光线打到一个点上时，会被均匀反射到四周。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622173813.png"></p><p>通过观察就可以知道，着色点的法线n和光照打来的方向l的夹角θ，会和这个着色点接收到的光照能量成反比。而这个反比有一个推导，叫 <strong>朗伯余弦定理 Lambert’s cosine law</strong>。</p><p>朗伯余弦定理的推导中，将点光源发出的光的轨迹视作一个个圆球体，而根据能量守恒，只要在真空中传播没有发生损耗，这些圆球体上某点的能量和圆球体表面积（也就是半径平方r）成正比。</p><p>最终公式如下：<img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622182248.png"></p><p>从上面也能得知一件事，就是<strong>漫反射与观测方向v无关</strong> =&gt; 通俗点说就是某点被漫反射了，即使你在不同的位置看它，它的着色情况也是不变的。</p><p>公式里还有个系数kd，这是颜色系数，乘以漫反射光的强度（右边的值），得到最终显示的颜色。</p><h2 id="高光-Specular-Term"><a href="#高光-Specular-Term" class="headerlink" title="高光 Specular Term"></a>高光 Specular Term</h2><p><strong>高光与v有关。</strong>当你的观测角度v，和反射光的方向R一致或者接近的时候，你才能看到高光。</p><p>而观测角度v和反射光R的夹角有多大，又可以转化为更简单的计算：求l和v的中间向量，然后和法线n求夹角。 这一个计算转化算是优化了，计算R和v夹角的方式叫做Phong模型，而我们这种优化的方式叫做<strong>Blinn-Phong模型</strong>，推导过程和最终公式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623001727.png"></p><p>公式里还有一个问题，就是为什么要有一个<strong>P次方</strong>去处理cosα？原因是cos函数的容忍度太大了，导致非常大的夹角仍然能保持高光，这是不合理的，所以需要人为控制一下，一般P会采用256甚至以上，让夹角控制在3°以内。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623003907.png"></p><h2 id="环境光照-Ambient-Term"><a href="#环境光照-Ambient-Term" class="headerlink" title="环境光照 Ambient Term"></a>环境光照 Ambient Term</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;目前为止我们学会了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相机和物体 -&amp;gt; 变换坐标到原点 -&amp;gt; 拉伸后映射成2D图像 -&amp;gt; 对2D图像进行光栅化：滤波、采样、后处理，最终变成屏幕上的像素点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:/</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 遮挡与深度</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-5/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-5/</id>
    <published>2022-06-22T14:32:28.594Z</published>
    <updated>2022-06-22T14:32:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>之前几节课学了怎么映射一个三角面到画面上，这节学多个三角面之间的遮挡关系处理，谁在前谁在后，也就是<strong>可见性</strong>怎么处理。</p><h1 id="实现遮挡关系"><a href="#实现遮挡关系" class="headerlink" title="实现遮挡关系"></a>实现遮挡关系</h1><h2 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h2><p>由远及近依次画（光栅化）。近的物体覆盖远的物体，就可以实现遮挡关系。</p><p>但是画家算法也存在一些问题，比如存在一些不可依赖深度排序解决的问题。所以不会直接用画家算法。</p><h2 id="深度缓存-Z-Buffer"><a href="#深度缓存-Z-Buffer" class="headerlink" title="深度缓存 Z-Buffer"></a>深度缓存 Z-Buffer</h2><p>这是工业界采用的算法。这里的z不是z轴，而是深度 depth，是摄像机位置到所求点的距离。</p><p>最后，只渲染每个像素上depth最浅的那个颜色。当物体发生运动后，会同步更新深度，有更小值出现就重新赋色。</p><p>深度缓存的复杂度是O(n)，而不是排序的O(nlogn)，因为深度缓存并不排序只求最小值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前几节课学了怎么映射一个三角面到画面上，这节学多个三角面之间的遮挡关系处理，谁在前谁在后，也就是&lt;strong&gt;可见性&lt;/strong&gt;怎么处理。&lt;/p&gt;
&lt;h1 id=&quot;实现遮挡关系&quot;&gt;&lt;a href=&quot;#实现遮挡关系&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 光栅化</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-4/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-4/</id>
    <published>2022-06-22T14:32:28.591Z</published>
    <updated>2022-06-22T14:32:28.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学之前你必须知道"><a href="#学之前你必须知道" class="headerlink" title="学之前你必须知道"></a>学之前你必须知道</h1><h2 id="视锥"><a href="#视锥" class="headerlink" title="视锥"></a>视锥</h2><p>这是透视相机的概念，用来衡量视距的大小。一般用2种属性来描述一个视锥：</p><ol><li>  near面的宽高比</li><li>  垂直视角 Vertical Field of View</li></ol><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621104507.png"></p><p>有了上面2个确定值，然后再自己定义一个near的值（近平面与相机的距离），就能确定成像了，视锥完成。</p><h2 id="屏幕上的概念"><a href="#屏幕上的概念" class="headerlink" title="屏幕上的概念"></a>屏幕上的概念</h2><p><strong>分辨率</strong>，也就是1080p、2k等，就是像素的多少。</p><p><strong>屏幕 Raster</strong>，德语中的屏幕的意思，而屏幕是一个光栅成像设备。</p><p><strong>光栅化 Rasterize</strong>，把东西画在屏幕上的过程。</p><p><strong>像素 Pixel</strong>，全名picture element，是最小单位的小正方形，它的颜色由Red、Green、Blue三个色(0~255)来混和成。</p><h2 id="屏幕发展过程"><a href="#屏幕发展过程" class="headerlink" title="屏幕发展过程"></a>屏幕发展过程</h2><p><strong>过去方式</strong></p><ol><li>  示波器</li><li>  阴极射线管 Cathode Ray Tube：和示波器原理相同，用很多电子打在屏幕上。通过扫描一样的方式，一条一条画横线，组成图像。</li></ol><p>隔行扫描 Raster Scan：上面的画横线，优化的话还会在一帧只画1、3、5…奇数行，下一帧再只画偶数行。这样省去了一半的工作量，也能一定程度欺骗到肉眼。</p><p><strong>现代方式</strong></p><ol><li>  液晶显示器 LCD（Liquid Crystal Display）：通过液晶扭曲光的方向，让其可以通过对应的光栅。</li><li>  控制发光二极管的显示器 LED（Light Emitting diode array）</li><li>  电墨水：通过电子控制只有黑、白像素的电墨水，实现电纸书的页面刷新。</li></ol><p>帧缓存技术 Frame Buffer（Memory for a Raster Display）：将显卡中的一块内存区域中，存储的内容反映到屏幕上。</p><h1 id="光栅化一个Cube"><a href="#光栅化一个Cube" class="headerlink" title="光栅化一个Cube"></a>光栅化一个Cube</h1><h2 id="视口变换-Viewport"><a href="#视口变换-Viewport" class="headerlink" title="视口变换 Viewport"></a>视口变换 Viewport</h2><p>光栅化之前要做的事。将一个 <code>[-1,1] x [-1,1]</code> 的2维平面，转换成<code>[width,0] x [0,height]</code>的笛卡尔坐标系内来表示。这叫做视口变换，看下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621115856.png"></p><p>最后算出，变换矩阵如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621121741.png"></p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>我们将原图形分解成很多个三角面，投影到屏幕的像素点上。</p><h3 id="首先，怎么判断一个像素点与三角形的位置关系？"><a href="#首先，怎么判断一个像素点与三角形的位置关系？" class="headerlink" title="首先，怎么判断一个像素点与三角形的位置关系？"></a>首先，怎么判断一个像素点与三角形的位置关系？</h3><p>靠前面的知识，已经可以做到任何一个点都确定性地投影到屏幕上了。</p><p>那么如果想判断一个像素点是否在一个三角面内呢？也就是问，<strong>如何确定这个像素的着色？</strong></p><p>可以通过判断这个像素点的中心点与三角形的位置关系来确定，为了方便，就定义一个判断函数<code>Inside()</code>。而这个函数就是进行3次叉积。</p><h3 id="然后，哪些像素点需要判断呢？"><a href="#然后，哪些像素点需要判断呢？" class="headerlink" title="然后，哪些像素点需要判断呢？"></a>然后，哪些像素点需要判断呢？</h3><p>如果需要把整个屏幕的点都进行一次<code>Inside()</code>判断，实在是没有必要，那么哪些需要、哪些不需要，这就涉及到<strong>包围盒</strong>了。</p><p>简单介绍一个AABB包围盒，它就是取三角面3个顶点的<code>Min(x), Min(y), Max(x), Max(y),</code>作为他的盒子。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621151747.png"></p><h3 id="最后，成像完有锯齿-Jaggies-怎么解决？"><a href="#最后，成像完有锯齿-Jaggies-怎么解决？" class="headerlink" title="最后，成像完有锯齿 (Jaggies) 怎么解决？"></a>最后，成像完有锯齿 (Jaggies) 怎么解决？</h3><p>又叫做反走样（Aliasing ）、抗锯齿。</p><p>在解决之前先理解为什么会有这类问题？取哪些像素点来表示这个三角面，叫做<strong>采样（Sample）</strong>。而采样会有3种<strong>瑕疵（Artifacts）</strong></p><ol><li>  锯齿 Jaggies</li><li>  摩尔纹 Moire</li><li>  运动速度过快 Wagon wheel effect</li></ol><p>产生原因是信号变化的速度太快，而采样速度跟不上了。</p><p><strong>那么怎么抗锯齿？</strong></p><p>可以对三角面做预处理，比如滤波、模糊，之后再进行采样。</p><h1 id="抗锯齿-Anti-Aliasing"><a href="#抗锯齿-Anti-Aliasing" class="headerlink" title="抗锯齿 Anti-Aliasing"></a>抗锯齿 Anti-Aliasing</h1><p>前面了解了为什么会产生锯齿，以及大致的抗锯齿技术（滤波、模糊）。这里细说。</p><p><strong>频域 Frequency Domain</strong>：描述信号在频率方面特性时用到的一种坐标系。想象一下cos2Π的图。</p><p><strong>滤波 Filtering</strong>：把某个时段内，特殊的频率给过滤掉。</p><p><strong>傅里叶变换</strong>：变幻的具体内容不要深究，只要知道，可以通过傅里叶变换把一张图变换为频域图，这样就能知道哪些地方的信号量多、少。中心定义为低频、周围定义为高频。最后，得到的频域图，是可逆的！</p><p>// TODO 下面的都只简单理解，更为深入要去学习 数字图像处理</p><h2 id="先傅里叶变换，再过滤一张图-FFP"><a href="#先傅里叶变换，再过滤一张图-FFP" class="headerlink" title="先傅里叶变换，再过滤一张图 FFP"></a>先傅里叶变换，再过滤一张图 FFP</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621180700.png"></p><p>中心定义为低频、周围定义为高频。当颜色变化差异巨大的时候（比如人物边缘），会产生高频信息。</p><p>为什么会有十字线？没有学过信号学不能看懂这张频谱图，只能理解为傅里叶变换前会把这一张图复制很多份拼起来，来取样。拼起来之后每张图的4个边的边界之间的信息差异巨大，就有巨大的高频信息，而这十字线的高亮就是边界的映射。</p><h3 id="高通率波"><a href="#高通率波" class="headerlink" title="高通率波"></a>高通率波</h3><p>High-pass，就是只有高频能通过，低频直接忽略的滤波方式。可以看到，逆变换回来的图几乎只保留了边界信息（人物描边），这是因为<strong>边界处的信号量差异很大，这就是高频的信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182236.png"></p><h3 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h3><p>滤掉高频，也就是滤掉边界信息，那么就会像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182524.png"></p><h3 id="高低滤波"><a href="#高低滤波" class="headerlink" title="高低滤波"></a>高低滤波</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622105657.png"></p><h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><p>只简单概述结论：</p><p>在空间域中，对一张图进行卷积滤波 = 对一张图进行傅里叶变换、再对其乘以卷积核的傅里叶变换、最后逆傅里叶变换回去</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622111008.png"></p><h1 id="采样-Sample"><a href="#采样-Sample" class="headerlink" title="采样 Sample"></a>采样 Sample</h1><p>稀疏采样会产生更多混叠，导致走样；密集采样更少混叠，所以映射结果更好一些。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622114336.png"></p><h2 id="怎么较少走样，也就是如何反走样？"><a href="#怎么较少走样，也就是如何反走样？" class="headerlink" title="怎么较少走样，也就是如何反走样？"></a>怎么较少走样，也就是如何反走样？</h2><p>本质上，就是想办法增大傅里叶副本之间的距离来减少混叠。</p><p><strong>1.增加采样率</strong>（更高分辨率的屏幕）</p><p><strong>2.抗锯齿</strong>，通过对图像模糊预处理（使用傅里叶来低通滤波）再采样</p><h2 id="常规采样流程"><a href="#常规采样流程" class="headerlink" title="常规采样流程"></a>常规采样流程</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622115530.png"></p><p>先用低通滤波器模糊原图，然后再采样。</p><h3 id="抗锯齿：模糊操作"><a href="#抗锯齿：模糊操作" class="headerlink" title="抗锯齿：模糊操作"></a>抗锯齿：模糊操作</h3><p>取像素颜色时，根据三角面的在该像素块中覆盖的面积，来设置灰度。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622120331.png"></p><p>这个理论很简单，但是实现比较困难，于是采用一种类似的方法，对一个像素块再进行划分、进行更多的采样，也就是**多重采样抗锯齿 MSAA (MultiSampling Anti-Aliasing) **来实现。</p><p>下图就是一个MSAA的例子：把一个像素格分成了2x2，来确定0%、25%、50%、75%、100%。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622121659.png"></p><p>工业界会优化，想要2x2的效果不会这么单纯的分割成4个正方形，而是一些其他不规则图形，甚至可能多个像素块复用一个点，这么做都是为了减少需要检测的点数量。</p><h3 id="其他抗锯齿方法"><a href="#其他抗锯齿方法" class="headerlink" title="其他抗锯齿方法"></a>其他抗锯齿方法</h3><p>FXAA（Fast Approximate AA）：快速近似抗锯齿，是一种后处理，会对有锯齿的地方进行修正。</p><p>TAA（Temporal AA）：利用时间而不是空间采样，对于静止的连续帧，上一帧有效的采样点才继续采样。</p><p>DLSS（DeepLearning SuperSimple）：当低分辨率拉伸成高分辨率时，会有很多锯齿，此时用深度学习来猜测描绘。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学之前你必须知道&quot;&gt;&lt;a href=&quot;#学之前你必须知道&quot; class=&quot;headerlink&quot; title=&quot;学之前你必须知道&quot;&gt;&lt;/a&gt;学之前你必须知道&lt;/h1&gt;&lt;h2 id=&quot;视锥&quot;&gt;&lt;a href=&quot;#视锥&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - MVP变换</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-3/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-3/</id>
    <published>2022-06-17T01:51:05.738Z</published>
    <updated>2022-06-22T14:32:28.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从三维旋转到欧拉角"><a href="#从三维旋转到欧拉角" class="headerlink" title="从三维旋转到欧拉角"></a>从三维旋转到欧拉角</h1><p>首先三维旋转绕某个轴旋转，已经知道是这样的了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p><p>那么就可以通过对3个轴的旋转分别描述，来实现复杂的旋转角。这3个旋转角就叫做欧拉角。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620123437.png"></p><h1 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h1><p>一个公式，来实现绕轴n旋转α角度。轴n的定义为起点为原点，方向为n。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620141702.png"></p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>// TODO</p><h1 id="四元数的引入"><a href="#四元数的引入" class="headerlink" title="四元数的引入"></a>四元数的引入</h1><p>由于用旋转矩阵来做<strong>平滑插值</strong>并不合理（旋转20°矩阵 和 旋转50°矩阵 的平均值并不是旋转35°），并且存在<strong>万向锁</strong>问题，所以引入四元数。games101不展开。</p><h1 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h1><p>Model-View-Projection 模型-视图-投影变换：将3D的模型（Model）投影到2D的屏幕（View）上。</p><p>先定义相机的 <strong>位置 Position、朝向 Look-at、向上方向 Up direction</strong>（与朝向垂直，用于确定相机本身的旋转角）。</p><p>视图结果是相对不变的，当物体和相机的移动方式完全一致、没有相对运动时，成像不变。</p><h2 id="标准相机"><a href="#标准相机" class="headerlink" title="标准相机"></a>标准相机</h2><p>我们定义一个Position在 原点，Look-at在 -Z，Up direction在 Y的相机作为默认相机。</p><p>以后就可以将其他相机移成标准相机、然后再做变换、最后移回就实现了相机旋转。</p><h2 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影 Projection"></a>投影 Projection</h2><p>投影是说3D转到2D屏幕的过程。首先分2种，<strong>正交投影</strong>和<strong>透视投影 Perspective</strong>。</p><p>正交不会有近大远小、每个平行边也不会有交点，但透视都会有。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620161157.png"></p><h2 id="正交投影-Orthographic"><a href="#正交投影-Orthographic" class="headerlink" title="正交投影 Orthographic"></a>正交投影 Orthographic</h2><p>定义6个点，就可以描述一个3维的长方体：</p><p>x轴：left =&gt; right ；y轴：buttom =&gt; top ；<font color="red">z轴：fear =&gt; near</font> 。</p><p>注意z轴，因为上面所有的<code>=&gt;</code>指的都是右手坐标系的负=&gt;正，near离我们更近、被定义为正值。</p><p>OpenGL用的是左手坐标系，全部相反。</p><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620182401.png"></p><p>上图的过程就是标准化，也就是将一个长方体变成一个中心点为原点，6个点为-1、1的正方体。标准化的好处是能够更好做正交相机的投影。</p><p>标准化的变换矩阵如下，将长度定为2是为了满足(-1,1)。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620184611.png"></p><h2 id="透视投影-Perspective"><a href="#透视投影-Perspective" class="headerlink" title="透视投影 Perspective"></a>透视投影 Perspective</h2><p>近大远小、平行线会相交。这是因为不同平面内的线投影到一个平面，会有交点。</p><h3 id="齐次坐标性质"><a href="#齐次坐标性质" class="headerlink" title="齐次坐标性质"></a>齐次坐标性质</h3><p>(x,y,z,1) 和 (kx,ky,kz,k) 表示的是同一个点。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620190109.png"></p><h3 id="透视投影拆分⭐"><a href="#透视投影拆分⭐" class="headerlink" title="透视投影拆分⭐"></a>透视投影拆分⭐</h3><p>要实现一个透视投影变换，拆成2步：1.将透视投影相机视锥，挤成一个长方体（正交相机视锥）；2.将得到的长方体进行正交投影。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620225451.png"></p><p>第二步的做法已经在正交投影里写了，那么关键就是第一步怎么做，其实就是乘以一个 <strong>透视=&gt;正交 的拉伸矩阵M</strong>。</p><p>这个矩阵M（4x4）的推导如下：</p><p>1.近似三角形可推导出除了第三行以外的所有矩阵</p><p>2.性质：近平面点挤压后，点坐标的x,y,z都不变（相机的近平面，就是最终2d屏幕的大小）</p><p>3.性质：远平面点挤压后，点坐标的z不变（z轴是深度，想象一下拉伸后，远平面的深度不会变）</p><p>4.根据性质2、3可以推导出矩阵的第三行</p><p>具体推导看第四章的PPT p29-36吧，这里把主要的近似三角形概念图放下来，结合上面的拉伸概念图可以自己推导了：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620235549.png"></p><p>最后4x4的透视=&gt;正交 的拉伸矩阵M：</p><p>n    0    0    0<br>0    n    0    0<br>0    0    n+f    -nf<br>0    0    1    0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从三维旋转到欧拉角&quot;&gt;&lt;a href=&quot;#从三维旋转到欧拉角&quot; class=&quot;headerlink&quot; title=&quot;从三维旋转到欧拉角&quot;&gt;&lt;/a&gt;从三维旋转到欧拉角&lt;/h1&gt;&lt;p&gt;首先三维旋转绕某个轴旋转，已经知道是这样的了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 矩阵变换入门</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-2/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-2/</id>
    <published>2022-06-17T01:51:05.735Z</published>
    <updated>2022-06-22T15:51:07.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量 Vector"></a>向量 Vector</h1><h2 id="小概念"><a href="#小概念" class="headerlink" title="小概念"></a>小概念</h2><p>数学上叫做向量，物理上喜欢称作矢量。</p><p>向量的模 Magnitude。</p><p>向量的归一化，意味着求单位向量 unit Vector。</p><h2 id="向量矩阵"><a href="#向量矩阵" class="headerlink" title="向量矩阵"></a>向量矩阵</h2><p>下面是在表示笛卡尔坐标系x-y下的某个向量，可以用矩阵来表示向量。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220615180557.png"></p><h2 id="点乘-Dot"><a href="#点乘-Dot" class="headerlink" title="点乘 Dot"></a>点乘 Dot</h2><p>满足交换律、结合律、分配律。</p><p>结果是一个数值，可以用来检测2个向量的夹角，&lt;90度为正，90度为0，90~180度为负。</p><h2 id="叉乘-Cross"><a href="#叉乘-Cross" class="headerlink" title="叉乘 Cross"></a>叉乘 Cross</h2><p>不满足交换律！向量A x 向量B = -向量B x 向量A</p><p>结果是一个向量，这个向量是与A、B向量所组成平面的垂直向量，也就是说A、B、C向量构成一个右手直角坐标系。<strong>而法线的方向，满足右手螺旋。注意a在前所以a是食指</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620122459.png"></p><p><strong>图形学上，</strong>用来检测某个点是否在一个多边形（比如三角形）内。</p><p>因为 向量AB x 向量AP 的结果大于0则说明P在AB左侧，小于0则说明P在AB右侧。</p><p>所以一个三角面ABC和一个点P，只要通过3次叉乘的结果（都大于0或者都小于0），就能判断出点P在三角面ABC中。这是光栅化的基础，用于着色判断。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616105243.png"></p><h1 id="矩阵变换：线性变换"><a href="#矩阵变换：线性变换" class="headerlink" title="矩阵变换：线性变换"></a>矩阵变换：线性变换</h1><p>关键是，要找出变换前后每一个点之间的变化关系式。矩阵的乘法是不满足交换律的。</p><h2 id="缩放-Sacle"><a href="#缩放-Sacle" class="headerlink" title="缩放 Sacle"></a>缩放 Sacle</h2><p>可以使用对角阵*向量来进行缩放，这个对角阵叫缩放矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616114924.png"></p><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h2><p>用于翻折的单位矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616115506.png"></p><h2 id="切变-Shear"><a href="#切变-Shear" class="headerlink" title="切变 Shear"></a>切变 Shear</h2><p>要找出每一个点之间的变化关系式。</p><p>比如下图情况，只是水平方向的点发生了变化，竖直方向的不变。水平方向上的每个点发生了a / 1 * y的平移。那么久可以很容易写出切变矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616120005.png"></p><h2 id="旋转-Rotate"><a href="#旋转-Rotate" class="headerlink" title="旋转 Rotate"></a>旋转 Rotate</h2><p>二维情况下，逆时针旋转θ角：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151759.png"></p><p>推导过程（只展示A、C。B、D的话由点0,1可以推出）如下，其实只是展开了点(1,0)的偏移等式。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151646.png"></p><p>再进一步探究可知，<strong>逆旋转矩阵 = 将原旋转矩阵转置</strong>。这意味着想要旋转一个负角度，只要求出正角度的旋转矩阵再转置就可以得到旋转矩阵了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620113534.png"></p><h2 id="统称：线性变换"><a href="#统称：线性变换" class="headerlink" title="统称：线性变换"></a>统称：线性变换</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616165650.png"></p><h1 id="矩阵变换：非线性变换"><a href="#矩阵变换：非线性变换" class="headerlink" title="矩阵变换：非线性变换"></a>矩阵变换：非线性变换</h1><h2 id="平移-Translation"><a href="#平移-Translation" class="headerlink" title="平移 Translation"></a>平移 Translation</h2><p>平移比较特殊，它不能通过2阶矩阵<strong>线性变换</strong>（矩阵乘法）得出。因为矩阵乘法你只能得到ax+by的结果，没法出现常数c，所以只能靠加法。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616170433.png"></p><h2 id="平移解决方案：更高1阶的矩阵"><a href="#平移解决方案：更高1阶的矩阵" class="headerlink" title="平移解决方案：更高1阶的矩阵"></a>平移解决方案：更高1阶的矩阵</h2><p>平移必须涉及到同阶矩阵的加法，没法直接用线性变换了。为了在这种情况下也能只使用矩阵乘法就达到变换的目的，可以使用2+1阶的矩阵。多出来的矩阵值，点是1、向量是0。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616175212.png"></p><p><strong>将二维的点，最后一个矩阵值写为1。</strong>如果不是1，那么就看作x =&gt; x/w、y =&gt; y/w。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616184017.png"></p><p>那么最后，给出2维 向量、点 的变化矩阵：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616185009.png"></p><h2 id="逆变换-Inverse"><a href="#逆变换-Inverse" class="headerlink" title="逆变换 Inverse"></a>逆变换 Inverse</h2><p>通过使用逆矩阵，可以撤回变换。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616190117.png"></p><h1 id="组合的矩阵变换"><a href="#组合的矩阵变换" class="headerlink" title="组合的矩阵变换"></a>组合的矩阵变换</h1><p>先旋转，后平移。否则会出错，因为矩阵乘法没有交换律！</p><p>那么通过矩阵乘法表示线性变换、矩阵平移的时候，就是从右到左一个个乘。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620101520.png"></p><p><strong>虽然没有交换律，但是有结合律</strong>，可以让前面的变换矩阵合成为一个：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102212.png"></p><h1 id="分解复杂的矩阵变换"><a href="#分解复杂的矩阵变换" class="headerlink" title="分解复杂的矩阵变换"></a>分解复杂的矩阵变换</h1><p>对于一个复杂的矩阵变换（线性变换+平移变换），需要分解为几步，才能通过矩阵乘法来实现。</p><h2 id="绕某点旋转"><a href="#绕某点旋转" class="headerlink" title="绕某点旋转"></a>绕某点旋转</h2><p>将c移到原点 =&gt; 绕原点旋转 =&gt; 移回原来</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102642.png"></p><h1 id="由二维引申到三维"><a href="#由二维引申到三维" class="headerlink" title="由二维引申到三维"></a>由二维引申到三维</h1><p>上面讨论的都是二维，转到三维空间，其实也是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620103459.png"></p><h2 id="三维缩放、平移"><a href="#三维缩放、平移" class="headerlink" title="三维缩放、平移"></a>三维缩放、平移</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115450.png"></p><h2 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h2><p>绕某个轴旋转，该轴上的点位置不变。</p><p>至于为什么y和x、z轴旋转不一样，详细参考叉乘的<strong>右手螺旋定则</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;向量-Vector&quot;&gt;&lt;a href=&quot;#向量-Vector&quot; class=&quot;headerlink&quot; title=&quot;向量 Vector&quot;&gt;&lt;/a&gt;向量 Vector&lt;/h1&gt;&lt;h2 id=&quot;小概念&quot;&gt;&lt;a href=&quot;#小概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 导学</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-1/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-1/</id>
    <published>2022-06-17T01:51:05.734Z</published>
    <updated>2022-06-22T14:32:28.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h1><p>看一个游戏的图形方面做得如何，一般可以参考画面亮不亮，原因是这关系到了全局光照。</p><h2 id="光栅化-Rasterization"><a href="#光栅化-Rasterization" class="headerlink" title="光栅化 Rasterization"></a>光栅化 Rasterization</h2><p>把三维的几何形体画在屏幕上，这个画的过程，就叫光栅化。</p><h2 id="几何学-Curves-and-Meshes"><a href="#几何学-Curves-and-Meshes" class="headerlink" title="几何学 Curves and Meshes"></a>几何学 Curves and Meshes</h2><h2 id="光线追踪-Ray-Tracing"><a href="#光线追踪-Ray-Tracing" class="headerlink" title="光线追踪 Ray Tracing"></a>光线追踪 Ray Tracing</h2><p>从相机发射光线穿过每个像素，计算交集和阴影，并继续反射光线直到它们击中光源。</p><h2 id="动画、仿真-Animation-Simulation"><a href="#动画、仿真-Animation-Simulation" class="headerlink" title="动画、仿真 Animation/Simulation"></a>动画、仿真 Animation/Simulation</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机图形学&quot;&gt;&lt;a href=&quot;#计算机图形学&quot; class=&quot;headerlink&quot; title=&quot;计算机图形学&quot;&gt;&lt;/a&gt;计算机图形学&lt;/h1&gt;&lt;p&gt;看一个游戏的图形方面做得如何，一般可以参考画面亮不亮，原因是这关系到了全局光照。&lt;/p&gt;
&lt;h2 id=&quot;光</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - Button</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_6/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_6/</id>
    <published>2022-06-17T01:51:05.730Z</published>
    <updated>2022-06-17T01:51:05.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><code>Button</code>继承自<code>Selectable</code>、<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>。</p><h2 id="外部注册"><a href="#外部注册" class="headerlink" title="外部注册"></a>外部注册</h2><h3 id="IPointerClickHandler"><a href="#IPointerClickHandler" class="headerlink" title="IPointerClickHandler"></a>IPointerClickHandler</h3><p><code>IPointerClickHandler</code>接口仅包含一个<code>OnPointerClick()</code>方法，当鼠标点击时会调用该接口的方法。而<code>Button</code>能触发点击事件是因为继承自<code>IPointerClickHandler</code>接口，并且重写了<code>OnPointerClick</code>方法。那<code>IPointerClickHandler</code>接口的方法又是被谁调用的呢？查找引用，发现是<code>ExecuteEvents</code>类的<code>Execute</code>方法，并且<code>Execute</code>方法赋值给<code>s_PointerClickHandler</code>字段。</p><p>没错，ExecuteEvents，和之前我在<a href="https://codingcodingk.top/Tech/Game/UI/ugui_2/">UGUI学习 - 事件系统、射线检测</a>的分析一致。</p><h3 id="AddListener"><a href="#AddListener" class="headerlink" title="AddListener"></a>AddListener</h3><p>那么<code>onClick.AddListener()</code>的本质也可以挖一下，其实就是监听了<code> public ButtonClickedEvent onClick</code>。而这个追溯到最底层，就是对一个回调方法队列进行<code>List.Add()</code>。</p><h2 id="Unity调用"><a href="#Unity调用" class="headerlink" title="Unity调用"></a>Unity调用</h2><p>也是和之前分析的一样，在Process方法体内进行循环检测、触发OnClick等。</p><p><code>EventSystem</code>会在<code>Update()</code>中调用当前可用<code>BaseInputModule</code>的<code>Process()</code>方法，该方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用<code>ReleaseMouse()</code>方法，并最终调用<code>Execute()</code>方法并触发<code>IPointerClick</code>事件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlink&quot; title=&quot;整体流程&quot;&gt;&lt;/a&gt;整体流程&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Button&lt;/code&gt;继承自&lt;code&gt;Selectable&lt;/code&gt;、&lt;code&gt;IPointercl</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>AOI视野管理</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/aoi/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/aoi/</id>
    <published>2022-06-13T13:55:50.492Z</published>
    <updated>2022-06-13T14:03:31.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是AOI"><a href="#什么是AOI" class="headerlink" title="什么是AOI"></a>什么是AOI</h1><h2 id="AOI"><a href="#AOI" class="headerlink" title="AOI"></a>AOI</h2><p>AOI（Area of Interest），一般指一个游戏对象在所处游戏场景（MMO居多）中的视野范围。</p><p>因为玩家和较远距离的角色不会产生互动，所以不需要他们的状态，只要关注、同步视野范围内的其他单位即可。</p><h2 id="AOI主要方式"><a href="#AOI主要方式" class="headerlink" title="AOI主要方式"></a>AOI主要方式</h2><ul><li>暴力计算：每隔一定帧数，就执行一次位置计算</li><li>十字链表：只关注上下左右四个方位。</li><li>九宫格：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是AOI&quot;&gt;&lt;a href=&quot;#什么是AOI&quot; class=&quot;headerlink&quot; title=&quot;什么是AOI&quot;&gt;&lt;/a&gt;什么是AOI&lt;/h1&gt;&lt;h2 id=&quot;AOI&quot;&gt;&lt;a href=&quot;#AOI&quot; class=&quot;headerlink&quot; title=&quot;AOI</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="mmo" scheme="https://codingcodingk.github.io/categories/Game/mmo/"/>
    
    <category term="AOI" scheme="https://codingcodingk.github.io/categories/Game/mmo/AOI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - LayoutSystem布局系统</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_4/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_4/</id>
    <published>2022-03-25T12:02:18.563Z</published>
    <updated>2022-03-29T05:44:10.095Z</updated>
    
    <content type="html"><![CDATA[<p>学习博客：<br><a href="https://blog.csdn.net/qq_28820675/article/details/106245195">https://blog.csdn.net/qq_28820675/article/details/106245195</a></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328144810.png"></p><blockquote><p> CanvasUpdateSystem中更新布局的具体实现系统。</p></blockquote><h1 id="布局-LayoutSystem"><a href="#布局-LayoutSystem" class="headerlink" title="布局 LayoutSystem"></a>布局 LayoutSystem</h1><p>也就是上一篇中说的 Canvas刷新系统 中，重建得2个数组之一<strong>Layout数组</strong>是怎么来的、又是怎么重建得。</p><h2 id="什么时候标记"><a href="#什么时候标记" class="headerlink" title="什么时候标记"></a>什么时候标记</h2><p>也是用脏标记。时机一般为尺寸改变时（RectTransform Dimensions）。</p><h2 id="标记后干什么"><a href="#标记后干什么" class="headerlink" title="标记后干什么"></a>标记后干什么</h2><p>UGUI组件（如Graphic、ScrollRect…）在需要布局处理时（也就是被标记或OnDisable时），会把自身的RectTransform组件用LayoutRebuilder对象包装，之后加入<strong>Layout数组</strong>。</p><h2 id="重建布局"><a href="#重建布局" class="headerlink" title="重建布局"></a>重建布局</h2><p>这个的执行时机，在画布刷新系统那篇里有细写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CanvasUpdateSystem触发重建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (executing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.Layout:</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputHorizontal());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutHorizontal());</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputVertical());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutVertical());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="布局组件-LayoutGroup"><a href="#布局组件-LayoutGroup" class="headerlink" title="布局组件 LayoutGroup"></a>布局组件 LayoutGroup</h1><p>经过对LayoutSystem、LayoutRebuilder的分析，布局接口的触发规则已经被摸清楚了。</p><p>虽然UGUI组件中有一些组件都继承了ILayoutElement接口（例如：Image,Text,ScrollRect,InputField），但它们并不会涉及对接口方法的实现。这是因为这些组件主要是布局操作的接收方，只需要通过该接口被布局实施方所发现即可。而UGUI中负责这些接收物体的布局设置功能主要是由LayoutGroup衍生的子类组件来完成。</p><blockquote><p><strong>LayoutGroup</strong>，是布局组件的基类（GridLayoutGroup、HorizontalOrVerticalLayoutGroup）。先对纵横布局组件（HorizontalLayoutGroup、VerticalLayoutGroup）进行分析。</p></blockquote><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328212851.png"></p><p>Padding：内部边距，调整实际用于布局区域的大小<br>Spacing ：子物体直接的间隔<br>Child Alignment ：子物体对齐方式<br>Child Controls Size ：组件控制子物体尺寸开关，开启时组件可以更改物体尺寸。<br>Child Force Expand ：组件控制子物体填充区域开关，若可以修改尺寸则会改变子物体尺寸填充区域，若不可以修改尺寸，则根据区域大小均衡分布子物体。</p><h2 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h2><p>以HorizontalLayoutGroup为例。</p><p>1.对该GameObject下所有子物体（只做一次GetChild）进行遍历，获取其子节点下所有没有被标记<strong>ignoreLayout</strong>的物体。放到一个List中。</p><p>2.对List中的每一个Cell都进行尺寸与位置的计算。然后设置其属性。</p><h1 id="ContentSizeFitter"><a href="#ContentSizeFitter" class="headerlink" title="ContentSizeFitter"></a>ContentSizeFitter</h1><p>布局系统中尺寸调节组件。</p><p><strong>ContentSizeFitter</strong>，是用于调整组件区域使其自适的组件，一般用于与ScrollRect滑动列表以及纵横布局组件搭配，实现动态数量的滑动列表效果，以及与Text组件一起使用，可以根据文字长短进行区域尺寸的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习博客：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/106245195&quot;&gt;https://blog.csdn.net/qq_28820675/article/details/10624519</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - 画布刷新、重建</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_3/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_3/</id>
    <published>2022-03-25T12:02:18.562Z</published>
    <updated>2022-06-17T01:51:05.728Z</updated>
    
    <content type="html"><![CDATA[<p>学习博客：</p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105746002">https://blog.csdn.net/qq_28820675/article/details/105746002</a></p><p><a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">https://blog.csdn.net/gaojinjingg/article/details/103565840</a></p><p>更好的入门文章：</p><p><a href="https://zhuanlan.zhihu.com/p/448293298">https://zhuanlan.zhihu.com/p/448293298</a></p><p><img src="https://img-blog.csdnimg.cn/20200425104339184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODIwNjc1,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>由Canvas控制，通过 ICanvasElement 接口，使用脏标记方法来统一更新CanvasElement</p></blockquote><h1 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h1><p>摘自<a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">大佬博客</a>。</p><ul><li>   <strong>Canvas</strong>， 是Unity渲染系统给层状几何体( layered geometry )提供的可以被画入、被放在上面或者放在世界空间的底层Unity组件。Canvas负责将它包含的几何体组合成batch，生成合适的渲染命令发送给Unity图形系统。这个过程在底层的C++代码中完成，这个过程被称为一次rebatch或者一次batch build。当一个Canvas被标记为包含需要rebatch的几何体时，这个Canvas被认为是dirty的。</li><li>   <strong>layered geometry</strong> , 由Canvas Renderer组件提供给Canvas。[ Canvas 负责进行渲染, Canvas Renderer负责采集/接收. ]</li><li>   **动静隔离 **, 一个子Canvas仅仅是一个嵌套在父Canvas中的组件，子Canvas将它的子物体和它的父Canvas隔离，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild，反之亦然。（这些在某些特殊情况下是不确定的，比如说改变父Canvas的大小导致子Canvas的大小改变。）</li><li>   <strong>Graphic</strong> , 是UGUI的C#库提供的一个基类。它是UGUI所有类的基类，给所有的UGUI类提供可以画在Canvas系统上的几何图形。大多数Unity内置的继承Graphic的类都是通过继承一个叫MaskableGraphic的子类来实现，这使得他们可以通过IMaskable接口来被隐藏。Drawable类的子类主要是image和text，已经提供了同名的组件。</li><li>  <strong>Layout</strong> , 组件控制着RectTransform的大小和位置，经常被用于要生成具有相似的大小和位置关系内容的复杂布局。它只依靠RectTransform，只影响与其相关的RectTransform的属性。这些layout组件不依赖于Graphic类，可以独立于UGUI的Graphic组件之外使用。</li><li>  <strong>CanvasUpdateRegistry</strong> , Graphic和Layout组件都依赖于CanvasUpdateRegistry类，它不会在Unity编辑器的界面中显示。这个类追踪那些Graphic和Layout组件必须被更新的时候，还有与其对应的Canvas触发了willRenderCanvases事件的时候。更新Graphic类和Layout类叫做rebuild。</li><li> <strong>Rebuild</strong> , 过程是指Layout和UGUI的C#的Graphic组件的网格被重新计算，这是在CanvasUpdateRegistry类中执行的。这是一个C＃类，它的源码可以在Unity的Bitbucket上找到。<br>   <strong>CanvasUpdateRegistry</strong> , 类中，PerformUpdate方法，当一个Canvas组件触发它的WillRenderCanvases事件时，这个方法就会被执行。这个事件每帧调用一次。<br>   <strong>PerformUpdate</strong> , 函数运行的三个步骤：<br>   1- 通过ICanvasElement.Rebuild函数，请求rebuild被Dirty的Layout组件。<br>   2- 所有被注册的裁剪组件（例如Mask），对需要被裁剪的组件进行剔除。这在ClippingRegistry.Cull中执行。<br>   3- dirty的Graphic组件被要求rebuild其图形元素。</li><li>   <strong>Layout Rebuild</strong> , 要重新计算一个或者多个Layout组件所包含的UI组件的适当位置（以及可能的大小），有必要对Layout应用层次的排序。在GameObject的hierarchy中靠近root的Layout可能会影响改变嵌套在它里面的其他Layout的位置和大小，所以必须首先计算。 </li><li>   <strong>Graphic Rebuild</strong> , 当Graphic组件被rebuild的时候，UGUI将控制传递给ICanvasElement接口的Rebuild方法。Graphic执行了这一步，并在rebuild过程中的PreRender阶段运行了两个不同的rebuild步骤：1.如果顶点数据已经被标为Dirty（例如组件的<strong>RectTransform</strong>已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的<strong>material或者texture</strong>已经被改变），则关联的Canvas Renderer的材质将被更新。Graphic的Rebuild不会按照Graphic组件的特殊顺序进行，也不会进行任何的排序操作。</li></ul><h1 id="入门理解"><a href="#入门理解" class="headerlink" title="入门理解"></a>入门理解</h1><p>这里对大佬的<a href="https://zhuanlan.zhihu.com/p/448293298">文章</a>进行摘要。</p><p><strong>Unity是怎么绘制UI元素的？</strong></p><p>Unity中渲染的物体都是由网格(Mesh)构成的，而网格的绘制单元是图元(点、线、三角面)。在unity中添加一个<em>Image</em>和<em>Text</em>，并且将<em>Shadings Mode</em>设置为<em>Wireframe</em>模式，可以看到一个<em>Image</em>由四个顶点和两个三角面构成，<em>Text</em>也是由许多顶点和三角面构成。</p><p>绘制信息都存储在<em>Vertexhelper</em>类中，除了顶点外，还包括法线、UV、颜色、切线以及一些函数。</p><p><strong>数据存储好了，那怎么绘制呢？</strong></p><p>这是依靠<em>CanvasRenderer</em>来完成的，它听起来可能比较陌生，但实际上当我们在项目中创建的一些UI元素，比如<em>Button</em>、<em>Image</em>、<em>Text</em>时，都包含组件<em>CanvasRenderer</em>，这个类提供了许多关键绘制信息，比如被渲染物体的颜色、材质和<em>Mesh</em>等，主要作用就是<strong>渲染包含在Canvas中的UI对象</strong>，但是在<em>Inspector</em>界面中并不会展示任何属性。</p><p><strong>总结一下就是，Unity会把要绘制的UI信息保存在Vertexhelper中，并且调用CanvasRenderer里面的方法进行绘制。</strong></p><h1 id="重建-Rebuild"><a href="#重建-Rebuild" class="headerlink" title="重建 Rebuild"></a>重建 Rebuild</h1><p><strong>UI重建分为两类，一类是布局重建(Layout Rebuild)，另一类是图形重建(Graphic Rebuild)。</strong></p><p>一个UI若要重建，必须继承自<em>ICanvasElement</em>接口，因为执行重建操作的时候会调用接口中的<em>Rebuild</em>函数。</p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>是Unity渲染系统给层状几何体( layered geometry )提供的可以被画入、被放在上面或者放在世界空间的底层Unity组件。</p><p>Canvas在<strong>渲染前</strong>会调用willRenderCanvases事件，也就是Registry的PerformUpdate方法，用委托的形式传进去的。</p><h2 id="CanvasUpdateRegistry"><a href="#CanvasUpdateRegistry" class="headerlink" title="CanvasUpdateRegistry"></a>CanvasUpdateRegistry</h2><p>画面刷新的注册工具类，在它的构造函数中会给Canvas注册回调：<code>Canvas.willRenderCanvases += PerformUpdate;</code></p><p>内部维护2个队列（都是 ICanvasElement类型 的）：</p><ul><li>  LayoutRebuildQueue：布局重建队列</li><li>  GraphicRebuildQueue：图像重建队列</li></ul><p>这2个队列提供了公开方法向其添加内容。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向m_LayoutRebuildQueue中添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向m_GraphicRebuildQueue中添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加内容时机"><a href="#添加内容时机" class="headerlink" title="添加内容时机"></a>添加内容时机</h2><p>那么什么时候对2个重建队列添加内容，也就是怎么确定哪些要重建呢？是通过脏数据实现的。</p><p>布局（Layout）、材质（Material）、顶点（Vertices）三部分，设置布局为脏，将进行布局重建；设置顶点或材质为脏，则进行图形重建。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetAllDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 略了，就是根据一些flag依次调用下面3个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLayoutDirty</span>(<span class="params"></span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!IsActive())</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//将元素加入布局重建队列</span></span><br><span class="line">     LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">     </span><br><span class="line">     Debug.Log(<span class="string">&quot;Rebuild:&quot;</span> + rectTransform.name);</span><br><span class="line">     <span class="keyword">if</span> (m_OnDirtyLayoutCallback != <span class="literal">null</span>)</span><br><span class="line">         m_OnDirtyLayoutCallback();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetVerticesDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m_VertsDirty = <span class="literal">true</span>;   </span><br><span class="line">    <span class="comment">//将元素加入图形重建队列</span></span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyVertsCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyVertsCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetMaterialDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    m_MaterialDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//将元素加入图形重建队列</span></span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyMaterialCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyMaterialCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发重建"><a href="#触发重建" class="headerlink" title="触发重建"></a>触发重建</h2><p>加入重建队列之后，CanvasUpdateRegistry就会在<code>PerformUpdate</code>函数中调用它的<code>Rebuild</code>进行重建。Graphic对Rebuild进行了实现：如果顶点或材质被标记为“脏”的话，会更新元素的几何网格(<em>UpdateGeometry</em>)和材质(<em>UpdateMaterial</em>)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate update</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (canvasRenderer == <span class="literal">null</span> || canvasRenderer.cull)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.PreRender:</span><br><span class="line">            <span class="keyword">if</span> (m_VertsDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdateGeometry();</span><br><span class="line">                m_VertsDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m_MaterialDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdateMaterial();</span><br><span class="line">                m_MaterialDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>UpdateGeometry</em>函数用于确定元素的网格(<em>Mesh</em>)信息，这些信息包括顶点、三角面、UV、颜色等，它们将会被填充到<em>s_VertexHelper</em>中，并最终调用<em>canvasRenderer.SetMesh(workerMesh)<em>设置</em>Mesh</em>信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoMeshGeneration</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rectTransform != <span class="literal">null</span> &amp;&amp; rectTransform.rect.width &gt;= <span class="number">0</span> &amp;&amp; rectTransform.rect.height &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//UI元素需要生成顶点时的回调函数，用以填充顶点缓冲区的数据</span></span><br><span class="line">        <span class="comment">//其子类重写了这个方法</span></span><br><span class="line">        OnPopulateMesh(s_VertexHelper);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s_VertexHelper.Clear();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前对象是否有IMeshModifier接口，</span></span><br><span class="line">    <span class="comment">//Text的描边和阴影都是通过它的ModifyMesh方法实现的</span></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    GetComponents(<span class="keyword">typeof</span>(IMeshModifier), components);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        ((IMeshModifier)components[i]).ModifyMesh(s_VertexHelper);</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line"></span><br><span class="line">    s_VertexHelper.FillMesh(workerMesh);</span><br><span class="line">    <span class="comment">//设置渲染所需的网格信息</span></span><br><span class="line">    canvasRenderer.SetMesh(workerMesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染前流程"><a href="#渲染前流程" class="headerlink" title="渲染前流程"></a>渲染前流程</h2><ul><li>  <em>PerformUpdate</em>函数对<em>m_LayoutRebuildQueue</em>中的元素进行排序，依据是父节点的多少。接下来依次将<em>Prelayout</em>、<em>Layout</em>和<em>PostLayout</em>作为参数传递给<em>Rebuild</em>进行布局重建，完成后通知布局队列中的元素重建完成。</li><li>  调用<em>ClipperRegistry</em>的<em>Cull</em>函数进行裁剪。</li><li>  进行图形重建，遍历<em>m_GraphicRebuildQueue</em>的值，分别将参数<em>PreRender</em>、<em>LatePreRender</em>作为参数传递给<em>Rebuild</em>函数进行图形重建。</li><li>  最后通知图形重建完成。</li></ul><h1 id="Rebuild时机：脏标记"><a href="#Rebuild时机：脏标记" class="headerlink" title="Rebuild时机：脏标记"></a>Rebuild时机：脏标记</h1><p>这里用脏标记，就是将重建的行为延迟到用户需要这个物体的时候才执行，一种优化重新渲染的手段。</p><p>在Graphic 中存在三种脏标记分别代表三种等待重建</p><ul><li><p>  尺寸改变时（RectTransformDimensions）：LayoutRebuild 布局重建</p></li><li><p>  尺寸、颜色改变时：Vertices to GraphicRebuild 图像顶点重建</p></li><li><p>  材质改变时：Material to GraphicRebuild 图像材质重建</p></li></ul><p>层级改变、应用动画属性（DidApplyAnimationProperties） ：All to Rebuild 重建所有</p><h2 id="案例1：Image"><a href="#案例1：Image" class="headerlink" title="案例1：Image"></a>案例1：Image</h2><p>举例Image的情况，Image间接继承自Graphic，当它的Sprite发生变化时，会调用SetAllDirty函数；设置Sprite大小的时候也会调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sprite sprite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Sprite; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Sprite != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_Sprite != <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_SkipLayoutUpdate = m_Sprite.rect.size.Equals(<span class="keyword">value</span> ? <span class="keyword">value</span>.rect.size : Vector2.zero);</span><br><span class="line">                m_SkipMaterialUpdate = m_Sprite.texture == (<span class="keyword">value</span> ? <span class="keyword">value</span>.texture : <span class="literal">null</span>);</span><br><span class="line">                m_Sprite = <span class="keyword">value</span>;</span><br><span class="line">                </span><br><span class="line">                SetAllDirty();</span><br><span class="line">                TrackSprite();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_SkipLayoutUpdate = <span class="keyword">value</span>.rect.size == Vector2.zero;</span><br><span class="line">            m_SkipMaterialUpdate = <span class="keyword">value</span>.texture == <span class="literal">null</span>;</span><br><span class="line">            m_Sprite = <span class="keyword">value</span>;</span><br><span class="line">            </span><br><span class="line">            SetAllDirty();</span><br><span class="line">            TrackSprite();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例more"><a href="#案例more" class="headerlink" title="案例more"></a>案例more</h2><ul><li>  <em>Text</em>控件 文本的内容及颜色变化、设置是否支持富文本、更改换行模式、设置字体最大最小值、变更文本使用的对齐锚点、设置是否通过几何对齐、变更字体大小、变更是否支持水平及垂直溢出、修改行间距、变更字体样式(正常、斜体…..)。</li><li>  <em>Image</em>控件 颜色变化、变更显示类型(<em>Simple</em>、<em>Sliced</em>、<em>Tiled</em>、<em>Filled</em>)、变更是否应保留<em>Sprite</em>宽高比(<em>Image.preserveAspect</em>属性的变更)，<em>FillCenter</em>属性变更(是否渲染平铺或切片图像的中心)、变更填充方式(<em>Horizontal</em>、<em>Vertical</em>、<em>Radial360</em>….)、变更图像填充率(<em>fillAmount</em>)、变更图像顺逆时针填充类型(<em>Image</em>.<em>fillClockwise</em>)、变更填充过程的原点(<em>Image.FillOrigin</em>)。</li><li>  <em>RawImage</em>控件 设置<em>Texture</em>、变更纹理使用的<em>UVRcet</em>。</li><li>  <em>Shadow</em>效果 改变效果的距离(<em>effectDistance</em>)及颜色(<em>effectColor</em>)、变更是否使用<em>Graphic</em>中的<em>Alpha</em>透明度(<em>useGraphicAlpha</em>)。</li><li>  <em>Mask</em>控件 设置是否展示与<em>Mask</em>渲染区域相关的图形(<em>showMaskGraphic</em>),<em>enable</em>发生变化</li><li>  所有继承<em>MaskableGraphic</em>的控件(<em>Image</em>、<em>RawImage</em>、<em>RectMask2D</em>、<em>Text</em>) 设置此图形是否允许被遮盖、<em>enable</em>发生变化、父节点发生变化(<em>TransFromParentChanged</em>)、在<em>Hierachy</em>面板上发生改变(<em>HierachyChanged</em>)。</li><li>  所有继承自<em>BaseMeshEffect</em>的效果类(目前只看到<em>Shadow</em>及<em>PositionAsUV1</em>)的<em>enable</em>变化及应用动画属性的操作。</li><li>  所有继承自<em>Graphic</em>的UI控件材质(<em>material</em>)发生变化。</li></ul><h1 id="一整轮Rebuild：PerformUpdate方法"><a href="#一整轮Rebuild：PerformUpdate方法" class="headerlink" title="一整轮Rebuild：PerformUpdate方法"></a>一整轮Rebuild：PerformUpdate方法</h1><p>1.在布局重建队列、图像重建队列中，<strong>剔除已销毁对象</strong>。</p><p>2.<strong>更新布局</strong>。根据父节点数量排序，先深后浅。更新类型依次为 Prelayout 、Layout 、PostLayout。详细见ugui_4。</p><p>3.执行<code>LayoutComplete</code>回调，也就是通知LayoutRebuild队列的所有元素，<strong>通知布局已完成</strong>。</p><p>4.布局完成，可以<strong>对UI（IClipper）进行裁剪</strong>了，显示不到的就不渲染</p><p>5.<strong>更新图像</strong>。依次 PreRender、LatePreRender、MaxUpdateValue：1.如果顶点数据已经被标为Dirty（例如组件的RectTransform已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的material或者texture已经被改变），则关联的Canvas Renderer的材质将被更新。</p><p>6.执行<code>GraphicUpdateComplete</code>回调，<strong>通知图像更新完成</strong>。</p><h1 id="顺序枚举"><a href="#顺序枚举" class="headerlink" title="顺序枚举"></a>顺序枚举</h1><p>CanvasUpdate，一个枚举类，很核心，代表着Canvas对Layout、Render的处理顺序：</p><ol start="0"><li>  Prelayout：Called before layout.</li><li>  Layout</li><li>  PostLayout：Called after layout.</li><li>  PreRender：Called before rendering.</li><li>  LatePreRender：Called late, before render.</li><li>  MaxUpdateValue：Max enum value. Always last.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/105746002&quot;&gt;https://blog.csdn.net/qq_28820675/article/details/1057</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 展示</title>
    <link href="https://codingcodingk.github.io/Intro/display/"/>
    <id>https://codingcodingk.github.io/Intro/display/</id>
    <published>2022-03-25T12:02:18.559Z</published>
    <updated>2022-03-25T12:02:18.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Demo简介"><a href="#Demo简介" class="headerlink" title="Demo简介"></a>Demo简介</h1><p>个人Demo项目，所有代码都已在github开源。// <strong>个人博客</strong>：CodingCodingK.top    <strong>github首页</strong>：github.com/CodingCodingK</p><p>使用Unity客户端、.net core服务端实现类王者荣耀帧同步Moba手游。系统方面主要实现了背包系统；战斗方面，实现了主要游戏流程、实现了3个人物及其技能：亚瑟、后裔、金克斯(lol)。</p><ul><li>使用UDP通信、Protobuf协议实现帧同步网络通信库</li><li>使用Odin、xNode实现自定义可视化编辑器，且保持数据一致</li><li>使用Luban实现本地Excel数据配置导表方案</li><li>使用对象池、虚拟列表等进行背包系统优化</li><li>使用定点数实现碰撞环境生成、确定性物理碰撞检测</li><li>实现基于客户端负责计算的帧同步Moba战斗系统</li><li>不同客户端独立计算的显示结果统一与运动平滑</li><li>逻辑层与显示层分离，复用技能、Buff、子弹逻辑代码的战斗系统</li><li>业务内容上，大致实现了登陆系统、大厅主城、背包系统、匹配系统、选角系统、加载系统、战斗系统。</li></ul><h1 id="Demo演示视频⭐"><a href="#Demo演示视频⭐" class="headerlink" title="Demo演示视频⭐"></a>Demo演示视频⭐</h1><p>1P 游戏内容展示：登录客户端1 =&gt; 大厅、背包系统展示 =&gt; 登录客户端2 =&gt; 匹配、选人、加载读条系统展示 =&gt; 整个战斗流程展示 =&gt; 结束返回大厅。</p><p>2P 开发环境展示：Excel配置、自定义编辑器、服务器数据库等。</p><h2 id="视频地址-↓↓↓"><a href="#视频地址-↓↓↓" class="headerlink" title="视频地址 ↓↓↓"></a>视频地址 ↓↓↓</h2><p><a href="https://www.bilibili.com/video/BV1ML4y177hc">https://www.bilibili.com/video/BV1ML4y177hc</a></p><h2 id="Demo演示环境"><a href="#Demo演示环境" class="headerlink" title="Demo演示环境"></a>Demo演示环境</h2><p>服务器：使用腾讯云，配置 4核 8G 带宽10M 微型个人服务器。</p><p>真机测试：华为P40手机 鸿蒙OS。</p><h1 id="Demo源码"><a href="#Demo源码" class="headerlink" title="Demo源码"></a>Demo源码</h1><p>apk下载地址（可连远端服务器，支持安卓实机）：<a href="https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ">https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ</a> 提取码：1234 </p><p>MobaDemo（双端）源码地址：<a href="https://github.com/CodingCodingK/UnityMobaDemo">https://github.com/CodingCodingK/UnityMobaDemo</a></p><h1 id="Demo实现细节展示"><a href="#Demo实现细节展示" class="headerlink" title="Demo实现细节展示"></a>Demo实现细节展示</h1><p>限于篇幅以及可观赏性，很多东西没办法通过视频的形式呈现，</p><p>每个模块的demo代码以及个人笔记地址。</p><h2 id="项目实现细节"><a href="#项目实现细节" class="headerlink" title="项目实现细节"></a>项目实现细节</h2><p>技能系统、物理碰撞模拟等在项目中的运用：<a href="https://codingcodingk.top/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/">王者荣耀复刻项目 笔记目录</a></p><h2 id="使用Protobuf协议的UDP简易网络通信库"><a href="#使用Protobuf协议的UDP简易网络通信库" class="headerlink" title="使用Protobuf协议的UDP简易网络通信库"></a>使用Protobuf协议的UDP简易网络通信库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingK_Session">https://github.com/CodingCodingK/CodingK_Session</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/protobuf/">工具篇：protobuf序列化</a>    <a href="https://codingcodingk.top/Tech/Game/tools/CodingK_Session/">工具篇：帧同步网络库</a></p><h2 id="常用定时器"><a href="#常用定时器" class="headerlink" title="常用定时器"></a>常用定时器</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKTimer">https://github.com/CodingCodingK/CodingKTimer</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKTimer/">工具篇：定时系统</a></p><h2 id="自用定点数数学库"><a href="#自用定点数数学库" class="headerlink" title="自用定点数数学库"></a>自用定点数数学库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKMath">https://github.com/CodingCodingK/CodingKMath</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKMath/">工具篇：定点数运算数学库</a></p><h2 id="自用定点数物理碰撞模拟"><a href="#自用定点数物理碰撞模拟" class="headerlink" title="自用定点数物理碰撞模拟"></a>自用定点数物理碰撞模拟</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKPhysx">https://github.com/CodingCodingK/CodingKPhysx</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKPhysx/">工具篇：定点数物理碰撞库</a></p><h2 id="基于Luban实现的Excel配置方案"><a href="#基于Luban实现的Excel配置方案" class="headerlink" title="基于Luban实现的Excel配置方案"></a>基于Luban实现的Excel配置方案</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/luban_study/">工具篇：本地配置</a></p><h2 id="Odin、xNode自定义编辑器"><a href="#Odin、xNode自定义编辑器" class="headerlink" title="Odin、xNode自定义编辑器"></a>Odin、xNode自定义编辑器</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/odin_study/">工具篇：Odin 可视化编辑器</a>    <a href="https://codingcodingk.top/Project/Unity/Moba/HOK/skilleditor/">王者荣耀复刻项目 技能配置编辑器篇</a></p><h1 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h1><p>其实在开始这个Demo之前，为了能够学习游戏开发，在业余时间我也在各类网课学习了<a href="https://github.com/CodingCodingK/Unity_Studys">很多简单的游戏案例</a>，尝试理解一些框架诸如GameFramework、UGUI的源码。从2021年4月起学习Unity官方游戏案例Ruby，到如今正式求职一份Unity工作已经过去了一年。我还有很多想学习的，想做出更接近商业级的东西。</p><p>非常感谢也许是面试官也许是hr的您，能够看到这里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Demo简介&quot;&gt;&lt;a href=&quot;#Demo简介&quot; class=&quot;headerlink&quot; title=&quot;Demo简介&quot;&gt;&lt;/a&gt;Demo简介&lt;/h1&gt;&lt;p&gt;个人Demo项目，所有代码都已在github开源。// &lt;strong&gt;个人博客&lt;/strong&gt;：Codi</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
  <entry>
    <title>什么叫“二进制”配置方案？</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/serialize/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/serialize/</id>
    <published>2022-03-18T13:18:05.707Z</published>
    <updated>2022-03-18T13:18:05.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的很懵，刚好自己的demo有用，挖一下。</p><h1 id="先说二进制式存储"><a href="#先说二进制式存储" class="headerlink" title="先说二进制式存储"></a>先说二进制式存储</h1><p>要理解为什么二进制更优，先明白什么是二进制式存储。</p><h2 id="什么是二进制文件？"><a href="#什么是二进制文件？" class="headerlink" title="什么是二进制文件？"></a>什么是二进制文件？</h2><p>所有对计算机有所了解的人肯定都知道计算机的存储在物理上是二进制（01）形式的。所以文本文件与二进制文件的区别并不是物理上，而是逻辑上的。其本质是两者在编码层次上的差异。简单的来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据应用的具体情况自定义自己的编码。</p><p>从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。</p><h2 id="文本文件是怎么读取的？"><a href="#文本文件是怎么读取的？" class="headerlink" title="文本文件是怎么读取的？"></a>文本文件是怎么读取的？</h2><p>文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。</p><p>比如选取ASCII码形式（ASCII码的一个字符是8个比特），它就会8个比特地来解释这个文件流：”01000000 01000001 01000010 01000011”用ASCII码解析出来是“ABCD”，显示在文本编辑器上。</p><h2 id="二进制文件vs文本文件"><a href="#二进制文件vs文本文件" class="headerlink" title="二进制文件vs文本文件"></a>二进制文件vs文本文件</h2><p><strong>译码难度</strong>：一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。</p><p><strong>文件大小</strong>：关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。</p><h1 id="再聊二进制配置"><a href="#再聊二进制配置" class="headerlink" title="再聊二进制配置"></a>再聊二进制配置</h1><h2 id="二进制和json的关系"><a href="#二进制和json的关系" class="headerlink" title="二进制和json的关系"></a>二进制和json的关系</h2><p>要存储一个json文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot; = 133,</span><br><span class="line">  &quot;color&quot; = [233, 0, 0],</span><br><span class="line">  &quot;pos&quot; = [34, 22]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>json一般以utf-8格式保存成文本</strong>，utf-8是unicode编码的一种实现形式。也就是说，像程序中的数字类型133，233，22等，一个uint8就能存储下了，可是133在json中却占了3个字节，要是存个12.432312等数据要占用更多的空间。而本文所说的二进制配置，直接存133等的uint8二进制编码0x85，这样便减少了一部分文件大小。<strong>编码与解码可以商量好自己的规则</strong>，比如time，编解码都以t代替，又可以节省一部分空间，甚至可以不存储time，color，pos等key，直接顺序在配置中写value，解码时直接读value（为了说的清楚，后面的例子保留了key）这样又可以减少配置文件的大小。</p><h2 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h2><blockquote><p>  序列化是将对象or对象图(比如数组)转换成字节流的过程，反序列化是将字节流转换回对象图的过程。</p></blockquote><p>上面这段来自我clr笔记的定义，就可以明白大佬们说的“二进制来做”，做的是序列化反序列化。</p><p>不通过这种常规读取方式：</p><p>读取utf-8的.json文件 =&gt; 将utf-8读取成二进制流byte[] =&gt; 此时byte[]是json字符串，也就是json序列化后的产物，我们再通过反射(至少我常用的库是反射)反序列化 =&gt; 反序列化完成，返回一个对象。</p><p>那如果加入“二进制来做”的读取方式：</p><p>读取.bin文件 =&gt; 二进制文件更小读取很快，获取到二进制流byte[]，然后根据自己定好的的规则去读流(比如按顺序获取定长比特来读取)，反序列化 =&gt; 反序列化完成，返回一个对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大佬们说的“二进制来做”，其实想指的是一个解决方案而不是指最终存的文件是二进制式的这么简单。</p><p>你可以<strong>可以自己写规则</strong>，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Custom_MemoryStream</span> : <span class="title">MemoryStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReadInt</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">base</span>.Read(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = BitConverter.GetBytes(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">base</span>.Write(arr, <span class="number">0</span>, arr.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 类似的还有很多比如string，这里略了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entity <span class="title">MakeEntity</span>(<span class="params">MemoryStream ms</span>)</span>&#123;</span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity();</span><br><span class="line">    entity.Id = ms.ReadInt();</span><br><span class="line">    entity.Name = ms.ReadString();</span><br><span class="line">    entity.Path = ms.ReadString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用现成的解决方案比如protobuf、FlatBuffers，他们的最终文件也都是<strong>二进制式的而不是文本格式，且读取的时候读二进制流直接按长度转换成字段</strong>。</p><p>最后，接上导表工具，就算成了。</p><p>可能对于定义上还是有一点点误解，以后会来改。但是我相信，无论怎样，目的都是为了更快、更小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="优化" scheme="https://codingcodingk.github.io/categories/Game/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：定点数物理碰撞库</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/CodingKPhysx/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/CodingKPhysx/</id>
    <published>2022-03-18T13:18:05.703Z</published>
    <updated>2022-03-25T12:02:18.564Z</updated>
    
    <content type="html"><![CDATA[<p>定点数基于《工具篇：定点数运算数学库》的定点数库。</p><h1 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h1><p>1.读取配置：初始化碰撞环境</p><p>2.读取配置：初始化玩家碰撞体</p><p>3.FixedUpdate（具体看《Unity生命流程》）：固定帧率检测碰撞发生</p><h1 id="碰撞配置"><a href="#碰撞配置" class="headerlink" title="碰撞配置"></a>碰撞配置</h1><p>ColldierConfig。</p><p>长方体类型：位置、长宽高、轴向。</p><p>圆柱体类型：位置、半径。</p><h1 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h1><h2 id="逻辑-视图分离"><a href="#逻辑-视图分离" class="headerlink" title="逻辑-视图分离"></a>逻辑-视图分离</h2><p>只维护逻辑值，视图则根据定点数逻辑值转换成浮点数来进行更新。但是，视图层更新后并不参与任何运算，只显示。</p><h1 id="碰撞环境"><a href="#碰撞环境" class="headerlink" title="碰撞环境"></a>碰撞环境</h1><p>环境初始化的前提是根据固定方式制作地图：<strong>只用 BoxCollider 和 CapsuleCollider 两种碰撞体，且全部放在一个EnvRoot结点下</strong>。</p><p>初始化时，遍历这个根节点，将所有的BoxCollider转化为定点数长方体形碰撞体，将所有的CapsuleCollider转化为定点数圆柱体形碰撞体。</p><p>生成下来，放到一个List中保存。</p><h1 id="碰撞检测-矫正计算（一对一）"><a href="#碰撞检测-矫正计算（一对一）" class="headerlink" title="碰撞检测+矫正计算（一对一）"></a>碰撞检测+矫正计算（一对一）</h1><h2 id="Cylinder碰到Box"><a href="#Cylinder碰到Box" class="headerlink" title="Cylinder碰到Box"></a>Cylinder碰到Box</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309232208.png"></p><p>1.求出 向量OK = Cylinder.Pos - Box.Pos。</p><p>2.求出 向量OK 分别在 Box.X方向向量、Box.Z方向向量 上的投影的长度：</p><p>使用点乘即可。具体推导是<a href="https://blog.csdn.net/liushao1031177/article/details/119776495">线代问题</a>，简单公式推导如下（向量v必须是方向向量也就是模为1）：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220308235857.png"></p><p>3.对上面求出的2段投影的长度进行钳制，让他们的范围小于的Box的半长和半宽。</p><p>4.由3的两断钳制后的投影距离 + Box.Pos ，简单计算出P点（表面最近的接触点）位置。</p><p>5.判断P点是否在Cylinder内部，不在就不需要矫正直接返回；在就需要矫正，往PO方向<strong>矫正距离</strong> Cylinder半径 - PO长度 即可。</p><p>6.如果需要矫正距离，那同时需要<strong>矫正速度方向</strong>，这可以利用向量的和来求出。求出 向量OV 在 向量PO 上的投影OT，和图中情况一致的话应该是个负数，用它可以求出 向量OT = 投影OT * 向量PO的单位向量。最后使用 向量OV - 向量OT ，得出向量TV，这就是修正后的方向向量。</p><h2 id="Cylinder碰到Cylinder"><a href="#Cylinder碰到Cylinder" class="headerlink" title="Cylinder碰到Cylinder"></a>Cylinder碰到Cylinder</h2><p>两个圆求是否相撞，直接用 两者半径之和 与 两者圆心距离 比较即可。</p><p>至于计算<strong>矫正距离</strong>就比较简单了，公式我在图中给出了。最后计算<strong>矫正速度方向</strong>，方法和上面的6是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309213302.png"></p><h1 id="碰撞检测-矫正计算（一对多）"><a href="#碰撞检测-矫正计算（一对多）" class="headerlink" title="碰撞检测+矫正计算（一对多）"></a>碰撞检测+矫正计算（一对多）</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220311014107.png"></p><p>碰撞检测如图。</p><p>目前采用一个有微小误差的办法：<br>检测速度向量OV和向量和OB的夹角：角VOB，<br>与Max(角AOB,角COB)进行比较，</p><p>如果角VOB更小，那么就当作不需要矫正；<br>如果角VOB更大，那么就当作需要矫正。</p><p>如果不需要矫正，就当作墙体的反作用力完美抵消了速度V，撤销本次预执行的位置更新，方向修正为Vector.zero。<br>如果需要矫正，使用之前的方法（步骤6）求出 速度V 与 与法线夹角最大的那个向量的法线向量（AO）情况下的 修正方向。而矫正位置就很好算了，直接取所有碰撞点（一对一）的位置矫正之和。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定点数基于《工具篇：定点数运算数学库》的定点数库。&lt;/p&gt;
&lt;h1 id=&quot;处理流程&quot;&gt;&lt;a href=&quot;#处理流程&quot; class=&quot;headerlink&quot; title=&quot;处理流程&quot;&gt;&lt;/a&gt;处理流程&lt;/h1&gt;&lt;p&gt;1.读取配置：初始化碰撞环境&lt;/p&gt;
&lt;p&gt;2.读取配置：</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="物理碰撞库" scheme="https://codingcodingk.github.io/tags/%E7%89%A9%E7%90%86%E7%A2%B0%E6%92%9E%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Unity编辑器拓展</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_4/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_4/</id>
    <published>2022-03-18T13:18:05.702Z</published>
    <updated>2022-03-18T13:18:05.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识编辑器拓展"><a href="#初识编辑器拓展" class="headerlink" title="初识编辑器拓展"></a>初识编辑器拓展</h1><h2 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h2><ul><li>  菜单栏选项</li><li>  菜单栏窗口</li><li>  面板式编辑器</li><li>  窗口式编辑器</li></ul><p>unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。 用于扩展editor的类需要放到名字为“Editor”的文件夹中，这个文件夹可以直接放到”Assets“文件夹下，也可以是项目目录任何文件夹下的子文件夹，比如”Assets/SkillSystem/Editor”。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>重新绘制画面，主要是通过重写OnGUI、OnInspectorGUI之类的函数来实现的。</p><p>这些函数是生命周期中的一员，具体看Unity生命流程图。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>对上面提出的支持进行简单实践。</p><h2 id="菜单栏选项"><a href="#菜单栏选项" class="headerlink" title="菜单栏选项"></a>菜单栏选项</h2><p>菜单栏里添加“Tools &gt; 打包工具”项。点击执行方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;Tools/打包工具&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputAB</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单栏窗口"><a href="#菜单栏窗口" class="headerlink" title="菜单栏窗口"></a>菜单栏窗口</h2><p>菜单栏里添加“Example &gt; 打包工具”项。点击跳出制作的窗口以及控件。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121155.png"></p><p>使用方法：</p><ol><li>  继承ScriptableWizard</li><li>  调用ScriptableWizard.DisplayWizard函数可以快速创建这个向导窗口。这个向导窗口只支持小于或等于两个按钮的定制（即提供的消息响应函数只有两个按钮的）。显示的按钮名字通过ScriptableWizard.DisplayWizard函数传入。</li></ol><p>ScriptableWizard的API中的消息响应函数：（当满足某些条件下执行这些函数）</p><p>OnWizardCreate ：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”createButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardOtherButton：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”otherButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardUpdate：当向导窗口打开时或者用户改变窗口内容时都会被调用。一般会在这里显示帮助文字和进行内容有效性验证。也可以动态改变按钮状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptableWizardButton</span> : <span class="title">ScriptableWizard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firstObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform secondObject = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Example/Show OnWizardOtherButton Usage&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard(<span class="string">&quot;Click info to know the distance between the objects&quot;</span>, <span class="keyword">typeof</span>(ScriptableWizardButton), <span class="string">&quot;Finish!&quot;</span>, <span class="string">&quot;Info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstObject == <span class="literal">null</span> || secondObject == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">false</span>;</span><br><span class="line">            errorString = <span class="string">&quot;Select the objects you want to measure&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">true</span>;</span><br><span class="line">            errorString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Info&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardOtherButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> distanceObjs = Vector3.Distance(firstObject.position, secondObject.position);</span><br><span class="line">        EditorUtility.DisplayDialog(</span><br><span class="line">            <span class="string">&quot;The distance between the objects is: &quot;</span> + distanceObjs + <span class="string">&quot; Units&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Finish!&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorUtility.DisplayDialog(<span class="string">&quot;OnWizardCreate &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口式编辑器"><a href="#窗口式编辑器" class="headerlink" title="窗口式编辑器"></a>窗口式编辑器</h2><p>菜单栏里添加“Window &gt; MyEditorWnd”。点击打开窗口式面板。</p><p>使用方法：继承EditorWindow，重写“OnGUI”函数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121422.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEditorWnd</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">bool</span> groupEnabled;</span><br><span class="line">    <span class="built_in">bool</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">float</span> myFloat = <span class="number">1.23f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add menu named &quot;My Window&quot; to the Window menu</span></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Window/MyEditorWnd&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get existing open window or if none, make a new one:</span></span><br><span class="line">        MyEditorWnd window = (MyEditorWnd)EditorWindow.GetWindow(<span class="keyword">typeof</span>(MyEditorWnd));</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Base Settings&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        myString = EditorGUILayout.TextField(<span class="string">&quot;Text Field&quot;</span>, myString);</span><br><span class="line">        groupEnabled = EditorGUILayout.BeginToggleGroup(<span class="string">&quot;Optional Settings&quot;</span>, groupEnabled);</span><br><span class="line">        myBool = EditorGUILayout.Toggle(<span class="string">&quot;Toggle&quot;</span>, myBool);</span><br><span class="line">        myFloat = EditorGUILayout.Slider(<span class="string">&quot;Slider&quot;</span>, myFloat, <span class="number">-3</span>, <span class="number">3</span>);</span><br><span class="line">        EditorGUILayout.EndToggleGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面板式编辑器"><a href="#面板式编辑器" class="headerlink" title="面板式编辑器"></a>面板式编辑器</h1><p>对于上面提到所有拓展方式中，第三种“面板式编辑器”是最常用的一种，单独开篇。</p><h2 id="是在做什么？"><a href="#是在做什么？" class="headerlink" title="是在做什么？"></a>是在做什么？</h2><p>是在将 EditorGUI 拓展在 Inspector 面板上。</p><p>EditorGUI 和 GUI 的用法几乎完全一致，目前来说前者多用于编辑器开发，后者多用于发布后调试编辑器。总之，它们都是起辅助作用的。 EditorGUI 提供的组件非常丰富，常用的绘制元素包括文本、按钮、图片和滚动框等。做一个好的编辑器，是离不开 EditorGUI 的。</p><p>至于EditorGUI 和 数据的交互，是借由一个继承了MonoBehaviour的脚本的数据字段实现的。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>常规使用方法：</p><ol><li>  首先得有一个MonoBehaviour常规脚本，我们取名为“Show.cs”，可以在内自定义一些字段比如Sprite、List之类的。</li><li>  新建脚本，继承Editor类，标上[CustomEditor(typeof(Show))]标签当挂Showt脚本时就会显示这个编辑器，用来让编辑器和脚本互通。</li><li>  对2中新建的脚本重写”OnInspectorGUI”函数，对自己扩展的组件的编辑界面进行定制。</li></ol><p>以上示例代码见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><p>见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识编辑器拓展&quot;&gt;&lt;a href=&quot;#初识编辑器拓展&quot; class=&quot;headerlink&quot; title=&quot;初识编辑器拓展&quot;&gt;&lt;/a&gt;初识编辑器拓展&lt;/h1&gt;&lt;h2 id=&quot;支持&quot;&gt;&lt;a href=&quot;#支持&quot; class=&quot;headerlink&quot; title=&quot;支</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity协程原理</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_5/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_5/</id>
    <published>2022-03-18T13:18:05.702Z</published>
    <updated>2022-03-18T13:18:05.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开启一个协程发生了什么"><a href="#开启一个协程发生了什么" class="headerlink" title="开启一个协程发生了什么"></a>开启一个协程发生了什么</h1><p>分析如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ShowLog());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">IEnumerator <span class="title">ShowLog</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(i);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先描述一下里面用到的方法和类：</p><h2 id="StartCoroutine"><a href="#StartCoroutine" class="headerlink" title="StartCoroutine"></a>StartCoroutine</h2><p>StartCoroutine是 Monobehavior类的函数，有3个重载函数</p><blockquote><p>  public Coroutine StartCoroutine(string methodName);<br>  public Coroutine StartCoroutine(IEnumerator routine);<br>  public Coroutine StartCoroutine(string methodName, [DefaultValue(“null”)] object value);</p></blockquote><p>StartCoroutine的第一个和第三个methodName ，都是一个返回类型是IEnumerator的方法。</p><p>所以入参全是<strong>IEnumerator迭代器方法</strong>。返回类型全是<strong>Coroutine</strong>类。</p><h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>协同程序。继承自<strong>YieldInstruction</strong>类。</p><p><a href="https://docs.unity3d.com/cn/current/ScriptReference/MonoBehaviour.StartCoroutine.html">StartCoroutine函数</a> 返回 Coroutine。协同程序是一个可以暂停执行 (yield) 的函数，直到给定的 <a href="https://docs.unity3d.com/cn/current/ScriptReference/YieldInstruction.html">YieldInstruction</a> 完成。</p><h2 id="YieldInstruction"><a href="#YieldInstruction" class="headerlink" title="YieldInstruction"></a>YieldInstruction</h2><p>yield return后面可以是值，也可以是一个类型为继承自<strong>YieldInstruction的类</strong>。</p><p>如果yield return的是YieldInstruction的派生类，Unity就会将其理解为“持续等待”。比如WaitForEndOfFrame、WaitForFixedUpdate、WaitForSeconds、WWW、Coroutine（StartCoroutine的返回值），它们都是。</p><h2 id="yield-return"><a href="#yield-return" class="headerlink" title="yield return"></a>yield return</h2><p>yield return后面可以跟的表达式：</p><p>​        所有非YieldInstruction派生类（包括null）：协程将会在下一帧恢复，继续后续代码。</p><p>​        WaitForEndOfFrame：协程将会在这一帧结束之后（所有渲染、GUI）恢复，继续后续代码。</p><p>​        WaitForFixedUpdate：所有物理引擎计算完成之后恢复，继续后续代码。</p><p>​        WaitForSeconds：等待x秒后（以Unity内的计时系统为基准）恢复，继续后续代码。</p><p>​        WWW：等待一个web request结束后恢复，继续后续代码。</p><p>​        Coroutine 其他协程（协程嵌套）：等子协程Coroutine执行完后恢复，继续后续代码。如果子协程内有yield中断，那父协程会一直暂停，直到子协程运行完毕。</p><h2 id="CustomYieldInstruction"><a href="#CustomYieldInstruction" class="headerlink" title="CustomYieldInstruction"></a>CustomYieldInstruction</h2><p>想实现自定义和<code>YieldInstruction</code>一样，拥有“持续等待”逻辑的协程，就用这个。继承自<code>IEnumerator</code>类。</p><p>重写<code>keepWaiting</code>函数即可。要使协同程序保持暂停，则返回<code>true</code>；要使协同程序继续执行， 则返回<code>false</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Left mouse button up&quot;</span>);</span><br><span class="line">            StartCoroutine(waitForMouseDown());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">waitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Right mouse button pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaitForMouseDown</span> : <span class="title">CustomYieldInstruction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> keepWaiting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !Input.GetMouseButtonDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Waiting for Mouse right button down&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程原理"><a href="#协程原理" class="headerlink" title="协程原理"></a>协程原理</h1><p>如果代码中对<code>gameObject.SetActive(false)</code>，协程就会失效，即使再次激活，也不能继续执行。原因是协程是在StartCoroutine时被注册到的GameObject上，他的生命期受限于GameObject的生命期，因此受GameObject是否active的影响。</p><p><strong>不难得出，协程和Update一样是在每一帧被调用执行的。经过测试，一般是在LastUpdate之后执行的。</strong></p><p>而具体怎么执行，是利用了<strong>迭代器</strong>：每一帧检测yield的返回情况（想想StartCoroutine估计就是<code>while(MoveNext)</code>）。也就是<strong>每一帧都执行MoveNext</strong>，如果为true下一帧就继续执行MoveNext，如果为false就结束协程将其从协程队列中剔除。</p><h1 id="自己实现携程"><a href="#自己实现携程" class="headerlink" title="自己实现携程"></a>自己实现携程</h1><p>// 当然也可以考虑用async-await替代协程，ETTask就是这样的。具体以后再看，粗看应该是最后将回调放到<code>同步上下文.Post</code>里做了。</p><p>找到一个不错的实践，<a href="https://www.cnblogs.com/zblade/p/9857808.html">转载</a>一下。可以手动控制携程顺序、执行片长。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Profiling;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QuotaCoroutine</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每帧的额度时间，全局共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">float</span> frameQuotaSec = <span class="number">0.001f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">LinkedList</span>&lt;<span class="title">IEnumerator</span>&gt; s_tasks</span> = <span class="keyword">new</span> LinkedList&lt;IEnumerator&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartQuotaCoroutine(Task(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleTask();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartQuotaCoroutine</span>(<span class="params">IEnumerator task</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        s_tasks.AddLast(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ScheduleTask</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> timeStart = Time.realtimeSinceStartup;</span><br><span class="line">        <span class="keyword">while</span> (s_tasks.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> t = s_tasks.First.Value;</span><br><span class="line">            <span class="built_in">bool</span> taskFinish = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (Time.realtimeSinceStartup - timeStart &lt; frameQuotaSec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 执行任务的一步, 后续没步骤就是任务完成</span></span><br><span class="line">                Profiler.BeginSample(<span class="built_in">string</span>.Format(<span class="string">&quot;QuotaTaskStep, f:&#123;0&#125;&quot;</span>, Time.frameCount));</span><br><span class="line">                taskFinish = !t.MoveNext();</span><br><span class="line">                Profiler.EndSample();</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (taskFinish)</span><br><span class="line">                &#123;</span><br><span class="line">                    s_tasks.RemoveFirst();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 任务没结束执行到这里就是没时间额度了</span></span><br><span class="line">            <span class="keyword">if</span> (!taskFinish)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">IEnumerator <span class="title">Task</span>(<span class="params"><span class="built_in">int</span> taskId, <span class="built_in">int</span> stepCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; stepCount)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;, frame:&#123;2&#125;&quot;</span>, taskId, i, Time.frameCount);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开启一个协程发生了什么&quot;&gt;&lt;a href=&quot;#开启一个协程发生了什么&quot; class=&quot;headerlink&quot; title=&quot;开启一个协程发生了什么&quot;&gt;&lt;/a&gt;开启一个协程发生了什么&lt;/h1&gt;&lt;p&gt;分析如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UI屏幕自适应</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_1/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_1/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-18T13:18:05.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="面板基本"><a href="#面板基本" class="headerlink" title="面板基本"></a>面板基本</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217103517.png"></p><p>当我们点击一个GUI物体是它具有的属性为：</p><p><strong>Rect Transform</strong>：继承自Transform组件，它表示的是控件的Location位置，和一些基本的属性。这个控件的参数类型会随着锚点情况而改变，具体在下一节展示。</p><p><strong>Pivot</strong>：设置轴心（不是蓝色的，那个叫中心锚点）的位置，中心点的位置【0,0】表示的是控件的左下角的位置，【1,1】表示的是右上角的位置，【0.5,0.5】表示的是图像中心的位置。</p><p><strong>Anchors</strong>：它的取值和Pivot一个逻辑，也是0~1之间。Min点和Max点是2个点，2个点可以沿着x、y方向，确定出一个矩形。而这个矩形的4个点就是4个锚点。我们也可以直接拖动画面的锚点来快捷设置。</p><h2 id="Pivot-和-Center"><a href="#Pivot-和-Center" class="headerlink" title="Pivot 和 Center"></a>Pivot 和 Center</h2><p>Pivot上面说了，是轴心，可以自己在Rect Transform的面板里设置；</p><p>Center是中心，是在Unity中根据模型的mesh信息计算得到的中心位置，是所有物体共同的中心，如果同时选中了多个物体，则坐标是所有模型共同参与计算出来的坐标。</p><p>Center是由Unity计算出来的而不是设置出来的。Pivot在锚点重合情况下，代表着PosX和PosY画出来的的点。</p><h2 id="锚点、纽扣和中心点-Center"><a href="#锚点、纽扣和中心点-Center" class="headerlink" title="锚点、纽扣和中心点(Center)"></a>锚点、纽扣和中心点(Center)</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217104252.png"></p><p>这里先对3个点下定义，下面一节进行讨论。</p><p>单击图形显示着的的小篮圈，到底表示的是Pivot还是Center，是在Unity里设置的，两者完全不是一个东西。设置的话，在Global边上的选项里选择即可。</p><p>正常的二维UI，中心点总是在正中间，而轴心就可以自己设置了。</p><h1 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h1><h2 id="情况一：两个锚点重合"><a href="#情况一：两个锚点重合" class="headerlink" title="情况一：两个锚点重合"></a>情况一：两个锚点重合</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>两个锚点重合的情况，Image UI（也就是红色Image）的锚点和Pivot连成一条线，这条线会永远保持（也就是两点的距离会永远保持）。<strong>在这种情况下调整画面，Image UI不会变形，只会根据Pivot点到Anchor点的距离一致的原则调整位置。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120309.png"></p><p>一个值得关注的点是，此时Image UI的Rect Transform控件是Pos + Width,Height的组合。这个PosX和Y，指的是Anchor和Pivot之间的相对位置。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120631.png"></p><h3 id="示例动图"><a href="#示例动图" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored1.gif"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored2.gif"></p><h2 id="情况二：锚框"><a href="#情况二：锚框" class="headerlink" title="情况二：锚框"></a>情况二：锚框</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>当两个锚点（AnchorMin和AnchorMax）不重合时，两点就会确定一个矩形，这个矩形就是我们的锚框。<strong>这种情况会保持锚点到纽扣的距离保持不变。</strong></p><p>此时Image UI的Rect Transform控件是Left,Top + Right,Bottom的组合。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217121839.png"></p><p>这四个点什么意思呢？是纽扣的相对位置，相对的是锚点组成的坐标系。看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217134116.png"></p><p>所以明白了，锚点到纽扣的距离保持不变，那就意味着4条（图中2条以及左上右下未画出来的）绿线始终保持不变。同时意味着，代表这4个点相对位置的Rect Transform控件里的Left,Top,Right,Bottom值也都不变。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217135538.png"></p><h3 id="示例动图-1"><a href="#示例动图-1" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored3.gif"></p><h2 id="anchoredPosition属性"><a href="#anchoredPosition属性" class="headerlink" title="anchoredPosition属性"></a>anchoredPosition属性</h2><p>他本身是一个点，如果在AnchorMin和AnchorMax是重合的场合（情况一）下，anchoredPosition就是表示锚点到Pivot的位置。</p><p>但是如果AnchorMin和AnchorMax不重合的时候（情况二），anchoredPosition就比较复杂了，在这种情况下，Unity会根据Pivot、AnchorMin和AnchorMax计算出一个锚点，然后在通过Pivot和锚点来得出anchoredPosition的位置。</p><h2 id="offsetMin和offsetMax详解"><a href="#offsetMin和offsetMax详解" class="headerlink" title="offsetMin和offsetMax详解"></a>offsetMin和offsetMax详解</h2><p>offsetMin和offsetMax这两个属性。其中offsetMin表示物体（本文中的红框）左下角相对AnchorMin的偏移，offsetMax表示物体右上角相对AnchorMax的偏移。</p><p>情况一 anchor(0, 0)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151909.png"></p><p>情况二 anchorMin(0,0) anchorMax(1,1)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151935.png"></p><h2 id="sizeDelta详解"><a href="#sizeDelta详解" class="headerlink" title="sizeDelta详解"></a>sizeDelta详解</h2><p>sizeDelta就是offsetMax - offsetMin的值，即物体左下角到右上角的变量：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152058.png"></p><h1 id="画布缩放器-Canvas-Scaler"><a href="#画布缩放器-Canvas-Scaler" class="headerlink" title="画布缩放器 Canvas Scaler"></a>画布缩放器 Canvas Scaler</h1><p>Canvas新建时自带的脚本，专门解决屏幕适配问题的脚本，负责伸缩所有UI对象。以下内容主要取自<a href="https://docs.unity3d.com/cn/current/Manual/script-CanvasScaler.html">Unity中文手册</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152713.png"></p><p>三种模式：</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>UI Scale Mode</strong></td><td align="left">确定画布中的 UI 元素的缩放方式。</td></tr><tr><td align="left"><strong>Constant Pixel Size</strong></td><td align="left">无论屏幕大小如何，UI 元素都保持相同的像素大小。</td></tr><tr><td align="left"><strong>Scale With Screen Size</strong></td><td align="left">屏幕越大，UI 元素越大。</td></tr><tr><td align="left"><strong>Constant Physical Size</strong></td><td align="left">无论屏幕大小和分辨率如何，UI 元素都保持相同的物理大小。</td></tr></tbody></table><p>一般来说的配置方案是：<br>Canvas Scaler 选择 Scale With Screen Size<br>Screen Match Mode 选择 Match Width Or Height，</p><p>横屏游戏比例设为1，即只和高度进行适配；</p><p>竖屏游戏比例设为0，即只和宽度进行适配。</p><h2 id="1、Constant-Pixel-Size"><a href="#1、Constant-Pixel-Size" class="headerlink" title="1、Constant Pixel Size"></a>1、Constant Pixel Size</h2><p>一般美术拿它来做缩放图片，因为不同Size不失真。</p><p>使用 Constant Pixel Size 模式时，可在屏幕上按像素指定 UI 元素的位置和大小。这也是画布在未附加任何画布缩放器时的默认功能。但是，借助画布缩放器中的“Scale Factor”设置，可以向画布中的所有 UI 元素应用常量缩放。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Scale Factor</strong></td><td align="left">按此系数缩放画布中的所有 UI 元素。画布的缩放比例。默认况下为1，表示正常大小。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。每单位代表的像素量。</td></tr></tbody></table><h2 id="2、Scale-With-Screen-Size"><a href="#2、Scale-With-Screen-Size" class="headerlink" title="2、Scale With Screen Size"></a>2、Scale With Screen Size</h2><p>使用 Scale With Screen Size 模式时，可以根据指定参考分辨率的像素来指定位置和大小。如果当前屏幕分辨率大于参考分辨率，则画布会保持只具有参考分辨率的分辨率，但是会放大以便适应屏幕。如果当前屏幕分辨率小于参考分辨率，则画布会相应缩小以适应屏幕。</p><p>如果当前屏幕分辨率的宽高比与参考分辨率不同，则单独缩放每个轴以适应屏幕会形成非一致缩放，通常不希望发生这种情况。相反，ReferenceResolution 组件会使画布分辨率偏离参考分辨率，以便遵循屏幕的宽高比。可以使用 Screen Match Mode 设置控制此偏离的行为方式。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Reference Resolution</strong></td><td align="left">UI 布局设计的目标分辨率。如果屏幕分辨率较大，则 UI 会放大，如果较小，则 UI 会缩小。</td></tr><tr><td align="left"><strong>Screen Match Mode</strong></td><td align="left">在当前分辨率的宽高比不适应参考分辨率时，用于缩放画布区域的模式。</td></tr><tr><td align="left"><strong>Match Width or Height</strong>⭐常用</td><td align="left">以宽度、高度或二者的某种平均值作为参考来缩放画布区域。</td></tr><tr><td align="left"><strong>Expand</strong></td><td align="left">水平或垂直扩展画布区域，使画布不会小于参考。</td></tr><tr><td align="left"><strong>Shrink</strong></td><td align="left">水平或垂直裁剪画布区域，使画布不会大于参考。</td></tr><tr><td align="left"><strong>Match</strong></td><td align="left">确定是否以宽度、高度或二者的某种平均值作为参考进行缩放。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。</td></tr></tbody></table><h2 id="3、Constant-Physical-Size"><a href="#3、Constant-Physical-Size" class="headerlink" title="3、Constant Physical Size"></a>3、Constant Physical Size</h2><p>使用 Constant Physical Size 模式时，可按物理单位（如毫米、点或派卡）指定 UI 元素的位置和大小。此模式要求设备正确报告其屏幕 DPI。对于不报告 DPI 的设备，可以指定回退 DPI。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Physical Unit</strong></td><td align="left">用于指定位置和大小的物理单位。</td></tr><tr><td align="left"><strong>Fallback Screen DPI</strong></td><td align="left">在屏幕 DPI 未知时采用的 DPI。</td></tr><tr><td align="left"><strong>Default Sprite DPI</strong></td><td align="left">用于精灵的每英寸像素，使其“Pixels Per Unit”设置与“Reference Pixels Per Unit”设置匹配。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则其 DPI 将与“Default Sprite DPI”设置匹配。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;h2 id=&quot;面板基本&quot;&gt;&lt;a href=&quot;#面板基本&quot; class=&quot;headerlink&quot; title=&quot;面板基本&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UI常见优化</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_2/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_2/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-04-02T09:13:32.645Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。</p><h1 id="Unity性能优化"><a href="#Unity性能优化" class="headerlink" title="Unity性能优化"></a>Unity性能优化</h1><h2 id="优化关键"><a href="#优化关键" class="headerlink" title="优化关键"></a>优化关键</h2><p>先找到性能瓶颈。影响图形性能的关键因素主要有一下几个方面。</p><ol><li> GPU填充率和存储器带宽。</li><li> CPU经常是渲染物体的数量（也就是常常大家说的Draw Calls）。</li><li> 系统内存容量也是优化的一个关键指标。</li></ol><h2 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h2><p>GPU优化主要有下面几点：</p><ol><li>  减少三角形的使用数量（去掉不必要的三角形面）。</li><li>  尽量避免使用实时光照，能使用Static Lighting就使用烘焙光照，只计算一次。</li><li>  压缩纹理和多重纹理-mipmap（这样可以提高加载速度和降低内存占用），也极大提高渲染的性能。</li><li>  LOD（多细节层次），不同距离使用不同精度的模型。</li><li>  编写高性能着色器，将能能处理的逻辑放在定点着色器里面处理，减少片段着色器的计算量。</li></ol><h2 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h2><p>CPU主要开销在，显卡在渲染一个对象之前，CPU需要计算一些着色器和灯光影响，然后想显卡驱动发送绘制指令，单物体来说，不会太影响性能，累计就会产生性能问题。这里优化点主要从以下几个方面讨论，这里只是说出优化常用的方案，后面如果在下在项目里面遇到更加好的方案，或者是方法，我将会在这里补充出来。也欢迎大家指出错误，或者是更好的CPU优化方案。</p><ol><li> 合并材质球相同的对象，进而减少绘制指令的发送。合并的方式有，手工合并或者是使用Unity内置的选项合并，或者是使用自制脚本合并模型对象，但是注意的是:非相同材质对象，合并不会对性能有任何的提高。</li><li> 在对象或场景中使用更少的材质。可以将独立的纹理合并成一个更大的纹理图集，但是合并时注意，合并要以方便开发，节省资源为基础。</li><li> 避免使用物体被渲染多次的效果，这里主要体现在（反射，阴影，像素光照等）。</li><li> 优化游戏代码，也是优化CPU的一个关键点。</li></ol><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>性能优化最后一点，就是内存的优化，要优化Unity的内存资源，就首先必须了解内存的资源管理模式，以及Unity资源加载的方式，Unity资源动态加载主要有下面两种方式：</p><ol><li> Resource方式资源加载。</li><li> AssetBundle资源加载方式。</li></ol><p>这两种资源加载方式都提供同步和异步加载API。资源加载到内存里面的规范到底是什么样的，观察下面的图就一目了然。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210105112.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。&lt;/p&gt;
&lt;h1 id=&quot;Unity性能优化&quot;&gt;&lt;a href=&quot;#Unity性能优化&quot; class=&quot;headerlink&quot; title=&quot;Unity性能优化&quot;&gt;&lt;/a&gt;Unity性能优化&lt;/h</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity生命流程</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_3/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_3/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-18T13:18:05.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命流程图"><a href="#生命流程图" class="headerlink" title="生命流程图"></a>生命流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221094846.png"></p><h1 id="FixedUpdate"><a href="#FixedUpdate" class="headerlink" title="FixedUpdate"></a>FixedUpdate</h1><p>1、和Update主帧循环不同，Unity的刚体系统通过固定的时间来驱动也就是FixedUpdate。在刚体系统运算开始前，<strong>Unity会根据上一次刚体运算完成的时间再加上Fixed Timestep的所设置的值来作为这一次刚体运算时间的限定范围</strong>。然后刚体系统会开始计算，直到达到这个时间限制临界点。</p><p>2、FixedUpdate与Update的不同在于，Update在每帧被调用，但是调用时间不确定，所以我们要实现一个物体匀速运动是，是无法通过Update准确实现的，但是我们可以在FixedUpdate中实现，因为它在确定的时间间隔中被调用。FixedUpdate有可能在Update之前调用多次。FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。</p><p>3、FixedUpdate的频率可以自己设置，如果频率过高，导致一次Update的时间片内执行了多次FixedUpdate进行物理运算，那对CPU就是一种浪费（因为根本不显示出来）；而适当的低频率FixedUpdate，虽然偶尔会造成人物有顿感，但是往往是可以接受的。</p><p>4、FixedUpdate的最高值也是可以设置的。Time Manager中的Maximum Allowed Timestep就是给处理物体运算的FixedUpdate加上一个限制。如果某一帧的物理运算时间超过了这个值，物理引擎就会立即停止运算，以便让主循环Update可以追上,一旦这一帧主循环Update运行完成，物理引擎就会从它暂停的地方恢复计算就像它从来没有停止过一样。</p><h1 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate"></a>LateUpdate</h1><p>3、LateUpdate它会在所有update被调用后调用，这个函数可以在我们编写ai时被使用，因为我们要当所有物体和怪物移动过后再判断物体的一些策略，比如开枪等，这个时候就可以在LateUpdate中编写，因为LateUpdate基本可以保证所有物体在本帧的移动等操作均已经完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生命流程图&quot;&gt;&lt;a href=&quot;#生命流程图&quot; class=&quot;headerlink&quot; title=&quot;生命流程图&quot;&gt;&lt;/a&gt;生命流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/CodingCodingK/Coding</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity常见UI基础问题手册</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/Guide_UnityUI/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/Guide_UnityUI/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<p>仅作个人笔记用途。</p><h1 id="UI顶层显示"><a href="#UI顶层显示" class="headerlink" title="UI顶层显示"></a>UI顶层显示</h1><h2 id="方法一-做一个新的UI摄像机"><a href="#方法一-做一个新的UI摄像机" class="headerlink" title="方法一.做一个新的UI摄像机"></a>方法一.做一个新的UI摄像机</h2><p>① Canvas的Render Mode设置为<strong>Screen Space - Camera</strong></p><p>② 新建摄像机（后面称之为UI摄像机），放到原先摄像机的下面</p><p>③ 拖拽UI摄像机到Canvas的Render Camera</p><p>④ UI摄像机的 Clear Flags 设置为 <strong>Depth only</strong>，用来去掉背景；Culling Mask设置为 <strong>UI</strong>。</p><p>⑤ 确保 UI摄像机的Depth &gt; 其他摄像机的Depth （值小的会先渲染，所以值大的会在前面）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1dK4y1b7be?spm_id_from=333.999.0.0">超级细致的调试教学视频</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅作个人笔记用途。&lt;/p&gt;
&lt;h1 id=&quot;UI顶层显示&quot;&gt;&lt;a href=&quot;#UI顶层显示&quot; class=&quot;headerlink&quot; title=&quot;UI顶层显示&quot;&gt;&lt;/a&gt;UI顶层显示&lt;/h1&gt;&lt;h2 id=&quot;方法一-做一个新的UI摄像机&quot;&gt;&lt;a href=&quot;#方法一-做一</summary>
      
    
    
    
    <category term="Unity个人积累" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Unity渲染原理</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/Rendering/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/Rendering/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<p>渲染原理学习。// TODO</p><h1 id="Rending面板"><a href="#Rending面板" class="headerlink" title="Rending面板"></a>Rending面板</h1><h2 id="Color-Space"><a href="#Color-Space" class="headerlink" title="Color Space"></a>Color Space</h2><p>以前的阴极射线管电视，需要更强烈的色彩来弥补差设备显示，但现在硬件提升已经不需要了。</p><p>这就是为什么把Rendering的Color Space从Gamma切到Linear。</p><h3 id="阴极-真空管-电视"><a href="#阴极-真空管-电视" class="headerlink" title="阴极 真空管 电视"></a>阴极 真空管 电视</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118131229.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染原理学习。// TODO&lt;/p&gt;
&lt;h1 id=&quot;Rending面板&quot;&gt;&lt;a href=&quot;#Rending面板&quot; class=&quot;headerlink&quot; title=&quot;Rending面板&quot;&gt;&lt;/a&gt;Rending面板&lt;/h1&gt;&lt;h2 id=&quot;Color-Space&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/categories/Unity/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
</feed>
