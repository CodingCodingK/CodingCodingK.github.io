<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2021-11-06T04:30:33.222Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C# 同步异步探究</title>
    <link href="https://codingcodingk.github.io/2021/11/06/Tech/CSharp/Mine/tongbuyibu/"/>
    <id>https://codingcodingk.github.io/2021/11/06/Tech/CSharp/Mine/tongbuyibu/</id>
    <published>2021-11-06T04:30:33.222Z</published>
    <updated>2021-11-06T04:30:33.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>  项目中每天都在接触，但是对这俩概念比较模糊。看《CLR via C#》刚好提到了，就去网上找到一篇好文，理解写篇自己的笔记。</p><h3 id="IO-概念区分"><a href="#IO-概念区分" class="headerlink" title="IO 概念区分"></a>IO 概念区分</h3><ul><li><p>同步（Synchronous）</p></li><li><p>异步( Asynchronous)</p></li><li><p>阻塞( Blocking )</p></li><li><p>非阻塞( Nonblocking)</p></li></ul><p>那首先，要弄清楚同步异步、阻塞非阻塞之间的关系。</p><ul><li><p>同步异步 指的是在客户端，<br>同步意味着 客户端提出了一个请求以后，在回应之前只能等待。<br>异步意味着 客户端提出一个请求以后，还可以继续提其他请求。</p></li><li><p>阻塞非阻塞 指的是服务器端，<br>阻塞意味着 服务器接受一个请求后，在返回结果以前不能接受其他请求。<br>非阻塞意味着 服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求。</p></li></ul><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><ol><li>同步与异步意图<br>这个层级的还是很好理解，它们的核心是消息通信机制。</li></ol><ul><li>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。也就是说，代码执行会等着它，卡在那不动，直到执行结束把返回值给我才继续。</li><li>异步则是相反，调用在发出之后，这个调用就直接返回了，没有返回结果，我记得如果还没返回就去拿的话好像是null。也就是说，代码执行不会等它，你管你运行，返回值我不需要所以我继续往下跑，你运行完执行你自己的回调函数就行。用途有点类似于子线程。</li></ul><ol start="2"><li>阻塞与非阻塞意图<br>区分是调用结果返回之前，是否将调用的线程挂起，暂时不理其他请求。</li></ol><h3 id="不同模型的理解"><a href="#不同模型的理解" class="headerlink" title="不同模型的理解"></a>不同模型的理解</h3><p>直接把别人博客的图整理下拿过来了，<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211104120820.png"></p><ol><li>说的是单线程普通情况下，是这么执行的。按顺序一个个，等A有返回值回来了再B，B有返回值回来了再C。</li><li>说的是多线程同步的情况，并行运行，不展开，图简单，但实际交互非常复杂，通道、共享内存啥的。这里提这个是为了体现异步的作用。</li><li>说的是单线程异步执行，看得到ABC这运行，理论上是没有什么执行顺序可言的（项目经验告诉我，实际上这句话不对，但是概念上这么理解就够了，毕竟不可靠），属于是把程序执行顺序直接丢了。看上去事件花销和1的同步一样，那为什么要引入这个概念呢？看4。</li><li>可以看到，其实3还是比同步的情况下省了很多时间，这个waiting可能是方法里人工delay，也可能是在等待磁盘坑长的I/O操作返回结果，所以如果异步，灰色的部分就省下来了。由此也可知，异步唯一存在的阻塞情况，是无方法可执行的时候（ABC都在灰色段等着I/O给结果）。</li></ol><p>以上用于理解概念是够了，但是实际应用会多很多（比如异步有很多方法可以实现，每种方法可控性等不同）。</p><p>本来打算写到这就暂停的，但是工作中又遇到了关于await Task.Run(void)、await Task的问题，中文网站上根本搜不到，受不了，直接谷歌找了篇不错的blog，补充一下上面提到的“实际应用”。</p><h1 id="Async-and-Await"><a href="#Async-and-Await" class="headerlink" title="Async and Await"></a>Async and Await</h1><p>  一篇不错的文章，虽然是2012年（也就是Async/Await语法糖出来的时候）的还是英文，但是把两者分析的非常透彻。刚好作为实际应用的补充。</p><h3 id="先来介绍一下这两个C-关键字"><a href="#先来介绍一下这两个C-关键字" class="headerlink" title="先来介绍一下这两个C#关键字"></a>先来介绍一下这两个C#关键字</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoSomethingAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// In the Real World, we would actually do something...</span></span><br><span class="line">  <span class="comment">// For this example, we&#x27;re just going to (asynchronously) wait 100ms.</span></span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <font color='red'>async </font>只有2个作用。一是是允许await这个关键字的使用，二是改变了方法结果的处理方式。async在执行开始时，是和同步运行一样的。也就是说在遇到await之前，它是同步的。</p><p>  <font color='red'>await </font>是异步操作的启动器。它会持续监视一个<font color='red'>异步操作 </font>（asynchronous operation）的执行，<br>  如果这个异步操作已经完成了，那他就会继续跑后续代码；<br>  如果这个异步操作未完成，就开始真正的<font color='red'>异步</font>：调用者会将这个async任务暂时挂起，直到await监视的异步操作处理完后，才继续执行后续代码。注意了，这个处理完后的执行，是会根据遇到await之前捕捉下来的<font color='red'>上下文（Context） </font>环境来继续运行。u1s1，这听着很像unity的协程好吧。<br>  通过上面知道了，async方法体里遇到个await、且await后面跟了个需要时间去处理的方法（上面叫异步操作，举个例子比如I/O操作吧），这个时候这个async方法会被阻塞住，但是整个线程并不会被阻塞住，而是在做其他的异步方法了，直到其他方法也卡住。</p><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>  从上可知，你只需要提供<font color='red'>异步操作</font>就可以实现一个异步。你可以直接用微软提供支持的Task或者Task<T>，或者将各种方法转换成一个异步操作，或者是Task.Yield会返回不是Tasks的异步操作。<br>  关于异步操作的一个要点是:异步操作，指的不是async关键词修饰的就是异步操作，而是他是一个可以异步操作的类型。换句话说，你可以await一个类型为Task的async method，这是因为方法返回Task，而不是因为它是async的。所以你也可以await一个返回Task的非async方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">NewStuffAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use await and have fun with the new stuff.</span></span><br><span class="line">  <span class="keyword">await</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">MyOldTaskParallelLibraryCode</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 最开始就说的，因为这个方法没有async关键词修饰，所里方法体里不能用await关键词</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ComposeAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// We can await Tasks, regardless of where they come from.</span></span><br><span class="line">  <span class="keyword">await</span> NewStuffAsync();</span><br><span class="line">  <span class="keyword">await</span> MyOldTaskParallelLibraryCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Return-Types"><a href="#Return-Types" class="headerlink" title="Return Types"></a>Return Types</h3><p>  Async方法可以返回Task<T>、Task以及void，但是在大部分情况我们都会选择前两个而不是void，因为Task<T>、Task是可以等待的，而void不行。<br>  那什么时候用void呢？原文是这么说的：</p><blockquote><p>You have to return void when you have async event handlers.</p></blockquote><h3 id="Returning-Values"><a href="#Returning-Values" class="headerlink" title="Returning Values"></a>Returning Values</h3><p>  这个和上面不同，这个是返回值。Task和void一样都没有返回值，但是Task<T>有T类型的返回值。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>  上下文。上面提到过，当await的异步操作结束后，将会根据遇到await之前捕捉下来的上下文环境继续执行代码。上下文是什么？简单来说：</p><ul><li>如果你在一个UI线程上，那么就是个UI Context</li><li>如果你在一个ASP.NET请求上，那么就是个ASP.NET request context</li><li>否则，通常会是一个线程池环境（a thread pool context）。<br>好嘛，听君一席话。那么复杂点说呢？</li><li>如果<font color='red'>SynchronizationContext.Current</font>不是null的，那么SynchronizationContext.Current就是它的上下文（UI、ASP.NET）</li><li>其他情况，就是当前的<font color='red'>TaskScheduler</font><br>这两个名词暂时先不展开了。<br>下面看一个示例。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinForms 例子 (当然wpf也一样).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当这个异步方法DownloadFileAsync在await的时候，UI线程并不会被阻塞。</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASP.NET 例子</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">MyButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await之后，ASP.NET线程并不会因此被阻塞</span></span><br><span class="line">  <span class="comment">// 这使得这个线程仍然可以接受其他的request</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(...);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复ASP.NET Context，然后就可以连接到当前请求了</span></span><br><span class="line">  <span class="comment">// 也许结束那一瞬间，我们在其他的线程上，但是也能拥有同样的ASP.NET Context</span></span><br><span class="line">  Response.Write(<span class="string">&quot;File downloaded!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h1&gt;&lt;p&gt;  项目中每天都在接触，但是对这俩概念比较模糊。看《CLR via C#》刚好提到了，就去网上找到一篇好文，理解写篇</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="Mine" scheme="https://codingcodingk.github.io/categories/CSharp/Mine/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CLR Via C#个人笔记 - C#类的设计</title>
    <link href="https://codingcodingk.github.io/2021/11/06/Tech/CSharp/CLR-Via-CSharp/cp2/"/>
    <id>https://codingcodingk.github.io/2021/11/06/Tech/CSharp/CLR-Via-CSharp/cp2/</id>
    <published>2021-11-06T04:30:33.221Z</published>
    <updated>2021-11-06T04:30:33.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的根基"><a href="#类的根基" class="headerlink" title="类的根基"></a>类的根基</h1><h3 id="所有类都从System-Object派生"><a href="#所有类都从System-Object派生" class="headerlink" title="所有类都从System.Object派生"></a>所有类都从System.Object派生</h3><p>  CLR要求所有类最终都从<font color="#dd0000">System.Object类</font>派生。无论你的类写不写父类，都会继承自此。注意，通过反编译看构造比较难看出这一点，但是很重要。</p><h3 id="System-Object的方法"><a href="#System-Object的方法" class="headerlink" title="System.Object的方法"></a>System.Object的方法</h3><p>public：</p><ul><li>Equals： 没啥好说，如果不重写默认就是判断值是否相等，==判断的是引用地址是否相等。String的比较特殊，微软重写了，所以”AAA” == “AAA”是会返回true的。</li><li>GetHashCode： 返回对象的值得哈希码。用的少。</li><li>ToString： 返回类型的完整名称(this.GetType().FullName)。经常重写。</li><li>GetType： 获取类型，反射常用的。注意它是非虚，目的是不推荐修改。</li></ul><p>protected：</p><ul><li>MemberwiseClone： 非虚方法。书里讲得不好，简单来说本方法就是浅拷贝。浅拷贝简单理解为只对类里的值类型字段进行逐位复制，而引用类型字段则拷贝引用。引用也新造，就是深拷贝了。</li><li>Finalize： 在被GC前，会调用一次这个虚方法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类的根基&quot;&gt;&lt;a href=&quot;#类的根基&quot; class=&quot;headerlink&quot; title=&quot;类的根基&quot;&gt;&lt;/a&gt;类的根基&lt;/h1&gt;&lt;h3 id=&quot;所有类都从System-Object派生&quot;&gt;&lt;a href=&quot;#所有类都从System-Object派生&quot; cla</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="CLR via C#" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 通信</title>
    <link href="https://codingcodingk.github.io/2021/11/06/Project/Unity/Moba/HOK/cs/"/>
    <id>https://codingcodingk.github.io/2021/11/06/Project/Unity/Moba/HOK/cs/</id>
    <published>2021-11-06T04:30:33.220Z</published>
    <updated>2021-11-06T04:30:33.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-基础框架"><a href="#一-基础框架" class="headerlink" title="一.基础框架"></a>一.基础框架</h1><h3 id="1-基本构架"><a href="#1-基本构架" class="headerlink" title="1.基本构架"></a>1.基本构架</h3><ul><li></li></ul><p>To Be  Continued …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-基础框架&quot;&gt;&lt;a href=&quot;#一-基础框架&quot; class=&quot;headerlink&quot; title=&quot;一.基础框架&quot;&gt;&lt;/a&gt;一.基础框架&lt;/h1&gt;&lt;h3 id=&quot;1-基本构架&quot;&gt;&lt;a href=&quot;#1-基本构架&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
    <category term="C/S" scheme="https://codingcodingk.github.io/tags/C-S/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 序言</title>
    <link href="https://codingcodingk.github.io/2021/11/06/Project/Unity/Moba/HOK/intro/"/>
    <id>https://codingcodingk.github.io/2021/11/06/Project/Unity/Moba/HOK/intro/</id>
    <published>2021-11-06T04:30:33.220Z</published>
    <updated>2021-11-06T04:30:33.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零-MarkDown个人约束"><a href="#零-MarkDown个人约束" class="headerlink" title="零.MarkDown个人约束"></a>零.MarkDown个人约束</h1><ul><li><p>一级标题：# 一.XXX</p></li><li><p>二级标题：### 1.XXX</p></li><li><p>三级标题：#### ① XXX</p></li><li><p>有序内容：1. XXX</p></li><li><p>无序内容：* XXX</p></li><li><p>内容：XXX</p></li><li><p>文件头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">title: 王者荣耀复刻项目 序言</span><br><span class="line">cover: https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/hok.jpg</span><br><span class="line">tags:</span><br><span class="line">  - Unity</span><br><span class="line">  - 工程</span><br><span class="line">  - Moba</span><br><span class="line">categories:</span><br><span class="line">  - Unity</span><br><span class="line">  - Moba</span><br><span class="line">  - 王者荣耀复刻项目</span><br></pre></td></tr></table></figure></li></ul><h1 id="一-序言"><a href="#一-序言" class="headerlink" title="一.序言"></a>一.序言</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>仍然采用C/S构架,列一些需要涉及的Tags：Moba、云服务器部署代码、客户端帧同步</li></ul><h3 id="使用的自制库"><a href="#使用的自制库" class="headerlink" title="使用的自制库"></a>使用的自制库</h3><ul><li></li></ul><h3 id="游戏流程"><a href="#游戏流程" class="headerlink" title="游戏流程"></a>游戏流程</h3><p>To Be  Continued …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零-MarkDown个人约束&quot;&gt;&lt;a href=&quot;#零-MarkDown个人约束&quot; class=&quot;headerlink&quot; title=&quot;零.MarkDown个人约束&quot;&gt;&lt;/a&gt;零.MarkDown个人约束&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一级标题：# 一.XXX&lt;</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 UI篇</title>
    <link href="https://codingcodingk.github.io/2021/11/06/Project/Unity/Moba/HOK/ui/"/>
    <id>https://codingcodingk.github.io/2021/11/06/Project/Unity/Moba/HOK/ui/</id>
    <published>2021-11-06T04:30:33.220Z</published>
    <updated>2021-11-06T04:30:33.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UI部分"><a href="#UI部分" class="headerlink" title="UI部分"></a>UI部分</h1><h3 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h3><p>  客户端UI部分很简单，毕竟主要是为了学一个游戏类型，不用lua也不用像GF那样健壮:<br>  // TODO 这里是个脑图,做完了再贴</p><p>  <font color='red'> Service</font>，共通业务服务，抽出来就是为了方便调用。</p><ul><li>NetSvc： 用来进行与服务器交互，具体的可以在通信那章看实现</li><li>ResSvc： 用来缓存各类资源在内存中，方便再次调用</li><li>AudioSvc： 播放bgm、clip</li></ul><p>  <font color='red'> System</font>，具体业务层，每个业务层拥有自己管理的窗口，每个业务层之间可以相互交互，但是每个窗口之间禁止交互，需要交互的话要通过业务层交互。嘛，反正是人为规定的，就是为了易读、解耦。这套还是上个项目里直接拿来的，以前觉得有点繁琐，现在才发现大部分代码都可以挪过来直接用，真爽。</p><ul><li>LoginSys： 登录业务</li><li>LobbySys： MOBA大厅（其实就是主城…）、匹配的业务</li><li>BattleSys： 战斗业务，这个会专门在一章里讲</li></ul><p>  <font color='red'> Window</font>，窗口页面逻辑。下面细说。方便回忆，采用why（为什么存在=对应什么需求）- what（是什么=没看过这块代码的程序员对这个黑箱业务的认知）- how（如何=代码层面是怎么实现的）描述法。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>  NetSvc放在通信那章讲，所以只说Res和Audio。</p><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><h5 id="TipsWindow"><a href="#TipsWindow" class="headerlink" title="TipsWindow"></a>TipsWindow</h5><p>why：<br>中间提示一下就消失的Tip，用于提示用户。<br>what：<br>调用它的<code>SetTips</code>方法，放入一个string参数，就可以在画面上自动播一个提醒，带动画。如果同时调用，会按照调用顺序一个一个轮播，直到全部播完。永远在画面最上层。<br>how：<br>画面最上层，很好解决，窗口GameObject移到Canvas的最下面就行了。</p><p>解决多个地方同时发请求展示Tips时候的竞争处理，用了队列、锁和一个记录是否正在播放tips的flag <code>isTipShow</code>。<br>先做一个队列<code>Queue&lt;string&gt; tipsPool</code>用于临时存储传进来的参。在Update中会检查tipsPool的大小，大于0且isTipShow为false则上锁，从tipsPool中Dequeue一个成员出来，对其执行播放动画方法、并把isTipShow设置为true，再执行一个带协程等待（等待时长为tips动画时长）的方法，方法里将isTipsShow设回false，其实就是个异步回调。当然这个回调也可以不用协程等待这种代码方式实现，用unity方式的话直接在Animation的最后一帧加入一个Animation Event，执行这个回调事件即可。</p><p>至于动画是怎么做的就不说了，无非是新建一个Animation会多一个Animator组件，之后再关键帧录制就能实现的东西，注意取消状态机里的动画loop。</p><p>To Be  Continued …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UI部分&quot;&gt;&lt;a href=&quot;#UI部分&quot; class=&quot;headerlink&quot; title=&quot;UI部分&quot;&gt;&lt;/a&gt;UI部分&lt;/h1&gt;&lt;h3 id=&quot;整体介绍&quot;&gt;&lt;a href=&quot;#整体介绍&quot; class=&quot;headerlink&quot; title=&quot;整体介绍&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
    <category term="C/S" scheme="https://codingcodingk.github.io/tags/C-S/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Hexo?</title>
    <link href="https://codingcodingk.github.io/2021/10/29/Tech/Hexo/htUseHexo/"/>
    <id>https://codingcodingk.github.io/2021/10/29/Tech/Hexo/htUseHexo/</id>
    <published>2021-10-29T08:04:44.156Z</published>
    <updated>2021-11-06T04:30:33.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Markdown个人约束"><a href="#一-Markdown个人约束" class="headerlink" title="一.Markdown个人约束"></a>一.Markdown个人约束</h1><ul><li><p>一级标题：# 一.XXX</p></li><li><p>二级标题：### 1.XXX</p></li><li><p>三级标题：#### ① XXX</p></li><li><p>有序内容：1. XXX</p></li><li><p>无序内容：* XXX</p></li><li><p>内容：XXX</p></li></ul><h1 id="二-Markdown常用语法"><a href="#二-Markdown常用语法" class="headerlink" title="二.Markdown常用语法"></a>二.Markdown常用语法</h1><ul><li><p>引用内容：&gt; XXX</p></li><li><p>单行代码：``</p></li><li><p>多行代码：``````</p></li><li><p>其他：<a href="https://www.jianshu.com/p/a6a6a22e9393">https://www.jianshu.com/p/a6a6a22e9393</a></p></li></ul><h1 id="三-Hexo文件头"><a href="#三-Hexo文件头" class="headerlink" title="三.Hexo文件头"></a>三.Hexo文件头</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">title: 如何使用Hexo?</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">  - 技术</span><br><span class="line">categories:</span><br><span class="line">  - Hexo</span><br><span class="line">    - Hexo1</span><br><span class="line">    Hexo2</span><br><span class="line">    cover: 文章封面图</span><br><span class="line">    top_img: 文章Top图</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-Markdown个人约束&quot;&gt;&lt;a href=&quot;#一-Markdown个人约束&quot; class=&quot;headerlink&quot; title=&quot;一.Markdown个人约束&quot;&gt;&lt;/a&gt;一.Markdown个人约束&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一级标题：# 一.XXX&lt;</summary>
      
    
    
    
    <category term="Hexo" scheme="https://codingcodingk.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://codingcodingk.github.io/tags/Hexo/"/>
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CLR Via C#个人笔记 - CLR基础</title>
    <link href="https://codingcodingk.github.io/2021/10/29/Tech/CSharp/CLR-Via-CSharp/cp1/"/>
    <id>https://codingcodingk.github.io/2021/10/29/Tech/CSharp/CLR-Via-CSharp/cp1/</id>
    <published>2021-10-29T08:04:44.155Z</published>
    <updated>2021-11-06T04:30:33.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h1><h3 id="CLR是什么"><a href="#CLR是什么" class="headerlink" title="CLR是什么"></a>CLR是什么</h3><ul><li><strong>Common Language Runtime 公共语言运行时</strong>，CLR和Java虚拟机一样也<strong>是一个运行时环境</strong>，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。</li></ul><p>再丢几个概念，除了编译器，另外3个会在下面讲PE文件会提到，因为这3个是托管PE文件的构成部分。</p><ul><li><p><strong>「编译器」</strong>检查源代码，确定根据所使用语言语法所写的代码是有意义的，并输出实现其意图的代码。</p></li><li><p><strong>元数据</strong>，每个托管模块都包含元数据表，主要是2种表：描述源代码中定义的类型和成员；描述源代码引用的类型和成员。</p></li><li><p><strong>IL</strong>，中间语言代码，编译器编译源代码时生成的代码。在运行时，CLR将IL编译成本机CPU指令。</p></li><li><p><strong>PE32或PE32+头</strong>，决定程序是以32位还是64位运行的<strong>文件头</strong>，它和VS中的目标平台中选项（下面叫做**/platform开关选项**）相关联</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211022161435339.png" alt="image-20211022161435339"></p></li></ul><h3 id="CLR、程序集是怎么跑起来的"><a href="#CLR、程序集是怎么跑起来的" class="headerlink" title="CLR、程序集是怎么跑起来的"></a>CLR、程序集是怎么跑起来的</h3><h6 id="①-项目运行流程"><a href="#①-项目运行流程" class="headerlink" title="① 项目运行流程"></a>① 项目运行流程</h6><ol><li>Windows检查EXE文件头，决定是创建32位还是64位进程之后，会在进程地址空间加载MSCorEE.dll的对应版本（比如x86版本在%SystemRoot%\System32目录中）。</li><li>然后，进程的主线程调用MSCorEE.dll中定义的一个方法，这个方法初始化CLR，加载EXE程序集，再调用其入口方法（Main）。</li><li>随即，托管应用程序启动并运行。</li></ol><h6 id="②-从代码文件到托管模块运行流程"><a href="#②-从代码文件到托管模块运行流程" class="headerlink" title="②  从代码文件到托管模块运行流程"></a>②  从代码文件到托管模块运行流程</h6><p>源代码 -&gt; 编译器（是面向进行时的编译器） -&gt; 托管模块（是32或64位的Windows可移植执行体文件）</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211021173506928.png" alt="image-20211021173506928"></p><h3 id="IL代码"><a href="#IL代码" class="headerlink" title="IL代码"></a>IL代码</h3><h6 id="①-IL是很高级的机器语言。"><a href="#①-IL是很高级的机器语言。" class="headerlink" title="①  IL是很高级的机器语言。"></a>①  IL是很高级的机器语言。</h6><blockquote><p>IL是与CPU无关的机器语言，它比大多数CPU机器语言都高级。</p><p>IL基于栈。这意味着它的所有指令都要将操作数压入（push）一个执行栈，并从栈中弹出（pop）结果。</p></blockquote><ol><li><p>它是面向对象的，它能访问和操作对象类型，并提供指令初始化对象、调用对象虚方法等。</p></li><li><p>由于C#、VB语言、F#等高级语言，最终都是被对应编译器转换为IL代码，所以比如可以将C#（擅长I/O）、vb.net的代码集成到一个解决方案中一起写，好处是能同时用<strong>各自的语言特性</strong>和<strong>语言所使用的CLR功能模块</strong>。如下，CLS是规定的所有语言必须支持的最小功能集。<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102121640.png"></p></li><li><p>为了执行方法，首先必须把方法的IL转换成本机（native）CPU指令。这是CLR的JIT（just-in-time或者“即时”）编译器的职责。</p><blockquote><p>JIT编译器： 因为JITCompiler是即时编译的，所以被称为JIT just-in-time。</p></blockquote></li></ol><h6 id="②-JITCompiler参与了什么？"><a href="#②-JITCompiler参与了什么？" class="headerlink" title="②  JITCompiler参与了什么？"></a>②  <strong>JITCompiler</strong>参与了什么？</h6><p>   主要是JITCompiler做的事，它会把第一次遇到的IL代码进行验证+编译，最后放进内存中。</p><p>   方法仅在首次调用时才会有一些性能损失，以后对该方法的所有调用都以本机代码的形式全速运行。</p><p>   注意第一次执行方法WriteLine时会比第二次执行WriteLIne所消耗的多：</p><p>   <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211022164732481.png" alt="image-20211022164732481"></p><p>   <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/image-20211022170151293.png" alt="image-20211022170151293"></p><h6 id="③-IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。"><a href="#③-IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。" class="headerlink" title="③  IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。"></a>③  IL的最大优势不是他对底层CPU的抽象，而是健壮性和安全性。</h6><p>   CLR在IL编译成本机CPU时，会进行一步**<font color="#dd0000">验证</font>**工序。它会检查高级IL代码，确定代码所做的一切都是安全的（比如方法的入参是否正确）。<br>   Windows的每个进程都有自己的虚拟地址空间，给进程自己的独立地址空间，是为了相互之间不影响。当然每个进程可以有多个AppDomain，此不多拓展。</p><h6 id="④-unsafe代码"><a href="#④-unsafe代码" class="headerlink" title="④ unsafe代码"></a>④ unsafe代码</h6><p>   c#编译器默认生成safe代码，这种代码安全性可以验证。然而c#编译器也允许unsafe代码存在，这类代码允许直接操作内存地址，并可操作这些地址处的字节。需要用unsafe{}关键字标记，通常用于处理非托管。<br>   winform项目中遇到过，很不建议c#程序员操作内存，非常难定位崩溃原因。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public unsafe void swap(int* p, int *q)</span><br><span class="line">&#123;</span><br><span class="line">int temp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NGen-exe工具"><a href="#NGen-exe工具" class="headerlink" title="NGen.exe工具"></a>NGen.exe工具</h3><p>  .Net Framework提供的NGen.exe工具，可以在应用程序安装到用户计算机时，将IL代码编译成本机代码。<br>  直接使用本机代码可以跳过编译步骤。但在本机代码文件缺失的地方，仍然会去用JIT编译IL代码。<br>  是否用它的利弊很难平衡。启动速度是快了，但如果本机环境一变（比如换了cpu、windows版本等），就会仍然需要JIT编译。而且本机代码，无法像JIT一样对本机做出许多假定，就会少很多优化。</p><h3 id="Framework类库"><a href="#Framework类库" class="headerlink" title="Framework类库"></a>Framework类库</h3><p>  可以了解下Framework都能做什么。</p><ul><li>Web服务 这个用的是ASP.Net，对应的是.NET CORE框架，和framework区别还挺大的。</li><li>GUI 应用程序 一般说的就是wpf、winform，官方提供的，主要写PC客户端程序。</li><li>控制台程序</li><li>Windows服务 通过SCM（windows服务控制管理器）控制，这个不太懂</li><li>数据库存储过程</li><li>组件库 就是自己写的单独程序集，导出，以后当插件用了</li></ul><h3 id="CTS规范"><a href="#CTS规范" class="headerlink" title="CTS规范"></a>CTS规范</h3><p>  通用类型系统 Common Type System，没啥难点，应该是很早的一个规范了。说的就是，</p><ul><li>类成员需要按照Field、Methond、Property、Event这几个去写。</li><li>访问规则要定，就是public、protected那几个。</li></ul><p>  每个不同的语言都拥有自己对类不同的写法和特点，但即使代码不同，它们的行为（也就是想让它实现什么）是可以完全一致的。</p><h1 id="生成、打包、部署、管理应用程序"><a href="#生成、打包、部署、管理应用程序" class="headerlink" title="生成、打包、部署、管理应用程序"></a>生成、打包、部署、管理应用程序</h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>  C#编译器在执行一个像下面一样的代码时，<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Program.cs :</span><br><span class="line">public sealed class Program&#123;</span><br><span class="line">public static void Main()&#123;</span><br><span class="line">System.Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  因为，调用了System这个包，所以为了生成这个示例应用程序需要在命令行输入：<br>  <code>csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs</code><br>  这个命令行指示C#编译器生成名为Program.exe的可执行文件(/out:Program.exe)，类型是32位控制台应用程序类型exe。<br>  其中MSCorLib.dll因为太常用了，会自动引用，所以不写也行。</p><h3 id="响应文件"><a href="#响应文件" class="headerlink" title="响应文件"></a>响应文件</h3><p>  响应文件就是个cmd命令集的可执行程序，执行它就相当于对控制台逐行输入命令。<br>  一键设置参数省力用的，它长下面这样：<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// CSC.exe :</span><br><span class="line">/out:MyProject.exe</span><br><span class="line">/target:winexe</span><br></pre></td></tr></table></figure><br>  当用命令行执行响应文件CSC.exe时，还会去其所在目录寻找文件CSC.rsp，里面放你想要全局都引用的dll。</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>  在说元数据之前，先聊一下Program.exe文件，托管PE文件（可移植执行体）由4部分构成：</p><ul><li><p>PE32(+)头： 本篇开头提过，不多说。</p></li><li><p>IL： 前面也讲过了。</p></li><li><p>CLR头： 一个小的信息块，包含需要CLR的功能的模块。还是个模块的集合呗。可以查看CorHdr.h头文件定义的IMAGE_COR20_HEADER来了解CLR头的具体格式。</p></li><li><p><strong>元数据</strong>： 是由几个表构成的二进制数据块。分三种，定义表、引用表和清单表。图放在下面，看看有哪些类型的表来理解下意图就完了。</p></li></ul><p>  <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102170858.png"><br>  <img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102171005.png"></p><p>还有例案元数据代码在书35p，这个很推荐自己看代码，下面只记一个重点。<br>以上面写的那个 Program.exe (就那个Hello World)为例，经过ILDasm.exe整理+美化过的元数据表如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102172336.png"></p><p>注意划线的两块，一个是公共静态方法Main，一个是编译器自动生成的默认类构造器。<br>Main，公共静态方法，用IL代码实现，返回类型void，无参。<br>构造器，公共方法，也用IL代码实现，返回类型void，无参。有一个this指针，指向调用方法时构造对象的内存。</p><h3 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h3><p>  上面说的Program.exe不只是PE文件，也是个程序集(assembly)。上面上的元数据表的第三个清单表没讲，在这里引入：清单表包含一下3个信息，</p><ul><li>定义了程序集的可重用的类型</li><li>用一个版本号标记程序集</li><li>可以关联程序集的安全信息</li></ul><p>说的有点复杂了，从用途来看，把它当一个EXE或者DLL就行了。就和DLL一样，如果缺失就会去URL指向的位置下载文件到缓存中，如果仍然没有，就会抛出FileNotFoundException异常。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>  微软采用的就是如下的版本编号方案，建议个人也统一标准采用这个。</p><p>  比如2.5.719.2，2.5是公众对版本的认知；而719是程序集的build号，如果公司每天都生成程序集，那它应该每天递增；revesion是指出当前build的修订次数，如果公司某天内必须生成2次程序集，那revision该递增。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211102183028.png"></p><p>剩下2.7 - 2.8(讲config配置文件)实在是太枯燥，看完一遍也整理不出什么，就这样吧。</p><h1 id="共享程序集和强命名程序集"><a href="#共享程序集和强命名程序集" class="headerlink" title="共享程序集和强命名程序集"></a>共享程序集和强命名程序集</h1><h3 id="两种程序集，两种部署"><a href="#两种程序集，两种部署" class="headerlink" title="两种程序集，两种部署"></a>两种程序集，两种部署</h3><p>to be continued…    // 粗略看了一遍，感觉最后再看比较好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CLR&quot;&gt;&lt;a href=&quot;#CLR&quot; class=&quot;headerlink&quot; title=&quot;CLR&quot;&gt;&lt;/a&gt;CLR&lt;/h1&gt;&lt;h3 id=&quot;CLR是什么&quot;&gt;&lt;a href=&quot;#CLR是什么&quot; class=&quot;headerlink&quot; title=&quot;CLR是什么&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="CLR via C#" scheme="https://codingcodingk.github.io/categories/CSharp/CLR-via-C/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
</feed>
