<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2022-08-12T13:40:36.334Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP、UDP的区别</title>
    <link href="https://codingcodingk.github.io/Tech/Net/tcp_udp/"/>
    <id>https://codingcodingk.github.io/Tech/Net/tcp_udp/</id>
    <published>2022-08-12T13:40:36.334Z</published>
    <updated>2022-08-12T13:40:36.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是TCP、UDP"><a href="#什么是TCP、UDP" class="headerlink" title="什么是TCP、UDP"></a>什么是TCP、UDP</h1><p>协议，他们都只工作在传输层。</p><h1 id="什么是TCP的挥手、握手"><a href="#什么是TCP的挥手、握手" class="headerlink" title="什么是TCP的挥手、握手"></a>什么是TCP的挥手、握手</h1><p>三次握手、传输确认、四次挥手。</p><p><strong>三次握手：</strong>建立连接用的。客户端发起请求给服务端，服务端返回消息给客户端发番号，客户端再发送请求给服务端，完成连接的建立。</p><p>为什么需要第三步？为了<strong>解决网络信道不可靠问题</strong>。第一个请求包阻塞了，所以客户端重新再做了第一步成功建立了连接，此时之前的那个阻塞包又恢复了，此时如果没有第三步服务端就会成功建立第二个连接。</p><p><strong>传输确认：</strong>一包数据可能拆成多包发送，如何处理丢包问题？这些包的到达顺序不一定，如何处理乱序问题？答案是通过回复确认包。</p><p>这个根据下图模型理解。首先TCP会在建立连接之后，会创建如下的发送缓冲区。每次发送报文时，除了数据内容，还会在TCP协议头中附带本次数据内容的序列号（起始下标）+长度。接收端收到这个包后，会进行回复确认，内容为序列号+长度，也就是下一包的其实序列号。这样做是为了能够<strong>把整个包根据序列号和长度重组</strong>，中间遇到丢包的情况申请重发即可。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220811083837.png"></p><p><strong>四次挥手：</strong>结束连接用的。</p><p>一、二挥手：客户端发送结束包给服务端；服务端返回一个包表示自己进入终止等待状态。这前两次挥手完之后，服务端还可以给客户端发送之前未发完的数据，此时客户端还可以接收。也就是说这前两次是为了发送之前未发完数据。</p><p>三、四挥手：服务端发送完未完数据后，给客户端发送结束包，服务端进入最后确认状态；客户端收到后回复服务端一个确认包，客户端进入超时等待状态，超时后自动关闭连接。这最后一段等待是为了第四次挥手的确认包万一服务端没收到，服务端要求重发时客户端这还能响应。</p><h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><p>基于连接 与 基于非连接。</p><p>UDP不像TCP握手、确认、挥手，它是直接把数据包发过去的，所以占用资源少、速度快。</p><p>因此TCP稳定可靠，UDP速度快实时性强。</p><p>隧道网络：VPN等。// TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是TCP、UDP&quot;&gt;&lt;a href=&quot;#什么是TCP、UDP&quot; class=&quot;headerlink&quot; title=&quot;什么是TCP、UDP&quot;&gt;&lt;/a&gt;什么是TCP、UDP&lt;/h1&gt;&lt;p&gt;协议，他们都只工作在传输层。&lt;/p&gt;
&lt;h1 id=&quot;什么是TCP的挥手、握</summary>
      
    
    
    
    <category term="网络" scheme="https://codingcodingk.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="网络" scheme="https://codingcodingk.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：代码热更新</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/wolong_study/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/wolong_study/</id>
    <published>2022-08-12T13:40:36.330Z</published>
    <updated>2022-08-12T13:40:36.330Z</updated>
    
    <content type="html"><![CDATA[<p>非常感谢 HybridCLR(代号wolong) 的作者walon大佬。</p><h1 id="初识HybridCLR"><a href="#初识HybridCLR" class="headerlink" title="初识HybridCLR"></a>初识HybridCLR</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>能够不写lua，简直就是神。</p><p>HybridCLR ： <a href="https://github.com/focus-creative-games/hybridclr">github</a></p><p>HybridCLR li2cpp plus ： <a href="https://github.com/focus-creative-games/il2cpp_plus">github</a></p><p>HybridCLR示例项目 ： <a href="https://github.com/focus-creative-games/hybridclr_trial">github</a></p><p>手册：<a href="https://focus-creative-games.github.io/hybridclr">github.io</a></p><blockquote><p>HybridCLR 由两部分构成 <a href="https://github.com/focus-creative-games/il2cpp_plus">il2cpp_plus 仓库 (opens new window)</a>和 <a href="https://github.com/focus-creative-games/hybridclr">HybridCLR 仓库 (opens new window)</a>。il2cpp_plus 仓库基于 unity 原始 il2cpp 作了少量修改（几百行），使得它可以支持动态注册元数据，进行可以动态加载 dll。HybridCLR 仓库是 HybridCLR 的核心源代码。</p><p>HybridCLR的安装基于这两部分，安装有一定的<strong>版本规则</strong>。具体见<a href="https://focus-creative-games.github.io/hybridclr/support_versions/">支持的 Unity 版本</a>文档。</p></blockquote><h1 id="配置第一个Unity项目"><a href="#配置第一个Unity项目" class="headerlink" title="配置第一个Unity项目"></a>配置第一个Unity项目</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>Unity版本2020.3.7</p><ol><li>  拷贝<a href="https://github.com/focus-creative-games/il2cpp_plus">HybridCLR li2cpp plus</a>项目中的libil2cpp文件夹 到对应版本Editor的<code>Editor\Data\il2cpp</code>文件夹下，替换原先的libil2cpp文件夹。</li><li>  拷贝<a href="https://github.com/focus-creative-games/hybridclr">HybridCLR</a>中的huatuo文件夹 到对应版本Editor的<code>Editor\Data\il2cpp\libil2cpp</code>文件夹下。</li></ol><p>上面是老版本的安装方法，现在上面2步在示例中已经可以通过修改li2cpp的path来实现了，按照说明<strong>修改.bat、运行.bat</strong>即可自动从远端仓库拉取huatuo。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;非常感谢 HybridCLR(代号wolong) 的作者walon大佬。&lt;/p&gt;
&lt;h1 id=&quot;初识HybridCLR&quot;&gt;&lt;a href=&quot;#初识HybridCLR&quot; class=&quot;headerlink&quot; title=&quot;初识HybridCLR&quot;&gt;&lt;/a&gt;初识HybridC</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="热更新" scheme="https://codingcodingk.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法：查找与搜索</title>
    <link href="https://codingcodingk.github.io/Tech/Algorithm/search/"/>
    <id>https://codingcodingk.github.io/Tech/Algorithm/search/</id>
    <published>2022-06-29T12:18:40.296Z</published>
    <updated>2022-06-29T12:18:40.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p><strong>1.顺序查找</strong><br>        顺序遍历。</p><p><strong>2.二分查找</strong><br>        折半查找、二分查找，一个东西。对数据有要求，必须是按照关键字进行排序的。</p><p><strong>3.插值查找</strong><br>        在二分查找上做的优化。其实就是计算mid值不再是除以2，而是根据线性插值求出一个接近的数。对数据更高要求，不但得是顺序，还必须满足数值分布均匀。</p><p><strong>4.斐波那契查找</strong><br>        想在非均匀分布的数据中优化二分查找，就需要用到了。原理与黄金分割有关，从没见过暂时不看。</p><p><strong>5.分块查找</strong><br>        这个就是类似桶排序的行为，把数据分成多个区间块来查找。</p><p><strong>6.哈希查找</strong><br>        其实就是散列表。选一种哈希函数f，把数据的存储位置x和关键字y形成一种映射，然后查找关键字y时求出下标x即可（当然会有哈希碰撞问题要解决）。</p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深度优先-DFS"><a href="#深度优先-DFS" class="headerlink" title="深度优先 DFS"></a>深度优先 DFS</h2><p>属于图算法一种，是一个针对图和树的遍历算法。是盲目搜索算法。一般用堆+栈数据结构来辅助进行遍历，堆是要遍历的对象、栈内是路径结果。</p><p>搜索前先定义是先找左下子结点还是右下子结点。探索时会不停往下找，直到下方结点没有了，就开始往上一级。遍历期间，将遇到的结点入栈，如果遇到往上一级的情况，就把栈顶结点进行出栈。最后栈内会得到一条路径。</p><p>但注意，DFS终究是一种盲目搜索算法，并不是真正用来寻路的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220629121222.png"></p><h2 id="广度优先-BFS"><a href="#广度优先-BFS" class="headerlink" title="广度优先 BFS"></a>广度优先 BFS</h2><p>连通图的一种遍历算法。是盲目搜索算法。</p><p>一般用队列来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220629144906.png"></p><h2 id="爬山法-Hill-Climbing"><a href="#爬山法-Hill-Climbing" class="headerlink" title="爬山法 Hill Climbing"></a>爬山法 Hill Climbing</h2><p><a href="https://blog.csdn.net/qq_43285351/article/details/90926784">https://blog.csdn.net/qq_43285351/article/details/90926784</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://codingcodingk.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：常见排序</title>
    <link href="https://codingcodingk.github.io/Tech/Algorithm/sort/"/>
    <id>https://codingcodingk.github.io/Tech/Algorithm/sort/</id>
    <published>2022-06-28T15:23:18.461Z</published>
    <updated>2022-06-28T15:23:18.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>精简归纳：<a href="https://www.drflower.top/posts/6a923688/">https://www.drflower.top/posts/6a923688/</a></p><p>入门图解：</p><p><a href="https://blog.csdn.net/weixin_50651363/article/details/120070517">https://blog.csdn.net/weixin_50651363/article/details/120070517</a></p><p><a href="https://blog.csdn.net/kexuanxiu1163/article/details/103051357">https://blog.csdn.net/kexuanxiu1163/article/details/103051357</a></p><h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>我们先固定队尾。进行多次遍历，每一次遍历途中两两比较、两两交换，直到确定到最后1位。下一次还是从头开始遍历，但是之确定到倒数第2位…直到第1位为止。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bbsort.gif"></p><p>可以优化，如果某次遍历产生了0次交换，那么可以提前结束遍历。比如排序有序数组时，一次遍历就结束了。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>我们先固定队头。将队列分为2个部分，前面是排序完的部分、后面是待排序部分，每一次遍历都是去找待排序部分的最小值，放到排序完部分的队尾。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/xuanze_sort.gif"></p><p>Q:冒泡排序与选择排序哪个效率高？<br>A:两者时间复杂度都时候O(n)，但冒泡排序在内存循环交换，选择排序在外循环交换，一般而言选择排序效率更高。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>我们先固定队头。将队列分为2个部分，前面是即刻排序完的部分、后面是待排序部分，每一次遍历都是去待排序部分取第一个数字，保持插入后仍然有序地插入到前面的部分中。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/insertsort.gif"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的改进。选定一个整数增量序列：{a1,a2,…,1}，其中最大的a1&lt;=list.Count()，最小为1。</p><p>这里为了理解选取好1/2序列，也就是{count/2,count/4,…,1}。然后每隔count/2的数为一组进行排序，会分割成很多个内部不相邻的队列，分别对他们进行插入排序。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/shellsort.gif"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分治思想。简单来说就是，两两分组+指针。</p><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4.重复步骤 3 直到某一指针达到序列尾。</p><p>按上面的操作，进行递归，两两分组直至每一组都是1个数，不能再分为止。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/gbsort.gif"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>也是分治思想。简单来说就是，基准值+2个指针，让L指针左侧的数永远小于基准值、让R指针右侧的数永远大于基准值。</p><p>1.先选定一个基准值povit，然后放2个指针Left和Right到最左和最右。</p><p>2.对比L指针的值和povit，如果L小就是合理的，L指针右移，直至大于povit再停止；</p><p>3.当L指针停止后，开始移动R指针，如果R指向的值大就是合理的，R指针左移，直至小于povit再停止。</p><p>4.如果L和R都停止了，那么就将L、R指向的值互换，之后重启第2步继续右移L。</p><p>5.在2、3步中，如果发现L指针已经和R指针重合了，那么就证明本次分治下的排序结束。之后把L指针的值和povit的值进行交换就可以。</p><p>在上述完成后，最终结果会变成povit放在某个确定位置，而这个位置左侧的元素都小于povit，右边的元素都大于povit。所以这其实是在确定povit的最终位置。之后继续同样操作来排序povit左侧和右侧的2个队列，直至无可划分。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/quicksort.gif"></p><p>优化：1.想办法让povit取到中值（三数中值法）</p><p><a href="https://zhuanlan.zhihu.com/p/57436476">更细的步骤拆分和优化点</a></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>这个排序本身很简单，难点在于将堆用数组表现出来。所以分2部分说。</p><h3 id="用数组表示堆"><a href="#用数组表示堆" class="headerlink" title="用数组表示堆"></a>用数组表示堆</h3><ol><li>  堆：一个完全二叉树。完全二叉树就是从上到下、从左到右，直到最后一个结点为止，没有一个结点是空着的二叉树。</li><li>  大顶堆：一个堆，每个节点都能保证 父&gt;子。      小顶堆：一个堆，每个节点都能保证 父&lt;子。</li><li>  shift_down(结点k)：一个用来确定结点位置的方法。将结点k和它的2个孩子中的最大值做位置交换，然后让它继续和孩子比较，直至它比2个孩子都大。</li></ol><p>从堆的概念可以直到，你可以对堆从上到下、从左到右进行编号，编成0,1,2,…,n。这刚好对应着下标。而<strong>某个结点k的2个孩子，刚好对应结点2k+1、2k+2</strong>。</p><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>对数组化后的堆<code>H[0……n-1]</code>进行操作。</p><p>1.排出一个大顶堆；</p><p>2.把堆顶和堆尾交换，然后调用<code>shift_down(0)</code>来确保这还是一个大顶堆；</p><p>3.再把换到堆尾（也就是最大数）的那个数移除出堆，放到一个临时队列的尾部。堆结点数量-1。</p><p>重复1-3直至最后一个结点被移除。这个临时队列就是最终的排序结果。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/heapsort.gif"></p><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>外部排序是指内存中无法直接完成的大数据排序。是一种分治思想，当分到能在内存中排序的大小之后，再对其用内部排序。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>把数组遍历一遍，取出min和max值，将其范围划分为n个桶。桶内用内部排序排完之后，再把每个桶按顺序串起来。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bucketsort.gif"></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出序列中最大值和最小值，开辟Max-Min+1的辅助空间。<br>2.最小的数对应下标为0的位置，遇到一个数就给对应下标处的值+1。<br>3.遍历一遍辅助空间，就可以得到有序的一组序列。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/countsort.gif"></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>排序先把所有数字位数统一，不够的在前面用0补齐。</p><p>然后从后往前，一位一位的排，直至第一位。注意，放的时候先放，拿的时候也先拿，这样才能保持顺序，具体看动画吧。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/basesort.gif"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/O_1.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/O_2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;精简归纳：&lt;a href=&quot;https://www.drflower.top/posts/6a923688/&quot;&gt;https://www.dr</summary>
      
    
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://codingcodingk.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础：图论</title>
    <link href="https://codingcodingk.github.io/Tech/Algorithm/graph-1/"/>
    <id>https://codingcodingk.github.io/Tech/Algorithm/graph-1/</id>
    <published>2022-06-28T15:23:18.456Z</published>
    <updated>2022-06-28T15:23:18.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法基础" scheme="https://codingcodingk.github.io/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="算法基础" scheme="https://codingcodingk.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="图论" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 渲染管线、Shader、Texture</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-7/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-7/</id>
    <published>2022-06-25T05:13:48.938Z</published>
    <updated>2022-06-27T12:17:57.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h1><p>图形渲染管线 Graphics (Real-time Rendering) Pipeline</p><h2 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h2><p>前面学的流程串起来，就是下图。里面还涉及到了 <strong>Shader 和 Texture Mapping</strong> 的时机。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623160112.png"></p><h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><p>一般指 Shader Programs ，是一个程序，会<strong>对一个像素点/片段进行处理、着色</strong>。可以用OpenGL的语言写，也就是<strong>GLSL</strong>。</p><p>在线shader测试：<a href="http://shadertoy.com/view/ld3Gz2">http://shadertoy.com/view/ld3Gz2</a></p><p>shader展示：<a href="https://youtu.be/XuSnLbB1j6E">https://youtu.be/XuSnLbB1j6E</a></p><h1 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射 Texture Mapping"></a>纹理映射 Texture Mapping</h1><p>前面已经知道，每个像素点的漫反射系数kd乘以光照强度，会得到该像素点最终的颜色。显然，每个像素点的漫反射系数是由物体本身的<strong>颜色属性</strong>来决定的，而这个像素点的颜色属性我们会通过一张<strong>材质图</strong>来确定。这就是贴图。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623175805.png"></p><h2 id="uv"><a href="#uv" class="headerlink" title="uv"></a>uv</h2><p>uv坐标是指纹理展开后，纹理上的坐标。u和v的范围，都定义在0-1之内。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623182239.png"></p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>前面已经学了，三角面内进行插值着色，是用重心坐标来计算出任一个点对应的uv贴图坐标的（也就是决定漫反射系数k）。那么会出现什么问题？</p><h2 id="纹理拉伸-纹理图过小"><a href="#纹理拉伸-纹理图过小" class="headerlink" title="纹理拉伸(纹理图过小)"></a>纹理拉伸(纹理图过小)</h2><p>当纹理贴图太小了，多个像素点会映射到一个纹理点上去，看上去就像是拉伸了。纹理拉伸现象，可以通过**双线性插值 ** 来优化处理。</p><p><strong>双线性插值 Bilinear Interpolation</strong>：当一个像素点映射到uv贴图上后，取出相邻的3个uv贴图点，进行2次水平、1次竖直方向上的插值，求出这个点在4个uv贴图点中的插值平滑结果（漫反射系数）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220626224605.png"></p><h2 id="纹理拉伸-纹理图过大"><a href="#纹理拉伸-纹理图过大" class="headerlink" title="纹理拉伸(纹理图过大)"></a>纹理拉伸(纹理图过大)</h2><p>纹理图过大时，一个像素点的映射区域会覆盖很大的范围，但是一个像素点只能映射一个颜色。最终会走样，产生大量摩尔纹和锯齿。</p><p>如果不考虑性能，可以考虑超采样来获取平均值。但是考虑到性能，我们可以用<strong>MipMap</strong>。</p><p><strong>MipMaps</strong>：只能做近似的、正方形的 范围查询。</p><p>先将原图进行一半分辨率的裁剪（比如32x32=&gt;16x16），直到1x1。所有Mipmap大小之和为的原图1/3。</p><p><strong>1.如何计算需要的数量</strong>：映射出像素点对应uv的范围是几x几。</p><p><strong>2.如何查询某个中间值</strong>（比如1.8x1.8）：三线性插值。比如1.8x1.8，就是把2x2和1x1的2张mipmap结果值，再进行一次线性插值，求出1.8的值作为最终结果。</p><p>通过上面2步完成一个正确的Mipmap处理，最终可以得到一个像素点映射连续变化的uv贴图（也就是色彩会平滑、渐变过度）。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220627113118.png"></p><p>上面说了只能做正方形的范围查询，那如果面对不同长宽比的情况（矩形）该怎么做来避免Overblur？</p><p><strong>各向异性过滤 Ripmaps</strong>：水平和竖直方向上的表现各不相同，不是1：1时，生成长宽拉伸后的图以提供矩形查询，处理长宽比不同的情况。最终额外的贴图大小是原图的3倍。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220627120903.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图形渲染管线&quot;&gt;&lt;a href=&quot;#图形渲染管线&quot; class=&quot;headerlink&quot; title=&quot;图形渲染管线&quot;&gt;&lt;/a&gt;图形渲染管线&lt;/h1&gt;&lt;p&gt;图形渲染管线 Graphics (Real-time Rendering) Pipeline&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 着色</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-6/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-6/</id>
    <published>2022-06-22T14:32:28.598Z</published>
    <updated>2022-06-26T14:22:00.553Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目前为止我们学会了什么？</strong></p><p>相机和物体 -&gt; 变换坐标到原点 -&gt; 拉伸后映射成2D图像 -&gt; 对2D图像进行光栅化：滤波、采样、后处理，最终变成屏幕上的像素点</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622162501.png"></p><p>现在我们引入<strong>着色</strong>。</p><h1 id="着色-Shading"><a href="#着色-Shading" class="headerlink" title="着色 Shading"></a>着色 Shading</h1><h2 id="什么是着色？"><a href="#什么是着色？" class="headerlink" title="什么是着色？"></a>什么是着色？</h2><p>着色在普世意义上，是对明暗、颜色进行绘制。</p><p>而在图形学中，<strong>着色是一个对物体应用材质的过程</strong>，正是材质的不同才导致颜色不同。</p><h2 id="理解一个简单的着色模型"><a href="#理解一个简单的着色模型" class="headerlink" title="理解一个简单的着色模型"></a>理解一个简单的着色模型</h2><p><strong>Blinn-Phong Reflectance Model</strong> 是一个常用参考的光照反射模型，它分为以下：</p><p><strong>高光 Specular highlights</strong>：一根光线打到光滑平面（比如镜面）上，会往镜面反射附近去反射。</p><p><strong>漫反射 Diffuse reflections</strong>：一根光线打到粗糙平面（比如墙面）上，被反射到各个地方的情况。图中茶杯从浅黄到深黄的变化。</p><p><strong>环境光照 Ambient lighting</strong>：是由间接光源组成的光源统称。图中光线并没有直接打到箭头处，而是打到桌面上被反射，反射光再打到了箭头处。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622163914.png"></p><h2 id="开始前先定义一个“着色点”-shading-point"><a href="#开始前先定义一个“着色点”-shading-point" class="headerlink" title="开始前先定义一个“着色点” shading point"></a>开始前先定义一个“着色点” shading point</h2><p>虽然反射到的面有曲面、有直面，但我们只观察一个最小的反射点，那么曲面的极小也可以当作<strong>直面</strong>。这个被观察的点我们叫做 <strong>shading point</strong> ，同时再定义几个其他的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622170625.png"></p><p>单位向量 v：和相机的连线。</p><p>单位向量 n：反射面的法线。</p><p>单位向量 l：光照方向。</p><p>表面参数：颜色 color、反射强度 shininess、…</p><p><strong>着色的局部性 shading is local：我们着色只关注光线照过来这个点该怎么着色。</strong>比如因为遮挡产生的阴影，着色器是不考虑的。</p><p>接下来我们根据定义好的观测点 shading point，来分析上面提到的3种反射情况。</p><h2 id="漫反射-Diffuse-reflections"><a href="#漫反射-Diffuse-reflections" class="headerlink" title="漫反射 Diffuse reflections"></a>漫反射 Diffuse reflections</h2><p>一根光线打到一个点上时，会被均匀反射到四周。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622173813.png"></p><p>通过观察就可以知道，着色点的法线n和光照打来的方向l的夹角θ，会和这个着色点接收到的光照能量成反比。而这个反比有一个推导，叫 <strong>朗伯余弦定理 Lambert’s cosine law</strong>。</p><p>朗伯余弦定理的推导中，将点光源发出的光的轨迹视作一个个圆球体，而根据能量守恒，只要在真空中传播没有发生损耗，这些圆球体上某点的能量和圆球体表面积（也就是半径平方r）成正比。</p><p>最终公式如下：<img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622182248.png"></p><p>从上面也能得知一件事，就是<strong>漫反射与观测方向v无关</strong> =&gt; 通俗点说就是某点被漫反射了，即使你在不同的位置看它，它的着色情况也是不变的。</p><p>公式里还有个系数kd，这是颜色系数，乘以漫反射光的强度（右边的值），得到最终显示的颜色。</p><h2 id="高光-Specular-Term"><a href="#高光-Specular-Term" class="headerlink" title="高光 Specular Term"></a>高光 Specular Term</h2><p><strong>高光与v有关。</strong>当你的观测角度v，和反射光的方向R一致或者接近的时候，你才能看到高光。</p><p>而观测角度v和反射光R的夹角有多大，又可以转化为更简单的计算：求l和v的中间向量，然后和法线n求夹角。 这一个计算转化算是优化了，计算R和v夹角的方式叫做Phong模型，而我们这种优化的方式叫做<strong>Blinn-Phong模型</strong>，推导过程和最终公式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623001727.png"></p><p>公式里还有一个问题，就是为什么要有一个<strong>P次方</strong>去处理cosα？原因是cos函数的容忍度太大了，导致非常大的夹角仍然能保持高光，这是不合理的，所以需要人为控制一下，一般P会采用256甚至以上，让夹角控制在3°以内。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623003907.png"></p><h2 id="环境光照-Ambient-Term"><a href="#环境光照-Ambient-Term" class="headerlink" title="环境光照 Ambient Term"></a>环境光照 Ambient Term</h2><p>环境光来自四面八方，与光照方向l和观测方向v都没有关系，是一个常数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623101513.png"></p><h2 id="最终3种光照"><a href="#最终3种光照" class="headerlink" title="最终3种光照"></a>最终3种光照</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623102155.png"></p><h1 id="着色频率-Shading-Frequencies"><a href="#着色频率-Shading-Frequencies" class="headerlink" title="着色频率 Shading Frequencies"></a>着色频率 Shading Frequencies</h1><p>下面介绍3种着色方式，对应着不同的着色频率。</p><h2 id="逐三角面着色-flat-shading"><a href="#逐三角面着色-flat-shading" class="headerlink" title="逐三角面着色 flat shading"></a>逐三角面着色 flat shading</h2><p>每个三角面着一次色。</p><h2 id="逐顶点着色-Gouraud-shading"><a href="#逐顶点着色-Gouraud-shading" class="headerlink" title="逐顶点着色 Gouraud shading"></a>逐顶点着色 Gouraud shading</h2><p>每个三角面的3个顶点进行着色，着色完后三角面进行内部<strong>插值</strong>着色。顶点的法线方向，是通过这个顶点周围所有的面的法线平均或者加权平均算出来的。</p><p>插值可以用<strong>重心坐标插值</strong>，但是需要用投影前的重心坐标，而不是投影拉伸到屏幕后的，因为深度不同。取到重心坐标之后可以转换为uv坐标，这样就能取到对应的着色系数了。之后再把系数带入漫反射公式，算出光照下该像素的最终颜色。</p><h2 id="逐像素着色-Phong-shading"><a href="#逐像素着色-Phong-shading" class="headerlink" title="逐像素着色 Phong shading"></a>逐像素着色 Phong shading</h2><p>在顶点插值完之后，对每个像素都进行单独计算着色。</p><h2 id="并不是频率越高越好"><a href="#并不是频率越高越好" class="headerlink" title="并不是频率越高越好"></a>并不是频率越高越好</h2><p>当面数比较多的时候，哪怕是逐三角面着色也会有很好的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220623121534.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;目前为止我们学会了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相机和物体 -&amp;gt; 变换坐标到原点 -&amp;gt; 拉伸后映射成2D图像 -&amp;gt; 对2D图像进行光栅化：滤波、采样、后处理，最终变成屏幕上的像素点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:/</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 遮挡与深度</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-5/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-5/</id>
    <published>2022-06-22T14:32:28.594Z</published>
    <updated>2022-06-22T14:32:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>之前几节课学了怎么映射一个三角面到画面上，这节学多个三角面之间的遮挡关系处理，谁在前谁在后，也就是<strong>可见性</strong>怎么处理。</p><h1 id="实现遮挡关系"><a href="#实现遮挡关系" class="headerlink" title="实现遮挡关系"></a>实现遮挡关系</h1><h2 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h2><p>由远及近依次画（光栅化）。近的物体覆盖远的物体，就可以实现遮挡关系。</p><p>但是画家算法也存在一些问题，比如存在一些不可依赖深度排序解决的问题。所以不会直接用画家算法。</p><h2 id="深度缓存-Z-Buffer"><a href="#深度缓存-Z-Buffer" class="headerlink" title="深度缓存 Z-Buffer"></a>深度缓存 Z-Buffer</h2><p>这是工业界采用的算法。这里的z不是z轴，而是深度 depth，是摄像机位置到所求点的距离。</p><p>最后，只渲染每个像素上depth最浅的那个颜色。当物体发生运动后，会同步更新深度，有更小值出现就重新赋色。</p><p>深度缓存的复杂度是O(n)，而不是排序的O(nlogn)，因为深度缓存并不排序只求最小值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前几节课学了怎么映射一个三角面到画面上，这节学多个三角面之间的遮挡关系处理，谁在前谁在后，也就是&lt;strong&gt;可见性&lt;/strong&gt;怎么处理。&lt;/p&gt;
&lt;h1 id=&quot;实现遮挡关系&quot;&gt;&lt;a href=&quot;#实现遮挡关系&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 光栅化</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-4/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-4/</id>
    <published>2022-06-22T14:32:28.591Z</published>
    <updated>2022-06-22T14:32:28.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学之前你必须知道"><a href="#学之前你必须知道" class="headerlink" title="学之前你必须知道"></a>学之前你必须知道</h1><h2 id="视锥"><a href="#视锥" class="headerlink" title="视锥"></a>视锥</h2><p>这是透视相机的概念，用来衡量视距的大小。一般用2种属性来描述一个视锥：</p><ol><li>  near面的宽高比</li><li>  垂直视角 Vertical Field of View</li></ol><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621104507.png"></p><p>有了上面2个确定值，然后再自己定义一个near的值（近平面与相机的距离），就能确定成像了，视锥完成。</p><h2 id="屏幕上的概念"><a href="#屏幕上的概念" class="headerlink" title="屏幕上的概念"></a>屏幕上的概念</h2><p><strong>分辨率</strong>，也就是1080p、2k等，就是像素的多少。</p><p><strong>屏幕 Raster</strong>，德语中的屏幕的意思，而屏幕是一个光栅成像设备。</p><p><strong>光栅化 Rasterize</strong>，把东西画在屏幕上的过程。</p><p><strong>像素 Pixel</strong>，全名picture element，是最小单位的小正方形，它的颜色由Red、Green、Blue三个色(0~255)来混和成。</p><h2 id="屏幕发展过程"><a href="#屏幕发展过程" class="headerlink" title="屏幕发展过程"></a>屏幕发展过程</h2><p><strong>过去方式</strong></p><ol><li>  示波器</li><li>  阴极射线管 Cathode Ray Tube：和示波器原理相同，用很多电子打在屏幕上。通过扫描一样的方式，一条一条画横线，组成图像。</li></ol><p>隔行扫描 Raster Scan：上面的画横线，优化的话还会在一帧只画1、3、5…奇数行，下一帧再只画偶数行。这样省去了一半的工作量，也能一定程度欺骗到肉眼。</p><p><strong>现代方式</strong></p><ol><li>  液晶显示器 LCD（Liquid Crystal Display）：通过液晶扭曲光的方向，让其可以通过对应的光栅。</li><li>  控制发光二极管的显示器 LED（Light Emitting diode array）</li><li>  电墨水：通过电子控制只有黑、白像素的电墨水，实现电纸书的页面刷新。</li></ol><p>帧缓存技术 Frame Buffer（Memory for a Raster Display）：将显卡中的一块内存区域中，存储的内容反映到屏幕上。</p><h1 id="光栅化一个Cube"><a href="#光栅化一个Cube" class="headerlink" title="光栅化一个Cube"></a>光栅化一个Cube</h1><h2 id="视口变换-Viewport"><a href="#视口变换-Viewport" class="headerlink" title="视口变换 Viewport"></a>视口变换 Viewport</h2><p>光栅化之前要做的事。将一个 <code>[-1,1] x [-1,1]</code> 的2维平面，转换成<code>[width,0] x [0,height]</code>的笛卡尔坐标系内来表示。这叫做视口变换，看下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621115856.png"></p><p>最后算出，变换矩阵如下：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621121741.png"></p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>我们将原图形分解成很多个三角面，投影到屏幕的像素点上。</p><h3 id="首先，怎么判断一个像素点与三角形的位置关系？"><a href="#首先，怎么判断一个像素点与三角形的位置关系？" class="headerlink" title="首先，怎么判断一个像素点与三角形的位置关系？"></a>首先，怎么判断一个像素点与三角形的位置关系？</h3><p>靠前面的知识，已经可以做到任何一个点都确定性地投影到屏幕上了。</p><p>那么如果想判断一个像素点是否在一个三角面内呢？也就是问，<strong>如何确定这个像素的着色？</strong></p><p>可以通过判断这个像素点的中心点与三角形的位置关系来确定，为了方便，就定义一个判断函数<code>Inside()</code>。而这个函数就是进行3次叉积。</p><h3 id="然后，哪些像素点需要判断呢？"><a href="#然后，哪些像素点需要判断呢？" class="headerlink" title="然后，哪些像素点需要判断呢？"></a>然后，哪些像素点需要判断呢？</h3><p>如果需要把整个屏幕的点都进行一次<code>Inside()</code>判断，实在是没有必要，那么哪些需要、哪些不需要，这就涉及到<strong>包围盒</strong>了。</p><p>简单介绍一个AABB包围盒，它就是取三角面3个顶点的<code>Min(x), Min(y), Max(x), Max(y),</code>作为他的盒子。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621151747.png"></p><h3 id="最后，成像完有锯齿-Jaggies-怎么解决？"><a href="#最后，成像完有锯齿-Jaggies-怎么解决？" class="headerlink" title="最后，成像完有锯齿 (Jaggies) 怎么解决？"></a>最后，成像完有锯齿 (Jaggies) 怎么解决？</h3><p>又叫做反走样（Aliasing ）、抗锯齿。</p><p>在解决之前先理解为什么会有这类问题？取哪些像素点来表示这个三角面，叫做<strong>采样（Sample）</strong>。而采样会有3种<strong>瑕疵（Artifacts）</strong></p><ol><li>  锯齿 Jaggies</li><li>  摩尔纹 Moire</li><li>  运动速度过快 Wagon wheel effect</li></ol><p>产生原因是信号变化的速度太快，而采样速度跟不上了。</p><p><strong>那么怎么抗锯齿？</strong></p><p>可以对三角面做预处理，比如滤波、模糊，之后再进行采样。</p><h1 id="抗锯齿-Anti-Aliasing"><a href="#抗锯齿-Anti-Aliasing" class="headerlink" title="抗锯齿 Anti-Aliasing"></a>抗锯齿 Anti-Aliasing</h1><p>前面了解了为什么会产生锯齿，以及大致的抗锯齿技术（滤波、模糊）。这里细说。</p><p><strong>频域 Frequency Domain</strong>：描述信号在频率方面特性时用到的一种坐标系。想象一下cos2Π的图。</p><p><strong>滤波 Filtering</strong>：把某个时段内，特殊的频率给过滤掉。</p><p><strong>傅里叶变换</strong>：变幻的具体内容不要深究，只要知道，可以通过傅里叶变换把一张图变换为频域图，这样就能知道哪些地方的信号量多、少。中心定义为低频、周围定义为高频。最后，得到的频域图，是可逆的！</p><p>// TODO 下面的都只简单理解，更为深入要去学习 数字图像处理</p><h2 id="先傅里叶变换，再过滤一张图-FFP"><a href="#先傅里叶变换，再过滤一张图-FFP" class="headerlink" title="先傅里叶变换，再过滤一张图 FFP"></a>先傅里叶变换，再过滤一张图 FFP</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621180700.png"></p><p>中心定义为低频、周围定义为高频。当颜色变化差异巨大的时候（比如人物边缘），会产生高频信息。</p><p>为什么会有十字线？没有学过信号学不能看懂这张频谱图，只能理解为傅里叶变换前会把这一张图复制很多份拼起来，来取样。拼起来之后每张图的4个边的边界之间的信息差异巨大，就有巨大的高频信息，而这十字线的高亮就是边界的映射。</p><h3 id="高通率波"><a href="#高通率波" class="headerlink" title="高通率波"></a>高通率波</h3><p>High-pass，就是只有高频能通过，低频直接忽略的滤波方式。可以看到，逆变换回来的图几乎只保留了边界信息（人物描边），这是因为<strong>边界处的信号量差异很大，这就是高频的信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182236.png"></p><h3 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h3><p>滤掉高频，也就是滤掉边界信息，那么就会像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220621182524.png"></p><h3 id="高低滤波"><a href="#高低滤波" class="headerlink" title="高低滤波"></a>高低滤波</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622105657.png"></p><h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><p>只简单概述结论：</p><p>在空间域中，对一张图进行卷积滤波 = 对一张图进行傅里叶变换、再对其乘以卷积核的傅里叶变换、最后逆傅里叶变换回去</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622111008.png"></p><h1 id="采样-Sample"><a href="#采样-Sample" class="headerlink" title="采样 Sample"></a>采样 Sample</h1><p>稀疏采样会产生更多混叠，导致走样；密集采样更少混叠，所以映射结果更好一些。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622114336.png"></p><h2 id="怎么较少走样，也就是如何反走样？"><a href="#怎么较少走样，也就是如何反走样？" class="headerlink" title="怎么较少走样，也就是如何反走样？"></a>怎么较少走样，也就是如何反走样？</h2><p>本质上，就是想办法增大傅里叶副本之间的距离来减少混叠。</p><p><strong>1.增加采样率</strong>（更高分辨率的屏幕）</p><p><strong>2.抗锯齿</strong>，通过对图像模糊预处理（使用傅里叶来低通滤波）再采样</p><h2 id="常规采样流程"><a href="#常规采样流程" class="headerlink" title="常规采样流程"></a>常规采样流程</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622115530.png"></p><p>先用低通滤波器模糊原图，然后再采样。</p><h3 id="抗锯齿：模糊操作"><a href="#抗锯齿：模糊操作" class="headerlink" title="抗锯齿：模糊操作"></a>抗锯齿：模糊操作</h3><p>取像素颜色时，根据三角面的在该像素块中覆盖的面积，来设置灰度。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622120331.png"></p><p>这个理论很简单，但是实现比较困难，于是采用一种类似的方法，对一个像素块再进行划分、进行更多的采样，也就是**多重采样抗锯齿 MSAA (MultiSampling Anti-Aliasing) **来实现。</p><p>下图就是一个MSAA的例子：把一个像素格分成了2x2，来确定0%、25%、50%、75%、100%。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220622121659.png"></p><p>工业界会优化，想要2x2的效果不会这么单纯的分割成4个正方形，而是一些其他不规则图形，甚至可能多个像素块复用一个点，这么做都是为了减少需要检测的点数量。</p><h3 id="其他抗锯齿方法"><a href="#其他抗锯齿方法" class="headerlink" title="其他抗锯齿方法"></a>其他抗锯齿方法</h3><p>FXAA（Fast Approximate AA）：快速近似抗锯齿，是一种后处理，会对有锯齿的地方进行修正。</p><p>TAA（Temporal AA）：利用时间而不是空间采样，对于静止的连续帧，上一帧有效的采样点才继续采样。</p><p>DLSS（DeepLearning SuperSimple）：当低分辨率拉伸成高分辨率时，会有很多锯齿，此时用深度学习来猜测描绘。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学之前你必须知道&quot;&gt;&lt;a href=&quot;#学之前你必须知道&quot; class=&quot;headerlink&quot; title=&quot;学之前你必须知道&quot;&gt;&lt;/a&gt;学之前你必须知道&lt;/h1&gt;&lt;h2 id=&quot;视锥&quot;&gt;&lt;a href=&quot;#视锥&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - MVP变换</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-3/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-3/</id>
    <published>2022-06-17T01:51:05.738Z</published>
    <updated>2022-06-22T14:32:28.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从三维旋转到欧拉角"><a href="#从三维旋转到欧拉角" class="headerlink" title="从三维旋转到欧拉角"></a>从三维旋转到欧拉角</h1><p>首先三维旋转绕某个轴旋转，已经知道是这样的了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p><p>那么就可以通过对3个轴的旋转分别描述，来实现复杂的旋转角。这3个旋转角就叫做欧拉角。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620123437.png"></p><h1 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h1><p>一个公式，来实现绕轴n旋转α角度。轴n的定义为起点为原点，方向为n。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620141702.png"></p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>// TODO</p><h1 id="四元数的引入"><a href="#四元数的引入" class="headerlink" title="四元数的引入"></a>四元数的引入</h1><p>由于用旋转矩阵来做<strong>平滑插值</strong>并不合理（旋转20°矩阵 和 旋转50°矩阵 的平均值并不是旋转35°），并且存在<strong>万向锁</strong>问题，所以引入四元数。games101不展开。</p><h1 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h1><p>Model-View-Projection 模型-视图-投影变换：将3D的模型（Model）投影到2D的屏幕（View）上。</p><p>先定义相机的 <strong>位置 Position、朝向 Look-at、向上方向 Up direction</strong>（与朝向垂直，用于确定相机本身的旋转角）。</p><p>视图结果是相对不变的，当物体和相机的移动方式完全一致、没有相对运动时，成像不变。</p><h2 id="标准相机"><a href="#标准相机" class="headerlink" title="标准相机"></a>标准相机</h2><p>我们定义一个Position在 原点，Look-at在 -Z，Up direction在 Y的相机作为默认相机。</p><p>以后就可以将其他相机移成标准相机、然后再做变换、最后移回就实现了相机旋转。</p><h2 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影 Projection"></a>投影 Projection</h2><p>投影是说3D转到2D屏幕的过程。首先分2种，<strong>正交投影</strong>和<strong>透视投影 Perspective</strong>。</p><p>正交不会有近大远小、每个平行边也不会有交点，但透视都会有。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620161157.png"></p><h2 id="正交投影-Orthographic"><a href="#正交投影-Orthographic" class="headerlink" title="正交投影 Orthographic"></a>正交投影 Orthographic</h2><p>定义6个点，就可以描述一个3维的长方体：</p><p>x轴：left =&gt; right ；y轴：buttom =&gt; top ；<font color="red">z轴：fear =&gt; near</font> 。</p><p>注意z轴，因为上面所有的<code>=&gt;</code>指的都是右手坐标系的负=&gt;正，near离我们更近、被定义为正值。</p><p>OpenGL用的是左手坐标系，全部相反。</p><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620182401.png"></p><p>上图的过程就是标准化，也就是将一个长方体变成一个中心点为原点，6个点为-1、1的正方体。标准化的好处是能够更好做正交相机的投影。</p><p>标准化的变换矩阵如下，将长度定为2是为了满足(-1,1)。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620184611.png"></p><h2 id="透视投影-Perspective"><a href="#透视投影-Perspective" class="headerlink" title="透视投影 Perspective"></a>透视投影 Perspective</h2><p>近大远小、平行线会相交。这是因为不同平面内的线投影到一个平面，会有交点。</p><h3 id="齐次坐标性质"><a href="#齐次坐标性质" class="headerlink" title="齐次坐标性质"></a>齐次坐标性质</h3><p>(x,y,z,1) 和 (kx,ky,kz,k) 表示的是同一个点。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620190109.png"></p><h3 id="透视投影拆分⭐"><a href="#透视投影拆分⭐" class="headerlink" title="透视投影拆分⭐"></a>透视投影拆分⭐</h3><p>要实现一个透视投影变换，拆成2步：1.将透视投影相机视锥，挤成一个长方体（正交相机视锥）；2.将得到的长方体进行正交投影。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620225451.png"></p><p>第二步的做法已经在正交投影里写了，那么关键就是第一步怎么做，其实就是乘以一个 <strong>透视=&gt;正交 的拉伸矩阵M</strong>。</p><p>这个矩阵M（4x4）的推导如下：</p><p>1.近似三角形可推导出除了第三行以外的所有矩阵</p><p>2.性质：近平面点挤压后，点坐标的x,y,z都不变（相机的近平面，就是最终2d屏幕的大小）</p><p>3.性质：远平面点挤压后，点坐标的z不变（z轴是深度，想象一下拉伸后，远平面的深度不会变）</p><p>4.根据性质2、3可以推导出矩阵的第三行</p><p>具体推导看第四章的PPT p29-36吧，这里把主要的近似三角形概念图放下来，结合上面的拉伸概念图可以自己推导了：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620235549.png"></p><p>最后4x4的透视=&gt;正交 的拉伸矩阵M：</p><p>n    0    0    0<br>0    n    0    0<br>0    0    n+f    -nf<br>0    0    1    0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从三维旋转到欧拉角&quot;&gt;&lt;a href=&quot;#从三维旋转到欧拉角&quot; class=&quot;headerlink&quot; title=&quot;从三维旋转到欧拉角&quot;&gt;&lt;/a&gt;从三维旋转到欧拉角&lt;/h1&gt;&lt;p&gt;首先三维旋转绕某个轴旋转，已经知道是这样的了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 矩阵变换入门</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-2/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-2/</id>
    <published>2022-06-17T01:51:05.735Z</published>
    <updated>2022-06-22T15:51:07.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量 Vector"></a>向量 Vector</h1><h2 id="小概念"><a href="#小概念" class="headerlink" title="小概念"></a>小概念</h2><p>数学上叫做向量，物理上喜欢称作矢量。</p><p>向量的模 Magnitude。</p><p>向量的归一化，意味着求单位向量 unit Vector。</p><h2 id="向量矩阵"><a href="#向量矩阵" class="headerlink" title="向量矩阵"></a>向量矩阵</h2><p>下面是在表示笛卡尔坐标系x-y下的某个向量，可以用矩阵来表示向量。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220615180557.png"></p><h2 id="点乘-Dot"><a href="#点乘-Dot" class="headerlink" title="点乘 Dot"></a>点乘 Dot</h2><p>满足交换律、结合律、分配律。</p><p>结果是一个数值，可以用来检测2个向量的夹角，&lt;90度为正，90度为0，90~180度为负。</p><h2 id="叉乘-Cross"><a href="#叉乘-Cross" class="headerlink" title="叉乘 Cross"></a>叉乘 Cross</h2><p>不满足交换律！向量A x 向量B = -向量B x 向量A</p><p>结果是一个向量，这个向量是与A、B向量所组成平面的垂直向量，也就是说A、B、C向量构成一个右手直角坐标系。<strong>而法线的方向，满足右手螺旋。注意a在前所以a是食指</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620122459.png"></p><p><strong>图形学上，</strong>用来检测某个点是否在一个多边形（比如三角形）内。</p><p>因为 向量AB x 向量AP 的结果大于0则说明P在AB左侧，小于0则说明P在AB右侧。</p><p>所以一个三角面ABC和一个点P，只要通过3次叉乘的结果（都大于0或者都小于0），就能判断出点P在三角面ABC中。这是光栅化的基础，用于着色判断。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616105243.png"></p><h1 id="矩阵变换：线性变换"><a href="#矩阵变换：线性变换" class="headerlink" title="矩阵变换：线性变换"></a>矩阵变换：线性变换</h1><p>关键是，要找出变换前后每一个点之间的变化关系式。矩阵的乘法是不满足交换律的。</p><h2 id="缩放-Sacle"><a href="#缩放-Sacle" class="headerlink" title="缩放 Sacle"></a>缩放 Sacle</h2><p>可以使用对角阵*向量来进行缩放，这个对角阵叫缩放矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616114924.png"></p><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h2><p>用于翻折的单位矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616115506.png"></p><h2 id="切变-Shear"><a href="#切变-Shear" class="headerlink" title="切变 Shear"></a>切变 Shear</h2><p>要找出每一个点之间的变化关系式。</p><p>比如下图情况，只是水平方向的点发生了变化，竖直方向的不变。水平方向上的每个点发生了a / 1 * y的平移。那么久可以很容易写出切变矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616120005.png"></p><h2 id="旋转-Rotate"><a href="#旋转-Rotate" class="headerlink" title="旋转 Rotate"></a>旋转 Rotate</h2><p>二维情况下，逆时针旋转θ角：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151759.png"></p><p>推导过程（只展示A、C。B、D的话由点0,1可以推出）如下，其实只是展开了点(1,0)的偏移等式。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616151646.png"></p><p>再进一步探究可知，<strong>逆旋转矩阵 = 将原旋转矩阵转置</strong>。这意味着想要旋转一个负角度，只要求出正角度的旋转矩阵再转置就可以得到旋转矩阵了。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620113534.png"></p><h2 id="统称：线性变换"><a href="#统称：线性变换" class="headerlink" title="统称：线性变换"></a>统称：线性变换</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616165650.png"></p><h1 id="矩阵变换：非线性变换"><a href="#矩阵变换：非线性变换" class="headerlink" title="矩阵变换：非线性变换"></a>矩阵变换：非线性变换</h1><h2 id="平移-Translation"><a href="#平移-Translation" class="headerlink" title="平移 Translation"></a>平移 Translation</h2><p>平移比较特殊，它不能通过2阶矩阵<strong>线性变换</strong>（矩阵乘法）得出。因为矩阵乘法你只能得到ax+by的结果，没法出现常数c，所以只能靠加法。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616170433.png"></p><h2 id="平移解决方案：更高1阶的矩阵"><a href="#平移解决方案：更高1阶的矩阵" class="headerlink" title="平移解决方案：更高1阶的矩阵"></a>平移解决方案：更高1阶的矩阵</h2><p>平移必须涉及到同阶矩阵的加法，没法直接用线性变换了。为了在这种情况下也能只使用矩阵乘法就达到变换的目的，可以使用2+1阶的矩阵。多出来的矩阵值，点是1、向量是0。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616175212.png"></p><p><strong>将二维的点，最后一个矩阵值写为1。</strong>如果不是1，那么就看作x =&gt; x/w、y =&gt; y/w。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616184017.png"></p><p>那么最后，给出2维 向量、点 的变化矩阵：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616185009.png"></p><h2 id="逆变换-Inverse"><a href="#逆变换-Inverse" class="headerlink" title="逆变换 Inverse"></a>逆变换 Inverse</h2><p>通过使用逆矩阵，可以撤回变换。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220616190117.png"></p><h1 id="组合的矩阵变换"><a href="#组合的矩阵变换" class="headerlink" title="组合的矩阵变换"></a>组合的矩阵变换</h1><p>先旋转，后平移。否则会出错，因为矩阵乘法没有交换律！</p><p>那么通过矩阵乘法表示线性变换、矩阵平移的时候，就是从右到左一个个乘。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620101520.png"></p><p><strong>虽然没有交换律，但是有结合律</strong>，可以让前面的变换矩阵合成为一个：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102212.png"></p><h1 id="分解复杂的矩阵变换"><a href="#分解复杂的矩阵变换" class="headerlink" title="分解复杂的矩阵变换"></a>分解复杂的矩阵变换</h1><p>对于一个复杂的矩阵变换（线性变换+平移变换），需要分解为几步，才能通过矩阵乘法来实现。</p><h2 id="绕某点旋转"><a href="#绕某点旋转" class="headerlink" title="绕某点旋转"></a>绕某点旋转</h2><p>将c移到原点 =&gt; 绕原点旋转 =&gt; 移回原来</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620102642.png"></p><h1 id="由二维引申到三维"><a href="#由二维引申到三维" class="headerlink" title="由二维引申到三维"></a>由二维引申到三维</h1><p>上面讨论的都是二维，转到三维空间，其实也是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620103459.png"></p><h2 id="三维缩放、平移"><a href="#三维缩放、平移" class="headerlink" title="三维缩放、平移"></a>三维缩放、平移</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115450.png"></p><h2 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h2><p>绕某个轴旋转，该轴上的点位置不变。</p><p>至于为什么y和x、z轴旋转不一样，详细参考叉乘的<strong>右手螺旋定则</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220620115509.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;向量-Vector&quot;&gt;&lt;a href=&quot;#向量-Vector&quot; class=&quot;headerlink&quot; title=&quot;向量 Vector&quot;&gt;&lt;/a&gt;向量 Vector&lt;/h1&gt;&lt;h2 id=&quot;小概念&quot;&gt;&lt;a href=&quot;#小概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>Games101 - 导学</title>
    <link href="https://codingcodingk.github.io/Tech/Graphics/games101-1/"/>
    <id>https://codingcodingk.github.io/Tech/Graphics/games101-1/</id>
    <published>2022-06-17T01:51:05.734Z</published>
    <updated>2022-07-04T06:35:33.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h1><p>看一个游戏的图形方面做得如何，一般可以参考画面亮不亮，原因是这关系到了全局光照。</p><h2 id="光栅化-Rasterization"><a href="#光栅化-Rasterization" class="headerlink" title="光栅化 Rasterization"></a>光栅化 Rasterization</h2><p>把三维的几何形体画在屏幕上，这个画的过程，就叫光栅化。</p><h2 id="几何学-Curves-and-Meshes"><a href="#几何学-Curves-and-Meshes" class="headerlink" title="几何学 Curves and Meshes"></a>几何学 Curves and Meshes</h2><h2 id="光线追踪-Ray-Tracing"><a href="#光线追踪-Ray-Tracing" class="headerlink" title="光线追踪 Ray Tracing"></a>光线追踪 Ray Tracing</h2><p>从相机发射光线穿过每个像素，计算交集和阴影，并继续反射光线直到它们击中光源。</p><h2 id="动画、仿真-Animation-Simulation"><a href="#动画、仿真-Animation-Simulation" class="headerlink" title="动画、仿真 Animation/Simulation"></a>动画、仿真 Animation/Simulation</h2><p>其他行业应用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="描述整个渲染管线"><a href="#描述整个渲染管线" class="headerlink" title="描述整个渲染管线"></a>描述整个渲染管线</h2><p>现代GPU常规流程。具体的可以看<a href="https://codingcodingk.top/Tech/Graphics/games101-7/">渲染管线篇</a>。</p><p>0.一堆三维空间的顶点。</p><p>1.将顶点做<strong>MVP变换</strong>，拉伸转换成2维平面。这步涉及2种相机、根据相似三角形确定的<strong>拉伸矩阵</strong>、<strong>纹理映射</strong>。（如果是顶点着色模式，这在一步，还会进行<strong>Shading</strong>。</p><ul><li>  纹理映射：这一步就要做，因为需要在3维空间内和uv贴图进行一一映射。关系是 二维像素 - 三维平面 - uv贴图。</li></ul><p>2.将二维平面的点进行连线，做出大量三角面（顺时针为正面）。</p><p>3.将三角面进行采样，投射到屏幕的像素点上，这一步叫<strong>光栅化</strong>。这步涉及：光栅化的预处理<strong>视口变换</strong>、采样阶段的优化<strong>包围盒、</strong>为了<strong>抗锯齿</strong>做的预处理（滤波、模糊）。</p><ul><li><p>  视口变换：光栅化的预处理，将一个 <code>[-1,1] x [-1,1]</code> 的2维平面，转换成<code>[width,0] x [0,height]</code>的笛卡尔坐标系内来表示。</p></li><li><p>  抗锯齿：通过对图像模糊预处理（使用傅里叶来低通滤波），再用 <strong>多重采样抗锯齿 MSAA</strong>（超采）或其他 技术来采样。</p></li></ul><p>4.确定了像素点，像素点之间还需要实现遮挡，用<strong>Z-Buffer</strong>。（如果是全像素着色模式，这在一步，还会进行<strong>Shading</strong>。</p><ul><li>  Z-Buffer：只渲染每个像素上depth最浅的那个颜色。当物体发生运动后，会同步更新深度，有更小值出现就重新赋色。</li></ul><p>5.通过 <strong>帧缓存技术 Framebuffer</strong>，将前面确定的像素点渲染到屏幕上。</p><ul><li>  帧缓存技术 Frame Buffer（Memory for a Raster Display）：将显卡中的一块内存区域中，存储的内容反映到屏幕上。</li></ul><p>6.Shading单独拉出来说。着色目的是为了确定一个像素点的颜色系数，它受到<strong>uv贴图上对应的像素点+光反射</strong>，得到最终值。光反射在<strong>Blinn-Phong模型</strong>下，有3种光源：高光、漫反射、环境光照。<strong>着色频率</strong>分为3种：逐三角面、逐顶点、逐像素。</p><p>此外，纹理处理也有2种处理：<strong>Mipmaps</strong> (1/3)、<strong>Ripmaps 各异向性过滤</strong>（3倍）。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>前向渲染 (Forward Rendering)：把空间的点进行各种剪裁后，进行处理。先渲染一遍物体，把法线和高光存在ARGB32的渲染纹理中（法线用rgb通道，高光用a通道），存在了z buffer里；然后通过深度信息，法线和高光信息计算光照（屏幕空间），光照信息缓存在Render Texture中；最后混合。</p><p>延后渲染 (Deferred Rendering)：将摄像机空间的点光栅化转化成屏幕坐标后再进行处理。先不进行光照运算，对每个像素生成一组数据(G-buffer)，包括位置，法线，高光等，然后用这些数据将每个光源以2D后处理的方式施加在最后图像上（屏幕空间），然后只进行了一次光照计算就实现了最终效果。缺点：不适用于半透明。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机图形学&quot;&gt;&lt;a href=&quot;#计算机图形学&quot; class=&quot;headerlink&quot; title=&quot;计算机图形学&quot;&gt;&lt;/a&gt;计算机图形学&lt;/h1&gt;&lt;p&gt;看一个游戏的图形方面做得如何，一般可以参考画面亮不亮，原因是这关系到了全局光照。&lt;/p&gt;
&lt;h2 id=&quot;光</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/categories/Game/Graphics/"/>
    
    
    <category term="图形学" scheme="https://codingcodingk.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Graphics" scheme="https://codingcodingk.github.io/tags/Graphics/"/>
    
    <category term="games101" scheme="https://codingcodingk.github.io/tags/games101/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - Button</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_6/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_6/</id>
    <published>2022-06-17T01:51:05.730Z</published>
    <updated>2022-06-17T01:51:05.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><code>Button</code>继承自<code>Selectable</code>、<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>。</p><h2 id="外部注册"><a href="#外部注册" class="headerlink" title="外部注册"></a>外部注册</h2><h3 id="IPointerClickHandler"><a href="#IPointerClickHandler" class="headerlink" title="IPointerClickHandler"></a>IPointerClickHandler</h3><p><code>IPointerClickHandler</code>接口仅包含一个<code>OnPointerClick()</code>方法，当鼠标点击时会调用该接口的方法。而<code>Button</code>能触发点击事件是因为继承自<code>IPointerClickHandler</code>接口，并且重写了<code>OnPointerClick</code>方法。那<code>IPointerClickHandler</code>接口的方法又是被谁调用的呢？查找引用，发现是<code>ExecuteEvents</code>类的<code>Execute</code>方法，并且<code>Execute</code>方法赋值给<code>s_PointerClickHandler</code>字段。</p><p>没错，ExecuteEvents，和之前我在<a href="https://codingcodingk.top/Tech/Game/UI/ugui_2/">UGUI学习 - 事件系统、射线检测</a>的分析一致。</p><h3 id="AddListener"><a href="#AddListener" class="headerlink" title="AddListener"></a>AddListener</h3><p>那么<code>onClick.AddListener()</code>的本质也可以挖一下，其实就是监听了<code> public ButtonClickedEvent onClick</code>。而这个追溯到最底层，就是对一个回调方法队列进行<code>List.Add()</code>。</p><h2 id="Unity调用"><a href="#Unity调用" class="headerlink" title="Unity调用"></a>Unity调用</h2><p>也是和之前分析的一样，在Process方法体内进行循环检测、触发OnClick等。</p><p><code>EventSystem</code>会在<code>Update()</code>中调用当前可用<code>BaseInputModule</code>的<code>Process()</code>方法，该方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用<code>ReleaseMouse()</code>方法，并最终调用<code>Execute()</code>方法并触发<code>IPointerClick</code>事件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlink&quot; title=&quot;整体流程&quot;&gt;&lt;/a&gt;整体流程&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Button&lt;/code&gt;继承自&lt;code&gt;Selectable&lt;/code&gt;、&lt;code&gt;IPointercl</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>AOI视野管理</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/aoi/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/aoi/</id>
    <published>2022-06-13T13:55:50.492Z</published>
    <updated>2022-06-13T14:03:31.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是AOI"><a href="#什么是AOI" class="headerlink" title="什么是AOI"></a>什么是AOI</h1><h2 id="AOI"><a href="#AOI" class="headerlink" title="AOI"></a>AOI</h2><p>AOI（Area of Interest），一般指一个游戏对象在所处游戏场景（MMO居多）中的视野范围。</p><p>因为玩家和较远距离的角色不会产生互动，所以不需要他们的状态，只要关注、同步视野范围内的其他单位即可。</p><h2 id="AOI主要方式"><a href="#AOI主要方式" class="headerlink" title="AOI主要方式"></a>AOI主要方式</h2><ul><li>暴力计算：每隔一定帧数，就执行一次位置计算</li><li>十字链表：只关注上下左右四个方位。</li><li>九宫格：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是AOI&quot;&gt;&lt;a href=&quot;#什么是AOI&quot; class=&quot;headerlink&quot; title=&quot;什么是AOI&quot;&gt;&lt;/a&gt;什么是AOI&lt;/h1&gt;&lt;h2 id=&quot;AOI&quot;&gt;&lt;a href=&quot;#AOI&quot; class=&quot;headerlink&quot; title=&quot;AOI</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="mmo" scheme="https://codingcodingk.github.io/categories/Game/mmo/"/>
    
    <category term="AOI" scheme="https://codingcodingk.github.io/categories/Game/mmo/AOI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - LayoutSystem布局系统</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_4/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_4/</id>
    <published>2022-03-25T12:02:18.563Z</published>
    <updated>2022-03-29T05:44:10.095Z</updated>
    
    <content type="html"><![CDATA[<p>学习博客：<br><a href="https://blog.csdn.net/qq_28820675/article/details/106245195">https://blog.csdn.net/qq_28820675/article/details/106245195</a></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328144810.png"></p><blockquote><p> CanvasUpdateSystem中更新布局的具体实现系统。</p></blockquote><h1 id="布局-LayoutSystem"><a href="#布局-LayoutSystem" class="headerlink" title="布局 LayoutSystem"></a>布局 LayoutSystem</h1><p>也就是上一篇中说的 Canvas刷新系统 中，重建得2个数组之一<strong>Layout数组</strong>是怎么来的、又是怎么重建得。</p><h2 id="什么时候标记"><a href="#什么时候标记" class="headerlink" title="什么时候标记"></a>什么时候标记</h2><p>也是用脏标记。时机一般为尺寸改变时（RectTransform Dimensions）。</p><h2 id="标记后干什么"><a href="#标记后干什么" class="headerlink" title="标记后干什么"></a>标记后干什么</h2><p>UGUI组件（如Graphic、ScrollRect…）在需要布局处理时（也就是被标记或OnDisable时），会把自身的RectTransform组件用LayoutRebuilder对象包装，之后加入<strong>Layout数组</strong>。</p><h2 id="重建布局"><a href="#重建布局" class="headerlink" title="重建布局"></a>重建布局</h2><p>这个的执行时机，在画布刷新系统那篇里有细写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CanvasUpdateSystem触发重建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (executing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.Layout:</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputHorizontal());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutHorizontal());</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputVertical());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutVertical());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="布局组件-LayoutGroup"><a href="#布局组件-LayoutGroup" class="headerlink" title="布局组件 LayoutGroup"></a>布局组件 LayoutGroup</h1><p>经过对LayoutSystem、LayoutRebuilder的分析，布局接口的触发规则已经被摸清楚了。</p><p>虽然UGUI组件中有一些组件都继承了ILayoutElement接口（例如：Image,Text,ScrollRect,InputField），但它们并不会涉及对接口方法的实现。这是因为这些组件主要是布局操作的接收方，只需要通过该接口被布局实施方所发现即可。而UGUI中负责这些接收物体的布局设置功能主要是由LayoutGroup衍生的子类组件来完成。</p><blockquote><p><strong>LayoutGroup</strong>，是布局组件的基类（GridLayoutGroup、HorizontalOrVerticalLayoutGroup）。先对纵横布局组件（HorizontalLayoutGroup、VerticalLayoutGroup）进行分析。</p></blockquote><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220328212851.png"></p><p>Padding：内部边距，调整实际用于布局区域的大小<br>Spacing ：子物体直接的间隔<br>Child Alignment ：子物体对齐方式<br>Child Controls Size ：组件控制子物体尺寸开关，开启时组件可以更改物体尺寸。<br>Child Force Expand ：组件控制子物体填充区域开关，若可以修改尺寸则会改变子物体尺寸填充区域，若不可以修改尺寸，则根据区域大小均衡分布子物体。</p><h2 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h2><p>以HorizontalLayoutGroup为例。</p><p>1.对该GameObject下所有子物体（只做一次GetChild）进行遍历，获取其子节点下所有没有被标记<strong>ignoreLayout</strong>的物体。放到一个List中。</p><p>2.对List中的每一个Cell都进行尺寸与位置的计算。然后设置其属性。</p><h1 id="ContentSizeFitter"><a href="#ContentSizeFitter" class="headerlink" title="ContentSizeFitter"></a>ContentSizeFitter</h1><p>布局系统中尺寸调节组件。</p><p><strong>ContentSizeFitter</strong>，是用于调整组件区域使其自适的组件，一般用于与ScrollRect滑动列表以及纵横布局组件搭配，实现动态数量的滑动列表效果，以及与Text组件一起使用，可以根据文字长短进行区域尺寸的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习博客：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/106245195&quot;&gt;https://blog.csdn.net/qq_28820675/article/details/10624519</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - 画布刷新、重建</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/ugui_3/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/ugui_3/</id>
    <published>2022-03-25T12:02:18.562Z</published>
    <updated>2022-06-17T01:51:05.728Z</updated>
    
    <content type="html"><![CDATA[<p>学习博客：</p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105746002">https://blog.csdn.net/qq_28820675/article/details/105746002</a></p><p><a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">https://blog.csdn.net/gaojinjingg/article/details/103565840</a></p><p>更好的入门文章：</p><p><a href="https://zhuanlan.zhihu.com/p/448293298">https://zhuanlan.zhihu.com/p/448293298</a></p><p><img src="https://img-blog.csdnimg.cn/20200425104339184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODIwNjc1,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>由Canvas控制，通过 ICanvasElement 接口，使用脏标记方法来统一更新CanvasElement</p></blockquote><h1 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h1><p>摘自<a href="https://blog.csdn.net/gaojinjingg/article/details/103565840">大佬博客</a>。</p><ul><li>   <strong>Canvas</strong>， 是Unity渲染系统给层状几何体( layered geometry )提供的可以被画入、被放在上面或者放在世界空间的底层Unity组件。Canvas负责将它包含的几何体组合成batch，生成合适的渲染命令发送给Unity图形系统。这个过程在底层的C++代码中完成，这个过程被称为一次rebatch或者一次batch build。当一个Canvas被标记为包含需要rebatch的几何体时，这个Canvas被认为是dirty的。</li><li>   <strong>layered geometry</strong> , 由Canvas Renderer组件提供给Canvas。[ Canvas 负责进行渲染, Canvas Renderer负责采集/接收. ]</li><li>   **动静隔离 **, 一个子Canvas仅仅是一个嵌套在父Canvas中的组件，子Canvas将它的子物体和它的父Canvas隔离，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild，反之亦然。（这些在某些特殊情况下是不确定的，比如说改变父Canvas的大小导致子Canvas的大小改变。）</li><li>   <strong>Graphic</strong> , 是UGUI的C#库提供的一个基类。它是UGUI所有类的基类，给所有的UGUI类提供可以画在Canvas系统上的几何图形。大多数Unity内置的继承Graphic的类都是通过继承一个叫MaskableGraphic的子类来实现，这使得他们可以通过IMaskable接口来被隐藏。Drawable类的子类主要是image和text，已经提供了同名的组件。</li><li>  <strong>Layout</strong> , 组件控制着RectTransform的大小和位置，经常被用于要生成具有相似的大小和位置关系内容的复杂布局。它只依靠RectTransform，只影响与其相关的RectTransform的属性。这些layout组件不依赖于Graphic类，可以独立于UGUI的Graphic组件之外使用。</li><li>  <strong>CanvasUpdateRegistry</strong> , Graphic和Layout组件都依赖于CanvasUpdateRegistry类，它不会在Unity编辑器的界面中显示。这个类追踪那些Graphic和Layout组件必须被更新的时候，还有与其对应的Canvas触发了willRenderCanvases事件的时候。更新Graphic类和Layout类叫做rebuild。</li><li> <strong>Rebuild</strong> , 过程是指Layout和UGUI的C#的Graphic组件的网格被重新计算，这是在CanvasUpdateRegistry类中执行的。这是一个C＃类，它的源码可以在Unity的Bitbucket上找到。<br>   <strong>CanvasUpdateRegistry</strong> , 类中，PerformUpdate方法，当一个Canvas组件触发它的WillRenderCanvases事件时，这个方法就会被执行。这个事件每帧调用一次。<br>   <strong>PerformUpdate</strong> , 函数运行的三个步骤：<br>   1- 通过ICanvasElement.Rebuild函数，请求rebuild被Dirty的Layout组件。<br>   2- 所有被注册的裁剪组件（例如Mask），对需要被裁剪的组件进行剔除。这在ClippingRegistry.Cull中执行。<br>   3- dirty的Graphic组件被要求rebuild其图形元素。</li><li>   <strong>Layout Rebuild</strong> , 要重新计算一个或者多个Layout组件所包含的UI组件的适当位置（以及可能的大小），有必要对Layout应用层次的排序。在GameObject的hierarchy中靠近root的Layout可能会影响改变嵌套在它里面的其他Layout的位置和大小，所以必须首先计算。 </li><li>   <strong>Graphic Rebuild</strong> , 当Graphic组件被rebuild的时候，UGUI将控制传递给ICanvasElement接口的Rebuild方法。Graphic执行了这一步，并在rebuild过程中的PreRender阶段运行了两个不同的rebuild步骤：1.如果顶点数据已经被标为Dirty（例如组件的<strong>RectTransform</strong>已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的<strong>material或者texture</strong>已经被改变），则关联的Canvas Renderer的材质将被更新。Graphic的Rebuild不会按照Graphic组件的特殊顺序进行，也不会进行任何的排序操作。</li></ul><h1 id="入门理解"><a href="#入门理解" class="headerlink" title="入门理解"></a>入门理解</h1><p>这里对大佬的<a href="https://zhuanlan.zhihu.com/p/448293298">文章</a>进行摘要。</p><p><strong>Unity是怎么绘制UI元素的？</strong></p><p>Unity中渲染的物体都是由网格(Mesh)构成的，而网格的绘制单元是图元(点、线、三角面)。在unity中添加一个<em>Image</em>和<em>Text</em>，并且将<em>Shadings Mode</em>设置为<em>Wireframe</em>模式，可以看到一个<em>Image</em>由四个顶点和两个三角面构成，<em>Text</em>也是由许多顶点和三角面构成。</p><p>绘制信息都存储在<em>Vertexhelper</em>类中，除了顶点外，还包括法线、UV、颜色、切线以及一些函数。</p><p><strong>数据存储好了，那怎么绘制呢？</strong></p><p>这是依靠<em>CanvasRenderer</em>来完成的，它听起来可能比较陌生，但实际上当我们在项目中创建的一些UI元素，比如<em>Button</em>、<em>Image</em>、<em>Text</em>时，都包含组件<em>CanvasRenderer</em>，这个类提供了许多关键绘制信息，比如被渲染物体的颜色、材质和<em>Mesh</em>等，主要作用就是<strong>渲染包含在Canvas中的UI对象</strong>，但是在<em>Inspector</em>界面中并不会展示任何属性。</p><p><strong>总结一下就是，Unity会把要绘制的UI信息保存在Vertexhelper中，并且调用CanvasRenderer里面的方法进行绘制。</strong></p><h1 id="重建-Rebuild"><a href="#重建-Rebuild" class="headerlink" title="重建 Rebuild"></a>重建 Rebuild</h1><p><strong>UI重建分为两类，一类是布局重建(Layout Rebuild)，另一类是图形重建(Graphic Rebuild)。</strong></p><p>一个UI若要重建，必须继承自<em>ICanvasElement</em>接口，因为执行重建操作的时候会调用接口中的<em>Rebuild</em>函数。</p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>是Unity渲染系统给层状几何体( layered geometry )提供的可以被画入、被放在上面或者放在世界空间的底层Unity组件。</p><p>Canvas在<strong>渲染前</strong>会调用willRenderCanvases事件，也就是Registry的PerformUpdate方法，用委托的形式传进去的。</p><h2 id="CanvasUpdateRegistry"><a href="#CanvasUpdateRegistry" class="headerlink" title="CanvasUpdateRegistry"></a>CanvasUpdateRegistry</h2><p>画面刷新的注册工具类，在它的构造函数中会给Canvas注册回调：<code>Canvas.willRenderCanvases += PerformUpdate;</code></p><p>内部维护2个队列（都是 ICanvasElement类型 的）：</p><ul><li>  LayoutRebuildQueue：布局重建队列</li><li>  GraphicRebuildQueue：图像重建队列</li></ul><p>这2个队列提供了公开方法向其添加内容。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向m_LayoutRebuildQueue中添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向m_GraphicRebuildQueue中添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加内容时机"><a href="#添加内容时机" class="headerlink" title="添加内容时机"></a>添加内容时机</h2><p>那么什么时候对2个重建队列添加内容，也就是怎么确定哪些要重建呢？是通过脏数据实现的。</p><p>布局（Layout）、材质（Material）、顶点（Vertices）三部分，设置布局为脏，将进行布局重建；设置顶点或材质为脏，则进行图形重建。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetAllDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 略了，就是根据一些flag依次调用下面3个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLayoutDirty</span>(<span class="params"></span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!IsActive())</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//将元素加入布局重建队列</span></span><br><span class="line">     LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">     </span><br><span class="line">     Debug.Log(<span class="string">&quot;Rebuild:&quot;</span> + rectTransform.name);</span><br><span class="line">     <span class="keyword">if</span> (m_OnDirtyLayoutCallback != <span class="literal">null</span>)</span><br><span class="line">         m_OnDirtyLayoutCallback();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetVerticesDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m_VertsDirty = <span class="literal">true</span>;   </span><br><span class="line">    <span class="comment">//将元素加入图形重建队列</span></span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyVertsCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyVertsCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetMaterialDirty</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    m_MaterialDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//将元素加入图形重建队列</span></span><br><span class="line">    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_OnDirtyMaterialCallback != <span class="literal">null</span>)</span><br><span class="line">        m_OnDirtyMaterialCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发重建"><a href="#触发重建" class="headerlink" title="触发重建"></a>触发重建</h2><p>加入重建队列之后，CanvasUpdateRegistry就会在<code>PerformUpdate</code>函数中调用它的<code>Rebuild</code>进行重建。Graphic对Rebuild进行了实现：如果顶点或材质被标记为“脏”的话，会更新元素的几何网格(<em>UpdateGeometry</em>)和材质(<em>UpdateMaterial</em>)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate update</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (canvasRenderer == <span class="literal">null</span> || canvasRenderer.cull)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.PreRender:</span><br><span class="line">            <span class="keyword">if</span> (m_VertsDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdateGeometry();</span><br><span class="line">                m_VertsDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m_MaterialDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdateMaterial();</span><br><span class="line">                m_MaterialDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>UpdateGeometry</em>函数用于确定元素的网格(<em>Mesh</em>)信息，这些信息包括顶点、三角面、UV、颜色等，它们将会被填充到<em>s_VertexHelper</em>中，并最终调用<em>canvasRenderer.SetMesh(workerMesh)<em>设置</em>Mesh</em>信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoMeshGeneration</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rectTransform != <span class="literal">null</span> &amp;&amp; rectTransform.rect.width &gt;= <span class="number">0</span> &amp;&amp; rectTransform.rect.height &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//UI元素需要生成顶点时的回调函数，用以填充顶点缓冲区的数据</span></span><br><span class="line">        <span class="comment">//其子类重写了这个方法</span></span><br><span class="line">        OnPopulateMesh(s_VertexHelper);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s_VertexHelper.Clear();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前对象是否有IMeshModifier接口，</span></span><br><span class="line">    <span class="comment">//Text的描边和阴影都是通过它的ModifyMesh方法实现的</span></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    GetComponents(<span class="keyword">typeof</span>(IMeshModifier), components);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        ((IMeshModifier)components[i]).ModifyMesh(s_VertexHelper);</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line"></span><br><span class="line">    s_VertexHelper.FillMesh(workerMesh);</span><br><span class="line">    <span class="comment">//设置渲染所需的网格信息</span></span><br><span class="line">    canvasRenderer.SetMesh(workerMesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染前流程"><a href="#渲染前流程" class="headerlink" title="渲染前流程"></a>渲染前流程</h2><ul><li>  <em>PerformUpdate</em>函数对<em>m_LayoutRebuildQueue</em>中的元素进行排序，依据是父节点的多少。接下来依次将<em>Prelayout</em>、<em>Layout</em>和<em>PostLayout</em>作为参数传递给<em>Rebuild</em>进行布局重建，完成后通知布局队列中的元素重建完成。</li><li>  调用<em>ClipperRegistry</em>的<em>Cull</em>函数进行裁剪。</li><li>  进行图形重建，遍历<em>m_GraphicRebuildQueue</em>的值，分别将参数<em>PreRender</em>、<em>LatePreRender</em>作为参数传递给<em>Rebuild</em>函数进行图形重建。</li><li>  最后通知图形重建完成。</li></ul><h1 id="Rebuild时机：脏标记"><a href="#Rebuild时机：脏标记" class="headerlink" title="Rebuild时机：脏标记"></a>Rebuild时机：脏标记</h1><p>这里用脏标记，就是将重建的行为延迟到用户需要这个物体的时候才执行，一种优化重新渲染的手段。</p><p>在Graphic 中存在三种脏标记分别代表三种等待重建</p><ul><li><p>  尺寸改变时（RectTransformDimensions）：LayoutRebuild 布局重建</p></li><li><p>  尺寸、颜色改变时：Vertices to GraphicRebuild 图像顶点重建</p></li><li><p>  材质改变时：Material to GraphicRebuild 图像材质重建</p></li></ul><p>层级改变、应用动画属性（DidApplyAnimationProperties） ：All to Rebuild 重建所有</p><h2 id="案例1：Image"><a href="#案例1：Image" class="headerlink" title="案例1：Image"></a>案例1：Image</h2><p>举例Image的情况，Image间接继承自Graphic，当它的Sprite发生变化时，会调用SetAllDirty函数；设置Sprite大小的时候也会调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sprite sprite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Sprite; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Sprite != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_Sprite != <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_SkipLayoutUpdate = m_Sprite.rect.size.Equals(<span class="keyword">value</span> ? <span class="keyword">value</span>.rect.size : Vector2.zero);</span><br><span class="line">                m_SkipMaterialUpdate = m_Sprite.texture == (<span class="keyword">value</span> ? <span class="keyword">value</span>.texture : <span class="literal">null</span>);</span><br><span class="line">                m_Sprite = <span class="keyword">value</span>;</span><br><span class="line">                </span><br><span class="line">                SetAllDirty();</span><br><span class="line">                TrackSprite();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_SkipLayoutUpdate = <span class="keyword">value</span>.rect.size == Vector2.zero;</span><br><span class="line">            m_SkipMaterialUpdate = <span class="keyword">value</span>.texture == <span class="literal">null</span>;</span><br><span class="line">            m_Sprite = <span class="keyword">value</span>;</span><br><span class="line">            </span><br><span class="line">            SetAllDirty();</span><br><span class="line">            TrackSprite();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例more"><a href="#案例more" class="headerlink" title="案例more"></a>案例more</h2><ul><li>  <em>Text</em>控件 文本的内容及颜色变化、设置是否支持富文本、更改换行模式、设置字体最大最小值、变更文本使用的对齐锚点、设置是否通过几何对齐、变更字体大小、变更是否支持水平及垂直溢出、修改行间距、变更字体样式(正常、斜体…..)。</li><li>  <em>Image</em>控件 颜色变化、变更显示类型(<em>Simple</em>、<em>Sliced</em>、<em>Tiled</em>、<em>Filled</em>)、变更是否应保留<em>Sprite</em>宽高比(<em>Image.preserveAspect</em>属性的变更)，<em>FillCenter</em>属性变更(是否渲染平铺或切片图像的中心)、变更填充方式(<em>Horizontal</em>、<em>Vertical</em>、<em>Radial360</em>….)、变更图像填充率(<em>fillAmount</em>)、变更图像顺逆时针填充类型(<em>Image</em>.<em>fillClockwise</em>)、变更填充过程的原点(<em>Image.FillOrigin</em>)。</li><li>  <em>RawImage</em>控件 设置<em>Texture</em>、变更纹理使用的<em>UVRcet</em>。</li><li>  <em>Shadow</em>效果 改变效果的距离(<em>effectDistance</em>)及颜色(<em>effectColor</em>)、变更是否使用<em>Graphic</em>中的<em>Alpha</em>透明度(<em>useGraphicAlpha</em>)。</li><li>  <em>Mask</em>控件 设置是否展示与<em>Mask</em>渲染区域相关的图形(<em>showMaskGraphic</em>),<em>enable</em>发生变化</li><li>  所有继承<em>MaskableGraphic</em>的控件(<em>Image</em>、<em>RawImage</em>、<em>RectMask2D</em>、<em>Text</em>) 设置此图形是否允许被遮盖、<em>enable</em>发生变化、父节点发生变化(<em>TransFromParentChanged</em>)、在<em>Hierachy</em>面板上发生改变(<em>HierachyChanged</em>)。</li><li>  所有继承自<em>BaseMeshEffect</em>的效果类(目前只看到<em>Shadow</em>及<em>PositionAsUV1</em>)的<em>enable</em>变化及应用动画属性的操作。</li><li>  所有继承自<em>Graphic</em>的UI控件材质(<em>material</em>)发生变化。</li></ul><h1 id="一整轮Rebuild：PerformUpdate方法"><a href="#一整轮Rebuild：PerformUpdate方法" class="headerlink" title="一整轮Rebuild：PerformUpdate方法"></a>一整轮Rebuild：PerformUpdate方法</h1><p>1.在布局重建队列、图像重建队列中，<strong>剔除已销毁对象</strong>。</p><p>2.<strong>更新布局</strong>。根据父节点数量排序，先深后浅。更新类型依次为 Prelayout 、Layout 、PostLayout。详细见ugui_4。</p><p>3.执行<code>LayoutComplete</code>回调，也就是通知LayoutRebuild队列的所有元素，<strong>通知布局已完成</strong>。</p><p>4.布局完成，可以<strong>对UI（IClipper）进行裁剪</strong>了，显示不到的就不渲染</p><p>5.<strong>更新图像</strong>。依次 PreRender、LatePreRender、MaxUpdateValue：1.如果顶点数据已经被标为Dirty（例如组件的RectTransform已经改变大小），则重建网格。2.如果材质数据已经被标为Dirty（例如组件的material或者texture已经被改变），则关联的Canvas Renderer的材质将被更新。</p><p>6.执行<code>GraphicUpdateComplete</code>回调，<strong>通知图像更新完成</strong>。</p><h1 id="顺序枚举"><a href="#顺序枚举" class="headerlink" title="顺序枚举"></a>顺序枚举</h1><p>CanvasUpdate，一个枚举类，很核心，代表着Canvas对Layout、Render的处理顺序：</p><ol start="0"><li>  Prelayout：Called before layout.</li><li>  Layout</li><li>  PostLayout：Called after layout.</li><li>  PreRender：Called before rendering.</li><li>  LatePreRender：Called late, before render.</li><li>  MaxUpdateValue：Max enum value. Always last.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28820675/article/details/105746002&quot;&gt;https://blog.csdn.net/qq_28820675/article/details/1057</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 展示</title>
    <link href="https://codingcodingk.github.io/Intro/display/"/>
    <id>https://codingcodingk.github.io/Intro/display/</id>
    <published>2022-03-25T12:02:18.559Z</published>
    <updated>2022-03-25T12:02:18.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Demo简介"><a href="#Demo简介" class="headerlink" title="Demo简介"></a>Demo简介</h1><p>个人Demo项目，所有代码都已在github开源。// <strong>个人博客</strong>：CodingCodingK.top    <strong>github首页</strong>：github.com/CodingCodingK</p><p>使用Unity客户端、.net core服务端实现类王者荣耀帧同步Moba手游。系统方面主要实现了背包系统；战斗方面，实现了主要游戏流程、实现了3个人物及其技能：亚瑟、后裔、金克斯(lol)。</p><ul><li>使用UDP通信、Protobuf协议实现帧同步网络通信库</li><li>使用Odin、xNode实现自定义可视化编辑器，且保持数据一致</li><li>使用Luban实现本地Excel数据配置导表方案</li><li>使用对象池、虚拟列表等进行背包系统优化</li><li>使用定点数实现碰撞环境生成、确定性物理碰撞检测</li><li>实现基于客户端负责计算的帧同步Moba战斗系统</li><li>不同客户端独立计算的显示结果统一与运动平滑</li><li>逻辑层与显示层分离，复用技能、Buff、子弹逻辑代码的战斗系统</li><li>业务内容上，大致实现了登陆系统、大厅主城、背包系统、匹配系统、选角系统、加载系统、战斗系统。</li></ul><h1 id="Demo演示视频⭐"><a href="#Demo演示视频⭐" class="headerlink" title="Demo演示视频⭐"></a>Demo演示视频⭐</h1><p>1P 游戏内容展示：登录客户端1 =&gt; 大厅、背包系统展示 =&gt; 登录客户端2 =&gt; 匹配、选人、加载读条系统展示 =&gt; 整个战斗流程展示 =&gt; 结束返回大厅。</p><p>2P 开发环境展示：Excel配置、自定义编辑器、服务器数据库等。</p><h2 id="视频地址-↓↓↓"><a href="#视频地址-↓↓↓" class="headerlink" title="视频地址 ↓↓↓"></a>视频地址 ↓↓↓</h2><p><a href="https://www.bilibili.com/video/BV1ML4y177hc">https://www.bilibili.com/video/BV1ML4y177hc</a></p><h2 id="Demo演示环境"><a href="#Demo演示环境" class="headerlink" title="Demo演示环境"></a>Demo演示环境</h2><p>服务器：使用腾讯云，配置 4核 8G 带宽10M 微型个人服务器。</p><p>真机测试：华为P40手机 鸿蒙OS。</p><h1 id="Demo源码"><a href="#Demo源码" class="headerlink" title="Demo源码"></a>Demo源码</h1><p>apk下载地址（可连远端服务器，支持安卓实机）：<a href="https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ">https://pan.baidu.com/s/1tI8O0xLUQ4xP9YpQrNxOgQ</a> 提取码：1234 </p><p>MobaDemo（双端）源码地址：<a href="https://github.com/CodingCodingK/UnityMobaDemo">https://github.com/CodingCodingK/UnityMobaDemo</a></p><h1 id="Demo实现细节展示"><a href="#Demo实现细节展示" class="headerlink" title="Demo实现细节展示"></a>Demo实现细节展示</h1><p>限于篇幅以及可观赏性，很多东西没办法通过视频的形式呈现，</p><p>每个模块的demo代码以及个人笔记地址。</p><h2 id="项目实现细节"><a href="#项目实现细节" class="headerlink" title="项目实现细节"></a>项目实现细节</h2><p>技能系统、物理碰撞模拟等在项目中的运用：<a href="https://codingcodingk.top/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/">王者荣耀复刻项目 笔记目录</a></p><h2 id="使用Protobuf协议的UDP简易网络通信库"><a href="#使用Protobuf协议的UDP简易网络通信库" class="headerlink" title="使用Protobuf协议的UDP简易网络通信库"></a>使用Protobuf协议的UDP简易网络通信库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingK_Session">https://github.com/CodingCodingK/CodingK_Session</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/protobuf/">工具篇：protobuf序列化</a>    <a href="https://codingcodingk.top/Tech/Game/tools/CodingK_Session/">工具篇：帧同步网络库</a></p><h2 id="常用定时器"><a href="#常用定时器" class="headerlink" title="常用定时器"></a>常用定时器</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKTimer">https://github.com/CodingCodingK/CodingKTimer</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKTimer/">工具篇：定时系统</a></p><h2 id="自用定点数数学库"><a href="#自用定点数数学库" class="headerlink" title="自用定点数数学库"></a>自用定点数数学库</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKMath">https://github.com/CodingCodingK/CodingKMath</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKMath/">工具篇：定点数运算数学库</a></p><h2 id="自用定点数物理碰撞模拟"><a href="#自用定点数物理碰撞模拟" class="headerlink" title="自用定点数物理碰撞模拟"></a>自用定点数物理碰撞模拟</h2><p>源码地址：<a href="https://github.com/CodingCodingK/CodingKPhysx">https://github.com/CodingCodingK/CodingKPhysx</a></p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/CodingKPhysx/">工具篇：定点数物理碰撞库</a></p><h2 id="基于Luban实现的Excel配置方案"><a href="#基于Luban实现的Excel配置方案" class="headerlink" title="基于Luban实现的Excel配置方案"></a>基于Luban实现的Excel配置方案</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/luban_study/">工具篇：本地配置</a></p><h2 id="Odin、xNode自定义编辑器"><a href="#Odin、xNode自定义编辑器" class="headerlink" title="Odin、xNode自定义编辑器"></a>Odin、xNode自定义编辑器</h2><p>源码在<a href="https://github.com/CodingCodingK/UnityMobaDemo">moba demo</a>中。</p><p>个人笔记：<a href="https://codingcodingk.top/Tech/Game/tools/odin_study/">工具篇：Odin 可视化编辑器</a>    <a href="https://codingcodingk.top/Project/Unity/Moba/HOK/skilleditor/">王者荣耀复刻项目 技能配置编辑器篇</a></p><h1 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h1><p>其实在开始这个Demo之前，为了能够学习游戏开发，在业余时间我也在各类网课学习了<a href="https://github.com/CodingCodingK/Unity_Studys">很多简单的游戏案例</a>，尝试理解一些框架诸如GameFramework、UGUI的源码。从2021年4月起学习Unity官方游戏案例Ruby，到如今正式求职一份Unity工作已经过去了一年。我还有很多想学习的，想做出更接近商业级的东西。</p><p>非常感谢也许是面试官也许是hr的您，能够看到这里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Demo简介&quot;&gt;&lt;a href=&quot;#Demo简介&quot; class=&quot;headerlink&quot; title=&quot;Demo简介&quot;&gt;&lt;/a&gt;Demo简介&lt;/h1&gt;&lt;p&gt;个人Demo项目，所有代码都已在github开源。// &lt;strong&gt;个人博客&lt;/strong&gt;：Codi</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
  <entry>
    <title>什么叫“二进制”配置方案？</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/serialize/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/serialize/</id>
    <published>2022-03-18T13:18:05.707Z</published>
    <updated>2022-03-18T13:18:05.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的很懵，刚好自己的demo有用，挖一下。</p><h1 id="先说二进制式存储"><a href="#先说二进制式存储" class="headerlink" title="先说二进制式存储"></a>先说二进制式存储</h1><p>要理解为什么二进制更优，先明白什么是二进制式存储。</p><h2 id="什么是二进制文件？"><a href="#什么是二进制文件？" class="headerlink" title="什么是二进制文件？"></a>什么是二进制文件？</h2><p>所有对计算机有所了解的人肯定都知道计算机的存储在物理上是二进制（01）形式的。所以文本文件与二进制文件的区别并不是物理上，而是逻辑上的。其本质是两者在编码层次上的差异。简单的来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据应用的具体情况自定义自己的编码。</p><p>从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。</p><h2 id="文本文件是怎么读取的？"><a href="#文本文件是怎么读取的？" class="headerlink" title="文本文件是怎么读取的？"></a>文本文件是怎么读取的？</h2><p>文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。</p><p>比如选取ASCII码形式（ASCII码的一个字符是8个比特），它就会8个比特地来解释这个文件流：”01000000 01000001 01000010 01000011”用ASCII码解析出来是“ABCD”，显示在文本编辑器上。</p><h2 id="二进制文件vs文本文件"><a href="#二进制文件vs文本文件" class="headerlink" title="二进制文件vs文本文件"></a>二进制文件vs文本文件</h2><p><strong>译码难度</strong>：一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。</p><p><strong>文件大小</strong>：关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。</p><h1 id="再聊二进制配置"><a href="#再聊二进制配置" class="headerlink" title="再聊二进制配置"></a>再聊二进制配置</h1><h2 id="二进制和json的关系"><a href="#二进制和json的关系" class="headerlink" title="二进制和json的关系"></a>二进制和json的关系</h2><p>要存储一个json文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot; = 133,</span><br><span class="line">  &quot;color&quot; = [233, 0, 0],</span><br><span class="line">  &quot;pos&quot; = [34, 22]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>json一般以utf-8格式保存成文本</strong>，utf-8是unicode编码的一种实现形式。也就是说，像程序中的数字类型133，233，22等，一个uint8就能存储下了，可是133在json中却占了3个字节，要是存个12.432312等数据要占用更多的空间。而本文所说的二进制配置，直接存133等的uint8二进制编码0x85，这样便减少了一部分文件大小。<strong>编码与解码可以商量好自己的规则</strong>，比如time，编解码都以t代替，又可以节省一部分空间，甚至可以不存储time，color，pos等key，直接顺序在配置中写value，解码时直接读value（为了说的清楚，后面的例子保留了key）这样又可以减少配置文件的大小。</p><h2 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h2><blockquote><p>  序列化是将对象or对象图(比如数组)转换成字节流的过程，反序列化是将字节流转换回对象图的过程。</p></blockquote><p>上面这段来自我clr笔记的定义，就可以明白大佬们说的“二进制来做”，做的是序列化反序列化。</p><p>不通过这种常规读取方式：</p><p>读取utf-8的.json文件 =&gt; 将utf-8读取成二进制流byte[] =&gt; 此时byte[]是json字符串，也就是json序列化后的产物，我们再通过反射(至少我常用的库是反射)反序列化 =&gt; 反序列化完成，返回一个对象。</p><p>那如果加入“二进制来做”的读取方式：</p><p>读取.bin文件 =&gt; 二进制文件更小读取很快，获取到二进制流byte[]，然后根据自己定好的的规则去读流(比如按顺序获取定长比特来读取)，反序列化 =&gt; 反序列化完成，返回一个对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大佬们说的“二进制来做”，其实想指的是一个解决方案而不是指最终存的文件是二进制式的这么简单。</p><p>你可以<strong>可以自己写规则</strong>，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Custom_MemoryStream</span> : <span class="title">MemoryStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReadInt</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">base</span>.Read(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = BitConverter.GetBytes(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">base</span>.Write(arr, <span class="number">0</span>, arr.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 类似的还有很多比如string，这里略了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entity <span class="title">MakeEntity</span>(<span class="params">MemoryStream ms</span>)</span>&#123;</span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity();</span><br><span class="line">    entity.Id = ms.ReadInt();</span><br><span class="line">    entity.Name = ms.ReadString();</span><br><span class="line">    entity.Path = ms.ReadString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用现成的解决方案比如protobuf、FlatBuffers，他们的最终文件也都是<strong>二进制式的而不是文本格式，且读取的时候读二进制流直接按长度转换成字段</strong>。</p><p>最后，接上导表工具，就算成了。</p><p>可能对于定义上还是有一点点误解，以后会来改。但是我相信，无论怎样，目的都是为了更快、更小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="优化" scheme="https://codingcodingk.github.io/categories/Game/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：定点数物理碰撞库</title>
    <link href="https://codingcodingk.github.io/Tech/Game/tools/CodingKPhysx/"/>
    <id>https://codingcodingk.github.io/Tech/Game/tools/CodingKPhysx/</id>
    <published>2022-03-18T13:18:05.703Z</published>
    <updated>2022-03-25T12:02:18.564Z</updated>
    
    <content type="html"><![CDATA[<p>定点数基于《工具篇：定点数运算数学库》的定点数库。</p><h1 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h1><p>1.读取配置：初始化碰撞环境</p><p>2.读取配置：初始化玩家碰撞体</p><p>3.FixedUpdate（具体看《Unity生命流程》）：固定帧率检测碰撞发生</p><h1 id="碰撞配置"><a href="#碰撞配置" class="headerlink" title="碰撞配置"></a>碰撞配置</h1><p>ColldierConfig。</p><p>长方体类型：位置、长宽高、轴向。</p><p>圆柱体类型：位置、半径。</p><h1 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h1><h2 id="逻辑-视图分离"><a href="#逻辑-视图分离" class="headerlink" title="逻辑-视图分离"></a>逻辑-视图分离</h2><p>只维护逻辑值，视图则根据定点数逻辑值转换成浮点数来进行更新。但是，视图层更新后并不参与任何运算，只显示。</p><h1 id="碰撞环境"><a href="#碰撞环境" class="headerlink" title="碰撞环境"></a>碰撞环境</h1><p>环境初始化的前提是根据固定方式制作地图：<strong>只用 BoxCollider 和 CapsuleCollider 两种碰撞体，且全部放在一个EnvRoot结点下</strong>。</p><p>初始化时，遍历这个根节点，将所有的BoxCollider转化为定点数长方体形碰撞体，将所有的CapsuleCollider转化为定点数圆柱体形碰撞体。</p><p>生成下来，放到一个List中保存。</p><h1 id="碰撞检测-矫正计算（一对一）"><a href="#碰撞检测-矫正计算（一对一）" class="headerlink" title="碰撞检测+矫正计算（一对一）"></a>碰撞检测+矫正计算（一对一）</h1><h2 id="Cylinder碰到Box"><a href="#Cylinder碰到Box" class="headerlink" title="Cylinder碰到Box"></a>Cylinder碰到Box</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309232208.png"></p><p>1.求出 向量OK = Cylinder.Pos - Box.Pos。</p><p>2.求出 向量OK 分别在 Box.X方向向量、Box.Z方向向量 上的投影的长度：</p><p>使用点乘即可。具体推导是<a href="https://blog.csdn.net/liushao1031177/article/details/119776495">线代问题</a>，简单公式推导如下（向量v必须是方向向量也就是模为1）：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220308235857.png"></p><p>3.对上面求出的2段投影的长度进行钳制，让他们的范围小于的Box的半长和半宽。</p><p>4.由3的两断钳制后的投影距离 + Box.Pos ，简单计算出P点（表面最近的接触点）位置。</p><p>5.判断P点是否在Cylinder内部，不在就不需要矫正直接返回；在就需要矫正，往PO方向<strong>矫正距离</strong> Cylinder半径 - PO长度 即可。</p><p>6.如果需要矫正距离，那同时需要<strong>矫正速度方向</strong>，这可以利用向量的和来求出。求出 向量OV 在 向量PO 上的投影OT，和图中情况一致的话应该是个负数，用它可以求出 向量OT = 投影OT * 向量PO的单位向量。最后使用 向量OV - 向量OT ，得出向量TV，这就是修正后的方向向量。</p><h2 id="Cylinder碰到Cylinder"><a href="#Cylinder碰到Cylinder" class="headerlink" title="Cylinder碰到Cylinder"></a>Cylinder碰到Cylinder</h2><p>两个圆求是否相撞，直接用 两者半径之和 与 两者圆心距离 比较即可。</p><p>至于计算<strong>矫正距离</strong>就比较简单了，公式我在图中给出了。最后计算<strong>矫正速度方向</strong>，方法和上面的6是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220309213302.png"></p><h1 id="碰撞检测-矫正计算（一对多）"><a href="#碰撞检测-矫正计算（一对多）" class="headerlink" title="碰撞检测+矫正计算（一对多）"></a>碰撞检测+矫正计算（一对多）</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220311014107.png"></p><p>碰撞检测如图。</p><p>目前采用一个有微小误差的办法：<br>检测速度向量OV和向量和OB的夹角：角VOB，<br>与Max(角AOB,角COB)进行比较，</p><p>如果角VOB更小，那么就当作不需要矫正；<br>如果角VOB更大，那么就当作需要矫正。</p><p>如果不需要矫正，就当作墙体的反作用力完美抵消了速度V，撤销本次预执行的位置更新，方向修正为Vector.zero。<br>如果需要矫正，使用之前的方法（步骤6）求出 速度V 与 与法线夹角最大的那个向量的法线向量（AO）情况下的 修正方向。而矫正位置就很好算了，直接取所有碰撞点（一对一）的位置矫正之和。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定点数基于《工具篇：定点数运算数学库》的定点数库。&lt;/p&gt;
&lt;h1 id=&quot;处理流程&quot;&gt;&lt;a href=&quot;#处理流程&quot; class=&quot;headerlink&quot; title=&quot;处理流程&quot;&gt;&lt;/a&gt;处理流程&lt;/h1&gt;&lt;p&gt;1.读取配置：初始化碰撞环境&lt;/p&gt;
&lt;p&gt;2.读取配置：</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="物理碰撞库" scheme="https://codingcodingk.github.io/tags/%E7%89%A9%E7%90%86%E7%A2%B0%E6%92%9E%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Unity编辑器拓展</title>
    <link href="https://codingcodingk.github.io/Tech/Game/UI/uiboy_4/"/>
    <id>https://codingcodingk.github.io/Tech/Game/UI/uiboy_4/</id>
    <published>2022-03-18T13:18:05.702Z</published>
    <updated>2022-03-18T13:18:05.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识编辑器拓展"><a href="#初识编辑器拓展" class="headerlink" title="初识编辑器拓展"></a>初识编辑器拓展</h1><h2 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h2><ul><li>  菜单栏选项</li><li>  菜单栏窗口</li><li>  面板式编辑器</li><li>  窗口式编辑器</li></ul><p>unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。 用于扩展editor的类需要放到名字为“Editor”的文件夹中，这个文件夹可以直接放到”Assets“文件夹下，也可以是项目目录任何文件夹下的子文件夹，比如”Assets/SkillSystem/Editor”。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>重新绘制画面，主要是通过重写OnGUI、OnInspectorGUI之类的函数来实现的。</p><p>这些函数是生命周期中的一员，具体看Unity生命流程图。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>对上面提出的支持进行简单实践。</p><h2 id="菜单栏选项"><a href="#菜单栏选项" class="headerlink" title="菜单栏选项"></a>菜单栏选项</h2><p>菜单栏里添加“Tools &gt; 打包工具”项。点击执行方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;Tools/打包工具&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputAB</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单栏窗口"><a href="#菜单栏窗口" class="headerlink" title="菜单栏窗口"></a>菜单栏窗口</h2><p>菜单栏里添加“Example &gt; 打包工具”项。点击跳出制作的窗口以及控件。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121155.png"></p><p>使用方法：</p><ol><li>  继承ScriptableWizard</li><li>  调用ScriptableWizard.DisplayWizard函数可以快速创建这个向导窗口。这个向导窗口只支持小于或等于两个按钮的定制（即提供的消息响应函数只有两个按钮的）。显示的按钮名字通过ScriptableWizard.DisplayWizard函数传入。</li></ol><p>ScriptableWizard的API中的消息响应函数：（当满足某些条件下执行这些函数）</p><p>OnWizardCreate ：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”createButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardOtherButton：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”otherButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardUpdate：当向导窗口打开时或者用户改变窗口内容时都会被调用。一般会在这里显示帮助文字和进行内容有效性验证。也可以动态改变按钮状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptableWizardButton</span> : <span class="title">ScriptableWizard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firstObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform secondObject = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Example/Show OnWizardOtherButton Usage&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard(<span class="string">&quot;Click info to know the distance between the objects&quot;</span>, <span class="keyword">typeof</span>(ScriptableWizardButton), <span class="string">&quot;Finish!&quot;</span>, <span class="string">&quot;Info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstObject == <span class="literal">null</span> || secondObject == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">false</span>;</span><br><span class="line">            errorString = <span class="string">&quot;Select the objects you want to measure&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">true</span>;</span><br><span class="line">            errorString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Info&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardOtherButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> distanceObjs = Vector3.Distance(firstObject.position, secondObject.position);</span><br><span class="line">        EditorUtility.DisplayDialog(</span><br><span class="line">            <span class="string">&quot;The distance between the objects is: &quot;</span> + distanceObjs + <span class="string">&quot; Units&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Finish!&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorUtility.DisplayDialog(<span class="string">&quot;OnWizardCreate &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口式编辑器"><a href="#窗口式编辑器" class="headerlink" title="窗口式编辑器"></a>窗口式编辑器</h2><p>菜单栏里添加“Window &gt; MyEditorWnd”。点击打开窗口式面板。</p><p>使用方法：继承EditorWindow，重写“OnGUI”函数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121422.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEditorWnd</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">bool</span> groupEnabled;</span><br><span class="line">    <span class="built_in">bool</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">float</span> myFloat = <span class="number">1.23f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add menu named &quot;My Window&quot; to the Window menu</span></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Window/MyEditorWnd&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get existing open window or if none, make a new one:</span></span><br><span class="line">        MyEditorWnd window = (MyEditorWnd)EditorWindow.GetWindow(<span class="keyword">typeof</span>(MyEditorWnd));</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Base Settings&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        myString = EditorGUILayout.TextField(<span class="string">&quot;Text Field&quot;</span>, myString);</span><br><span class="line">        groupEnabled = EditorGUILayout.BeginToggleGroup(<span class="string">&quot;Optional Settings&quot;</span>, groupEnabled);</span><br><span class="line">        myBool = EditorGUILayout.Toggle(<span class="string">&quot;Toggle&quot;</span>, myBool);</span><br><span class="line">        myFloat = EditorGUILayout.Slider(<span class="string">&quot;Slider&quot;</span>, myFloat, <span class="number">-3</span>, <span class="number">3</span>);</span><br><span class="line">        EditorGUILayout.EndToggleGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面板式编辑器"><a href="#面板式编辑器" class="headerlink" title="面板式编辑器"></a>面板式编辑器</h1><p>对于上面提到所有拓展方式中，第三种“面板式编辑器”是最常用的一种，单独开篇。</p><h2 id="是在做什么？"><a href="#是在做什么？" class="headerlink" title="是在做什么？"></a>是在做什么？</h2><p>是在将 EditorGUI 拓展在 Inspector 面板上。</p><p>EditorGUI 和 GUI 的用法几乎完全一致，目前来说前者多用于编辑器开发，后者多用于发布后调试编辑器。总之，它们都是起辅助作用的。 EditorGUI 提供的组件非常丰富，常用的绘制元素包括文本、按钮、图片和滚动框等。做一个好的编辑器，是离不开 EditorGUI 的。</p><p>至于EditorGUI 和 数据的交互，是借由一个继承了MonoBehaviour的脚本的数据字段实现的。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>常规使用方法：</p><ol><li>  首先得有一个MonoBehaviour常规脚本，我们取名为“Show.cs”，可以在内自定义一些字段比如Sprite、List之类的。</li><li>  新建脚本，继承Editor类，标上[CustomEditor(typeof(Show))]标签当挂Showt脚本时就会显示这个编辑器，用来让编辑器和脚本互通。</li><li>  对2中新建的脚本重写”OnInspectorGUI”函数，对自己扩展的组件的编辑界面进行定制。</li></ol><p>以上示例代码见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><p>见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识编辑器拓展&quot;&gt;&lt;a href=&quot;#初识编辑器拓展&quot; class=&quot;headerlink&quot; title=&quot;初识编辑器拓展&quot;&gt;&lt;/a&gt;初识编辑器拓展&lt;/h1&gt;&lt;h2 id=&quot;支持&quot;&gt;&lt;a href=&quot;#支持&quot; class=&quot;headerlink&quot; title=&quot;支</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
