<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2022-03-18T13:18:05.707Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么叫“二进制”配置方案？</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/tools/serialize/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/tools/serialize/</id>
    <published>2022-03-18T13:18:05.707Z</published>
    <updated>2022-03-18T13:18:05.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的很懵，刚好自己的demo有用，挖一下。</p><h1 id="先说二进制式存储"><a href="#先说二进制式存储" class="headerlink" title="先说二进制式存储"></a>先说二进制式存储</h1><p>要理解为什么二进制更优，先明白什么是二进制式存储。</p><h2 id="什么是二进制文件？"><a href="#什么是二进制文件？" class="headerlink" title="什么是二进制文件？"></a>什么是二进制文件？</h2><p>所有对计算机有所了解的人肯定都知道计算机的存储在物理上是二进制（01）形式的。所以文本文件与二进制文件的区别并不是物理上，而是逻辑上的。其本质是两者在编码层次上的差异。简单的来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据应用的具体情况自定义自己的编码。</p><p>从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。</p><h2 id="文本文件是怎么读取的？"><a href="#文本文件是怎么读取的？" class="headerlink" title="文本文件是怎么读取的？"></a>文本文件是怎么读取的？</h2><p>文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。</p><p>比如选取ASCII码形式（ASCII码的一个字符是8个比特），它就会8个比特地来解释这个文件流：”01000000 01000001 01000010 01000011”用ASCII码解析出来是“ABCD”，显示在文本编辑器上。</p><h2 id="二进制文件vs文本文件"><a href="#二进制文件vs文本文件" class="headerlink" title="二进制文件vs文本文件"></a>二进制文件vs文本文件</h2><p><strong>译码难度</strong>：一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。</p><p><strong>文件大小</strong>：关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。</p><h1 id="再聊二进制配置"><a href="#再聊二进制配置" class="headerlink" title="再聊二进制配置"></a>再聊二进制配置</h1><h2 id="二进制和json的关系"><a href="#二进制和json的关系" class="headerlink" title="二进制和json的关系"></a>二进制和json的关系</h2><p>要存储一个json文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot; = 133,</span><br><span class="line">  &quot;color&quot; = [233, 0, 0],</span><br><span class="line">  &quot;pos&quot; = [34, 22]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>json一般以utf-8格式保存成文本</strong>，utf-8是unicode编码的一种实现形式。也就是说，像程序中的数字类型133，233，22等，一个uint8就能存储下了，可是133在json中却占了3个字节，要是存个12.432312等数据要占用更多的空间。而本文所说的二进制配置，直接存133等的uint8二进制编码0x85，这样便减少了一部分文件大小。<strong>编码与解码可以商量好自己的规则</strong>，比如time，编解码都以t代替，又可以节省一部分空间，甚至可以不存储time，color，pos等key，直接顺序在配置中写value，解码时直接读value（为了说的清楚，后面的例子保留了key）这样又可以减少配置文件的大小。</p><h2 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h2><blockquote><p>  序列化是将对象or对象图(比如数组)转换成字节流的过程，反序列化是将字节流转换回对象图的过程。</p></blockquote><p>上面这段来自我clr笔记的定义，就可以明白大佬们说的“二进制来做”，做的是序列化反序列化。</p><p>不通过这种常规读取方式：</p><p>读取utf-8的.json文件 =&gt; 将utf-8读取成二进制流byte[] =&gt; 此时byte[]是json字符串，也就是json序列化后的产物，我们再通过反射(至少我常用的库是反射)反序列化 =&gt; 反序列化完成，返回一个对象。</p><p>那如果加入“二进制来做”的读取方式：</p><p>读取.bin文件 =&gt; 二进制文件更小读取很快，获取到二进制流byte[]，然后根据自己定好的的规则去读流(比如按顺序获取定长比特来读取)，反序列化 =&gt; 反序列化完成，返回一个对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大佬们说的“二进制来做”，其实想指的是一个解决方案而不是指最终存的文件是二进制式的这么简单。</p><p>你可以<strong>可以自己写规则</strong>，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Custom_MemoryStream</span> : <span class="title">MemoryStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReadInt</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">base</span>.Read(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = BitConverter.GetBytes(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">base</span>.Write(arr, <span class="number">0</span>, arr.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 类似的还有很多比如string，这里略了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entity <span class="title">MakeEntity</span>(<span class="params">MemoryStream ms</span>)</span>&#123;</span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity();</span><br><span class="line">    entity.Id = ms.ReadInt();</span><br><span class="line">    entity.Name = ms.ReadString();</span><br><span class="line">    entity.Path = ms.ReadString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用现成的解决方案比如protobuf、FlatBuffers，他们的最终文件也都是<strong>二进制式的而不是文本格式，且读取的时候读二进制流直接按长度转换成字段</strong>。</p><p>最后，接上导表工具，就算成了。</p><p>可能对于定义上还是有一点点误解，以后会来改。但是我相信，无论怎样，目的都是为了更快、更小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="优化" scheme="https://codingcodingk.github.io/categories/Game/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity编辑器拓展</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_4/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_4/</id>
    <published>2022-03-18T13:18:05.702Z</published>
    <updated>2022-03-18T13:18:05.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识编辑器拓展"><a href="#初识编辑器拓展" class="headerlink" title="初识编辑器拓展"></a>初识编辑器拓展</h1><h2 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h2><ul><li>  菜单栏选项</li><li>  菜单栏窗口</li><li>  面板式编辑器</li><li>  窗口式编辑器</li></ul><p>unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。 用于扩展editor的类需要放到名字为“Editor”的文件夹中，这个文件夹可以直接放到”Assets“文件夹下，也可以是项目目录任何文件夹下的子文件夹，比如”Assets/SkillSystem/Editor”。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>重新绘制画面，主要是通过重写OnGUI、OnInspectorGUI之类的函数来实现的。</p><p>这些函数是生命周期中的一员，具体看Unity生命流程图。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>对上面提出的支持进行简单实践。</p><h2 id="菜单栏选项"><a href="#菜单栏选项" class="headerlink" title="菜单栏选项"></a>菜单栏选项</h2><p>菜单栏里添加“Tools &gt; 打包工具”项。点击执行方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;Tools/打包工具&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputAB</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单栏窗口"><a href="#菜单栏窗口" class="headerlink" title="菜单栏窗口"></a>菜单栏窗口</h2><p>菜单栏里添加“Example &gt; 打包工具”项。点击跳出制作的窗口以及控件。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121155.png"></p><p>使用方法：</p><ol><li>  继承ScriptableWizard</li><li>  调用ScriptableWizard.DisplayWizard函数可以快速创建这个向导窗口。这个向导窗口只支持小于或等于两个按钮的定制（即提供的消息响应函数只有两个按钮的）。显示的按钮名字通过ScriptableWizard.DisplayWizard函数传入。</li></ol><p>ScriptableWizard的API中的消息响应函数：（当满足某些条件下执行这些函数）</p><p>OnWizardCreate ：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”createButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardOtherButton：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”otherButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardUpdate：当向导窗口打开时或者用户改变窗口内容时都会被调用。一般会在这里显示帮助文字和进行内容有效性验证。也可以动态改变按钮状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptableWizardButton</span> : <span class="title">ScriptableWizard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firstObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform secondObject = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Example/Show OnWizardOtherButton Usage&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard(<span class="string">&quot;Click info to know the distance between the objects&quot;</span>, <span class="keyword">typeof</span>(ScriptableWizardButton), <span class="string">&quot;Finish!&quot;</span>, <span class="string">&quot;Info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstObject == <span class="literal">null</span> || secondObject == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">false</span>;</span><br><span class="line">            errorString = <span class="string">&quot;Select the objects you want to measure&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">true</span>;</span><br><span class="line">            errorString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Info&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardOtherButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> distanceObjs = Vector3.Distance(firstObject.position, secondObject.position);</span><br><span class="line">        EditorUtility.DisplayDialog(</span><br><span class="line">            <span class="string">&quot;The distance between the objects is: &quot;</span> + distanceObjs + <span class="string">&quot; Units&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Finish!&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorUtility.DisplayDialog(<span class="string">&quot;OnWizardCreate &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口式编辑器"><a href="#窗口式编辑器" class="headerlink" title="窗口式编辑器"></a>窗口式编辑器</h2><p>菜单栏里添加“Window &gt; MyEditorWnd”。点击打开窗口式面板。</p><p>使用方法：继承EditorWindow，重写“OnGUI”函数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121422.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEditorWnd</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">bool</span> groupEnabled;</span><br><span class="line">    <span class="built_in">bool</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">float</span> myFloat = <span class="number">1.23f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add menu named &quot;My Window&quot; to the Window menu</span></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Window/MyEditorWnd&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get existing open window or if none, make a new one:</span></span><br><span class="line">        MyEditorWnd window = (MyEditorWnd)EditorWindow.GetWindow(<span class="keyword">typeof</span>(MyEditorWnd));</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Base Settings&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        myString = EditorGUILayout.TextField(<span class="string">&quot;Text Field&quot;</span>, myString);</span><br><span class="line">        groupEnabled = EditorGUILayout.BeginToggleGroup(<span class="string">&quot;Optional Settings&quot;</span>, groupEnabled);</span><br><span class="line">        myBool = EditorGUILayout.Toggle(<span class="string">&quot;Toggle&quot;</span>, myBool);</span><br><span class="line">        myFloat = EditorGUILayout.Slider(<span class="string">&quot;Slider&quot;</span>, myFloat, <span class="number">-3</span>, <span class="number">3</span>);</span><br><span class="line">        EditorGUILayout.EndToggleGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面板式编辑器"><a href="#面板式编辑器" class="headerlink" title="面板式编辑器"></a>面板式编辑器</h1><p>对于上面提到所有拓展方式中，第三种“面板式编辑器”是最常用的一种，单独开篇。</p><h2 id="是在做什么？"><a href="#是在做什么？" class="headerlink" title="是在做什么？"></a>是在做什么？</h2><p>是在将 EditorGUI 拓展在 Inspector 面板上。</p><p>EditorGUI 和 GUI 的用法几乎完全一致，目前来说前者多用于编辑器开发，后者多用于发布后调试编辑器。总之，它们都是起辅助作用的。 EditorGUI 提供的组件非常丰富，常用的绘制元素包括文本、按钮、图片和滚动框等。做一个好的编辑器，是离不开 EditorGUI 的。</p><p>至于EditorGUI 和 数据的交互，是借由一个继承了MonoBehaviour的脚本的数据字段实现的。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>常规使用方法：</p><ol><li>  首先得有一个MonoBehaviour常规脚本，我们取名为“Show.cs”，可以在内自定义一些字段比如Sprite、List之类的。</li><li>  新建脚本，继承Editor类，标上[CustomEditor(typeof(Show))]标签当挂Showt脚本时就会显示这个编辑器，用来让编辑器和脚本互通。</li><li>  对2中新建的脚本重写”OnInspectorGUI”函数，对自己扩展的组件的编辑界面进行定制。</li></ol><p>以上示例代码见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><p>见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识编辑器拓展&quot;&gt;&lt;a href=&quot;#初识编辑器拓展&quot; class=&quot;headerlink&quot; title=&quot;初识编辑器拓展&quot;&gt;&lt;/a&gt;初识编辑器拓展&lt;/h1&gt;&lt;h2 id=&quot;支持&quot;&gt;&lt;a href=&quot;#支持&quot; class=&quot;headerlink&quot; title=&quot;支</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity协程原理</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_5/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_5/</id>
    <published>2022-03-18T13:18:05.702Z</published>
    <updated>2022-03-18T13:18:05.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开启一个协程发生了什么"><a href="#开启一个协程发生了什么" class="headerlink" title="开启一个协程发生了什么"></a>开启一个协程发生了什么</h1><p>分析如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ShowLog());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">IEnumerator <span class="title">ShowLog</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(i);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先描述一下里面用到的方法和类：</p><h2 id="StartCoroutine"><a href="#StartCoroutine" class="headerlink" title="StartCoroutine"></a>StartCoroutine</h2><p>StartCoroutine是 Monobehavior类的函数，有3个重载函数</p><blockquote><p>  public Coroutine StartCoroutine(string methodName);<br>  public Coroutine StartCoroutine(IEnumerator routine);<br>  public Coroutine StartCoroutine(string methodName, [DefaultValue(“null”)] object value);</p></blockquote><p>StartCoroutine的第一个和第三个methodName ，都是一个返回类型是IEnumerator的方法。</p><p>所以入参全是<strong>IEnumerator迭代器方法</strong>。返回类型全是<strong>Coroutine</strong>类。</p><h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>协同程序。继承自<strong>YieldInstruction</strong>类。</p><p><a href="https://docs.unity3d.com/cn/current/ScriptReference/MonoBehaviour.StartCoroutine.html">StartCoroutine函数</a> 返回 Coroutine。协同程序是一个可以暂停执行 (yield) 的函数，直到给定的 <a href="https://docs.unity3d.com/cn/current/ScriptReference/YieldInstruction.html">YieldInstruction</a> 完成。</p><h2 id="YieldInstruction"><a href="#YieldInstruction" class="headerlink" title="YieldInstruction"></a>YieldInstruction</h2><p>yield return后面可以是值，也可以是一个类型为继承自<strong>YieldInstruction的类</strong>。</p><p>如果yield return的是YieldInstruction的派生类，Unity就会将其理解为“持续等待”。比如WaitForEndOfFrame、WaitForFixedUpdate、WaitForSeconds、WWW、Coroutine（StartCoroutine的返回值），它们都是。</p><h2 id="yield-return"><a href="#yield-return" class="headerlink" title="yield return"></a>yield return</h2><p>yield return后面可以跟的表达式：</p><p>​        所有非YieldInstruction派生类（包括null）：协程将会在下一帧恢复，继续后续代码。</p><p>​        WaitForEndOfFrame：协程将会在这一帧结束之后（所有渲染、GUI）恢复，继续后续代码。</p><p>​        WaitForFixedUpdate：所有物理引擎计算完成之后恢复，继续后续代码。</p><p>​        WaitForSeconds：等待x秒后（以Unity内的计时系统为基准）恢复，继续后续代码。</p><p>​        WWW：等待一个web request结束后恢复，继续后续代码。</p><p>​        Coroutine 其他协程（协程嵌套）：等子协程Coroutine执行完后恢复，继续后续代码。如果子协程内有yield中断，那父协程会一直暂停，直到子协程运行完毕。</p><h2 id="CustomYieldInstruction"><a href="#CustomYieldInstruction" class="headerlink" title="CustomYieldInstruction"></a>CustomYieldInstruction</h2><p>想实现自定义和<code>YieldInstruction</code>一样，拥有“持续等待”逻辑的协程，就用这个。继承自<code>IEnumerator</code>类。</p><p>重写<code>keepWaiting</code>函数即可。要使协同程序保持暂停，则返回<code>true</code>；要使协同程序继续执行， 则返回<code>false</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Left mouse button up&quot;</span>);</span><br><span class="line">            StartCoroutine(waitForMouseDown());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">waitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Right mouse button pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaitForMouseDown</span> : <span class="title">CustomYieldInstruction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> keepWaiting</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !Input.GetMouseButtonDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitForMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Waiting for Mouse right button down&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程原理"><a href="#协程原理" class="headerlink" title="协程原理"></a>协程原理</h1><p>如果代码中对<code>gameObject.SetActive(false)</code>，协程就会失效，即使再次激活，也不能继续执行。原因是协程是在StartCoroutine时被注册到的GameObject上，他的生命期受限于GameObject的生命期，因此受GameObject是否active的影响。</p><p><strong>不难得出，协程和Update一样是在每一帧被调用执行的。经过测试，一般是在LastUpdate之后执行的。</strong></p><p>而具体怎么执行，是利用了<strong>迭代器</strong>：每一帧检测yield的返回情况（想想StartCoroutine估计就是<code>while(MoveNext)</code>）。也就是<strong>每一帧都执行MoveNext</strong>，如果为true下一帧就继续执行MoveNext，如果为false就结束协程将其从协程队列中剔除。</p><h1 id="自己实现携程"><a href="#自己实现携程" class="headerlink" title="自己实现携程"></a>自己实现携程</h1><p>// 当然也可以考虑用async-await替代协程，ETTask就是这样的。具体以后再看，粗看应该是最后将回调放到<code>同步上下文.Post</code>里做了。</p><p>找到一个不错的实践，<a href="https://www.cnblogs.com/zblade/p/9857808.html">转载</a>一下。可以手动控制携程顺序、执行片长。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Profiling;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QuotaCoroutine</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每帧的额度时间，全局共享</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">float</span> frameQuotaSec = <span class="number">0.001f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">LinkedList</span>&lt;<span class="title">IEnumerator</span>&gt; s_tasks</span> = <span class="keyword">new</span> LinkedList&lt;IEnumerator&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartQuotaCoroutine(Task(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleTask();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartQuotaCoroutine</span>(<span class="params">IEnumerator task</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        s_tasks.AddLast(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ScheduleTask</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> timeStart = Time.realtimeSinceStartup;</span><br><span class="line">        <span class="keyword">while</span> (s_tasks.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> t = s_tasks.First.Value;</span><br><span class="line">            <span class="built_in">bool</span> taskFinish = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (Time.realtimeSinceStartup - timeStart &lt; frameQuotaSec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 执行任务的一步, 后续没步骤就是任务完成</span></span><br><span class="line">                Profiler.BeginSample(<span class="built_in">string</span>.Format(<span class="string">&quot;QuotaTaskStep, f:&#123;0&#125;&quot;</span>, Time.frameCount));</span><br><span class="line">                taskFinish = !t.MoveNext();</span><br><span class="line">                Profiler.EndSample();</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (taskFinish)</span><br><span class="line">                &#123;</span><br><span class="line">                    s_tasks.RemoveFirst();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 任务没结束执行到这里就是没时间额度了</span></span><br><span class="line">            <span class="keyword">if</span> (!taskFinish)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">IEnumerator <span class="title">Task</span>(<span class="params"><span class="built_in">int</span> taskId, <span class="built_in">int</span> stepCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; stepCount)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;, frame:&#123;2&#125;&quot;</span>, taskId, i, Time.frameCount);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开启一个协程发生了什么&quot;&gt;&lt;a href=&quot;#开启一个协程发生了什么&quot; class=&quot;headerlink&quot; title=&quot;开启一个协程发生了什么&quot;&gt;&lt;/a&gt;开启一个协程发生了什么&lt;/h1&gt;&lt;p&gt;分析如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UI屏幕自适应</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_1/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_1/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-18T13:18:05.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="面板基本"><a href="#面板基本" class="headerlink" title="面板基本"></a>面板基本</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217103517.png"></p><p>当我们点击一个GUI物体是它具有的属性为：</p><p><strong>Rect Transform</strong>：继承自Transform组件，它表示的是控件的Location位置，和一些基本的属性。这个控件的参数类型会随着锚点情况而改变，具体在下一节展示。</p><p><strong>Pivot</strong>：设置轴心（不是蓝色的，那个叫中心锚点）的位置，中心点的位置【0,0】表示的是控件的左下角的位置，【1,1】表示的是右上角的位置，【0.5,0.5】表示的是图像中心的位置。</p><p><strong>Anchors</strong>：它的取值和Pivot一个逻辑，也是0~1之间。Min点和Max点是2个点，2个点可以沿着x、y方向，确定出一个矩形。而这个矩形的4个点就是4个锚点。我们也可以直接拖动画面的锚点来快捷设置。</p><h2 id="Pivot-和-Center"><a href="#Pivot-和-Center" class="headerlink" title="Pivot 和 Center"></a>Pivot 和 Center</h2><p>Pivot上面说了，是轴心，可以自己在Rect Transform的面板里设置；</p><p>Center是中心，是在Unity中根据模型的mesh信息计算得到的中心位置，是所有物体共同的中心，如果同时选中了多个物体，则坐标是所有模型共同参与计算出来的坐标。</p><p>Center是由Unity计算出来的而不是设置出来的。Pivot在锚点重合情况下，代表着PosX和PosY画出来的的点。</p><h2 id="锚点、纽扣和中心点-Center"><a href="#锚点、纽扣和中心点-Center" class="headerlink" title="锚点、纽扣和中心点(Center)"></a>锚点、纽扣和中心点(Center)</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217104252.png"></p><p>这里先对3个点下定义，下面一节进行讨论。</p><p>单击图形显示着的的小篮圈，到底表示的是Pivot还是Center，是在Unity里设置的，两者完全不是一个东西。设置的话，在Global边上的选项里选择即可。</p><p>正常的二维UI，中心点总是在正中间，而轴心就可以自己设置了。</p><h1 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h1><h2 id="情况一：两个锚点重合"><a href="#情况一：两个锚点重合" class="headerlink" title="情况一：两个锚点重合"></a>情况一：两个锚点重合</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>两个锚点重合的情况，Image UI（也就是红色Image）的锚点和Pivot连成一条线，这条线会永远保持（也就是两点的距离会永远保持）。<strong>在这种情况下调整画面，Image UI不会变形，只会根据Pivot点到Anchor点的距离一致的原则调整位置。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120309.png"></p><p>一个值得关注的点是，此时Image UI的Rect Transform控件是Pos + Width,Height的组合。这个PosX和Y，指的是Anchor和Pivot之间的相对位置。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120631.png"></p><h3 id="示例动图"><a href="#示例动图" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored1.gif"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored2.gif"></p><h2 id="情况二：锚框"><a href="#情况二：锚框" class="headerlink" title="情况二：锚框"></a>情况二：锚框</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>当两个锚点（AnchorMin和AnchorMax）不重合时，两点就会确定一个矩形，这个矩形就是我们的锚框。<strong>这种情况会保持锚点到纽扣的距离保持不变。</strong></p><p>此时Image UI的Rect Transform控件是Left,Top + Right,Bottom的组合。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217121839.png"></p><p>这四个点什么意思呢？是纽扣的相对位置，相对的是锚点组成的坐标系。看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217134116.png"></p><p>所以明白了，锚点到纽扣的距离保持不变，那就意味着4条（图中2条以及左上右下未画出来的）绿线始终保持不变。同时意味着，代表这4个点相对位置的Rect Transform控件里的Left,Top,Right,Bottom值也都不变。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217135538.png"></p><h3 id="示例动图-1"><a href="#示例动图-1" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored3.gif"></p><h2 id="anchoredPosition属性"><a href="#anchoredPosition属性" class="headerlink" title="anchoredPosition属性"></a>anchoredPosition属性</h2><p>他本身是一个点，如果在AnchorMin和AnchorMax是重合的场合（情况一）下，anchoredPosition就是表示锚点到Pivot的位置。</p><p>但是如果AnchorMin和AnchorMax不重合的时候（情况二），anchoredPosition就比较复杂了，在这种情况下，Unity会根据Pivot、AnchorMin和AnchorMax计算出一个锚点，然后在通过Pivot和锚点来得出anchoredPosition的位置。</p><h2 id="offsetMin和offsetMax详解"><a href="#offsetMin和offsetMax详解" class="headerlink" title="offsetMin和offsetMax详解"></a>offsetMin和offsetMax详解</h2><p>offsetMin和offsetMax这两个属性。其中offsetMin表示物体（本文中的红框）左下角相对AnchorMin的偏移，offsetMax表示物体右上角相对AnchorMax的偏移。</p><p>情况一 anchor(0, 0)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151909.png"></p><p>情况二 anchorMin(0,0) anchorMax(1,1)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151935.png"></p><h2 id="sizeDelta详解"><a href="#sizeDelta详解" class="headerlink" title="sizeDelta详解"></a>sizeDelta详解</h2><p>sizeDelta就是offsetMax - offsetMin的值，即物体左下角到右上角的变量：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152058.png"></p><h1 id="画布缩放器-Canvas-Scaler"><a href="#画布缩放器-Canvas-Scaler" class="headerlink" title="画布缩放器 Canvas Scaler"></a>画布缩放器 Canvas Scaler</h1><p>Canvas新建时自带的脚本，专门解决屏幕适配问题的脚本，负责伸缩所有UI对象。以下内容主要取自<a href="https://docs.unity3d.com/cn/current/Manual/script-CanvasScaler.html">Unity中文手册</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152713.png"></p><p>三种模式：</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>UI Scale Mode</strong></td><td align="left">确定画布中的 UI 元素的缩放方式。</td></tr><tr><td align="left"><strong>Constant Pixel Size</strong></td><td align="left">无论屏幕大小如何，UI 元素都保持相同的像素大小。</td></tr><tr><td align="left"><strong>Scale With Screen Size</strong></td><td align="left">屏幕越大，UI 元素越大。</td></tr><tr><td align="left"><strong>Constant Physical Size</strong></td><td align="left">无论屏幕大小和分辨率如何，UI 元素都保持相同的物理大小。</td></tr></tbody></table><p>一般来说的配置方案是：<br>Canvas Scaler 选择 Scale With Screen Size<br>Screen Match Mode 选择 Match Width Or Height，</p><p>横屏游戏比例设为1，即只和高度进行适配；</p><p>竖屏游戏比例设为0，即只和宽度进行适配。</p><h2 id="1、Constant-Pixel-Size"><a href="#1、Constant-Pixel-Size" class="headerlink" title="1、Constant Pixel Size"></a>1、Constant Pixel Size</h2><p>一般美术拿它来做缩放图片，因为不同Size不失真。</p><p>使用 Constant Pixel Size 模式时，可在屏幕上按像素指定 UI 元素的位置和大小。这也是画布在未附加任何画布缩放器时的默认功能。但是，借助画布缩放器中的“Scale Factor”设置，可以向画布中的所有 UI 元素应用常量缩放。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Scale Factor</strong></td><td align="left">按此系数缩放画布中的所有 UI 元素。画布的缩放比例。默认况下为1，表示正常大小。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。每单位代表的像素量。</td></tr></tbody></table><h2 id="2、Scale-With-Screen-Size"><a href="#2、Scale-With-Screen-Size" class="headerlink" title="2、Scale With Screen Size"></a>2、Scale With Screen Size</h2><p>使用 Scale With Screen Size 模式时，可以根据指定参考分辨率的像素来指定位置和大小。如果当前屏幕分辨率大于参考分辨率，则画布会保持只具有参考分辨率的分辨率，但是会放大以便适应屏幕。如果当前屏幕分辨率小于参考分辨率，则画布会相应缩小以适应屏幕。</p><p>如果当前屏幕分辨率的宽高比与参考分辨率不同，则单独缩放每个轴以适应屏幕会形成非一致缩放，通常不希望发生这种情况。相反，ReferenceResolution 组件会使画布分辨率偏离参考分辨率，以便遵循屏幕的宽高比。可以使用 Screen Match Mode 设置控制此偏离的行为方式。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Reference Resolution</strong></td><td align="left">UI 布局设计的目标分辨率。如果屏幕分辨率较大，则 UI 会放大，如果较小，则 UI 会缩小。</td></tr><tr><td align="left"><strong>Screen Match Mode</strong></td><td align="left">在当前分辨率的宽高比不适应参考分辨率时，用于缩放画布区域的模式。</td></tr><tr><td align="left"><strong>Match Width or Height</strong>⭐常用</td><td align="left">以宽度、高度或二者的某种平均值作为参考来缩放画布区域。</td></tr><tr><td align="left"><strong>Expand</strong></td><td align="left">水平或垂直扩展画布区域，使画布不会小于参考。</td></tr><tr><td align="left"><strong>Shrink</strong></td><td align="left">水平或垂直裁剪画布区域，使画布不会大于参考。</td></tr><tr><td align="left"><strong>Match</strong></td><td align="left">确定是否以宽度、高度或二者的某种平均值作为参考进行缩放。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。</td></tr></tbody></table><h2 id="3、Constant-Physical-Size"><a href="#3、Constant-Physical-Size" class="headerlink" title="3、Constant Physical Size"></a>3、Constant Physical Size</h2><p>使用 Constant Physical Size 模式时，可按物理单位（如毫米、点或派卡）指定 UI 元素的位置和大小。此模式要求设备正确报告其屏幕 DPI。对于不报告 DPI 的设备，可以指定回退 DPI。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Physical Unit</strong></td><td align="left">用于指定位置和大小的物理单位。</td></tr><tr><td align="left"><strong>Fallback Screen DPI</strong></td><td align="left">在屏幕 DPI 未知时采用的 DPI。</td></tr><tr><td align="left"><strong>Default Sprite DPI</strong></td><td align="left">用于精灵的每英寸像素，使其“Pixels Per Unit”设置与“Reference Pixels Per Unit”设置匹配。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则其 DPI 将与“Default Sprite DPI”设置匹配。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;h2 id=&quot;面板基本&quot;&gt;&lt;a href=&quot;#面板基本&quot; class=&quot;headerlink&quot; title=&quot;面板基本&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UI常见优化</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_2/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_2/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-18T13:18:05.701Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。</p><h1 id="Unity性能优化"><a href="#Unity性能优化" class="headerlink" title="Unity性能优化"></a>Unity性能优化</h1><h2 id="优化关键"><a href="#优化关键" class="headerlink" title="优化关键"></a>优化关键</h2><p>先找到性能瓶颈。影响图形性能的关键因素主要有一下几个方面。</p><ol><li> GPU填充率和存储器带宽。</li><li> CPU经常是渲染物体的数量（也就是常常大家说的Draw Calls）。</li><li> 系统内存容量也是优化的一个关键指标。</li></ol><h2 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h2><p>GPU优化主要有下面几点：</p><ol><li>  减少三角形的使用数量（去掉不必要的三角形面）。</li><li>  尽量避免使用实时光照，能使用Static Lighting就使用烘焙光照，只计算一次。</li><li>  压缩纹理和多重纹理-minmaps（这样可以提高加载速度和降低内存占用），也极大提高渲染的性能。</li><li>  LOD（多细节层次），不同距离使用不同精度的模型。</li><li>  编写高性能着色器，将能能处理的逻辑放在定点着色器里面处理，减少片段着色器的计算量。</li></ol><h2 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h2><p>CPU主要开销在，显卡在渲染一个对象之前，CPU需要计算一些着色器和灯光影响，然后想显卡驱动发送绘制指令，单物体来说，不会太影响性能，累计就会产生性能问题。这里优化点主要从以下几个方面讨论，这里只是说出优化常用的方案，后面如果在下在项目里面遇到更加好的方案，或者是方法，我将会在这里补充出来。也欢迎大家指出错误，或者是更好的CPU优化方案。</p><ol><li> 合并材质球相同的对象，进而减少绘制指令的发送。合并的方式有，手工合并或者是使用Unity内置的选项合并，或者是使用自制脚本合并模型对象，但是注意的是:非相同材质对象，合并不会对性能有任何的提高。</li><li> 在对象或场景中使用更少的材质。可以将独立的纹理合并成一个更大的纹理图集，但是合并时注意，合并要以方便开发，节省资源为基础。</li><li> 避免使用物体被渲染多次的效果，这里主要体现在（反射，阴影，像素光照等）。</li><li> 优化游戏代码，也是优化CPU的一个关键点。</li></ol><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>性能优化最后一点，就是内存的优化，要优化Unity的内存资源，就首先必须了解内存的资源管理模式，以及Unity资源加载的方式，Unity资源动态加载主要有下面两种方式：</p><ol><li> Resource方式资源加载。</li><li> AssetBundle资源加载方式。</li></ol><p>这两种资源加载方式都提供同步和异步加载API，这里我就过多介绍AIP是哪些，使用的时候可以直接查看。这里需要注意的是资源加载到内存里面的规范到底是什么样的，观察下面的图就一目了然。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210105112.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。&lt;/p&gt;
&lt;h1 id=&quot;Unity性能优化&quot;&gt;&lt;a href=&quot;#Unity性能优化&quot; class=&quot;headerlink&quot; title=&quot;Unity性能优化&quot;&gt;&lt;/a&gt;Unity性能优化&lt;/h</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity生命流程</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_3/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/uiboy_3/</id>
    <published>2022-03-18T13:18:05.701Z</published>
    <updated>2022-03-18T13:18:05.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命流程图"><a href="#生命流程图" class="headerlink" title="生命流程图"></a>生命流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221094846.png"></p><h1 id="FixedUpdate"><a href="#FixedUpdate" class="headerlink" title="FixedUpdate"></a>FixedUpdate</h1><p>1、和Update主帧循环不同，Unity的刚体系统通过固定的时间来驱动也就是FixedUpdate。在刚体系统运算开始前，<strong>Unity会根据上一次刚体运算完成的时间再加上Fixed Timestep的所设置的值来作为这一次刚体运算时间的限定范围</strong>。然后刚体系统会开始计算，直到达到这个时间限制临界点。</p><p>2、FixedUpdate与Update的不同在于，Update在每帧被调用，但是调用时间不确定，所以我们要实现一个物体匀速运动是，是无法通过Update准确实现的，但是我们可以在FixedUpdate中实现，因为它在确定的时间间隔中被调用。FixedUpdate有可能在Update之前调用多次。FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。</p><p>3、FixedUpdate的频率可以自己设置，如果频率过高，导致一次Update的时间片内执行了多次FixedUpdate进行物理运算，那对CPU就是一种浪费（因为根本不显示出来）；而适当的低频率FixedUpdate，虽然偶尔会造成人物有顿感，但是往往是可以接受的。</p><p>4、FixedUpdate的最高值也是可以设置的。Time Manager中的Maximum Allowed Timestep就是给处理物体运算的FixedUpdate加上一个限制。如果某一帧的物理运算时间超过了这个值，物理引擎就会立即停止运算，以便让主循环Update可以追上,一旦这一帧主循环Update运行完成，物理引擎就会从它暂停的地方恢复计算就像它从来没有停止过一样。</p><h1 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate"></a>LateUpdate</h1><p>3、LateUpdate它会在所有update被调用后调用，这个函数可以在我们编写ai时被使用，因为我们要当所有物体和怪物移动过后再判断物体的一些策略，比如开枪等，这个时候就可以在LateUpdate中编写，因为LateUpdate基本可以保证所有物体在本帧的移动等操作均已经完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生命流程图&quot;&gt;&lt;a href=&quot;#生命流程图&quot; class=&quot;headerlink&quot; title=&quot;生命流程图&quot;&gt;&lt;/a&gt;生命流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/CodingCodingK/Coding</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity常见UI基础问题手册</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/Guide_UnityUI/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/Guide_UnityUI/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<p>仅作个人笔记用途。</p><h1 id="UI顶层显示"><a href="#UI顶层显示" class="headerlink" title="UI顶层显示"></a>UI顶层显示</h1><h2 id="方法一-做一个新的UI摄像机"><a href="#方法一-做一个新的UI摄像机" class="headerlink" title="方法一.做一个新的UI摄像机"></a>方法一.做一个新的UI摄像机</h2><p>① Canvas的Render Mode设置为<strong>Screen Space - Camera</strong></p><p>② 新建摄像机（后面称之为UI摄像机），放到原先摄像机的下面</p><p>③ 拖拽UI摄像机到Canvas的Render Camera</p><p>④ UI摄像机的 Clear Flags 设置为 <strong>Depth only</strong>，用来去掉背景；Culling Mask设置为 <strong>UI</strong>。</p><p>⑤ 确保 UI摄像机的Depth &gt; 其他摄像机的Depth （值小的会先渲染，所以值大的会在前面）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1dK4y1b7be?spm_id_from=333.999.0.0">超级细致的调试教学视频</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅作个人笔记用途。&lt;/p&gt;
&lt;h1 id=&quot;UI顶层显示&quot;&gt;&lt;a href=&quot;#UI顶层显示&quot; class=&quot;headerlink&quot; title=&quot;UI顶层显示&quot;&gt;&lt;/a&gt;UI顶层显示&lt;/h1&gt;&lt;h2 id=&quot;方法一-做一个新的UI摄像机&quot;&gt;&lt;a href=&quot;#方法一-做一</summary>
      
    
    
    
    <category term="Unity个人积累" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Unity渲染原理</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/Rendering/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/Rendering/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<p>渲染原理学习。// TODO</p><h1 id="Rending面板"><a href="#Rending面板" class="headerlink" title="Rending面板"></a>Rending面板</h1><h2 id="Color-Space"><a href="#Color-Space" class="headerlink" title="Color Space"></a>Color Space</h2><p>以前的阴极射线管电视，需要更强烈的色彩来弥补差设备显示，但现在硬件提升已经不需要了。</p><p>这就是为什么把Rendering的Color Space从Gamma切到Linear。</p><h3 id="阴极-真空管-电视"><a href="#阴极-真空管-电视" class="headerlink" title="阴极 真空管 电视"></a>阴极 真空管 电视</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118131229.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染原理学习。// TODO&lt;/p&gt;
&lt;h1 id=&quot;Rending面板&quot;&gt;&lt;a href=&quot;#Rending面板&quot; class=&quot;headerlink&quot; title=&quot;Rending面板&quot;&gt;&lt;/a&gt;Rending面板&lt;/h1&gt;&lt;h2 id=&quot;Color-Space&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/categories/Unity/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - Base篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/ugui_1/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/ugui_1/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><a href="https://github.com/Unity-Technologies/uGUI">源码地址</a></p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105619250">学习博客</a></p><p>GF源码看了，UGUI自适应用了，自定义编辑器写了，但是对于UGUI却一直是纯黑盒使用。想体系化学习一遍UGUI。</p><p>学习目的：按照博客阅读源码，理解后整理成自己的笔记，方便回忆。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h1><p>好图，转自大佬<a href="https://blog.csdn.net/qq_28820675/article/details/105619250">博客</a>！</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220316142853.png"></p><h1 id="UIBehaviour"><a href="#UIBehaviour" class="headerlink" title="UIBehaviour"></a>UIBehaviour</h1><blockquote><p>  namespace UnityEngine.EventSystems :</p><p>  public abstract class UIBehaviour : MonoBehaviour</p></blockquote><p>是一个抽象类，里面提供了一系列虚方法：</p><ul><li>  生命周期（Awake,OnEnable,Start,OnDisable,OnDestroy）</li><li>  UnityEditor 辅助方法</li><li>  UGUI 通用方法（IsActive,OnValidate,OnRectTransformDimensionsChange等锚点相关）</li></ul><p>和一个非虚方法 IsDestroyed：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsDestroyed</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Unity-Technologies/uGUI&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习 - 事件系统篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/ugui_2/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/Game/UI/ugui_2/</id>
    <published>2022-03-18T13:18:05.700Z</published>
    <updated>2022-03-18T13:18:05.700Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zzmkljd/article/details/52880870">https://blog.csdn.net/zzmkljd/article/details/52880870</a></p><p><a href="https://blog.csdn.net/qq_28820675/article/details/105619356">https://blog.csdn.net/qq_28820675/article/details/105619356</a></p><h1 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h1><p>平时新建一个Canvas时，会创建EventSystem组件，这个组件所挂载的脚本就是EventSystem。EventSystem组件主要负责处理输入、射线投射以及发送事件，一个场景中只能有一个EventSystem组件。</p><h2 id="只会有一个EventSystem正在on-call"><a href="#只会有一个EventSystem正在on-call" class="headerlink" title="只会有一个EventSystem正在on call"></a>只会有一个EventSystem正在on call</h2><p>它的内部有一个静态队列：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">EventSystem</span>&gt; m_EventSystems</span> = <span class="keyword">new</span> List&lt;EventSystem&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventSystem current &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_EventSystems.Count &gt; <span class="number">0</span> ? m_EventSystems[<span class="number">0</span>] : <span class="literal">null</span>; &#125; <span class="keyword">set</span> &#123;...&#125; &#125;</span><br></pre></td></tr></table></figure><p>所有的EventSystem都是在事件组件OnEnable时注册进队，OnDisable时反注册离队。</p><p>外部能接触的只有current，也就是返回队列中第一个EventSystem对象的属性方法。所以可以把EventSystem理解为单例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zzmkljd/article/details/52880870&quot;&gt;https://blog.csdn.net/zzmkljd/article/details/52880870&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UGUI" scheme="https://codingcodingk.github.io/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 同步异步、多线程篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/tongbuyibu_obsolete/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/tongbuyibu_obsolete/</id>
    <published>2022-03-18T13:18:05.699Z</published>
    <updated>2022-03-18T13:18:05.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零-为什么我会理解错"><a href="#零-为什么我会理解错" class="headerlink" title="零.为什么我会理解错"></a>零.为什么我会理解错</h1><p>在看完clr之前，我曾对异步同步探究看了十几篇文章，但很可惜，没有完全理解，只知道了一大堆概念：IRP、异步要借用多线程…</p><p>在看完之后，我理解并甚至尝试实现一个简单的异步的时候才明白，之前无法理解是因为我不懂：</p><p><strong>异步编程 和 异步函数 是不同的东西。也就是说，异步函数async/await 只是异步编程的一种罢了，你大可以利用ContinueWith或ThreadPool等来实现异步。</strong></p><p>很多博客混淆了这两个概念，我不知道他们是否真正理解了，但是这会导致我这种代码先行基础后补的菜b无法理解。</p><p>所以这篇文章的理解是片面的，等有空了我再整理一下。</p><h1 id="一-同步与异步"><a href="#一-同步与异步" class="headerlink" title="一.同步与异步"></a>一.同步与异步</h1><p>  项目中每天都在接触，但是对这俩概念比较模糊。看《CLR via C#》刚好提到了，就去网上找到几篇好文，理解写篇自己的笔记。首先得说明的是，这一节讨论的只是概念，都是单纯的、不考虑多线程处理的同步与异步区别。</p><h3 id="IO-概念区分"><a href="#IO-概念区分" class="headerlink" title="IO 概念区分"></a>IO 概念区分</h3><ul><li><p>同步（Synchronous）</p></li><li><p>异步( Asynchronous)</p></li><li><p>阻塞( Blocking )</p></li><li><p>非阻塞( Nonblocking)</p></li></ul><p>那首先，要弄清楚同步异步、阻塞非阻塞之间的关系。</p><ul><li><p>同步异步 指的是在客户端，<br>同步意味着 客户端提出了一个请求以后，在回应之前只能等待。<br>异步意味着 客户端提出一个请求以后，还可以继续提其他请求。</p></li><li><p>阻塞非阻塞 指的是服务器端，<br>阻塞意味着 服务器接受一个请求后，在返回结果以前不能接受其他请求。<br>非阻塞意味着 服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求。</p></li></ul><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><ol><li>同步与异步意图<br>这个层级的还是很好理解，它们的核心是消息通信机制。</li></ol><ul><li>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。也就是说，代码执行会等着它，卡在那不动，直到执行结束把返回值给我才继续。</li><li>异步则是相反，调用在发出之后，这个调用就直接返回了，没有返回结果，我记得如果还没返回就去拿的话好像是null。也就是说，代码执行不会等它，你管你运行，返回值我不需要所以我继续往下跑，你运行完执行你自己的回调函数就行。用途有点类似于子线程。</li></ul><ol start="2"><li>阻塞与非阻塞意图<br>区分是调用结果返回之前，是否将调用的线程挂起，暂时不理其他请求。</li></ol><h3 id="不同模型的理解"><a href="#不同模型的理解" class="headerlink" title="不同模型的理解"></a>不同模型的理解</h3><p>直接把别人博客的图整理下拿过来了，<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211104120820.png"></p><ol><li>说的是单线程普通情况下，是这么执行的。按顺序一个个，等A有返回值回来了再B，B有返回值回来了再C。</li><li>说的是多线程同步的情况，并行运行，不展开，图简单，但实际交互非常复杂，通道、共享内存啥的。这里提这个是为了体现异步的作用。</li><li>说的是单线程异步执行，看得到ABC这运行，理论上是没有什么执行顺序可言的（项目经验告诉我，实际上这句话不对，但是概念上这么理解就够了，毕竟不可靠），属于是把程序执行顺序直接丢了。看上去事件花销和1的同步一样，那为什么要引入这个概念呢？看4。</li><li>可以看到，其实3还是比同步的情况下省了很多时间，这个waiting可能是方法里人工delay，也可能是在等待磁盘坑长的I/O操作返回结果，所以如果异步，灰色的部分就省下来了。由此也可知，异步唯一存在的阻塞情况，是无方法可执行的时候（ABC都在灰色段等着I/O给结果）。</li></ol><p>以上用于理解概念是够了，但是实际应用会多很多（比如异步有很多方法可以实现，每种方法可控性等不同）。</p><p>搞懂最基本的同步异步之后，开始结合c#的用法，看下怎么用。</p><h1 id="二-Async-and-Await"><a href="#二-Async-and-Await" class="headerlink" title="二.Async and Await"></a>二.Async and Await</h1><p>  一篇不错的文章，虽然是2012年（也就是Async/Await语法糖出来的时候）的还是英文，但是把两者分析的非常透彻。刚好作为实际应用的补充。</p><h3 id="先来介绍一下这两个C-关键字"><a href="#先来介绍一下这两个C-关键字" class="headerlink" title="先来介绍一下这两个C#关键字"></a>先来介绍一下这两个C#关键字</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoSomethingAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// In the Real World, we would actually do something...</span></span><br><span class="line">  <span class="comment">// For this example, we&#x27;re just going to (asynchronously) wait 100ms.</span></span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <font color='red'>async </font>只有2个作用。一是是允许await这个关键字的使用，二是改变了方法结果的处理方式。async在执行开始时，是和同步运行一样的。也就是说在遇到await之前，它是同步的。</p><p>  <font color='red'>await </font>是异步操作的启动器。它会持续监视一个<font color='red'>异步操作 </font>（asynchronous operation）的执行，<br>  如果这个异步操作已经完成了，那他就会继续跑后续代码；<br>  如果这个异步操作未完成，就开始真正的<font color='red'>异步</font>：调用者会将这个async任务暂时挂起，直到await监视的异步操作处理完后，才继续执行后续代码。注意了，这个处理完后的执行，是会根据遇到await之前捕捉下来的<font color='red'>上下文（Context） </font>环境来继续运行。u1s1，这听着很像unity的协程好吧。<br>  通过上面知道了，async方法体里遇到个await、且await后面跟了个需要时间去处理的方法（上面叫异步操作，举个例子比如I/O操作吧），这个时候这个async方法会被阻塞住，但是整个线程并不会被阻塞住，而是在做其他的异步方法了，直到其他方法也卡住。</p><h3 id="Asynchronous-Operation"><a href="#Asynchronous-Operation" class="headerlink" title="Asynchronous Operation"></a>Asynchronous Operation</h3><p>  上面提到的异步操作。从上可知，你只需要提供<font color='red'>异步操作</font>就可以实现一个异步。你可以直接用微软提供支持的Task或者<code>Task&lt;T&gt;</code>，或者将各种方法转换成一个异步操作，或者是Task.Yield会返回不是Tasks的异步操作。<br>  关于异步操作的一个要点是:异步操作，指的不是async关键词修饰的就是异步操作，而是他是一个可以异步操作的类型。换句话说，你可以await一个类型为Task的async method，这是因为方法返回Task，而不是因为它是async的。所以你也可以await一个返回Task的非async方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">NewStuffAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use await and have fun with the new stuff.</span></span><br><span class="line">  <span class="keyword">await</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">MyOldTaskParallelLibraryCode</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 最开始就说的，因为这个方法没有async关键词修饰，所里方法体里不能用await关键词</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ComposeAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// We can await Tasks, regardless of where they come from.</span></span><br><span class="line">  <span class="keyword">await</span> NewStuffAsync();</span><br><span class="line">  <span class="keyword">await</span> MyOldTaskParallelLibraryCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Return-Types"><a href="#Return-Types" class="headerlink" title="Return Types"></a>Return Types</h3><p>  Async方法可以返回<code>Task&lt;T&gt;</code>、Task以及void，但是在大部分情况我们都会选择前两个而不是void，因为<code>Task&lt;T&gt;</code>、Task是可以等待的，而void不行。<br>  那什么时候用void呢？原文是这么说的：</p><blockquote><p>You have to return void when you have async event handlers.</p></blockquote><h3 id="Returning-Values"><a href="#Returning-Values" class="headerlink" title="Returning Values"></a>Returning Values</h3><p>  这个和上面不同，这个是返回值。Task和void一样都没有返回值，但是<code>Task&lt;T&gt;</code>有T类型的返回值。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>  上下文。上面提到过，当await的异步操作结束后，将会根据遇到await之前捕捉下来的上下文环境继续执行代码。上下文是什么？简单来说：</p><ul><li>如果你在一个UI线程上，那么就是个UI Context</li><li>如果你在一个ASP.NET请求上，那么就是个ASP.NET request context</li><li>否则，通常会是一个线程池环境（a thread pool context）。<br>好嘛，听君一席话。那么复杂点说呢？</li><li>如果<font color='red'>SynchronizationContext.Current</font>不是null的，那么SynchronizationContext.Current就是它的上下文（UI、ASP.NET）</li><li>其他情况，就是当前的<font color='red'>TaskScheduler</font><br>这两个名词暂时先不展开了。<br>下面看一个示例。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinForms 例子 (当然wpf也一样).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当这个异步方法DownloadFileAsync在await的时候，UI线程并不会被阻塞。</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASP.NET 例子</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">MyButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await之后，ASP.NET线程并不会因此被阻塞</span></span><br><span class="line">  <span class="comment">// 这使得这个线程仍然可以接受其他的request</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(...);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复ASP.NET Context，然后就可以连接到当前请求了</span></span><br><span class="line">  <span class="comment">// 也许结束那一瞬间，我们在其他的线程上，但是也能拥有同样的ASP.NET Context</span></span><br><span class="line">  Response.Write(<span class="string">&quot;File downloaded!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Avoiding-Context"><a href="#Avoiding-Context" class="headerlink" title="Avoiding Context"></a>Avoiding Context</h3><p>  上下文有个大概的概念了，关键词还是await。那么，有的时候不需要去抓取整个main的上下文，比如下面的例子，一个Task中并不需要UI的上下文。<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadFileAsync</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这一个调用http api的下载任务</span></span><br><span class="line">  <span class="keyword">var</span> fileContents = <span class="keyword">await</span> DownloadFileContentsAsync(fileName).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为上面设置了ConfigureAwait(false),我们不在原来的上下文中</span></span><br><span class="line">  <span class="comment">// 那我们在什么上下文中？在线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将文件数据写入磁盘</span></span><br><span class="line">  <span class="keyword">await</span> WriteToDiskAsync(fileName,fileContents).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WinForms、Wpf例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">DownloadFileButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当我们进入await后，UI线程并没有被这个下载任务所阻塞</span></span><br><span class="line">  <span class="keyword">await</span> DownloadFileAsync(fileNameTextBox.Text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到await结束，才会在这里恢复UI Context，然后就可以连接到UI Elements了。</span></span><br><span class="line">  resultTextBox.Text = <span class="string">&quot;File downloaded!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上述例子还需要注意的是，每个层级的async方法都有自己的上下文。<code>DownloadFileButton_Click</code>方法中是由UI上下文启动的，随后进入<code>DownloadFileAsync</code>也是由UI上下文启动的，但是随着<code>ConfigureAwait(false)</code>的设置，又会跳出UI上下文，转到线程池上下文中继续运行。最后，当<code>DownloadFileAsync</code>方法执行结束回到<code>DownloadFileButton_Click</code>方法后，又会回到UI上下文继续。<br>  所以有一个优化方法就是，设置不需要UI上下文的异步方法<code>ConfigureAwait(false)</code>。</p><h3 id="Async-Composition"><a href="#Async-Composition" class="headerlink" title="Async Composition"></a>Async Composition</h3>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoOperationsConcurrentlyAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Task[] tasks = <span class="keyword">new</span> Task[<span class="number">3</span>];</span><br><span class="line">  tasks[<span class="number">0</span>] = DoOperation0Async();</span><br><span class="line">  tasks[<span class="number">1</span>] = DoOperation1Async();</span><br><span class="line">  tasks[<span class="number">2</span>] = DoOperation2Async();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个时间点，所有任务都在并行执行</span></span><br><span class="line">  <span class="comment">// 我们对所有任务都进行等待</span></span><br><span class="line">  <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetFirstToRespondAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Call two web services; take the first response.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt;[] tasks = <span class="keyword">new</span>[] &#123; WebService1Async(), WebService2Async() &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Await for the first one to respond.</span></span><br><span class="line">  Task&lt;<span class="built_in">int</span>&gt; firstTask = <span class="keyword">await</span> Task.WhenAny(tasks);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the result.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> firstTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-非常重要，暂停一下"><a href="#三-非常重要，暂停一下" class="headerlink" title="三.非常重要，暂停一下"></a>三.非常重要，暂停一下</h1><p>  从上可知，异步和同步大概是什么了。根据上两篇去理解，异步就是为了去解决I/O阻塞画面线程问题而推出的技术，而在C#里就是<code>async await Task</code>这三个关键词组合去实现的。执行起来是你做A遇到了子任务B，结果子任务B里有I/O卡壳了，你就立刻回头去做A剩下的直到B结束了会做B这样，看上去就是主线程自己的事。那么实际上呢？直接实践一下：<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Chinese Output</span></span><br><span class="line">Console.OutputEncoding = Encoding.GetEncoding(<span class="number">936</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;头部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">CallerWithAsync(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;尾部已执行，当前主线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> Test Wait</span></span><br><span class="line">Console.Read();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallerWithAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;异步调用头部执行，当前线程Id为：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> result = <span class="keyword">await</span> SayHiAsync(name);</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">SayHiAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点1，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;测试断点2，此刻线程为: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">$&quot;Hello,<span class="subst">&#123;name&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211109113849.png"></p><p>  可以看到“测试断点2，此刻线程为: 4”，并不是主线程1，所以说C#的异步实践并不是和第一篇里说的一样，并不是在一个线程上解决的！！！当然还有很多其他方法，这个就不拓展了，只讨论最常用最简洁的实践方案。<br>  原因是什么呢？最直接地说，是因为第一篇的文章是基于单线程的最简单情况去理解同步与异步的，而C#实现不是，毕竟考虑到性能后的实现是很复杂的。而且，你要把一个任务挂起等执行完毕，那总得有线程去处理它对吧。<br>  为了明白这是什么意思，需要理解一下多线程与异步之间的关系。<br>  异步同步，其实和多线程还是单线程并不是一个维度的概念。我的理解是异步是一种程序运行的优化机制、是运行过程最终目的，而多线程还是单线程是一种可供你选择的条件，你可以单线程异步也可以多线程异步。</p><p>  传统异步（第一篇里诉说的）：遇到await时，将目前线程挂起，去做其他的事，不停调度。<br>  实际上基于多线程的异步编程（C#异步实现方法之一）：<font color='red'>遇到<code>Task.Run()</code>的多开线程指令或者真正需要异步挂起某任务时</font>，会从线程池取一个新线程（如果不够用就开新的），然后把这个线程拿来处理挂起的任务，主线程则是返回到方法体外去执行剩下的代码。<font color='red'>注意了，新开线程（也就是真正开始异步）的情况，并不是遇到await那一刻，就像图中的log那样，直到断点1都还是同步的，但是Task.Delay就会开始真正的异步。</font><br>  总结：C#中的异步可以简单的用async 和 await 配合来实现，使用异步的函数，在没有调用await前，还是按顺序单线程执行的，当运行到await的时候，系统才会异步调用其他的方法来运行，如果没有await, 函数就是同步按顺序的运行。所以，await才是异步中的关键部分，在await 范围内的代码，是多线程方式运行的（当然没有Task就不会取线程），可以将需要异步处理的代码放在await中运行，或者简单的用一个Task.Delay来延时，以达到异步切换代码运行的效果。await 后面接的是一个Task, 每一个Task在运行时，由系统的Task池来分配，以实现异步的功能。<br>这里再来说说用aysnc和直接用thread的区别，其实简单来讲，就是效率的问题，async用的线程池，在await中运行的代码是由线程池分配的线程，根据系统的任务，自动分配和释放，而用 new thread的方法，通常是需要手动控制的。很显然，在处理一些短时间，且对运行的时间性和稳定性不是特别严格的问题时，用async会很有优势，但是对于一些在后台需要长时间稳定运行的程序，用thread会更好，可以保证它在运行的过程中，不过有别的代码来插队。</p><h1 id="四-I-O操作时，没有线程在执行"><a href="#四-I-O操作时，没有线程在执行" class="headerlink" title="四.I/O操作时，没有线程在执行"></a>四.I/O操作时，没有线程在执行</h1><p>  <a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">There is no thread</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">微软Docs：异步编程</a> ，两篇文章大意是，当遇到await进行I/O操作时，因为现在的磁盘很牛逼，支持Direct Memory Access (DMA)操作，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。所以程序遇到I/O异步时，只是从线程池里拿了个线程，进行一次CPU操作命令之后这个线程就没事了，他不负责执行I/O、也不实时监视I/O的运行情况、更不会被阻塞。它理论来说直接送回线程池了，然后可以去处理其他操作，此时硬件自己和内存交换数据。I/O完成之后，硬件会触发一个中断来通知操作完成。</p><p>  以下来自微软官方文档：</p><blockquote><p>调用系统 API 后，请求位于内核空间，一路来到操作系统的网络子系统（例如 Linux 内核中的 <code>/net</code>）。 此处操作系统将对网络请求进行异步 处理。 所用操作系统不同，细节可能有所不同（可能会将设备驱动程序调用安排为发送回运行时的信号，或者会执行设备驱动程序调用然后 有一个信号发送回来），但最终都会通知运行时网络请求正在进行中。 此时，设备驱动程序工作处于已计划、正在进行或是已完成（请求已“通过网络”发出），但由于这些均为异步进行，设备驱动程序可立即着手处理其他事项！</p><p>例如，在 Windows 中操作系统线程调用网络设备驱动程序并要求它通过表示操作的中断请求数据包 (IRP) 执行网络操作。 设备驱动程序接收 IRP，调用网络，将 IRP 标记为“待定”，并返回到操作系统。 由于现在操作系统线程了解到 IRP 为“待定”，因此无需再为此作业进行进一步操作，将其“返回”，这样它就可用于完成其他工作。</p><p>请求完成且数据通过设备驱动程序返回后，会经由中断通知 CPU 新接收到的数据。 处理中断的方式因操作系统不同而有所不同，但最终都会通过操作系统将数据传递到系统互操作调用（例如，Linux 中的中断处理程序将安排 IRQ 的下半部分通过操作系统异步向上传递数据）。 这也是异步发生的！ 在下一个可用线程能执行异步方法且“解包”已完成任务的结果前，结果会排入队列。</p></blockquote><h1 id="五-思考"><a href="#五-思考" class="headerlink" title="五.思考"></a>五.思考</h1><p>  看了十几篇文章之后，对异步稍微是理解进了一小步。在此留下我的最简短理解：<br><font color='red'>  异步，就是为了让单个线程不会因为某个长时间I/O操作而卡死自己，从而达到压榨线程剩余价值的目的。（特别是UI主线程对于客户端来说的剩余价值特别大）</font></p><p>  关于应用上，整理了一下工作会用到的：</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>  当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。<br>  而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。工作中用到过的：</p><p> <code>大数据量Collection.AsParallel.ForEach(Task.Run(你的任务))</code>　　</p><h3 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h3><table><thead><tr><th>使用以下方式…</th><th>而不是…</th><th>若要执行此操作…</th></tr></thead><tbody><tr><td>await</td><td>Task.Wait 或 Task.Result</td><td>检索后台任务的结果</td></tr><tr><td>await Task.WhenAny</td><td>Task.WaitAny</td><td>等待任何任务完成</td></tr><tr><td>await Task.WhenAll</td><td>Task.WaitAll</td><td>等待所有任务完成</td></tr><tr><td>await Task.Delay</td><td>Thread.Sleep</td><td>等待一段时间</td></tr></tbody></table><p>补充：</p><p>再深入的话，可能要自己尝试实现一下线程池+异步I/O。以后再补吧。</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</a></p><p>ref:</p><p><a href="https://blog.csdn.net/qq_36936155/article/details/78991050">https://blog.csdn.net/qq_36936155/article/details/78991050</a></p><p><a href="https://blog.stephencleary.com/2012/02/async-and-await.html">https://blog.stephencleary.com/2012/02/async-and-await.html</a></p><p><a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">https://blog.stephencleary.com/2013/11/there-is-no-thread.html</a></p><p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">https://docs.microsoft.com/zh-cn/dotnet/csharp/async</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth">https://docs.microsoft.com/zh-cn/dotnet/standard/async-in-depth</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零-为什么我会理解错&quot;&gt;&lt;a href=&quot;#零-为什么我会理解错&quot; class=&quot;headerlink&quot; title=&quot;零.为什么我会理解错&quot;&gt;&lt;/a&gt;零.为什么我会理解错&lt;/h1&gt;&lt;p&gt;在看完clr之前，我曾对异步同步探究看了十几篇文章，但很可惜，没有完全理解，</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - Mono篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/mono/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/mono/</id>
    <published>2022-03-18T13:18:05.697Z</published>
    <updated>2022-03-18T13:18:05.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IL是什么？"><a href="#IL是什么？" class="headerlink" title="IL是什么？"></a>IL是什么？</h1><p>IL的全称是 Intermediate Language，是一种中间语言。它是一种属于通用语言架构和.NET框架的低阶（lowest-level）的人类可读的编程语言。目标为.NET框架的语言被编译成IL代码，然后汇编成字节码。</p><p>具体过程是：C#或者VB这样遵循CLI规范的高级语言，被先被各自的编译器编译成中间语言IL。等到需要真正执行的时候，这些IL会被加载到运行时库，也就是CLR中，由CLR动态编译（JIT）成汇编代码然后在执行。</p><h1 id="JIT是什么？"><a href="#JIT是什么？" class="headerlink" title="JIT是什么？"></a>JIT是什么？</h1><p>just-in-time compiler，即时编译器。它将IL翻译成汇编语言，它自身会对运行环境做出许多假定，从而进行自己的优化方案。</p><p>比如第一次调用一个方法时，JIT会把遇到的IL代码进行验证+编译，最后放进内存中。方法仅在首次调用时才会有一些性能损失，以后对该方法的所有调用都以本机代码的形式全速运行。</p><h1 id="Mono是什么？"><a href="#Mono是什么？" class="headerlink" title="Mono是什么？"></a>Mono是什么？</h1><p>是支持.net跨平台的一种方式。因为.net本身不支持跨平台只能运行在Windows上，所以需要一个<strong>跨平台的第三方.net库，这就是Mono</strong>。</p><p>mono作为一个中间层将IL代码的处理分出好多个分支，分别对应不同的平台。Mono其实和.net framework 是同一个东西，只不过Mono支持更多的平台，但.net的运行效率更高。<br>Unity打包时会将mono一同打包进来，同时Unity将脚本编译为IL代码打包，这样只要是Mono支持的平台，都可以在Mono中编译成平台本地代码。</p><h1 id="IL2CPP是什么？"><a href="#IL2CPP是什么？" class="headerlink" title="IL2CPP是什么？"></a>IL2CPP是什么？</h1><p>把IL中间语言转换成CPP文件。</p><p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p><p>但是GC还是C#方式来处理。</p><h1 id="为什么有了Mono还需要IL2CPP？"><a href="#为什么有了Mono还需要IL2CPP？" class="headerlink" title="为什么有了Mono还需要IL2CPP？"></a>为什么有了Mono还需要IL2CPP？</h1><p>主要是2点。</p><p>1.Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成。Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，非常耗时耗力。</p><p>2.根据官方的实验数据，Mono换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p><h1 id="工作中怎么涉及到Mono呢"><a href="#工作中怎么涉及到Mono呢" class="headerlink" title="工作中怎么涉及到Mono呢"></a>工作中怎么涉及到Mono呢</h1><p>可以在Unity工程打包得选项中，选择是用Mono还是IL2CPP方式输出。</p><p>IL2CPP能把IL中间码转为C++代码，然后交给各平台的C++编译器处理，有自己的代码裁剪规则。是一种目前效率更高的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IL是什么？&quot;&gt;&lt;a href=&quot;#IL是什么？&quot; class=&quot;headerlink&quot; title=&quot;IL是什么？&quot;&gt;&lt;/a&gt;IL是什么？&lt;/h1&gt;&lt;p&gt;IL的全称是 Intermediate Language，是一种中间语言。它是一种属于通用语言架构和.NET</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 反射篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/reflection/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/reflection/</id>
    <published>2022-03-18T13:18:05.697Z</published>
    <updated>2022-03-18T13:18:05.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射提供了封装程序集、模块和类型的对象（Type 类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性。如果代码中使用了属性，可以利用反射对它们进行访问。</p><p>Assembly类可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并创建该类型的实例。</p><p>Type类可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性等等，通过Type类可以得到这些要素的信息，并且调用之。</p><p>MethodInfo包含方法的信息，通过这个类可以得到方法的名称、参数、返回值等，并且可以调用之。</p><p>反射：反射提供了封装程序集，模块和类型对象，可以用反射动态地创建类型的实例，将类型绑定到现有对象，或者从现有对象类型里获取类型，然后调用类型的方法或访问字段和属性。</p><p>序列化：将对象转换为另一种媒介传输的格式过程。如，序列化一个对象，用Http通过internet在客户端和服务器之间传递该对象，在另一端用反序列化从该流中重新得到对象。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;p&gt;反射提供了封装程序集、模块和类型的对象（Type 类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 委托与事件篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/delegate/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/delegate/</id>
    <published>2022-03-18T13:18:05.696Z</published>
    <updated>2022-03-18T13:18:05.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="委托和事件的区别是什么？"><a href="#委托和事件的区别是什么？" class="headerlink" title="委托和事件的区别是什么？"></a>委托和事件的区别是什么？</h1><p>委托本质是一个继承自System.MulticastDelegate的类；而事件是一个类型成员，是对委托的封装，就和属性是对字段的封装一样。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>通过event关键词来定义。是对委托的封装。</p><h2 id="为什么封装？"><a href="#为什么封装？" class="headerlink" title="为什么封装？"></a>为什么封装？</h2><p>为了让委托链的意义，从一个方法执行队列变成一个可订阅、可通知（触发）的中介。</p><h2 id="怎么封装的？"><a href="#怎么封装的？" class="headerlink" title="怎么封装的？"></a>怎么封装的？</h2><p>随便在类内定义一个public事件，再查看IL代码多帮我们做了什么：</p><p>1.生成一个私有的委托字段（没错还是委托链实现的）</p><p>2.生成add和remove方法，内部处理是对生成的委托字段进行Delegate.Combine、Delegate.Remove。</p><h2 id="怎么设计？"><a href="#怎么设计？" class="headerlink" title="怎么设计？"></a>怎么设计？</h2><p>举个例子的话，WPF的画面交互事件用的EventHandler其实就是一个sender加一个args参数，自定义可以如下的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params">EventSender sender,MyEventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托本质是一个继承自System.MulticastDelegate的类，所以像类一样使用即可。</p><h2 id="新建一个委托发生了什么？"><a href="#新建一个委托发生了什么？" class="headerlink" title="新建一个委托发生了什么？"></a>新建一个委托发生了什么？</h2><p>当你写delegate的时候，编译器就视为你继承了System.MulticastDelegate类，且生成以下几个字段：</p><p>1.构造器</p><p><strong>它获取2个参数：一个是对象引用，另一个是引用了回调方法的整数</strong>。类似于<code>public MyDelegate(Object @object, IntPtr method)</code>。但是我们new的时候，不需要这么复杂的参数，直接<code>new MyDelegate(MyMethod)</code>就可以了，编译器会分析。</p><p>最后这2个参数会作为MulticastDelegate的2个重要字段！</p><p>2.Invoke方法</p><p>用于调用。<code>myDelegate(1);</code>其实编译器内部就会变成<code>myDelegate.Invoke(1);</code></p><p>3.BeginInvoke、EndInvoke方法</p><p>用于异步回调。</p><h2 id="MulticastDelegate类是什么？"><a href="#MulticastDelegate类是什么？" class="headerlink" title="MulticastDelegate类是什么？"></a>MulticastDelegate类是什么？</h2><p>又称多播委托，是所有委托的父类。</p><p>它的内部有3个重要字段和1个内部机制来实现委托链。</p><h3 id="3个重要字段"><a href="#3个重要字段" class="headerlink" title="3个重要字段"></a>3个重要字段</h3><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_target</td><td>System.Object</td><td>这个字段引用的是回调方法要操作的对象。当委托对象包装静态方法时，这个字段返回null；当委托对象包装实例方法时，这个字段引用回调方法要操作的对象。在委托构造器中将对象引用作为参数获取、赋值给_target。</td></tr><tr><td>_methodPtr</td><td>System.IntPtr</td><td>一个内部的整数值，CLR用它标识要回调的方法。在委托构造器中将回调方法IntPtr作为参数获取、赋值给_methodPtr。</td></tr><tr><td>_invocationList</td><td>System.Object</td><td>只有单个委托时为null。构造委托链时它引用一个委托数组。</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211210173655.png"></p><h3 id="1个机制"><a href="#1个机制" class="headerlink" title="1个机制"></a>1个机制</h3><p>从外部新建一个委托的整个生命流程来理解：</p><p>1.申明一个委托实例fbChain，为null。</p><p>2.对其进行 += 操作（Delegate.Combine语法糖），Combine方法内部发现fbChain是null，所以直接返回一个_invocationList为null的委托。</p><p>3.对其再进行 += 操作，Combine方法内部发现fbChain内部已经包含了一个委托,就会构造一个新的委托对象，这个新委托对象的_invocationList字段引用了一个委托对象数组，里面按顺序包含着之前的所有委托。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211213095622.png"></p><p>4.对委托实例fbChain进行调用，实际就是对整个委托链传入参数，依次遍历进行Invoke。</p><p>5.对委托实例fbChain进行 -= 操作（Delegate.Remove语法糖），Remove方法内部倒序循环遍历_invocationList数组，匹配_target和_methodPtr字段相同的元素进行删除，只删除一个元素。</p><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p><strong>Action和Func</strong></p><p>微软定义好的泛型委托就是Action和Func，Action有16个Func有17个。为啥Action少一个？看下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span>;<span class="comment">// 这个不是泛型，所以不算，少在这了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">TResult</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">TResult</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">// 1个参数的</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="title">T1</span>, ..., <span class="title">T16</span>, <span class="title">TResult</span>&gt;(<span class="params">T1 arg1, ..., T16 arg16</span>)</span>;<span class="comment">// 最多16个参数的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;委托和事件的区别是什么？&quot;&gt;&lt;a href=&quot;#委托和事件的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;委托和事件的区别是什么？&quot;&gt;&lt;/a&gt;委托和事件的区别是什么？&lt;/h1&gt;&lt;p&gt;委托本质是一个继承自System.MulticastDele</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 常用数据结构篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/arrary_list_dic/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/arrary_list_dic/</id>
    <published>2022-03-18T13:18:05.695Z</published>
    <updated>2022-03-18T13:18:05.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>最基本的数组类型。</p><h2 id="真实类型"><a href="#真实类型" class="headerlink" title="真实类型"></a>真实类型</h2><p>所有数组类型都隐式从<strong>System.Array抽象类</strong>派生，System.Array又从Object派生，所以数组都是<strong>引用类型</strong>。Array实现了IEnumerable、ICollection、IList接口。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>在内存中是连续存储的，所以它的索引速度非常快。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在new的时候，就必须指定它的Length大小。</p><p>数组单个元素的类型：</p><p>如果是值类型比如Int32，就会在托管堆上分配100个未装箱Int32所需的内存块，并给每个Int32实例都附上default值0；<br>如果是引用类型比如Control，就会在托管堆上分配50个Control引用的内存块，并给每个引用都附上null。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>无法动态扩容，只能手动调用接口<code>Array.Resize (ref T[] array, int newSize)</code>。</p><p>内部创建新数组，使用<code>Array.Copy</code>将原数组拷贝到新数组中，再修改传入指针指向新数组。如果新Length还不如原数组Length大，会采用新Length，多的直接截断不要了。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>接口<code>Array.Find (T[] array, Predicate&lt;T&gt; match)</code>。传进去的match是一个签名为“参数为T返回值为bool”的委托，也就是一个比较器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; array.Length; ++index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (match(array[index])) <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话很麻烦，还不如自己遍历。</p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>在数组的基础上加入了动态扩容的概念，因此插入数据更方便了。</p><h2 id="真实类型-1"><a href="#真实类型-1" class="headerlink" title="真实类型"></a>真实类型</h2><p>实现了接口 IList、ICollection、IEnumerable、ICloneable。</p><p>而<strong>内部的数据其实还是用一个object[ ]来装</strong>，字段名是items。没错可以理解ArrayList为对Array的包装。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>虽然比数组多了很多快捷操作接口，但是内部用object[ ]，这导致会频繁发生拆装箱、且类型非常不安全导致你可以塞各种类型到一个ArrayList里。</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>在<code>new ArrayList()</code>中可以指定容量大小，也可以不指定。</p><p>如果不指定，那就将内部items数组设置为<code>ArrayList.emptyArray</code>，一个定义好的定数，实际就是 <code>new object[0]</code>。</p><p>如果指定，那就是<code>new object[capacity]</code>。</p><h2 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h2><p>引入动态扩容，调用接口<code>ArrayList.Add (object val)</code>即可。</p><p>先说结论，如果容量为0则设置为4，否则一旦触发扩容就翻倍，也就是<strong>二倍扩容</strong>。扩容方式就是新建数组替换items。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnsureCapacity</span>(<span class="params"><span class="built_in">int</span> min</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._items.Length &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">int</span> num = <span class="keyword">this</span>._items.Length == <span class="number">0</span> ? <span class="number">4</span> : <span class="keyword">this</span>._items.Length * <span class="number">2</span>; <span class="comment">// num起始值为4，后续只会2倍2倍扩容，因此永远是2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">uint</span>) num &gt; <span class="number">2146435071U</span>)</span><br><span class="line">        num = <span class="number">2146435071</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; min)</span><br><span class="line">        num = min;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.Capacity = num; <span class="comment">// 扩容代码写在 属性Capacity 的set里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Capacity&#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="comment">// 只看核心部分，防错的if判断都被我删了</span></span><br><span class="line">        <span class="built_in">object</span>[] objArray = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="keyword">value</span>];</span><br><span class="line">        Array.Copy((Array) <span class="keyword">this</span>._items, <span class="number">0</span>, (Array) objArray, <span class="number">0</span>, <span class="keyword">this</span>._size);</span><br><span class="line">        <span class="keyword">this</span>._items = objArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>接口<code>ArrayList.Insert (int index, object val)</code></p><p>也就是判断一下 size+1 是否触发动态扩容，然后把index之后的数组值用<code>Array.Copy</code>拷贝到index+1起始位置，然后更新数组index的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.Copy((Array) <span class="keyword">this</span>._items, index, (Array) <span class="keyword">this</span>._items, index + <span class="number">1</span>, <span class="keyword">this</span>._size - index);</span><br><span class="line"><span class="keyword">this</span>._items[index] = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>接口<code>ArrayList.IndexOf (object value)</code></p><p>全遍历。内部for循环遍历，通过<code>obj.Equals(value)</code>比对罢了。</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>接口<code>ArrayList.Remove (object obj)</code></p><p>先用<code>ArrayList.IndexOf</code>查找到index，然后调用<code>ArrayList.RemoveAt</code>。</p><p>RemoveAt内部用了<code>Array.Copy</code>，把 index+1 之后的数组值拷贝到index起始位置，那么原来位于index的值就没了，且数组最后一位会是一个废数据，给它赋null。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.Copy((Array) <span class="keyword">this</span>._items, index + <span class="number">1</span>, (Array) <span class="keyword">this</span>._items, index, <span class="keyword">this</span>._size - index);</span><br><span class="line"><span class="keyword">this</span>._items[<span class="keyword">this</span>._size] = (<span class="built_in">object</span>) <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>在ArrayList的基础上，加入了泛型的概念。类型是<code>List&lt;T&gt;</code>，又叫泛型List。</p><h2 id="真实类型-2"><a href="#真实类型-2" class="headerlink" title="真实类型"></a>真实类型</h2><p>实现接口：IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>。</p><p><strong>内部维持的是一个泛型数组</strong>，<code>T[] _items;</code>。</p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>使用泛型，完美解决了ArrayList的拆装箱问题。</p><h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><p>和ArrayList一样，可以指定可以不指定，不指定就给item赋值<code>new T[0]</code>。</p><h2 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h2><p>和ArrayList一摸一样的<strong>初始为4，后续二倍扩容</strong>。</p><h2 id="插入、查找、移除"><a href="#插入、查找、移除" class="headerlink" title="插入、查找、移除"></a>插入、查找、移除</h2><p>没啥好看的，和前面一样，没有优化。</p><p>接口<code>public T Find (Predicate&lt;T&gt; match)</code>就是传入bool比较器，和Array的一样。接口<code>IndexOf</code>也是直接调用了Array自己的IndexOf，找不到就返回-1。</p><h2 id="linq"><a href="#linq" class="headerlink" title="linq"></a>linq</h2><p>linq拓展方法接口<code>FirstOrDefault</code>内部利用迭代器foreach遍历+bool比较器。</p><p>linq拓展方法接口<code>Where</code>内部利用迭代器，返回一个新的List指针（浅拷贝）。</p><h1 id="散列表、哈希"><a href="#散列表、哈希" class="headerlink" title="散列表、哈希"></a>散列表、哈希</h1><p>在看哈希表、字典这两个类型前，必须掌握的基础数据结构。</p><h2 id="在看之前"><a href="#在看之前" class="headerlink" title="在看之前"></a>在看之前</h2><p>在.Net  模仿java 的过程中   抛弃了 HashMap ，所以以后再去面试.Net的时候当别人问你HashTable 和HashMap 的区别的时候，请告诉他，C#.Net 中  没有HashMap。同时C#中也没有Java中的TreeMap和TreeSet（即底层是由红黑树实现的数据结构）。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数是<strong>单向映射</strong>，因为一个Key只可以映射出一个hashCode，但是一个hashCode却可以被多个Key映射到。</p><p>1、直接寻址法：取keyword或者keyword的某个线性函数值为散列地址，即H(key)=key或者H(key)=a·key+b，当中a和b为常数（这样的散列函数叫做自身函数）。这个的应用就是，比如我们世界地图的掩码，直接用坐标x*1000+坐标y，得到key。</p><p>2、数字分析法：找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。分析一组数据，比方一组员工的出生年月日，这时，我们发现出生年月日的前几位数字大体相同，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构造散列地址，则冲突几率就会明显减少。</p><p>3、平方取中法：取keyword平方后的中间几位作为散列地址。</p><p>4、折叠法：将keyword切割成位数同样的几部分，最后一部分分数能够不同，然后取这及部分的叠加和（去除进位）作为散列地址。</p><p>5、随机数法：选择一随机函数，取keyword的随机值作为散列地址，通常适用于keyword长度不同的场合。</p><p>6、除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即H(key)=key MOP p , p&lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算后取模，对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞。</p><h2 id="C-散列表"><a href="#C-散列表" class="headerlink" title="C#散列表"></a>C#散列表</h2><p>建立一个确定的对应关系，使得每个key值都和一个地址一一对应。</p><ul><li>  存储记录时，通过 散列函数+key值 计算记录的散列地址，并用该地址存储记录。</li><li>  查找记录时，通过同样的 散列函数+key值 计算记录的散列地址，并访问该记录。</li></ul><p>上述的只是完美散列表，理论存在。但是 .NET 的 <em>GetHashCode</em> 方法返回的是Int32，也就是一一对应就只能有最多2^32个key值。但实际肯定不止这么点情况（比如key你可以用Int64），那么会出现问题：多个key值通过算法映射出来的HashCode是相同的，这叫做<strong>哈希冲突</strong>。</p><p>如何解决、减少哈希冲突就成了性能瓶颈。</p><h2 id="C-解决哈希冲突"><a href="#C-解决哈希冲突" class="headerlink" title="C#解决哈希冲突"></a>C#解决哈希冲突</h2><p><strong>Hashtable</strong>：开放定址法（尝试的第一个单元被占了，那么就尝试下一个空单元）。</p><p><strong>Dictionary</strong>：拉链法/链地址法（将所有key取哈希码相同的记录存储在同一线性链表）。</p><p>其他：再哈希法（冲突后再用其他哈希函数哈希，直到不冲突）…</p><h2 id="为什么哈希表长要取质数？"><a href="#为什么哈希表长要取质数？" class="headerlink" title="为什么哈希表长要取质数？"></a>为什么哈希表长要取质数？</h2><p>.net解决哈希冲突：扩容、取质数（质数也叫素数）。</p><p>扩容部分在下面哈希表里再阐述，有一个词叫因子。</p><p><strong>那为什么哈希表长要取质数？</strong>因为表长也就是容量是拿来求模的，如果和被取模的数有公因子，会导致同模的数（也就是冲突的数）之间有更多规律（存在公因子），而现实中我们的 数据源、哈希函数 往往就是有一定的关系比如取长运算就是存在公因子2。那么结果就是，冲突很可能更频繁，当然并不是一定的具体得看你的数据源和哈希函数实现。</p><p>举例：</p><p>默认长度设置为6，则2的倍数（这里不提6自己的倍数毕竟质数也一样）的整数将固定散列在0、2、4这几个数内；3的倍数将固定散布在0、3、6这几个数内。 此时，GetHashCode你可能写成取一系列运算之后*2，那么结果是2、4、6、8、10、12…这样的数，他们取模后分别是2、4、0、2、4、0…，这种 GetHashCode + 表长 实现下的哈希散列表，冲突的概率就非常之大。而换成7这样的质数，取模后是2、4、6、1、3、5…有改进了对吧？</p><h2 id="自己避免哈希冲突"><a href="#自己避免哈希冲突" class="headerlink" title="自己避免哈希冲突"></a>自己避免哈希冲突</h2><p>开发者自己想避免哈希冲突，在.net里就是设计更好的散列表也就是设计更好的GetHashCode，使映射出来的int32值尽可能不重合。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>这里只指.net提供的Hashtable类型。又称哈希表、散列表。机制关键字是<strong>2倍质数扩容、装填因子确定装载数、双重散列法（属于开放定址法）</strong>这3个要点。</p><p><a href="https://blog.csdn.net/exiaojiu/article/details/51206024">https://blog.csdn.net/exiaojiu/article/details/51206024</a></p><p><a href="https://www.cnblogs.com/millionsmultiplication/p/9409290.html">https://www.cnblogs.com/millionsmultiplication/p/9409290.html</a></p><h2 id="真实类型-3"><a href="#真实类型-3" class="headerlink" title="真实类型"></a>真实类型</h2><p>内部数据是<strong>哈希桶</strong>，key-value对均为<strong>object类型</strong>，还有一个hash_coll是<strong>哈希码</strong>。</p><p>数据存在数组buckets里。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Hashtable.bucket[] buckets;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> bucket</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> val;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hash_coll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><p>使用双重散列法，查找内存的时间复杂度为<strong>常数级</strong>。key-val类型是object，因此类型并不安全。</p><h2 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h2><p>装填因子（loadFactor）是 装载数/哈希表长。<strong>它决定了装载数。</strong>值越小，表长越大也就是内存损耗更大，但是哈希冲突更少。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.loadsize = (<span class="built_in">int</span>) ((<span class="built_in">double</span>) <span class="keyword">this</span>.loadFactor * (<span class="built_in">double</span>) newsize); <span class="comment">// 装载数 是被 装填因子 所控制的。newsize是由buckets.Length取得的质数。</span></span><br></pre></td></tr></table></figure><p>加载因子是用户可以控制的，范围是0.1f ~ 1，默认是1。在Hashtable的构造函数中可以输入。</p><p>装填因子默认取0.72，是微软认为的最佳性能默认值。</p><p>最后，装填因子 = 加载因子*装填因子的范围是0.072 ~ 0.72，默认是0.72。</p><h2 id="装载数"><a href="#装载数" class="headerlink" title="装载数"></a>装载数</h2><p>装载数loadsize，装载数比桶数小。</p><p>当装满的桶数count超过装载数时会发生扩容，扩容后装载数随之更新（具体看“插入”）。</p><p>更新公式：loadsize = 装填因子 * 桶数bullets.Length（质数）</p><h2 id="双重散列法⭐"><a href="#双重散列法⭐" class="headerlink" title="双重散列法⭐"></a>双重散列法⭐</h2><p>双重散列法是开放地址法中最好的方法之一。</p><p>简单说就是有2个哈希函数，第一个哈希函数算出key的直接映射值(seed)，第二个哈希函数算出冲突时使用的增量(incr)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">uint</span> <span class="title">InitHash</span>(<span class="params">Object key, <span class="built_in">int</span> hashsize, <span class="keyword">out</span> <span class="built_in">uint</span> seed, <span class="keyword">out</span> <span class="built_in">uint</span> incr</span>)</span> &#123;      </span><br><span class="line">    <span class="built_in">uint</span> hashcode = (<span class="built_in">uint</span>) GetHash(key) &amp; <span class="number">0x7FFFFFFF</span>;<span class="comment">//取整数</span></span><br><span class="line">    seed = (<span class="built_in">uint</span>) hashcode;</span><br><span class="line">    </span><br><span class="line">    incr = (<span class="built_in">uint</span>)(<span class="number">1</span> + ((seed * HashPrime) % ((<span class="built_in">uint</span>)hashsize - <span class="number">1</span>))); <span class="comment">// HashPrime是101定数，暂不知道数学意义</span></span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取好了2个seed、incr两个数据之后，<strong>第一次会去找 bucketNumber = seed % buckets.Length 的值</strong>，如果冲突再找 bucketNumber + incr) % buckets.Length的值，直到匹配。</p><p>注意！注意！注意！上面说的 bucketNumber = seed % buckets.Length ，这很重要，这是哈希桶映射的核心，毕竟算出来的hashCode比buckets.Length（桶数）大太常见了，所以需要取模。<strong>这意味着扩容后， buckets.Length发生改变，buckets内部全体都需要重新排列。</strong></p><h2 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h2><p>可以输入加载因子和容量，默认的加载因子是1。</p><p>初始化时，**loadFactor = 0.72f * 加载因子(0.1f ~ 1)**。容量则最小为3（最小质数）。</p><h2 id="扩容-3"><a href="#扩容-3" class="headerlink" title="扩容"></a>扩容</h2><p>首先将冲突数occupancy归零，创建新bullets，然后开始拷贝旧数据。</p><p>1.创建新bullets。那它的数组长度（桶数）怎么确定？</p><p>​    如果是常规扩容（不是因为冲突数超过了预装载量），就会去质数表里找一个最小的、大于等于 bullets长度 * 2 的质数作为新的bullets长度。质数表：HashHelpers里的一个枚举数组，是个并不连续的质数表，从3开始一共有72个。</p><p>​    如果是冲突扩容（冲突数超过了预装载量），就按照目前bullets长度进行拷贝旧数据操作。所以实际并没有扩容，只做了拷贝旧数据操作，应该是因为冲突太多希望重新排列一次数据。</p><p>2.拷贝旧数据。并不是简单的复制粘贴，而是<strong>遍历buckets数组、利用putEntry重新添加元素</strong>。putEntry是Hashtable的内部插值方法，仍然是双重散列法插。为什么不直接复制粘贴？很简单，因为buckets.Length（桶数）变了，那么所有的<code>hashCode % buckets.Length</code>的下标位置都得变。</p><p>大规模的putEntry终究是高时耗的，所以新建hashtable时最好选择一个稍大的容量，避免重复扩容。</p><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>Insert的内部操作分三个步骤：</p><p>1.判断key是否为空，如果空，哈希函数是无法计算地址的。</p><p>2.判断<strong>bullets实际使用条目数count（装满的桶数） 是否大于等于装载数</strong>，如果满足，哈希表需要扩容为原来装载数的2倍以上（从质数表里取）；如果前一条不满足，则继续判断<strong>冲突数是否大于装载数</strong>，如果大于，则扩容。</p><p>3.接着在循环体内按照双重散列法寻找对应键值的桶并为对应键值的桶赋值。</p><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><p>就是双重散列法。</p><h2 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h2><p>核心就是按照双重散列法寻找对应键值的桶后将桶变成空桶，然后count–（实际桶数）。</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p><code>Dictionary&lt;TKey, TValue&gt;</code>泛型字典，解决Hashtable拆装箱。机制关键字是<strong>buckets+entries双数组、拉链法基础上改进、FreeList单链表</strong>这3个要点。</p><p><a href="https://www.cnblogs.com/xiaomowang/">https://www.cnblogs.com/xiaomowang/</a></p><h2 id="真实类型-4"><a href="#真实类型-4" class="headerlink" title="真实类型"></a>真实类型</h2><p>这里哈希桶主要用来进行Hash碰撞（和Hashtable类不一样），Entry数组用来存储字典的内容，并且标识下一个元素的位置。</p><p>Entry数组是一个单链表。</p><p>KeyCollection、ValueCollection内部真实数据就是这个字典本身。然后KeyCollection和ValueCollection实现了一些常用接口，比如GetEnumerator返回的时候帮你把字典的迭代返回类型<code>KeyValuePair&lt;TKey, TValue&gt;</code>转换成<code>TKey / TValue</code>了再返回。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] buckets; <span class="comment">// Hash桶，桶的下标是hashCode，桶内的int值是entries单链表的链下标</span></span><br><span class="line"><span class="keyword">private</span> Entry[] entries; <span class="comment">// Entry数组，存放元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> count; <span class="comment">// 当前entries的index位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> version; <span class="comment">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeList; <span class="comment">// 被删除Entry在entries中的下标index，这个位置是空闲的</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeCount; <span class="comment">// 有多少个被删除的Entry，有多少个空闲的位置</span></span><br><span class="line"><span class="keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer; <span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> KeyCollection keys; <span class="comment">// 存放Key的集合，内部用 Dictionary&lt;TKey, TValue&gt; dictionary</span></span><br><span class="line"><span class="keyword">private</span> ValueCollection values; <span class="comment">// 存放Value的集合，内部用 Dictionary&lt;TKey, TValue&gt; dictionary</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> Entry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hashCode;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> next; <span class="comment">// 证明entries是一个单链表！这样使得哈希冲突得以解决！</span></span><br><span class="line">    <span class="keyword">public</span> TKey key;</span><br><span class="line">    <span class="keyword">public</span> TValue <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><p>字典和哈希表不一样！它内部可不是用双重散列法了。</p><h2 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h2><p>如果不指定capacity，那么就基本什么也不做。内部方法<code>Initialize (capacity)</code>的调用，则会在第一次<code>Add</code>时进行。</p><p>如果指定了capacity，那么就会调用内部方法<code>Initialize (capacity)</code>。</p><p>1.首先，去质数表找一个大于等于capacity的质数（和Hashtable一样），作为哈希桶容量。</p><p>2.new哈希桶，全部赋值-1。</p><p>3.new Entry数组。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> prime = HashHelpers.GetPrime(capacity);</span><br><span class="line">    <span class="keyword">this</span>.buckets = <span class="keyword">new</span> <span class="built_in">int</span>[prime];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; <span class="keyword">this</span>.buckets.Length; ++index)</span><br><span class="line">        <span class="keyword">this</span>.buckets[index] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.entries = <span class="keyword">new</span> Dictionary&lt;TKey, TValue&gt;.Entry[prime];</span><br><span class="line">    <span class="keyword">this</span>.freeList = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容-4"><a href="#扩容-4" class="headerlink" title="扩容"></a>扩容</h2><h3 id="扩容时机"><a href="#扩容时机" class="headerlink" title="扩容时机"></a>扩容时机</h3><p>1.非冲突扩容。触发时机是Entries实际使用 == Entries元素总数。</p><p>2.冲突扩容（其实不是扩容，是重排序，但不用一个一个插入）</p><h3 id="扩容方式"><a href="#扩容方式" class="headerlink" title="扩容方式"></a>扩容方式</h3><p>先建新Buckets、Entries数组。新数组大小没有装填因子的概念，就是二倍扩容找质数罢了。</p><p>再直接拷贝Entries数组，直接<code>Array.Copy</code>（和Hashtable不一样）。</p><p>// 如果是冲突重排序，那么此时还需要把Entries里所有的元素重新计算一遍HashCode（当然我觉得没啥用）。</p><p>最后遍历Entries，对每个元素都进行<strong>重新映射赋值Buckets、重建链表</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> index1 = <span class="number">0</span>; index1 &lt; <span class="keyword">this</span>.count; ++index1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> index2 = entryArray[index1].hashCode % newSize; <span class="comment">// 重新赋值Buckets映射，因为扩容导致Size变了所以需要%newSize！</span></span><br><span class="line">entryArray[index1].next = numArray[index2]; <span class="comment">// 重链</span></span><br><span class="line">numArray[index2] = index1; <span class="comment">// 重链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h2><p><code>Add</code>接口，会直接调用内部方法<code>Insert</code>。</p><p>1.首先检测是不是没有执行初始化（new时没有输入capacity），没的话就执行<code>Initialize (0)</code>。</p><p>2.和下图一样，先<strong>哈希 + 位与intMax + 取模</strong>映射到Buckets下标，</p><p>  如果发现对应的桶内装的是-1，那就是没冲突过的哈希，不用处理；</p><p>  如果发现对应的桶内装的不是-1，那就是冲突了的哈希，就取找对应Entries里的元素，这个元素就是链头，获取它的Next，一直往后找，找到链尾（Next == -1），记录出冲突数num。</p><p>3.有个叫FreeList的单链表，它本身是个int（具体看“移除”节）。总之，会先去FreeList找碎片形式的Entry位，如果FreeList是空的（FreeCount == 0 ）就直接往后找从没用过的Entry位（具体就是用count++）。</p><p>找到新的Entry位后，如果没冲突过就将其Next设置成-1，如果冲突过就将它设置为新的链头。转化为代码很简单，就是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entries[没用过的Entry位].Next = Buckets[hashCode]; <span class="comment">// Buckets[hashCode]默认是-1，否则是链头</span></span><br><span class="line">Buckets[hashCode] = 没用过的Entry位;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220314144040.png"></p><h2 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h2><p>找起来就挺容易的，毕竟处理操作都在插入、移除的时候做好了。简单来说就是<strong>链地址法</strong>。</p><h2 id="移除-2"><a href="#移除-2" class="headerlink" title="移除"></a>移除</h2><p><code>Remove</code>接口。</p><p>分2步，第一步是根据Key算出哈希映射值，找到对应桶中指向的Entry结点。根据清空进行 <strong>更新链头or清空桶 / 更新链表</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (桶内指向的是链头)</span><br><span class="line">     <span class="keyword">this</span>.buckets[index1] = <span class="keyword">this</span>.entries[index3].next; <span class="comment">// 桶内指向新的链头。如果Entry无后续结点（Next是-1），相当于直接把桶也清空了。</span></span><br><span class="line"><span class="keyword">else</span> (桶内指向的是链中的某个结点)</span><br><span class="line">    <span class="keyword">this</span>.entries[index2].next = <span class="keyword">this</span>.entries[index3].next; <span class="comment">// 在链中删除结点</span></span><br></pre></td></tr></table></figure><p>第二步，<strong>把上面去掉的Entry节点清空内容后，作为FreeList的新链头</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.entries[index3].hashCode = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span>.entries[index3].key = <span class="literal">default</span> (TKey);</span><br><span class="line"><span class="keyword">this</span>.entries[index3].<span class="keyword">value</span> = <span class="literal">default</span> (TValue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.entries[index3].next = <span class="keyword">this</span>.freeList;</span><br><span class="line"><span class="keyword">this</span>.freeList = index3;</span><br><span class="line">++<span class="keyword">this</span>.freeCount;</span><br><span class="line">++<span class="keyword">this</span>.version;</span><br></pre></td></tr></table></figure><h1 id="哈希表vs字典"><a href="#哈希表vs字典" class="headerlink" title="哈希表vs字典"></a>哈希表vs字典</h1><p>解决冲突的方法不同。Hashtable用的是基于开放地址法的<strong>双重散列法</strong>；Dictionary用的是<strong>拉链法</strong>。</p><p>桶装的东西不同。内部都用到了桶的概念，但是Hashtable的桶装的是数据实体；Dictionary桶装的是int，存放着实体数组Entries的链头。</p><p>都是二倍质数扩容，但是扩容的时机不同。Hashtable多了<strong>装填因子、装载数</strong>的概念；Dictionary就直接<strong>比对count和Entries.Length</strong>。</p><h1 id="线程安全字典"><a href="#线程安全字典" class="headerlink" title="线程安全字典"></a>线程安全字典</h1><p>ConcurrentDictionary。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConcurrentDictionary&lt;TKey, TValue&gt;.Tables m_tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Tables</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;TKey, TValue&gt;.Node[] m_buckets;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> <span class="built_in">object</span>[] m_locks;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">volatile</span> <span class="built_in">int</span>[] m_countPerLock;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> IEqualityComparer&lt;TKey&gt; m_comparer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上很多对比ConcurrentDictionary和Dictionary+Lock效率的文章，说大规模情况下ConcurrentDictionary读快、Dictionary+Lock写快。所以更多会选择Dictionary+Lock的方案。</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="IEnumerable和IEnumerator区别"><a href="#IEnumerable和IEnumerator区别" class="headerlink" title="IEnumerable和IEnumerator区别"></a>IEnumerable和IEnumerator区别</h2><p>IEnumerable<strong>可迭代的</strong>是一个声明式的接口，声明实现该接口的类就是“可迭代的”，但并没用说明如何实现迭代器(iterator)。</p><p>IEnumerator<strong>迭代器</strong>是一个实现式的接口，它提供了具体怎么实现“可迭代的”。</p><p>我们自己写代码，一般给类实现IEnumerable接口即可。</p><p>IEnumerable：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;<span class="comment">// 返回一个循环访问集合的枚举器/迭代器。用于外部循环访问。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IEnumerator：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IDisposable</span>, <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    T Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach支持"><a href="#foreach支持" class="headerlink" title="foreach支持"></a>foreach支持</h2><p>用foreach遍历，并不需要实现IEnumerable接口，只要显式的实现IEnumerator GetEnumberator 无参方法即可。</p><p>foreach本质也是个语法糖，编译器帮你获取对象迭代器然后<code>while(MoveNext)&#123; Current &#125;</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator enumerator = test.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> current = enumerator.Current;</span><br><span class="line">    <span class="comment">// 下面是自己的代码</span></span><br><span class="line">    Console.WriteLine(current.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield使用"><a href="#yield使用" class="headerlink" title="yield使用"></a>yield使用</h2><p>普通使用迭代器的话，无效代码太多了。下面就是一个我选择最简单实现的例子，可以正常foreach。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Test_Iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Iterator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] datas = <span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> point = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        point++;</span><br><span class="line">        <span class="keyword">return</span> point &lt; datas.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        point = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = point % datas.Length;</span><br><span class="line">            <span class="keyword">return</span> datas[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是c#引入了yield语法糖，实现就容易多了。</p><p>可以在<strong>方法</strong>，<strong>属性</strong> 和 <strong>索引器</strong>中使用 <strong>yield 来</strong>实现<strong>迭代器</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">string</span>[] datas = <span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; datas.Length; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> datas[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yiled解析"><a href="#yiled解析" class="headerlink" title="yiled解析"></a>yiled解析</h2><p>yield语法糖，其实是编译器帮你在你定义的类中，生成了一个新的 IEnumerator实现类。接口需要的<strong>MoveNext、Reset、Current</strong>编译器都帮你用默认方式实现好了。</p><p>而<code> yield return; yield break;</code> 语法糖本身实现的意义，就是在MoveNext里写case。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (&lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="literal">default</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// yield return 3;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             &lt;&gt;<span class="number">2</span>__current = <span class="number">3</span>;</span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// yield return 5;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             &lt;&gt;<span class="number">2</span>__current = <span class="number">5</span>;</span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">2</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// yield break;</span></span><br><span class="line">             &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>// TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;最基本的数组类型。&lt;/p&gt;
&lt;h2 id=&quot;真实类型&quot;&gt;&lt;a href=&quot;#真实类型&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 异步篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/async/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/async/</id>
    <published>2022-03-18T13:18:05.695Z</published>
    <updated>2022-03-18T13:18:05.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h1><p>异步是一种任务执行的机制或者说方式，它的目的在于解决<strong>I/O等待会阻塞线程</strong>这个问题（最常见的就是GUI线程阻塞造成画面卡顿），它的实现依托于硬件底层的<strong>IRP</strong>(I/O Request Packet)，它的本质其实是回调。</p><p>我可以使用比如 ReadAsync + Task.ContinueWith 的组合，来实现一个<a href="https://blog.51cto.com/huangxincheng/2525748">异步实践</a>；</p><p>而更简单的方式是通过微软后续推出 .net4.5 的 <strong>async-await</strong> 这套关键词来实践。</p><h1 id="异步函数-async-await"><a href="#异步函数-async-await" class="headerlink" title="异步函数 async-await"></a>异步函数 async-await</h1><p>异步函数，实际通过 核心类TaskAwaiter + 状态机 实现。</p><h2 id="核心类-TaskAwaiter"><a href="#核心类-TaskAwaiter" class="headerlink" title="核心类 TaskAwaiter"></a>核心类 TaskAwaiter</h2><p>这个类比较简单，每个异步Task都有。我把它看作黑盒不细究，只看对外接口：</p><ul><li>  IsCompleted 属性：表示Task是否完成</li><li>  GetResult() 方法：结束异步任务完成的等待</li><li>  UnsafeOnCompleted(Action) 方法：设置延续任务</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>await必须在有async标记的方法内使用。如果async方法内部没有await，那它就和同步方法一样执行。</p><p>如果执行中遇到了await，就把需要await执行的Task交给线程池来执行，而原来那个线程则退出async方法的方法体，去执行外部的后续代码，直到await的Task执行完毕返回结果后，这个线程会回到方法体await处继续执行。整体流程看上去很像ContinueWith。</p><p>接下来研究编译器做的事。</p><h2 id="外部调用层"><a href="#外部调用层" class="headerlink" title="外部调用层"></a>外部调用层</h2><p>1.首先编译器看到方法有async标记，就会为其生成一个实现了IAsyncStateMachine接口的类，这个接口意味着它是一个<strong>异步状态机</strong>。</p><p>2.async方法自身则会被标记<strong>AsyncStateMachine特性</strong>，意味着这是个异步方法。</p><p>3.async方法内部则是new了一个异步状态机实例，先初始化，然后调用它的Start方法来启动状态机。Start方法内部主要是调用了状态机的<strong>MoveNext方法</strong>。</p><p>4.最后将指示方法运行状态的<code>builder.Task</code>对象 return 。</p><h2 id="内部状态机层"><a href="#内部状态机层" class="headerlink" title="内部状态机层"></a>内部状态机层</h2><p>每个异步状态机都有2个核心字段和一个核心方法：</p><ul><li>  builder：负责异步相关的操作，是方法实现异步执行的核心</li><li>  state：状态机的当前状态，<strong>初始化时赋值为 -1</strong>。</li><li>  MoveNext方法：状态机切换状态、执行任务、设置延续任务的方法</li></ul><p>我们直接讲MoveNext方法。</p><p><strong>第一次MoveNext时，我把它分成3块流程：</strong></p><p>1.第一次进入状态机时<code>state!=0</code>，await之前的代码被包裹到了MoveNext方法体内，照常顺序执行。</p><p>2.await那一行的代码，变成了获取任务的awaiter <code>Task.GetAwaiter()</code>。然后对任务的awaiter进行判断：</p><p>​      - 如果awaiter.IsCompleted 为true，意味着任务已经执行完了，执行第3步。</p><p>​      - 如果awaiter.IsCompleted 为false，意味着任务还未执行完（一般初始化完第一次进来，都是false）那就会做以下操作：</p><p>将<strong>state赋值为0</strong>，将awaiter存到自身字段内供后续使用，然后<strong>设置延续任务</strong><code>builder.AwaitUnsafeOnCompleted</code>，设置完之后会<strong>return掉而不执行第3步</strong>。</p><p>延续任务内部<a href="https://www.cnblogs.com/xiaoxiaotank/p/14303803.html">怎么设置的</a>比较复杂，我觉得不需要理解深入，理解为调了awaiter的接口就行了，反正最终效果是<strong>await的任务完成后再次调用MoveNext转动状态机</strong>。</p><p>3.结束awaiter <code>TaskAwaiter.GetResult() </code>。执行原先await那一行之后的后续代码。执行完成后，将state赋值为-2，并为builder标记任务成功<code>AsyncTaskMethodBuilder.SetResult()</code>。</p><p><strong>如果不是第一次MoveNext，就会省去1、2步：</strong></p><p>如果await的任务完成，就会触发延续任务：再次调用MoveNext。但是和第一次进不一样，此时因为<code>state==0</code>会跳过第1步第2步，将state设置为-1之后直接跳入第3步。</p><h2 id="多层嵌套async-await"><a href="#多层嵌套async-await" class="headerlink" title="多层嵌套async-await"></a>多层嵌套async-await</h2><p>其实实现也只是多层嵌套异步状态机而已，是一样的。</p><h2 id="一个async中多个await"><a href="#一个async中多个await" class="headerlink" title="一个async中多个await"></a>一个async中多个await</h2><p>在同一个异步状态机中，生成更多的awaiter、更多的state。</p><p>state的-2（完成）、-1（初始）是定好的，所以只会从0开始生成，而有几个await就有几个awaiter、state。</p><p>一旦state多起来，内部就不再 if-else 了，而是 switch-case + goto 。</p><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><p>接触的主要是，</p><p>SynchronizationContext 同步上下文：<strong>捕获</strong>提供在各种同步模型中传播同步上下文的基本功能。它有一个<code>Post()</code>虚方法，Winform、WPF等等会重写它，让它被调用时能产生不同的过程，但目的都是一个：实现使用GUI线程执行Post过去的委托。</p><p>ExecutionContext 执行上下文：<strong>流动</strong>。在执行委托时恢复另一个线程的状态环境。</p><h2 id="WPF中使用-async-await"><a href="#WPF中使用-async-await" class="headerlink" title="WPF中使用 async await"></a>WPF中使用 async await</h2><p>上面我们都是通过控制台举的例子，这是没有任何<code>SynchronizationContext</code>的，但是WPF（Winform同理）就不同了，在UI线程中，它拥有属于自己的<code>DispatcherSynchronizationContext</code>。</p><p>这个工作中有体会，就是<code>View.xmal.cs</code>文件内写诸如点击事件的async-await，延续任务会默认借调GUI线程而非await内分配的任务池线程。。</p><p>而我可以改成使用<code>SynchronizationContext.Post()</code>来实现类似的效果。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>用SynchronizationContext可以实现确定性使用GUI线程来执行委托，我的理解只到此。</p><p>参考：</p><p><a href="https://www.cnblogs.com/xiaoxiaotank/p/14303803.html">https://www.cnblogs.com/xiaoxiaotank/p/14303803.html</a></p><p><a href="https://www.cnblogs.com/xiaoxiaotank/p/13666913.html">https://www.cnblogs.com/xiaoxiaotank/p/13666913.html</a></p><p><a href="https://codingcodingk.top/2022/01/14/Tech/CSharp/CLR-Via-CSharp/cp7/">https://codingcodingk.top/2022/01/14/Tech/CSharp/CLR-Via-CSharp/cp7/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是异步？&quot;&gt;&lt;a href=&quot;#什么是异步？&quot; class=&quot;headerlink&quot; title=&quot;什么是异步？&quot;&gt;&lt;/a&gt;什么是异步？&lt;/h1&gt;&lt;p&gt;异步是一种任务执行的机制或者说方式，它的目的在于解决&lt;strong&gt;I/O等待会阻塞线程&lt;/strong&gt;这</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 类内成员篇</title>
    <link href="https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/classMember/"/>
    <id>https://codingcodingk.github.io/2022/03/18/Tech/CSharp/Essence/classMember/</id>
    <published>2022-03-18T13:18:05.695Z</published>
    <updated>2022-03-18T13:18:05.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类成员初始化顺序"><a href="#类成员初始化顺序" class="headerlink" title="类成员初始化顺序"></a>类成员初始化顺序</h1><p>一般初始化顺序：</p><ol><li> 子类静态字段内联</li><li> 子类静态构造</li><li> 子类实例字段内联</li><li> 父类静态字段内联</li><li> 父类静态构造</li><li> 父类实例字段内联</li><li> 父类实例构造</li><li> 子类实例构造</li></ol><p>原则就是：先内联后构造；先静态后实例；先子类后父类（除了构造器）。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>abstract抽象方法、virtual方法、隐式实现接口方法，它们本质上、在IL代码层中，都是virtual方法。</p><p>IL提供两种方式去调用方法：</p><p>call：可用于调用实例方法、虚方法和静态方法。// 我个人测下来感觉只有静态方法是用call…</p><p>callvirt：可用于调用实例方法、虚方法。过程会比call复杂一些，事前会check null，执行时也会去查虚函数表。</p><h2 id="非虚方式调用-call"><a href="#非虚方式调用-call" class="headerlink" title="非虚方式调用 call"></a>非虚方式调用 call</h2><p>call 调用的，是编译时确定的类型，也就是申明类型。</p><p>如果变量申明的类型没有对应的方法，就检查基类型来查找匹配方法。</p><h2 id="虚方法调用-callvirt"><a href="#虚方法调用-callvirt" class="headerlink" title="虚方法调用 callvirt"></a>虚方法调用 callvirt</h2><p>callvirt 调用的，是运行时确定的类型，也就是变量指向对象的实际类型（new的类型）。</p><p>上面说的是结果，但如果深究过程，在IL代码层的话，多态方法全部都是 callvirt 最初父类的同一个方法。</p><p>c++版本 虚表、虚函数调用整体流程：</p><p>1.编译器发现一个类中有虚函数时，便为该类<strong>生成虚函数表</strong>，虚表各表项为指向对应虚函数的指针。父类虚函数地址在前，子类在后，按照声明顺序。</p><p>2.<strong>生成子类</strong>时，如果发现子类中函数重写了父类中的虚函数，则用子类虚函数的地址<strong>覆盖</strong>掉对应父类虚函数的地址。</p><p>3.<strong>虚函数调用</strong>过程：</p><p>查自己类型的虚函数表，找到对应位置的虚函数。</p><p>​    有覆盖：该指针指向子类函数，调用子类的函数。</p><p>​    无覆盖：调用父类自己的函数。</p><p>4.每一个有虚函数的类都有一个虚函数表（V-Tablle），每个这些类的对象都会生成一个指向虚函数表的指针。</p><p>c#版本 虚表、虚函数调用整体流程：</p><p>网上很难找到c#版本的虚函数实现，全只有猜测。我自己整理了一下，目前理解是：</p><p>可以确定的是，在IL代码层，多态方法全部都是 callvirt 最初父类的同一个方法。</p><p>因此估计JIT是根据 <strong>推上栈的实际变量指向的对象 + callvirt最初父类的同一个方法</strong> 来获取偏移量、再根据偏移量确定具体调用方法，内部则可能和c++一样是用V-Table。</p><p><strong>那么最终结论就是</strong>，每个带有虚函数的类型，都会有一张V表；他们的每个子类，也有自己的V表，起始布局和父类一致，如果override了就替换自己的V表的方法指针；这些子类在堆上的对象，都有一个指针指向子类类型的V表。</p><p><a href="https://blog.csdn.net/li1914309758/article/details/79916414">文章推荐1</a>： <a href="http://c.biancheng.net/view/267.html">文章推荐2</a></p><h2 id="自己实现虚方法"><a href="#自己实现虚方法" class="headerlink" title="自己实现虚方法"></a>自己实现虚方法</h2><p>用静态方法就可以实现，将对象自己作为参数传入静态方法，然后根据其type来switch-case就可以简单实现一个。</p><p>总的来说，虚方法这么复杂的内部机制就是为了实现多态。</p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>常量，const关键字，是指值从不变化的符号，它的值必须能在编译时确定，最后会在元数据中嵌入。它总是隐式static的。</p><p>字段，是一种数据成员，其中容纳了一个值类型的实例或者对一个引用类型的引用。</p><table><thead><tr><th>C#关键字</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>默认</td><td>实例字段</td><td>该字段只与对象的一个实例关联，而不是与类型本身关联</td></tr><tr><td>static</td><td>静态字段</td><td>该字段是类型状态的一部分，而不是对象状态的一部分</td></tr><tr><td><strong>readonly</strong></td><td>只读字段</td><td><strong>该字段只能由一个构造器方法中的代码写入</strong>（但是可以通过反射修改）</td></tr></tbody></table><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>属性的本质是方法（get、set访问器），是对字段的封装。C#提供<code>&#123;get;set;&#125;</code>语法糖，编译时自动实现创建一个字段。</p><p>无参属性：我们常规说的属性。</p><p>有参属性：get、set访问器接受一个或多个参数，就叫有参属性。有参属性一般用处是索引器，索引器的实现是通过对<code>this[]</code>操作符进行重载。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Students</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] name = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//索引器必须以this关键字定义，其实这个this就是类实例化之后的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name[index]; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; name[index] = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">...</span><br><span class="line">Console.WriteLine(Students[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>具体见《C#精要 - 委托与事件篇》。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>避免拆装箱的最佳选择。最好的例子就是 ArrayList ( Object[ ] ) =&gt; List&lt; T &gt;；Action&lt; T &gt; (T arg)、Func&lt;in T, out TResult&gt; (T arg)。</p><p>它可以用where约束。</p><ul><li>  **逆变量(contravariant)**，意味着泛型类型参数可以从一个类更改为它的某个派生类。C#中用<code>in</code>来标记，只能出现在输入位置，比如入参。</li><li>  **协变量(covariant)**，意味着泛型类型参数可以从一个类更改为它的某个基类。C#中用<code>out</code>来标记，只能出现在输出位置，比如返回值。</li></ul><p>这两个概念看着挺复杂，其实就是 Func&lt;in T, out TResult&gt; (T arg)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类成员初始化顺序&quot;&gt;&lt;a href=&quot;#类成员初始化顺序&quot; class=&quot;headerlink&quot; title=&quot;类成员初始化顺序&quot;&gt;&lt;/a&gt;类成员初始化顺序&lt;/h1&gt;&lt;p&gt;一般初始化顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 子类静态字段内联&lt;/li&gt;
&lt;li&gt; 子类静态</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 线程篇</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/thread/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/thread/</id>
    <published>2022-03-04T14:13:03.121Z</published>
    <updated>2022-03-18T13:18:05.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程、进程？"><a href="#什么是线程、进程？" class="headerlink" title="什么是线程、进程？"></a>什么是线程、进程？</h1><p><strong>线程</strong>是对物理CPU进行虚拟化，也是操作系统能调度的最小单位。</p><p><strong>进程</strong>实际是应用程序的实例要使用的资源的集合，每个进程都被赋予了一个虚拟地址空间来避免被其它进程访问。</p><p>一个线程确定由某一进程拥有，一般不能跨进程。</p><h1 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h1><p>线程有空间（内存耗用）和时间（上下文调度）上的开销。</p><h2 id="内存耗用"><a href="#内存耗用" class="headerlink" title="内存耗用"></a>内存耗用</h2><p>① 线程内核对象 (thread kernel object)</p><p>主要是有对线程的描述属性。x64使用约1240字节。</p><p>值得注意的是<strong>线程上下文</strong>(thread context)：线程上下文是是线程上一次执行完毕后，CPU寄存器的状态（内存块）。</p><p>② 线程环境块 (thread environment block,TEB)</p><p>有GDI(图形设备接口)和OpenGL用的一些数据，以及<strong>异常处理链首</strong>：线程每进入一个try块，都会在链首(head)中插入一个节点(node)，退出try块时删除该节点。x64中4KB。</p><p>③ 用户模式栈 (user- mode stack)</p><p>堆栈概念中的栈说的就是这个了，默认分配1MB内存（其实windows是保留1MB容量，等用了才调拨给你）。</p><p>④ 内核模式栈 (kernel- mode stack)</p><p>应用程序代码向OS中的内核模式函数传递实参时，会复制 用户模式栈 传去的实参并加以验证并不允许修改。最后OS内核代码开始处理复制的值。分配x86是12KB，x64是24KB。</p><h2 id="上下文调度"><a href="#上下文调度" class="headerlink" title="上下文调度"></a>上下文调度</h2><p>Windows任何时刻都只将一个线程分配给一个CPU(或CPU核，下面称CPU)。</p><p>CPU会为线程执行一个**时间片 (quantum)**的时长，大概30ms吧，等时间片到期了，就会进行上下文调度切换执行另一个线程。</p><p>上下文调度具体流程：</p><ol><li> 将CPU寄存器的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。</li><li>从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有（而不是CPU上一次调度的线程的所属进程）， Windows在<br> 开始执行任何代码或者接触任何数据之前，还必须切换CPU“看见”的虚拟地址空间。</li><li> 将所选上下文结构中的值加载到CPU的寄存器中。</li></ol><p>上下文调度之后线程切换完成，CPU就会执行所选的线程，直到下一个时间片过了又要切换。</p><p>这是<strong>净开销</strong>，只是为了能够提供一个健壮的、响应灵敏的操作系统。具体就是cpu运行的某个线程卡死了，过一个时间片后也会被分配其他线程执行（比如任务管理器线程来终止卡死程序）。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>系统调度CPU执行哪一个线程，是由线程自己的优先级决定的，所以可能出现高优先级线程太多导致长时间没有处理低优先级线程，这种情况叫<strong>饥饿</strong>。</p><p>低优先级的线程哪怕时间片没用完，也会被立刻挂起执行优先级更高的线程，这是Windows称作<strong>抢占式多线程操作系统</strong>的原因。</p><p>优先级是0~31。</p><p>0是系统启动时会创建一个特殊的<strong>零页线程</strong>，优先级为0，在没有其他线程需要“干活儿”的时候，零页线程将系统RAM的所有空闲页清零。</p><p>自己创建的线程可以通过<code>ThreadA.Priority = ThreadPriority.AboveNormal;</code>的方式，指定优先级。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程的执行是<strong>事件分发式</strong>的，也就是内部维护一个操作请求队列。</p><h2 id="生命流程"><a href="#生命流程" class="headerlink" title="生命流程"></a>生命流程</h2><p>CLR初始化时，线程池中是没有线程的。在内部，线程池维护了一个<strong>操作请求队列</strong>。应用程序执行一个异步操作时，就会对线程池进行请求，具体是将一个记录项(entry)追加到队列中。</p><p>线程池会从这个队列中提取记录项，将这个记录项派发(dispatch)给一个线程池的线程；如果线程池没有线程，就创建一个新线程。当这个线程完成任务后并不销毁，而是返回线程池、进入空闲状态。</p><p>但是如果一个线程在线程池里闲太久了（应用程序很久不向线程池发出请求），为了避免资源浪费，CLR才会终止它。</p><h2 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h2><p>也就是具体是怎么分发任务的。</p><p>（线程池）全局队列：当调用ThreadPool.QueueUserWorkItem、Task时，新追加的任务会被添加进<strong>全局队列</strong>中，全局队列采用<strong>先进先出FIFO</strong>的方式，让工作者线程们自己去取任务。全局队列使用<strong>线程同步锁</strong>，这是为了避免多个线程同时取到一个任务。</p><p>（线程）本地队列：在全局队列中领完的任务会放入工作者线程各自的<strong>本地队列</strong>，本地队列采用<strong>后入先出LIFO</strong>的方式来执行任务。本地队列一般不锁，因为只有对应的工作者线程访问它。</p><p>如果工作者线程发现自己<strong>本地队列空</strong>了，就会尝试从另一个工作者线程的本地队列“偷”一个Task。这个Task在本地队列的队尾，并会要求获取一个线程同步锁。</p><p>如果<strong>所有本地队列都空</strong>了，工作者线程会使用FIFO算法从全局队列取出一个工作项并获得它的锁。</p><p>如果<strong>全局队列也为空</strong>，工作者线程会进入睡眠状态。</p><p>如果<strong>工作者线程睡眠时间很长</strong>，它会自己醒来并销毁自身，释放线程使用的资源（内核、栈等）。</p><h2 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h2><p>可以使用辅助类<strong>CancellationToken</strong>，它有一个bool字段可以用来判断是否取消执行了任务，只要执行Cancel方法就可以让他变成false。</p><p>自己传到线程里判断就行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">CancellationToken token = cts.Token;</span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">token.Register(() =&gt; Console.WriteLine(<span class="string">&quot;Count is cancelled, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">ThreadPool.QueueUserWorkItem(_ =&gt; Count(token, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Press &lt;Enter&gt; to cancel Thread Works&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line">cts.Cancel();</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params">CancellationToken token, <span class="built_in">int</span> countTo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> count = <span class="number">0</span>; count &lt; countTo; count++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 当Source执行Cancel时，会变成false</span></span><br><span class="line"><span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;break, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Console.WriteLine(count);</span><br><span class="line">Thread.Sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是线程、进程？&quot;&gt;&lt;a href=&quot;#什么是线程、进程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程、进程？&quot;&gt;&lt;/a&gt;什么是线程、进程？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;是对物理CPU进行虚拟化，也是操作系统能调度的</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - GC篇</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/gc/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/gc/</id>
    <published>2022-03-04T14:13:03.119Z</published>
    <updated>2022-03-18T13:18:05.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是GC？为什么需要GC？"><a href="#什么是GC？为什么需要GC？" class="headerlink" title="什么是GC？为什么需要GC？"></a>什么是GC？为什么需要GC？</h1><p>GC，即Garbage Collection，意为垃圾回收。</p><p>.Net不同于原生C++这种需要程序员手动管理内存的机制，存在<strong>自动释放内存的一套机制</strong>，这就叫GC。</p><p>GC可以让程序员<strong>不必关心资源的管理</strong>，也就是一个对象的生命流程中的4：</p><ol><li> 调用IL指令newobj，为代表资源的类型分配内存（C#中用new操作符完成）。</li><li> 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。</li><li> 访问类型的成员来使用资源（有必要可以重复）。</li><li> 摧毁资源的状态以进行清理。</li><li> 释放内存。垃圾回收器独自负责这一步。</li></ol><p>当然可以自己<strong>重写Finalize方法</strong>或手动<strong>调用GC.Collect</strong>。</p><h1 id="简单列举GC的优势（对比手动管理）"><a href="#简单列举GC的优势（对比手动管理）" class="headerlink" title="简单列举GC的优势（对比手动管理）"></a>简单列举GC的优势（对比手动管理）</h1><p>1.让程序员可以不必关心资源的管理。</p><p>2.避免手动管理时，顺序搞错，先销毁后调用导致空引用抛错。</p><p>3.避免手动管理时，由于标记引用未清空导致的内存泄露。</p><h1 id="讲讲GC算法"><a href="#讲讲GC算法" class="headerlink" title="讲讲GC算法"></a>讲讲GC算法</h1><p>三个方向上讲：从总体流程上来说，它有<strong>标记 -&gt; 压缩</strong>两个阶段；从确定是否销毁的方式上来说，它是<strong>从根遍历</strong>的；从销毁处理方式上来说，它是<strong>分代</strong>的。它解决了<strong>引用计数法</strong>循环引用的问题。</p><h2 id="先说下“引用计数法”是什么？为什么不行？"><a href="#先说下“引用计数法”是什么？为什么不行？" class="headerlink" title="先说下“引用计数法”是什么？为什么不行？"></a>先说下“引用计数法”是什么？为什么不行？</h2><p>引用计数是COM(Component Object Model)使用的办法，GC并不是用这个，而是用的从根遍历。说的是堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一“部分”到达代码某个不再需要对象的地方，就递减这个计数，直到0就可以删除了。</p><p>不行的理由很简单，它没有办法处理循环引用的关系，也就是A、B两个对象互相引用，各自引用计数为1，就没法销毁对方。</p><h1 id="1-先从流程上说：标记-gt-压缩"><a href="#1-先从流程上说：标记-gt-压缩" class="headerlink" title="1.先从流程上说：标记 -&gt; 压缩"></a>1.先从流程上说：标记 -&gt; 压缩</h1><p>标记：这个阶段，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含**可达(已标记)与不可达(未标记)**对象。</p><p>标记完成后，进入压缩阶段。</p><p>压缩：在这个阶段中，垃圾回收器线性的遍历堆、并对其进行内存碎片整理。让幸存对象都紧挨在一起，使内存的地址空间得到释放。操作完了之后，对引用了这些堆内对象的指针进行偏移，保持引用与之前一致。</p><p>压缩结束后，如果本次GC并没有分出足够的内存给接下来的new操作，意味着该进程的内存已耗尽，会抛出OutOfMemoryException。</p><h1 id="2-再从确定是否销毁上说：从根遍历"><a href="#2-再从确定是否销毁上说：从根遍历" class="headerlink" title="2.再从确定是否销毁上说：从根遍历"></a>2.再从确定是否销毁上说：从根遍历</h1><h2 id="根（Root）"><a href="#根（Root）" class="headerlink" title="根（Root）"></a>根（Root）</h2><p>我们将所有引用类型的变量都成为<strong>根</strong>，类中定义的任何静态字段，方法的参数，局部变量(仅限引用类型变量)等一系列”引用者”，都是根，根是CLR在堆之外可以找到的各种入口点。</p><h2 id="可达和不可达（Objects-reachable-and-unreachable）"><a href="#可达和不可达（Objects-reachable-and-unreachable）" class="headerlink" title="可达和不可达（Objects reachable and unreachable）"></a>可达和不可达（Objects reachable and unreachable）</h2><p>如果一个根引用了堆中的一个对象，则该对象为“可达”，否则即是“不可达”。不可达的对象是本次销毁的目标。</p><h2 id="引用跟踪"><a href="#引用跟踪" class="headerlink" title="引用跟踪"></a>引用跟踪</h2><p>也就是标记阶段是怎么标记的。</p><p>在这个阶段，CLR会先遍历堆中的所有对象，并全部设置为可回收状态的，然后检查所有活动根，查看他们引用了哪些对象，</p><p>如果一个根包含null，CLR会忽略这个根并检查下一个根；</p><p>如果根引用了堆上的对象，CLR会标记那个对象，并检查这个对象中的根，继续标记它们引用的对象。如果过程中发现对象已标记，则不重新检查，避免了循环引用而造成的死循环。。</p><p>检查完毕后，堆中的对象要么已标记，要么未标记。已标记对象的叫做<strong>可达的</strong>，未标记的对象叫做<strong>不可达的</strong>。</p><h1 id="3-最后说分代回收"><a href="#3-最后说分代回收" class="headerlink" title="3.最后说分代回收"></a>3.最后说分代回收</h1><p>CLR一共有3代：0、1、2代。这是在对可达对象进行处理。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>开始时：CLR初始化会为每一代选择一个<strong>预算容量</strong>。当有对象新分配时，会塞到第0代。</p><p>触发时机：当第0代满了，就会触发GC，没被回收的对象就会成为第1代对象。此时第0代空间中已经不包含任何对象，原来的对象可能已被回收，可能已被放置到第1代中。</p><p>触发特点1：当触发了GC时，第1代内的对象远小于它的预算，那么就不会对第1代进行检查。</p><p>触发特点2：当触发了GC时，可能存在老对象引用了新对象的可能性（比如1代引用0代）。这时新代回收时没有检查到来自老代的引用就会出现错误的回收。为了解决这个问题，垃圾回收器利用了JIT编译器内部的一个机制，这个机制在<strong>对象的引用字段发生变化时，会设置一个对应的标记位</strong>，这样一来垃圾回收器就会知道自上一次垃圾回收以来，哪些老对象的引用字段发生了变化，这样就算这次回收只回收新生代，也会去检测引用字段发生了变化的老对象，是否引用了新生代对象。</p><h2 id="分代回收的意义"><a href="#分代回收的意义" class="headerlink" title="分代回收的意义"></a>分代回收的意义</h2><p>为什么明明是不打算丢弃的可达对象，还要用分代去推出1代、2代呢？全部放0代不就完了？</p><p>事实上是，CLR做出了预设：<strong>回收堆的一部分，速度快于回收整个堆。</strong>事实一般也是如此。</p><p>所以只检查一部分，会比每次都检查全部快很多。</p><h2 id="代预算的动态调节"><a href="#代预算的动态调节" class="headerlink" title="代预算的动态调节"></a>代预算的动态调节</h2><p>在回收第0代后发现存活下来的对象很少，就可能减少第0代的预算，这意味着会更加频繁地执行垃圾回收，但每次回收需要检查的范围更小了。相反，如果回收了第0代后发现还有很多存活的对象，没有多少内存可以回收，就会增大第0代的预算，这样垃圾回收的次数就会减少。</p><h1 id="GC的触发时间点"><a href="#GC的触发时间点" class="headerlink" title="GC的触发时间点"></a>GC的触发时间点</h1><p>除了上文说到的检测到第0代超出预算的时候会触发垃圾回收，还有以下的：</p><h2 id="代码显式调用System-GC的静态Collect方法"><a href="#代码显式调用System-GC的静态Collect方法" class="headerlink" title="代码显式调用System.GC的静态Collect方法"></a>代码显式调用System.GC的静态Collect方法</h2><p>代码可显式请求CLR进行垃圾回收，但微软强烈反对这种请求，托管语言应该信任它本身的垃圾回收机制。</p><p>我日常会在印刷操作的时候调用它。</p><h2 id="Windows报告低内存情况"><a href="#Windows报告低内存情况" class="headerlink" title="Windows报告低内存情况"></a>Windows报告低内存情况</h2><p>如果Windows报告低内存，CLR会强制执行垃圾回收。</p><h2 id="CLR正在卸载AppDomain"><a href="#CLR正在卸载AppDomain" class="headerlink" title="CLR正在卸载AppDomain"></a>CLR正在卸载AppDomain</h2><p>当一个AppDomain卸载时，CLR认为其中一切都不是根，会执行涵盖所有代的垃圾回收。</p><h2 id="CLR正在关闭"><a href="#CLR正在关闭" class="headerlink" title="CLR正在关闭"></a>CLR正在关闭</h2><p>CLR在进程正常终止时关闭，CLR认为其中一切都不是根，对象有机会进行资源清理，但CLR不会试图压缩或释放内存。进程终止时，Windows会回收进程的全部内存。</p><h1 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h1><p>前面讨论的都是小对象，对于大对象（书中说是85000字节以上），CLR会区分对待：</p><p>内存不是在小对象的地址空间分配，而是进程地址空间的其他地方分配；总是第2代；目前不支持压缩。</p><p>所以GC一般不处理他们。</p><h1 id="Finalize方法"><a href="#Finalize方法" class="headerlink" title="Finalize方法"></a>Finalize方法</h1><p>System.Object定义了受保护的虚方法Finalize，如果类型重写了这个方法，对象在被GC判定销毁时会调用它。重写它一般是为了清理非托管资源。</p><h2 id="1-new时"><a href="#1-new时" class="headerlink" title="1.new时"></a>1.new时</h2><p>如果对象的类型定义了Finalize方法，那么这个实例在被构造之前，会将一个指向该对象的指针放到一个终结列表中（finalization list）。</p><h2 id="2-被回收时"><a href="#2-被回收时" class="headerlink" title="2.被回收时"></a>2.被回收时</h2><p>在被GC回收时，如果发现这个对象在终结列表中，就先不销毁，而是把指向它的指针扔到<strong>freachable队列中</strong>。</p><h2 id="3-在freachable队列时"><a href="#3-在freachable队列时" class="headerlink" title="3.在freachable队列时"></a>3.在freachable队列时</h2><p>freachable队列也是垃圾回收器的一种内部数据结构，队列中每一个引用都代表准备要调用Finalize方法的对象。当垃圾回收器把对象的引用从终结列表移到freachable队列时，对象不再被认为是垃圾，我们可以说对象被<strong>复活</strong>了。同时，该对象内引用的对象也会被标记、复活。</p><h2 id="4-复活"><a href="#4-复活" class="headerlink" title="4.复活"></a>4.复活</h2><p>说是复活，其实也就是本该销毁的对象延迟销毁了，没有在本该销毁的一次GC下被销毁。</p><p>这些复活的对象会被提升到老一代，之后CLR会用特殊的终结线程去调用freachable队列中每个对象的Finalize方法，并清空队列。之后他们就真正被销毁了。</p><h2 id="5-复活的思考"><a href="#5-复活的思考" class="headerlink" title="5.复活的思考"></a>5.复活的思考</h2><p>由3、4可知，这些定义了Finalize方法的“可终结”的对象，由于在第一次回收时，会被“复活”以执行Finalize方法，并可能会被提升到老一代，所以至少需要执行两次垃圾回收才能释放掉它们占用的托管堆内存，更需要注意到的是，这些对象中的引用字段所引用的对象也会存活下来并提升到老一代，会造成更大的性能负担。所以，要尽量避免为引用类型的字段定义为“可终结”对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是GC？为什么需要GC？&quot;&gt;&lt;a href=&quot;#什么是GC？为什么需要GC？&quot; class=&quot;headerlink&quot; title=&quot;什么是GC？为什么需要GC？&quot;&gt;&lt;/a&gt;什么是GC？为什么需要GC？&lt;/h1&gt;&lt;p&gt;GC，即Garbage Collection</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="GC" scheme="https://codingcodingk.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 技能编辑器篇</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Project/Unity/Moba/HOK/skilleditor/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Project/Unity/Moba/HOK/skilleditor/</id>
    <published>2022-03-04T14:13:03.118Z</published>
    <updated>2022-03-18T13:18:05.694Z</updated>
    
    <content type="html"><![CDATA[<p>从 技能配置可视化+纯业务 的角度，将原来的技能系统换个角度刨析一遍。</p><h1 id="大体分类"><a href="#大体分类" class="headerlink" title="大体分类"></a>大体分类</h1><p>按照可配置的文件来分类，可分为以下五大类：</p><ul><li>碰撞关系配置</li><li>buff配置</li><li>skill配置</li><li>单位配置</li><li>bullet配置</li></ul><p>下面对这几类的核心配置数据进行列举。</p><h1 id="碰撞关系配置"><a href="#碰撞关系配置" class="headerlink" title="碰撞关系配置"></a>碰撞关系配置</h1><ul><li>目标队伍</li><li>目标选择规则</li><li>目标单位</li><li>目标查找范围</li></ul><h1 id="buff配置"><a href="#buff配置" class="headerlink" title="buff配置"></a>buff配置</h1><ul><li>buff类型</li><li>buff附着目标</li><li>buff位置确定方式</li><li>碰撞关系配置</li></ul><h1 id="skill配置"><a href="#skill配置" class="headerlink" title="skill配置"></a>skill配置</h1><ul><li>  图片、音效资源路径</li><li>  技能动画名</li><li>  技能目标确定方式、范围等</li><li>  技能指示器类型</li></ul><h1 id="单位配置"><a href="#单位配置" class="headerlink" title="单位配置"></a>单位配置</h1><p>UnitInfoCfg，比较特殊，为了方便导表，逻辑碰撞体这块只提供一个Enum，在实际加载时使用它的派生类，根据Enum读取出不同的真实逻辑碰撞数据。</p><ul><li>  单位基础属性（基础血量、防御等）</li><li>  单位资源位置</li><li>  单位逻辑碰撞体类型（受击点高度 + 碰撞体大小、形状）</li></ul><h1 id="实现协作"><a href="#实现协作" class="headerlink" title="实现协作"></a>实现协作</h1><p>即想要结点编辑器、又想要表格式的批量填写。将他们协作起来需要多写一些代码，且他们的数据都必须来自同一套数据源——我采用Json数据源。</p><h2 id="Luban"><a href="#Luban" class="headerlink" title="Luban"></a>Luban</h2><p>由Luban提供2套类型：Editor专用的类型，用于和Json数据源交互；运行时使用的类型，也就是真实类型，用于和bytes数据源交互。</p><p>由Luban提供多种格式数据转换：2种Editor可视化面板中填写数据 =&gt; Editor专用Json类 =&gt; Json数据源；Json数据源 =&gt; bytes数据源；bytes数据源 =&gt; 填充运行时对象。</p><h2 id="Odin"><a href="#Odin" class="headerlink" title="Odin"></a>Odin</h2><p>实现在Unity中，表格式的批量填写配置数据。数据依赖于Json数据源，可视化面板需要单独写一套。</p><h2 id="xNode"><a href="#xNode" class="headerlink" title="xNode"></a>xNode</h2><p>实现在Unity中，结点式的树形填写配置数据。数据依赖于Json数据源，可视化面板需要单独写一套。</p><p>要点小记：</p><p>1.比如<code>List&lt;int&gt;</code>类型外键，实现结点连接。<br>2.多个不同类型的buff实现结点。<br>3.如何全遍历图，输出json。</p><h1 id="完全基于数据驱动的xNode连点图"><a href="#完全基于数据驱动的xNode连点图" class="headerlink" title="完全基于数据驱动的xNode连点图"></a>完全基于数据驱动的xNode连点图</h1><p>不依赖于SerializableObj的数据持久化内的数据，每次打开图，全部清空，只根据json数据来重新绘制整张图。这样就能保证多种编辑方式（普通编辑器、连点编辑器、excel）修改同一主体后，保持数据一致。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>需要人为保障准确的，只有Graph的命名，因为这代表着要读取数据的文件路径。按照统一风格标准来命名即可。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ol><li>  根据命名去取对应路径下的json数据源文件，读取；</li><li>  获取依赖的其他json文件（比如skill下的buffList），读取；</li><li>  将所有取得的文件可视化成对应的Node；</li><li>  根据1中获取的信息，对图中Node进行连线。</li></ol><h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><p>一点是，xNode在这里的用途非常小，数据层已完全分离、存于硬盘，graph是打开绘制的也不依赖于SerializableObj；另一点是，xNode效率真的太低了，实时刷新造成结点一多就卡顿。</p><p><strong>所以其实应该基于odin（甚至直接脱离unity用wpf）自己写一套简单的数据可视化连点器</strong>，再去掉它的高频刷新。会比xNode实现轻便的多，画面板也更轻松。最后<strong>加上Timeline，行为树和状态机的模板</strong>，就可以复用了。</p><p><strong>另外，关于luban的使用方式上有一点改进</strong>。比如SKillCfg.BuffList并不需要以int[]的形式去写数据了，而是直接以BuffCfg[]的形式，因为luban是支持多态记录json的。不过由于luban和editor都是UnityMobaDemo搭建完技能系统后才引入的，本次作罢。</p><p>考虑以后采用的技术方案选择：</p><p>时间线编辑器：timline flux slate</p><p>可视化连点器：NodeGraphProcessor</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从 技能配置可视化+纯业务 的角度，将原来的技能系统换个角度刨析一遍。&lt;/p&gt;
&lt;h1 id=&quot;大体分类&quot;&gt;&lt;a href=&quot;#大体分类&quot; class=&quot;headerlink&quot; title=&quot;大体分类&quot;&gt;&lt;/a&gt;大体分类&lt;/h1&gt;&lt;p&gt;按照可配置的文件来分类，可分为以下五大</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
</feed>
