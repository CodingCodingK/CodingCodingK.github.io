<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodingCodingK Blog</title>
  
  <subtitle>CodingCodingK</subtitle>
  <link href="https://codingcodingk.github.io/atom.xml" rel="self"/>
  
  <link href="https://codingcodingk.github.io/"/>
  <updated>2022-03-04T14:13:03.128Z</updated>
  <id>https://codingcodingk.github.io/</id>
  
  <author>
    <name>CodingCodingK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity编辑器拓展</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Tech/Game/uiboy_4/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Tech/Game/uiboy_4/</id>
    <published>2022-03-04T14:13:03.128Z</published>
    <updated>2022-03-04T14:13:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识编辑器拓展"><a href="#初识编辑器拓展" class="headerlink" title="初识编辑器拓展"></a>初识编辑器拓展</h1><h2 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h2><ul><li>  菜单栏选项</li><li>  菜单栏窗口</li><li>  面板式编辑器</li><li>  窗口式编辑器</li></ul><p>unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。 用于扩展editor的类需要放到名字为“Editor”的文件夹中，这个文件夹可以直接放到”Assets“文件夹下，也可以是项目目录任何文件夹下的子文件夹，比如”Assets/SkillSystem/Editor”。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>重新绘制画面，主要是通过重写OnGUI、OnInspectorGUI之类的函数来实现的。</p><p>这些函数是生命周期中的一员，具体看Unity生命流程图。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>对上面提出的支持进行简单实践。</p><h2 id="菜单栏选项"><a href="#菜单栏选项" class="headerlink" title="菜单栏选项"></a>菜单栏选项</h2><p>菜单栏里添加“Tools &gt; 打包工具”项。点击执行方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;Tools/打包工具&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OutputAB</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单栏窗口"><a href="#菜单栏窗口" class="headerlink" title="菜单栏窗口"></a>菜单栏窗口</h2><p>菜单栏里添加“Example &gt; 打包工具”项。点击跳出制作的窗口以及控件。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121155.png"></p><p>使用方法：</p><ol><li>  继承ScriptableWizard</li><li>  调用ScriptableWizard.DisplayWizard函数可以快速创建这个向导窗口。这个向导窗口只支持小于或等于两个按钮的定制（即提供的消息响应函数只有两个按钮的）。显示的按钮名字通过ScriptableWizard.DisplayWizard函数传入。</li></ol><p>ScriptableWizard的API中的消息响应函数：（当满足某些条件下执行这些函数）</p><p>OnWizardCreate ：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”createButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardOtherButton：两个按钮事件中的一个，当传入ScriptableWizard.DisplayWizard函数中”otherButtonName”参数对应的按钮被点击时调用。</p><p>OnWizardUpdate：当向导窗口打开时或者用户改变窗口内容时都会被调用。一般会在这里显示帮助文字和进行内容有效性验证。也可以动态改变按钮状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptableWizardButton</span> : <span class="title">ScriptableWizard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firstObject = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform secondObject = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Example/Show OnWizardOtherButton Usage&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard(<span class="string">&quot;Click info to know the distance between the objects&quot;</span>, <span class="keyword">typeof</span>(ScriptableWizardButton), <span class="string">&quot;Finish!&quot;</span>, <span class="string">&quot;Info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstObject == <span class="literal">null</span> || secondObject == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">false</span>;</span><br><span class="line">            errorString = <span class="string">&quot;Select the objects you want to measure&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                isValid = <span class="literal">true</span>;</span><br><span class="line">            errorString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Info&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardOtherButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> distanceObjs = Vector3.Distance(firstObject.position, secondObject.position);</span><br><span class="line">        EditorUtility.DisplayDialog(</span><br><span class="line">            <span class="string">&quot;The distance between the objects is: &quot;</span> + distanceObjs + <span class="string">&quot; Units&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called when you press the &quot;Finish!&quot; button.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorUtility.DisplayDialog(<span class="string">&quot;OnWizardCreate &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口式编辑器"><a href="#窗口式编辑器" class="headerlink" title="窗口式编辑器"></a>窗口式编辑器</h2><p>菜单栏里添加“Window &gt; MyEditorWnd”。点击打开窗口式面板。</p><p>使用方法：继承EditorWindow，重写“OnGUI”函数。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221121422.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEditorWnd</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">bool</span> groupEnabled;</span><br><span class="line">    <span class="built_in">bool</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">float</span> myFloat = <span class="number">1.23f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add menu named &quot;My Window&quot; to the Window menu</span></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Window/MyEditorWnd&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get existing open window or if none, make a new one:</span></span><br><span class="line">        MyEditorWnd window = (MyEditorWnd)EditorWindow.GetWindow(<span class="keyword">typeof</span>(MyEditorWnd));</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Base Settings&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        myString = EditorGUILayout.TextField(<span class="string">&quot;Text Field&quot;</span>, myString);</span><br><span class="line">        groupEnabled = EditorGUILayout.BeginToggleGroup(<span class="string">&quot;Optional Settings&quot;</span>, groupEnabled);</span><br><span class="line">        myBool = EditorGUILayout.Toggle(<span class="string">&quot;Toggle&quot;</span>, myBool);</span><br><span class="line">        myFloat = EditorGUILayout.Slider(<span class="string">&quot;Slider&quot;</span>, myFloat, <span class="number">-3</span>, <span class="number">3</span>);</span><br><span class="line">        EditorGUILayout.EndToggleGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面板式编辑器"><a href="#面板式编辑器" class="headerlink" title="面板式编辑器"></a>面板式编辑器</h1><p>对于上面提到所有拓展方式中，第三种“面板式编辑器”是最常用的一种，单独开篇。</p><h2 id="是在做什么？"><a href="#是在做什么？" class="headerlink" title="是在做什么？"></a>是在做什么？</h2><p>是在将 EditorGUI 拓展在 Inspector 面板上。</p><p>EditorGUI 和 GUI 的用法几乎完全一致，目前来说前者多用于编辑器开发，后者多用于发布后调试编辑器。总之，它们都是起辅助作用的。 EditorGUI 提供的组件非常丰富，常用的绘制元素包括文本、按钮、图片和滚动框等。做一个好的编辑器，是离不开 EditorGUI 的。</p><p>至于EditorGUI 和 数据的交互，是借由一个继承了MonoBehaviour的脚本的数据字段实现的。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>常规使用方法：</p><ol><li>  首先得有一个MonoBehaviour常规脚本，我们取名为“Show.cs”，可以在内自定义一些字段比如Sprite、List之类的。</li><li>  新建脚本，继承Editor类，标上[CustomEditor(typeof(Show))]标签当挂Showt脚本时就会显示这个编辑器，用来让编辑器和脚本互通。</li><li>  对2中新建的脚本重写”OnInspectorGUI”函数，对自己扩展的组件的编辑界面进行定制。</li></ol><p>以上示例代码见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><p>见<strong>文章【工具篇：Odin 可视化编辑器】</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识编辑器拓展&quot;&gt;&lt;a href=&quot;#初识编辑器拓展&quot; class=&quot;headerlink&quot; title=&quot;初识编辑器拓展&quot;&gt;&lt;/a&gt;初识编辑器拓展&lt;/h1&gt;&lt;h2 id=&quot;支持&quot;&gt;&lt;a href=&quot;#支持&quot; class=&quot;headerlink&quot; title=&quot;支</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity生命流程</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Tech/Game/uiboy_3/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Tech/Game/uiboy_3/</id>
    <published>2022-03-04T14:13:03.127Z</published>
    <updated>2022-03-04T14:13:03.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命流程图"><a href="#生命流程图" class="headerlink" title="生命流程图"></a>生命流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220221094846.png"></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>1、FixedUpdate与Update的不同在于，Update在每帧被调用，但是调用时间不确定，所以我们要实现一个物体匀速运动是，是无法通过Update准确实现的，但是我们可以在FixedUpdate中实现，因为它在确定的时间间隔中被调用。FixedUpdate有可能在Update之前调用多次。FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。</p><p>2、LateUpdate它会在所有update被调用后调用，这个函数可以在我们编写ai时被使用，因为我们要当所有物体和怪物移动过后再判断物体的一些策略，比如开枪等，这个时候就可以在LateUpdate中编写，因为LateUpdate基本可以保证所有物体在本帧的移动等操作均已经完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生命流程图&quot;&gt;&lt;a href=&quot;#生命流程图&quot; class=&quot;headerlink&quot; title=&quot;生命流程图&quot;&gt;&lt;/a&gt;生命流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/CodingCodingK/Coding</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 线程篇</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/thread/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/thread/</id>
    <published>2022-03-04T14:13:03.121Z</published>
    <updated>2022-03-04T14:13:03.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - 类内成员篇</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/method/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/method/</id>
    <published>2022-03-04T14:13:03.120Z</published>
    <updated>2022-03-04T14:13:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>方法、虚方法、属性、字段…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法、虚方法、属性、字段…&lt;/p&gt;
</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="技术" scheme="https://codingcodingk.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#精要 - GC篇</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/gc/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Tech/CSharp/Essence/gc/</id>
    <published>2022-03-04T14:13:03.119Z</published>
    <updated>2022-03-04T14:13:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是GC？为什么需要GC？"><a href="#什么是GC？为什么需要GC？" class="headerlink" title="什么是GC？为什么需要GC？"></a>什么是GC？为什么需要GC？</h1><p>GC，即Garbage Collection，意为垃圾回收。</p><p>.Net不同于原生C++这种需要程序员手动管理内存的机制，存在<strong>自动释放内存的一套机制</strong>，这就叫GC。</p><p>GC可以让程序员<strong>不必关心资源的管理</strong>，也就是一个对象的生命流程中的4：</p><ol><li> 调用IL指令newobj，为代表资源的类型分配内存（C#中用new操作符完成）。</li><li> 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。</li><li> 访问类型的成员来使用资源（有必要可以重复）。</li><li> 摧毁资源的状态以进行清理。</li><li> 释放内存。垃圾回收器独自负责这一步。</li></ol><p>当然可以自己<strong>重写Finalize方法</strong>或手动<strong>调用GC.Collect</strong>。</p><h1 id="简单列举GC的优势（对比手动管理）"><a href="#简单列举GC的优势（对比手动管理）" class="headerlink" title="简单列举GC的优势（对比手动管理）"></a>简单列举GC的优势（对比手动管理）</h1><p>1.让程序员可以不必关心资源的管理。</p><p>2.避免手动管理时，顺序搞错，先销毁后调用导致空引用抛错。</p><p>3.避免手动管理时，由于标记引用未清空导致的内存泄露。</p><h1 id="讲讲GC算法"><a href="#讲讲GC算法" class="headerlink" title="讲讲GC算法"></a>讲讲GC算法</h1><p>三个方向上讲：从总体流程上来说，它有<strong>标记 -&gt; 压缩</strong>两个阶段；从确定是否销毁的方式上来说，它是<strong>从根遍历</strong>的；从销毁处理方式上来说，它是<strong>分代</strong>的。它解决了<strong>引用计数法</strong>循环引用的问题。</p><h2 id="先说下“引用计数法”是什么？为什么不行？"><a href="#先说下“引用计数法”是什么？为什么不行？" class="headerlink" title="先说下“引用计数法”是什么？为什么不行？"></a>先说下“引用计数法”是什么？为什么不行？</h2><p>引用计数是COM(Component Object Model)使用的办法，GC并不是用这个，而是用的从根遍历。说的是堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一“部分”到达代码某个不再需要对象的地方，就递减这个计数，直到0就可以删除了。</p><p>不行的理由很简单，它没有办法处理循环引用的关系，也就是A、B两个对象互相引用，各自引用计数为1，就没法销毁对方。</p><h1 id="1-先从流程上说：标记-gt-压缩"><a href="#1-先从流程上说：标记-gt-压缩" class="headerlink" title="1.先从流程上说：标记 -&gt; 压缩"></a>1.先从流程上说：标记 -&gt; 压缩</h1><p>标记：这个阶段，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含**可达(已标记)与不可达(未标记)**对象。</p><p>标记完成后，进入压缩阶段。</p><p>压缩：在这个阶段中，垃圾回收器线性的遍历堆、并对其进行内存碎片整理。让幸存对象都紧挨在一起，使内存的地址空间得到释放。操作完了之后，对引用了这些堆内对象的指针进行偏移，保持引用与之前一致。</p><p>压缩结束后，如果本次GC并没有分出足够的内存给接下来的new操作，意味着该进程的内存已耗尽，会抛出OutOfMemoryException。</p><h1 id="2-再从确定是否销毁上说：从根遍历"><a href="#2-再从确定是否销毁上说：从根遍历" class="headerlink" title="2.再从确定是否销毁上说：从根遍历"></a>2.再从确定是否销毁上说：从根遍历</h1><h2 id="根（Root）"><a href="#根（Root）" class="headerlink" title="根（Root）"></a>根（Root）</h2><p>我们将所有引用类型的变量都成为<strong>根</strong>，类中定义的任何静态字段，方法的参数，局部变量(仅限引用类型变量)等一系列”引用者”，都是根，根是CLR在堆之外可以找到的各种入口点。</p><h2 id="可达和不可达（Objects-reachable-and-unreachable）"><a href="#可达和不可达（Objects-reachable-and-unreachable）" class="headerlink" title="可达和不可达（Objects reachable and unreachable）"></a>可达和不可达（Objects reachable and unreachable）</h2><p>如果一个根引用了堆中的一个对象，则该对象为“可达”，否则即是“不可达”。不可达的对象是本次销毁的目标。</p><h2 id="引用跟踪"><a href="#引用跟踪" class="headerlink" title="引用跟踪"></a>引用跟踪</h2><p>也就是标记阶段是怎么标记的。</p><p>在这个阶段，CLR会先遍历堆中的所有对象，并全部设置为可回收状态的，然后检查所有活动根，查看他们引用了哪些对象，</p><p>如果一个根包含null，CLR会忽略这个根并检查下一个根；</p><p>如果根引用了堆上的对象，CLR会标记那个对象，并检查这个对象中的根，继续标记它们引用的对象。如果过程中发现对象已标记，则不重新检查，避免了循环引用而造成的死循环。。</p><p>检查完毕后，堆中的对象要么已标记，要么未标记。已标记对象的叫做<strong>可达的</strong>，未标记的对象叫做<strong>不可达的</strong>。</p><h1 id="3-最后说分代回收"><a href="#3-最后说分代回收" class="headerlink" title="3.最后说分代回收"></a>3.最后说分代回收</h1><p>CLR一共有3代：0、1、2代。这是在对可达对象进行处理。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>开始时：CLR初始化会为每一代选择一个<strong>预算容量</strong>。当有对象新分配时，会塞到第0代。</p><p>触发时机：当第0代满了，就会触发GC，没被回收的对象就会成为第1代对象。此时第0代空间中已经不包含任何对象，原来的对象可能已被回收，可能已被放置到第1代中。</p><p>触发特点1：当触发了GC时，第1代内的对象远小于它的预算，那么就不会对第1代进行检查。</p><p>触发特点2：当触发了GC时，可能存在老对象引用了新对象的可能性（比如1代引用0代）。这时新代回收时没有检查到来自老代的引用就会出现错误的回收。为了解决这个问题，垃圾回收器利用了JIT编译器内部的一个机制，这个机制在<strong>对象的引用字段发生变化时，会设置一个对应的标记位</strong>，这样一来垃圾回收器就会知道自上一次垃圾回收以来，哪些老对象的引用字段发生了变化，这样就算这次回收只回收新生代，也会去检测引用字段发生了变化的老对象，是否引用了新生代对象。</p><h2 id="分代回收的意义"><a href="#分代回收的意义" class="headerlink" title="分代回收的意义"></a>分代回收的意义</h2><p>为什么明明是不打算丢弃的可达对象，还要用分代去推出1代、2代呢？全部放0代不就完了？</p><p>事实上是，CLR做出了预设：<strong>回收堆的一部分，速度快于回收整个堆。</strong>事实一般也是如此。</p><p>所以只检查一部分，会比每次都检查全部快很多。</p><h2 id="代预算的动态调节"><a href="#代预算的动态调节" class="headerlink" title="代预算的动态调节"></a>代预算的动态调节</h2><p>在回收第0代后发现存活下来的对象很少，就可能减少第0代的预算，这意味着会更加频繁地执行垃圾回收，但每次回收需要检查的范围更小了。相反，如果回收了第0代后发现还有很多存活的对象，没有多少内存可以回收，就会增大第0代的预算，这样垃圾回收的次数就会减少。</p><h1 id="GC的触发时间点"><a href="#GC的触发时间点" class="headerlink" title="GC的触发时间点"></a>GC的触发时间点</h1><p>除了上文说到的检测到第0代超出预算的时候会触发垃圾回收，还有以下的：</p><h2 id="代码显式调用System-GC的静态Collect方法"><a href="#代码显式调用System-GC的静态Collect方法" class="headerlink" title="代码显式调用System.GC的静态Collect方法"></a>代码显式调用System.GC的静态Collect方法</h2><p>代码可显式请求CLR进行垃圾回收，但微软强烈反对这种请求，托管语言应该信任它本身的垃圾回收机制。</p><p>我日常会在印刷操作的时候调用它。</p><h2 id="Windows报告低内存情况"><a href="#Windows报告低内存情况" class="headerlink" title="Windows报告低内存情况"></a>Windows报告低内存情况</h2><p>如果Windows报告低内存，CLR会强制执行垃圾回收。</p><h2 id="CLR正在卸载AppDomain"><a href="#CLR正在卸载AppDomain" class="headerlink" title="CLR正在卸载AppDomain"></a>CLR正在卸载AppDomain</h2><p>当一个AppDomain卸载时，CLR认为其中一切都不是根，会执行涵盖所有代的垃圾回收。</p><h2 id="CLR正在关闭"><a href="#CLR正在关闭" class="headerlink" title="CLR正在关闭"></a>CLR正在关闭</h2><p>CLR在进程正常终止时关闭，CLR认为其中一切都不是根，对象有机会进行资源清理，但CLR不会试图压缩或释放内存。进程终止时，Windows会回收进程的全部内存。</p><h1 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h1><p>前面讨论的都是小对象，对于大对象（书中说是85000字节以上），CLR会区分对待：</p><p>内存不是在小对象的地址空间分配，而是进程地址空间的其他地方分配；总是第2代；目前不支持压缩。</p><p>所以GC一般不处理他们。</p><h1 id="Finalize方法"><a href="#Finalize方法" class="headerlink" title="Finalize方法"></a>Finalize方法</h1><p>System.Object定义了受保护的虚方法Finalize，如果类型重写了这个方法，对象在被GC判定销毁时会调用它。</p><h2 id="1-new时"><a href="#1-new时" class="headerlink" title="1.new时"></a>1.new时</h2><p>如果对象的类型定义了Finalize方法，那么这个实例在被构造之前，会将一个指向该对象的指针放到一个终结列表中（finalization list）。</p><h2 id="2-被回收时"><a href="#2-被回收时" class="headerlink" title="2.被回收时"></a>2.被回收时</h2><p>在被GC回收时，如果发现这个对象在终结列表中，就先不销毁，而是把指向它的指针扔到<strong>freachable队列中</strong>。</p><h2 id="3-在freachable队列时"><a href="#3-在freachable队列时" class="headerlink" title="3.在freachable队列时"></a>3.在freachable队列时</h2><p>freachable队列也是垃圾回收器的一种内部数据结构，队列中每一个引用都代表准备要调用Finalize方法的对象。当垃圾回收器把对象的引用从终结列表移到freachable队列时，对象不再被认为是垃圾，我们可以说对象被<strong>复活</strong>了。同时，该对象内引用的对象也会被标记、复活。</p><h2 id="4-复活"><a href="#4-复活" class="headerlink" title="4.复活"></a>4.复活</h2><p>说是复活，其实也就是本该销毁的对象延迟销毁了，没有在本该销毁的一次GC下被销毁。</p><p>这些复活的对象会被提升到老一代，之后CLR会用特殊的终结线程去调用freachable队列中每个对象的Finalize方法，并清空队列。之后他们就真正被销毁了。</p><h2 id="5-复活的思考"><a href="#5-复活的思考" class="headerlink" title="5.复活的思考"></a>5.复活的思考</h2><p>由3、4可知，这些定义了Finalize方法的“可终结”的对象，由于在第一次回收时，会被“复活”以执行Finalize方法，并可能会被提升到老一代，所以至少需要执行两次垃圾回收才能释放掉它们占用的托管堆内存，更需要注意到的是，这些对象中的引用字段所引用的对象也会存活下来并提升到老一代，会造成更大的性能负担。所以，要尽量避免为引用类型的字段定义为“可终结”对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是GC？为什么需要GC？&quot;&gt;&lt;a href=&quot;#什么是GC？为什么需要GC？&quot; class=&quot;headerlink&quot; title=&quot;什么是GC？为什么需要GC？&quot;&gt;&lt;/a&gt;什么是GC？为什么需要GC？&lt;/h1&gt;&lt;p&gt;GC，即Garbage Collection</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="C#精要" scheme="https://codingcodingk.github.io/categories/CSharp/C-%E7%B2%BE%E8%A6%81/"/>
    
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="GC" scheme="https://codingcodingk.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 技能编辑器篇</title>
    <link href="https://codingcodingk.github.io/2022/03/04/Project/Unity/Moba/HOK/skilleditor/"/>
    <id>https://codingcodingk.github.io/2022/03/04/Project/Unity/Moba/HOK/skilleditor/</id>
    <published>2022-03-04T14:13:03.118Z</published>
    <updated>2022-03-04T14:13:03.119Z</updated>
    
    <content type="html"><![CDATA[<p>从 技能配置可视化+纯业务 的角度，将原来的技能系统换个角度刨析一遍。</p><h1 id="大体分类"><a href="#大体分类" class="headerlink" title="大体分类"></a>大体分类</h1><p>按照可配置的文件来分类，可分为以下五大类：</p><ul><li>碰撞关系配置</li><li>buff配置</li><li>skill配置</li><li>单位配置</li><li>bullet配置</li></ul><p>下面对这几类的核心配置数据进行列举。</p><h1 id="碰撞关系配置"><a href="#碰撞关系配置" class="headerlink" title="碰撞关系配置"></a>碰撞关系配置</h1><ul><li>目标队伍</li><li>目标选择规则</li><li>目标单位</li><li>目标查找范围</li></ul><h1 id="buff配置"><a href="#buff配置" class="headerlink" title="buff配置"></a>buff配置</h1><ul><li>buff类型</li><li>buff附着目标 // TODO</li><li>buff位置确定方式 // TODO</li><li>碰撞关系配置</li></ul><h1 id="skill配置"><a href="#skill配置" class="headerlink" title="skill配置"></a>skill配置</h1><ul><li>  图片、音效资源路径</li><li></li></ul><h1 id="单位配置"><a href="#单位配置" class="headerlink" title="单位配置"></a>单位配置</h1><p>UnitInfoCfg，比较特殊，为了方便导表，逻辑碰撞体这块只提供一个Enum，在实际加载时使用它的派生类，根据Enum读取出不同的真实逻辑碰撞数据。</p><ul><li>  单位基础属性（基础血量、防御等）</li><li>  单位资源位置</li><li>  单位逻辑碰撞体类型（受击点高度 + 碰撞体大小、形状）</li></ul><h1 id="实现协作"><a href="#实现协作" class="headerlink" title="实现协作"></a>实现协作</h1><p>即想要结点编辑器、又想要表格式的批量填写。将他们协作起来需要多写一些代码，且他们的数据都必须来自同一套数据源——我采用Json数据源。</p><h2 id="Luban"><a href="#Luban" class="headerlink" title="Luban"></a>Luban</h2><p>由Luban提供2套类型：Editor专用的类型，用于和Json数据源交互；运行时使用的类型，也就是真实类型，用于和bytes数据源交互。</p><p>由Luban提供多种格式数据转换：2种Editor可视化面板中填写数据 =&gt; Editor专用Json类 =&gt; Json数据源；Json数据源 =&gt; bytes数据源；bytes数据源 =&gt; 填充运行时对象。</p><h2 id="Odin"><a href="#Odin" class="headerlink" title="Odin"></a>Odin</h2><p>实现在Unity中，表格式的批量填写配置数据。数据依赖于Json数据源，可视化面板需要单独写一套。</p><h2 id="xNode"><a href="#xNode" class="headerlink" title="xNode"></a>xNode</h2><p>实现在Unity中，结点式的树形填写配置数据。数据依赖于Json数据源，可视化面板需要单独写一套。</p><p>要点小记：</p><p>1.比如<code>List&lt;int&gt;</code>类型外键，实现结点连接。<br>2.多个不同类型的buff实现结点。<br>3.如何全遍历图，输出json。</p><h1 id="完全基于数据驱动的xNode连点图"><a href="#完全基于数据驱动的xNode连点图" class="headerlink" title="完全基于数据驱动的xNode连点图"></a>完全基于数据驱动的xNode连点图</h1><p>不依赖于SerializableObj的数据持久化内的数据，每次打开图，全部清空，只根据json数据来重新绘制整张图。这样就能保证多种编辑方式（普通编辑器、连点编辑器、excel）修改同一主体后，保持数据一致。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>需要人为保障准确的，只有Graph的命名，因为这代表着要读取数据的文件路径。按照统一风格标准来命名即可。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ol><li>  根据命名去取对应路径下的json数据源文件，读取；</li><li>  获取依赖的其他json文件（比如skill下的buffList），读取；</li><li>  将所有取得的文件可视化成对应的Node；</li><li>  根据1中获取的信息，对图中Node进行连线。</li></ol><h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><p>一点是，xNode在这里的用途非常小，数据层已完全分离、存于硬盘，graph是打开绘制的也不依赖于SerializableObj；另一点是，xNode效率真的太低了，实时刷新造成结点一多就卡顿。</p><p><strong>所以其实应该基于odin（甚至直接脱离unity用wpf）自己写一套简单的数据可视化连点器</strong>，再去掉它的高频刷新。会比xNode实现轻便的多，画面板也更轻松。最后<strong>加上Timeline，行为树和状态机的模板</strong>，就可以复用了。</p><p><strong>另外，关于luban的使用方式上有一点改进</strong>。比如SKillCfg.BuffList并不需要以int[]的形式去写数据了，而是直接以BuffCfg[]的形式，因为luban是支持多态记录json的。不过由于luban和editor都是UnityMobaDemo搭建完技能系统后才引入的，本次作罢。</p><p>考虑以后采用的技术方案选择：</p><p>时间线编辑器：timline flux slate</p><p>可视化连点器：NodeGraphProcessor</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从 技能配置可视化+纯业务 的角度，将原来的技能系统换个角度刨析一遍。&lt;/p&gt;
&lt;h1 id=&quot;大体分类&quot;&gt;&lt;a href=&quot;#大体分类&quot; class=&quot;headerlink&quot; title=&quot;大体分类&quot;&gt;&lt;/a&gt;大体分类&lt;/h1&gt;&lt;p&gt;按照可配置的文件来分类，可分为以下五大</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：Odin 可视化编辑器</title>
    <link href="https://codingcodingk.github.io/2022/02/20/Tech/Game/tools/odin_study/"/>
    <id>https://codingcodingk.github.io/2022/02/20/Tech/Game/tools/odin_study/</id>
    <published>2022-02-20T08:37:13.533Z</published>
    <updated>2022-03-04T14:13:03.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可视化方案"><a href="#可视化方案" class="headerlink" title="可视化方案"></a>可视化方案</h1><h2 id="什么是Unity的可视化方案"><a href="#什么是Unity的可视化方案" class="headerlink" title="什么是Unity的可视化方案"></a>什么是Unity的可视化方案</h2><p>很多，直接举例一些。</p><h3 id="通用型"><a href="#通用型" class="headerlink" title="通用型"></a>通用型</h3><p>github开源：</p><ul><li>Node_Editor_Framework</li><li>xNode</li></ul><h3 id="特化型"><a href="#特化型" class="headerlink" title="特化型"></a>特化型</h3><p><strong>行为树</strong></p><ul><li>NodeCanvas</li><li>Behavior Designer</li></ul><p><strong>状态机</strong></p><ul><li>FlowCanvas</li><li>Bolt</li><li>PlayerMaker</li></ul><h2 id="行为树编辑器有什么作用"><a href="#行为树编辑器有什么作用" class="headerlink" title="行为树编辑器有什么作用"></a>行为树编辑器有什么作用</h2><ul><li>剧情（对话）编辑</li><li>AI编辑</li><li>技能编辑</li><li>碰撞关系编辑（纯数据，技能和单位是否可以碰撞）</li><li>装备合成路径编辑</li><li>其他</li></ul><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><ul><li>批量配置并不如Excel方便。</li><li>非常适合配合<strong>树状结构</strong>的数据。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>实现Excel和可视化编辑器之间的相互转化，会方便很多。</p><p>下面只进行odin的使用，不再对行为树、状态机一类的可视化插件进行关注。</p><h1 id="原生编辑器"><a href="#原生编辑器" class="headerlink" title="原生编辑器"></a>原生编辑器</h1><h2 id="精灵、List、字典"><a href="#精灵、List、字典" class="headerlink" title="精灵、List、字典"></a>精灵、List、字典</h2><p>show.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Show</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Sprite m_OriginSprite;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">int</span>&gt; m_OriginList</span> = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>&lt;<span class="title">int</span>, <span class="title">int</span>&gt; m_OriginDic</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Show_EditorExtension.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(Show))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Show_EditorExtension</span> : <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Show show = (Show) target;</span><br><span class="line">        show.m_OriginSprite = EditorGUILayout.ObjectField(<span class="string">&quot;这是一个精灵&quot;</span>, show.m_OriginSprite, <span class="keyword">typeof</span>(Sprite), <span class="literal">true</span>) <span class="keyword">as</span> Sprite;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;这是一个按钮&quot;</span>,GUILayout.Width(<span class="number">200</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;点击了按钮&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220220214646.png"></p><h1 id="Odin插件"><a href="#Odin插件" class="headerlink" title="Odin插件"></a>Odin插件</h1><h2 id="精灵、List、字典-1"><a href="#精灵、List、字典-1" class="headerlink" title="精灵、List、字典"></a>精灵、List、字典</h2><p>Show_EditorExtensionBasedOnOdin.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Show_EditorExtensionBasedOnOdin</span> : <span class="title">SerializedMonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">PreviewField</span>]</span><br><span class="line">    [<span class="meta">LabelText(<span class="meta-string">&quot;这是一个精灵&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">public</span> Sprite m_OriginSprite;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">int</span>&gt; m_OriginList</span> = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    [<span class="meta">LabelText(<span class="meta-string">&quot;这是一个字典&quot;</span>)</span>] </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>&lt;<span class="title">int</span>, <span class="title">int</span>&gt; m_OriginDic</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(<span class="meta-string">&quot;这是一个按钮&quot;</span>, 30), GUIColor(0.7f, 0.3f, 1.0f)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestButton</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;点击了按钮。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220220215442.png"></p><h2 id="简单实现Window"><a href="#简单实现Window" class="headerlink" title="简单实现Window"></a>简单实现Window</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyHybridEditorWindowOne</span> : <span class="title">OdinEditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;My Game/My Hybrid Editor&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetWindow&lt;MyHybridEditorWindowOne&gt;().Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">EnumToggleButtons, BoxGroup(<span class="meta-string">&quot;Settings&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> ScaleMode ScaleMode;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">FolderPath(RequireExistingPath = true), BoxGroup(<span class="meta-string">&quot;Settings&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> OutputPath;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">HorizontalGroup(0.5f)</span>]<span class="comment">//占比0.5</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Texture&gt; InputTextures;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HorizontalGroup, InlineEditor(InlineEditorModes.LargePreview)</span>]</span><br><span class="line">    <span class="keyword">public</span> Texture Preview;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(ButtonSizes.Gigantic), GUIColor(0, 1, 0)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PerformSomeAction</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单实现Menu"><a href="#简单实现Menu" class="headerlink" title="简单实现Menu"></a>简单实现Menu</h2><ol><li>  继承OdinMenuEditorWindow</li><li>  使用OdinMenuTree中的<code>Add</code>和<code>AddAllAssetsAtPath</code>函数添加菜单。</li></ol><p><strong>Add：</strong> 设置菜单名称并传入对应需要渲染的类</p><p><strong>AddAllAssetsAtPath：</strong>设置菜单名称，传入路径，示例中的第一个bool是指是否包含子路径，第二bool表示是否子路径的所有可用类都在一个层级中渲染，也就是要不要分Menu子选项。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyMenuEditorWindow</span> : <span class="title">OdinMenuEditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;My Game/My Menu Editor&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetWindow&lt;MyMenuEditorWindow&gt;().Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> OdinMenuTree <span class="title">BuildMenuTree</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tree = <span class="keyword">new</span> OdinMenuTree();</span><br><span class="line">        tree.Selection.SupportsMultiSelect = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        tree.Add(<span class="string">&quot;Settings&quot;</span>, GeneralDrawerConfig.Instance);</span><br><span class="line">        tree.Add(<span class="string">&quot;Utilities&quot;</span>, <span class="keyword">new</span> TextureUtilityEditor());</span><br><span class="line">        tree.AddAllAssetsAtPath(<span class="string">&quot;Odin Settings&quot;</span>, <span class="string">&quot;Assets/Plugins/Sirenix&quot;</span>, <span class="keyword">typeof</span>(ScriptableObject), <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TextureUtilityEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BoxGroup(<span class="meta-string">&quot;Tool&quot;</span>), HideLabel, EnumToggleButtons</span>]</span><br><span class="line">    <span class="keyword">public</span> Tool Tool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Texture&gt; Textures;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(ButtonSizes.Large), HideIf(<span class="meta-string">&quot;Tool&quot;</span>, Tool.Rotate)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeAction</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Button(ButtonSizes.Large), ShowIf(<span class="meta-string">&quot;Tool&quot;</span>, Tool.Rotate)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeOtherAction</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="xNode插件"><a href="#xNode插件" class="headerlink" title="xNode插件"></a>xNode插件</h1><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><h1 id="odin与luban-导表工具-结合"><a href="#odin与luban-导表工具-结合" class="headerlink" title="odin与luban(导表工具)结合"></a>odin与luban(导表工具)结合</h1><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>luban 生成编辑器专用类型代码 =&gt; 编辑器中制作生成原始数据 json（编译器读存专用） =&gt; luban 处理json，导出成 运行时用的bytes 或 运行时用的json =&gt; 程序使用。</p><p>也就是说，每一个Cfg类型，如果想要在编辑器中调试，需要额外准备一套类型代码（继承自 EditorBeanBase，luban可以生成），与运行时中使用的类型相同。</p><ol><li>写[xml/excel]定义数据类型</li><li>[xml/excel]生成Editor专用class类型，对其代码进行标签处理（odin在这里派上用场，美化编辑器页面）</li><li>——————————-以下为需要重复的操作——————————-</li><li>使用Editor生成json数据 / 使用Editor读取json文件</li><li>json数据 + [xml/excel] 生成bytes数据</li><li>bytes数据作为运行时配置</li></ol><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>这一套工作流，我已经写成了一个简单的示例。</p><p>开源地址：<a href="https://github.com/CodingCodingK/odin_study">https://github.com/CodingCodingK/odin_study</a></p><p>在这里感谢一下luban作者！教了我很多关于工作流搭建的思路和为什么这么做。</p><h1 id="手册收藏"><a href="#手册收藏" class="headerlink" title="手册收藏"></a>手册收藏</h1><p>方便自己写的时候查询。</p><p><a href="https://www.jianshu.com/p/a37bd00d12f2">非常全面的中文教程</a></p><p><a href="https://odininspector.com/attributes">odin官方手册</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;可视化方案&quot;&gt;&lt;a href=&quot;#可视化方案&quot; class=&quot;headerlink&quot; title=&quot;可视化方案&quot;&gt;&lt;/a&gt;可视化方案&lt;/h1&gt;&lt;h2 id=&quot;什么是Unity的可视化方案&quot;&gt;&lt;a href=&quot;#什么是Unity的可视化方案&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="编辑器" scheme="https://codingcodingk.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>UI常见优化</title>
    <link href="https://codingcodingk.github.io/2022/02/19/Tech/Game/uiboy_2/"/>
    <id>https://codingcodingk.github.io/2022/02/19/Tech/Game/uiboy_2/</id>
    <published>2022-02-19T05:08:45.208Z</published>
    <updated>2022-03-04T14:13:03.127Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。</p><h1 id="Unity性能优化"><a href="#Unity性能优化" class="headerlink" title="Unity性能优化"></a>Unity性能优化</h1><h2 id="优化关键"><a href="#优化关键" class="headerlink" title="优化关键"></a>优化关键</h2><p>先找到性能瓶颈。影响图形性能的关键因素主要有一下几个方面。</p><ol><li> GPU填充率和存储器带宽。</li><li> CPU经常是渲染物体的数量（也就是常常大家说的Draw Calls）。</li><li> 系统内存容量也是优化的一个关键指标。</li></ol><h2 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h2><p>GPU优化主要有下面几点：</p><ol><li>  减少三角形的使用数量（去掉不必要的三角形面）。</li><li>  尽量避免使用实时光照，能使用Static Lighting就使用烘焙光照，只计算一次。</li><li>  压缩纹理和多重纹理-minmaps（这样可以提高加载速度和降低内存占用），也极大提高渲染的性能。</li><li>  LOD（多细节层次），不同距离使用不同精度的模型。</li><li>  编写高性能着色器，将能能处理的逻辑放在定点着色器里面处理，减少片段着色器的计算量。</li></ol><h2 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h2><p>CPU主要开销在，显卡在渲染一个对象之前，CPU需要计算一些着色器和灯光影响，然后想显卡驱动发送绘制指令，单物体来说，不会太影响性能，累计就会产生性能问题。这里优化点主要从以下几个方面讨论，这里只是说出优化常用的方案，后面如果在下在项目里面遇到更加好的方案，或者是方法，我将会在这里补充出来。也欢迎大家指出错误，或者是更好的CPU优化方案。</p><ol><li> 合并材质球相同的对象，进而减少绘制指令的发送。合并的方式有，手工合并或者是使用Unity内置的选项合并，或者是使用自制脚本合并模型对象，但是注意的是:非相同材质对象，合并不会对性能有任何的提高。</li><li> 在对象或场景中使用更少的材质。可以将独立的纹理合并成一个更大的纹理图集，但是合并时注意，合并要以方便开发，节省资源为基础。</li><li> 避免使用物体被渲染多次的效果，这里主要体现在（反射，阴影，像素光照等）。</li><li> 优化游戏代码，也是优化CPU的一个关键点。</li></ol><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>性能优化最后一点，就是内存的优化，要优化Unity的内存资源，就首先必须了解内存的资源管理模式，以及Unity资源加载的方式，Unity资源动态加载主要有下面两种方式：</p><ol><li> Resource方式资源加载。</li><li> AssetBundle资源加载方式。</li></ol><p>这两种资源加载方式都提供同步和异步加载API，这里我就过多介绍AIP是哪些，使用的时候可以直接查看。这里需要注意的是资源加载到内存里面的规范到底是什么样的，观察下面的图就一目了然。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210105112.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;收集一些常见的UI优化手段和思路。当然，大部分是抄的，希望以后自己有能力总结。&lt;/p&gt;
&lt;h1 id=&quot;Unity性能优化&quot;&gt;&lt;a href=&quot;#Unity性能优化&quot; class=&quot;headerlink&quot; title=&quot;Unity性能优化&quot;&gt;&lt;/a&gt;Unity性能优化&lt;/h</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UI屏幕自适应</title>
    <link href="https://codingcodingk.github.io/2022/02/19/Tech/Game/uiboy_1/"/>
    <id>https://codingcodingk.github.io/2022/02/19/Tech/Game/uiboy_1/</id>
    <published>2022-02-19T05:08:45.192Z</published>
    <updated>2022-03-04T14:13:03.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="面板基本"><a href="#面板基本" class="headerlink" title="面板基本"></a>面板基本</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217103517.png"></p><p>当我们点击一个GUI物体是它具有的属性为：</p><p><strong>Rect Transform</strong>：继承自Transform组件，它表示的是控件的Location位置，和一些基本的属性。这个控件的参数类型会随着锚点情况而改变，具体在下一节展示。</p><p><strong>Pivot</strong>：设置轴心（不是蓝色的，那个叫中心锚点）的位置，中心点的位置【0,0】表示的是控件的左下角的位置，【1,1】表示的是右上角的位置，【0.5,0.5】表示的是图像中心的位置。</p><p><strong>Anchors</strong>：它的取值和Pivot一个逻辑，也是0~1之间。Min点和Max点是2个点，2个点可以沿着x、y方向，确定出一个矩形。而这个矩形的4个点就是4个锚点。我们也可以直接拖动画面的锚点来快捷设置。</p><h2 id="Pivot-和-Center"><a href="#Pivot-和-Center" class="headerlink" title="Pivot 和 Center"></a>Pivot 和 Center</h2><p>Pivot上面说了，是轴心，可以自己在Rect Transform的面板里设置；</p><p>Center是中心，是在Unity中根据模型的mesh信息计算得到的中心位置，是所有物体共同的中心，如果同时选中了多个物体，则坐标是所有模型共同参与计算出来的坐标。</p><p>Center是由Unity计算出来的而不是设置出来的。Pivot在锚点重合情况下，代表着PosX和PosY画出来的的点。</p><h2 id="锚点、纽扣和中心点-Center"><a href="#锚点、纽扣和中心点-Center" class="headerlink" title="锚点、纽扣和中心点(Center)"></a>锚点、纽扣和中心点(Center)</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217104252.png"></p><p>这里先对3个点下定义，下面一节进行讨论。</p><p>单击图形显示着的的小篮圈，到底表示的是Pivot还是Center，是在Unity里设置的，两者完全不是一个东西。设置的话，在Global边上的选项里选择即可。</p><p>正常的二维UI，中心点总是在正中间，而轴心就可以自己设置了。</p><h1 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h1><h2 id="情况一：两个锚点重合"><a href="#情况一：两个锚点重合" class="headerlink" title="情况一：两个锚点重合"></a>情况一：两个锚点重合</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>两个锚点重合的情况，Image UI（也就是红色Image）的锚点和Pivot连成一条线，这条线会永远保持（也就是两点的距离会永远保持）。<strong>在这种情况下调整画面，Image UI不会变形，只会根据Pivot点到Anchor点的距离一致的原则调整位置。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120309.png"></p><p>一个值得关注的点是，此时Image UI的Rect Transform控件是Pos + Width,Height的组合。这个PosX和Y，指的是Anchor和Pivot之间的相对位置。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217120631.png"></p><h3 id="示例动图"><a href="#示例动图" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored1.gif"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored2.gif"></p><h2 id="情况二：锚框"><a href="#情况二：锚框" class="headerlink" title="情况二：锚框"></a>情况二：锚框</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>当两个锚点（AnchorMin和AnchorMax）不重合时，两点就会确定一个矩形，这个矩形就是我们的锚框。<strong>这种情况会保持锚点到纽扣的距离保持不变。</strong></p><p>此时Image UI的Rect Transform控件是Left,Top + Right,Bottom的组合。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217121839.png"></p><p>这四个点什么意思呢？是纽扣的相对位置，相对的是锚点组成的坐标系。看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217134116.png"></p><p>所以明白了，锚点到纽扣的距离保持不变，那就意味着4条（图中2条以及左上右下未画出来的）绿线始终保持不变。同时意味着，代表这4个点相对位置的Rect Transform控件里的Left,Top,Right,Bottom值也都不变。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217135538.png"></p><h3 id="示例动图-1"><a href="#示例动图-1" class="headerlink" title="示例动图"></a>示例动图</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/UI_Anchored3.gif"></p><h2 id="anchoredPosition属性"><a href="#anchoredPosition属性" class="headerlink" title="anchoredPosition属性"></a>anchoredPosition属性</h2><p>他本身是一个点，如果在AnchorMin和AnchorMax是重合的场合（情况一）下，anchoredPosition就是表示锚点到Pivot的位置。</p><p>但是如果AnchorMin和AnchorMax不重合的时候（情况二），anchoredPosition就比较复杂了，在这种情况下，Unity会根据Pivot、AnchorMin和AnchorMax计算出一个锚点，然后在通过Pivot和锚点来得出anchoredPosition的位置。</p><h2 id="offsetMin和offsetMax详解"><a href="#offsetMin和offsetMax详解" class="headerlink" title="offsetMin和offsetMax详解"></a>offsetMin和offsetMax详解</h2><p>offsetMin和offsetMax这两个属性。其中offsetMin表示物体（本文中的红框）左下角相对AnchorMin的偏移，offsetMax表示物体右上角相对AnchorMax的偏移。</p><p>情况一 anchor(0, 0)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151909.png"></p><p>情况二 anchorMin(0,0) anchorMax(1,1)：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217151935.png"></p><h2 id="sizeDelta详解"><a href="#sizeDelta详解" class="headerlink" title="sizeDelta详解"></a>sizeDelta详解</h2><p>sizeDelta就是offsetMax - offsetMin的值，即物体左下角到右上角的变量：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152058.png"></p><h1 id="画布缩放器-Canvas-Scaler"><a href="#画布缩放器-Canvas-Scaler" class="headerlink" title="画布缩放器 Canvas Scaler"></a>画布缩放器 Canvas Scaler</h1><p>Canvas新建时自带的脚本，专门解决屏幕适配问题的脚本，负责伸缩所有UI对象。以下内容主要取自<a href="https://docs.unity3d.com/cn/current/Manual/script-CanvasScaler.html">Unity中文手册</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220217152713.png"></p><p>三种模式：</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>UI Scale Mode</strong></td><td align="left">确定画布中的 UI 元素的缩放方式。</td></tr><tr><td align="left"><strong>Constant Pixel Size</strong></td><td align="left">无论屏幕大小如何，UI 元素都保持相同的像素大小。</td></tr><tr><td align="left"><strong>Scale With Screen Size</strong></td><td align="left">屏幕越大，UI 元素越大。</td></tr><tr><td align="left"><strong>Constant Physical Size</strong></td><td align="left">无论屏幕大小和分辨率如何，UI 元素都保持相同的物理大小。</td></tr></tbody></table><p>一般来说的配置方案是：<br>Canvas Scaler 选择 Scale With Screen Size<br>Screen Match Mode 选择 Match Width Or Height，</p><p>横屏游戏比例设为1，即只和高度进行适配；</p><p>竖屏游戏比例设为0，即只和宽度进行适配。</p><h2 id="1、Constant-Pixel-Size"><a href="#1、Constant-Pixel-Size" class="headerlink" title="1、Constant Pixel Size"></a>1、Constant Pixel Size</h2><p>一般美术拿它来做缩放图片，因为不同Size不失真。</p><p>使用 Constant Pixel Size 模式时，可在屏幕上按像素指定 UI 元素的位置和大小。这也是画布在未附加任何画布缩放器时的默认功能。但是，借助画布缩放器中的“Scale Factor”设置，可以向画布中的所有 UI 元素应用常量缩放。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Scale Factor</strong></td><td align="left">按此系数缩放画布中的所有 UI 元素。画布的缩放比例。默认况下为1，表示正常大小。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。每单位代表的像素量。</td></tr></tbody></table><h2 id="2、Scale-With-Screen-Size"><a href="#2、Scale-With-Screen-Size" class="headerlink" title="2、Scale With Screen Size"></a>2、Scale With Screen Size</h2><p>使用 Scale With Screen Size 模式时，可以根据指定参考分辨率的像素来指定位置和大小。如果当前屏幕分辨率大于参考分辨率，则画布会保持只具有参考分辨率的分辨率，但是会放大以便适应屏幕。如果当前屏幕分辨率小于参考分辨率，则画布会相应缩小以适应屏幕。</p><p>如果当前屏幕分辨率的宽高比与参考分辨率不同，则单独缩放每个轴以适应屏幕会形成非一致缩放，通常不希望发生这种情况。相反，ReferenceResolution 组件会使画布分辨率偏离参考分辨率，以便遵循屏幕的宽高比。可以使用 Screen Match Mode 设置控制此偏离的行为方式。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Reference Resolution</strong></td><td align="left">UI 布局设计的目标分辨率。如果屏幕分辨率较大，则 UI 会放大，如果较小，则 UI 会缩小。</td></tr><tr><td align="left"><strong>Screen Match Mode</strong></td><td align="left">在当前分辨率的宽高比不适应参考分辨率时，用于缩放画布区域的模式。</td></tr><tr><td align="left"><strong>Match Width or Height</strong>⭐常用</td><td align="left">以宽度、高度或二者的某种平均值作为参考来缩放画布区域。</td></tr><tr><td align="left"><strong>Expand</strong></td><td align="left">水平或垂直扩展画布区域，使画布不会小于参考。</td></tr><tr><td align="left"><strong>Shrink</strong></td><td align="left">水平或垂直裁剪画布区域，使画布不会大于参考。</td></tr><tr><td align="left"><strong>Match</strong></td><td align="left">确定是否以宽度、高度或二者的某种平均值作为参考进行缩放。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则精灵中的每个像素将覆盖 UI 中的一个单位。</td></tr></tbody></table><h2 id="3、Constant-Physical-Size"><a href="#3、Constant-Physical-Size" class="headerlink" title="3、Constant Physical Size"></a>3、Constant Physical Size</h2><p>使用 Constant Physical Size 模式时，可按物理单位（如毫米、点或派卡）指定 UI 元素的位置和大小。此模式要求设备正确报告其屏幕 DPI。对于不报告 DPI 的设备，可以指定回退 DPI。</p><table><thead><tr><th align="left">属性</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>Physical Unit</strong></td><td align="left">用于指定位置和大小的物理单位。</td></tr><tr><td align="left"><strong>Fallback Screen DPI</strong></td><td align="left">在屏幕 DPI 未知时采用的 DPI。</td></tr><tr><td align="left"><strong>Default Sprite DPI</strong></td><td align="left">用于精灵的每英寸像素，使其“Pixels Per Unit”设置与“Reference Pixels Per Unit”设置匹配。</td></tr><tr><td align="left"><strong>Reference Pixels Per Unit</strong></td><td align="left">如果精灵具有此“Pixels Per Unit”设置，则其 DPI 将与“Default Sprite DPI”设置匹配。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;h2 id=&quot;面板基本&quot;&gt;&lt;a href=&quot;#面板基本&quot; class=&quot;headerlink&quot; title=&quot;面板基本&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Game/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀复刻项目 背包系统篇</title>
    <link href="https://codingcodingk.github.io/2022/02/19/Project/Unity/Moba/HOK/bag/"/>
    <id>https://codingcodingk.github.io/2022/02/19/Project/Unity/Moba/HOK/bag/</id>
    <published>2022-02-19T05:08:45.183Z</published>
    <updated>2022-03-04T14:13:03.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>数据库中只存储物品id、物品数量；客户端本地二进制式存储cfg，来显示物品详情；服务端本地二进制式存储cfg，来确定物品效果。</p><p>整体流程如下：</p><ol><li>  客户端登录时，获取到背包信息（物品id、物品数量）。</li><li>  客户端打开背包时，根据内存中的背包信息 + 本地cfg，来展示物品。</li><li>  客户端使用物品时，发送请求到服务端并让服务端在数据库验证数量。</li><li>  如果数量不足，则失败；</li><li>  如果数量足够，则根据服务端本地cfg来计算出账号收益，更新数据库后返回结果给客户端。</li><li>  客户端获得返回结果，刷新内存数据。</li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>  虚拟列表</li><li>  对象池</li><li>  摊帧加载</li></ul><h1 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h1><h2 id="Scroller-View"><a href="#Scroller-View" class="headerlink" title="Scroller View"></a>Scroller View</h2><p>Viewport，遮罩，决定能看到的内容。（视野）</p><p>Content，真实内容。（履带）</p><p>设置格子锚点到左上角。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>主要分为3块。</p><ul><li>  BagMgr，用来获取道具信息。</li><li>  BagItem，背包格子类。</li><li>  BagPanel，背包页面逻辑。</li></ul><h2 id="显式获取"><a href="#显式获取" class="headerlink" title="显式获取"></a>显式获取</h2><p>要计算出 起始显示的格子索引值、结束显示的格子索引值：</p><p>=====================================================================</p><p>  <strong>可视范围的起始位置Y</strong> / 一个格子的高 = 可视范围中，起始显示的是哪一行（向下取整），</p><p>  可视范围中，起始显示的是哪一行 * 一行有多少格子 = <strong>起始显示的格子索引值</strong>，</p><p>  用同样的方法，根据<strong>可视范围的结束位置Y</strong>也可以计算出<strong>结束显示的格子索引值</strong>。</p><p>=====================================================================</p><p>将上面计算出来的索引值取下来记录，放到 Dictionary&lt;int索引,格子对象&gt; 里。这些就是画面正要显示的格子们。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220215101132.png"></p><h2 id="格子位置确定"><a href="#格子位置确定" class="headerlink" title="格子位置确定"></a>格子位置确定</h2><p>物品位置确定。通过简单计算获得：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index是物品下标, oneRowColumns是一行几个, childWidth是格子宽度, paddingWidth是格子横向间隔</span></span><br><span class="line">go.transform.localPosition = <span class="keyword">new</span> Vector3((index % oneRowColumns) * (childWidth + paddingWidth), - (index / oneRowColumns) * (childHeight + paddingHeight),<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="未显示就不加载的虚拟列表"><a href="#未显示就不加载的虚拟列表" class="headerlink" title="未显示就不加载的虚拟列表"></a>未显示就不加载的虚拟列表</h2><p>显式获取 + 格子位置确定 就可以实现。</p><h1 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h1><p>在上面<strong>未显示就不加载的虚拟列表</strong>的实现基础上，进行优化。</p><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>对物品进行对象池管理，加载从池中取，销毁就返回池。</p><h2 id="去掉加载过、现在不显示的物品"><a href="#去掉加载过、现在不显示的物品" class="headerlink" title="去掉加载过、现在不显示的物品"></a>去掉加载过、现在不显示的物品</h2><p>在update中调用刷新物品方法，</p><p>计算显示下标 =&gt; 根据本次下标范围与上次记录下来的下标范围，算出哪些不再显示 =&gt; 把他们放回对象池。</p><h2 id="摊帧加载"><a href="#摊帧加载" class="headerlink" title="摊帧加载"></a>摊帧加载</h2><p>将<strong>异步加载</strong>的过程<strong>放入协程</strong>中执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步加载协程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">AsyncLoad</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> path, UnityAction&lt;T&gt; callBack</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        ResourceRequest rr = Resources.LoadAsync&lt;T&gt;(path);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> rr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rr.asset <span class="keyword">is</span> GameObject)</span><br><span class="line">        &#123;</span><br><span class="line">            callBack?.Invoke(GameObject.Instantiate&lt;T&gt;(rr.asset <span class="keyword">as</span> T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            callBack?.Invoke(rr.asset <span class="keyword">as</span> T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>demo已上传<a href="https://github.com/CodingCodingK/bag_study">github</a>。</p><h1 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h1><p>实际项目使用更为复杂。这里只展示一下实现了什么。</p><ul><li>  物品数量数据库存储：使用字符串标记，规则<code>物品id:数量</code>类似于<code>1:2#3:1#5:10</code>。</li><li>  物品选择状态显示：简单业务实现。</li><li>  服务端物品检测：数据处理使用服务端本地cfg读表，避免客户端作弊。</li><li>  二进制读表：luban 二进制读表，在加载流程中读取物品配置。</li><li>  优化：虚拟列表 + 对象池。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计&quot;&gt;&lt;a href=&quot;#设计&quot; class=&quot;headerlink&quot; title=&quot;设计&quot;&gt;&lt;/a&gt;设计&lt;/h1&gt;&lt;h2 id=&quot;基本实现&quot;&gt;&lt;a href=&quot;#基本实现&quot; class=&quot;headerlink&quot; title=&quot;基本实现&quot;&gt;&lt;/a&gt;基本实现&lt;/h</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/categories/Unity/Moba/"/>
    
    <category term="王者荣耀复刻项目" scheme="https://codingcodingk.github.io/categories/Unity/Moba/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%8D%E5%88%BB%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="工程" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="Moba" scheme="https://codingcodingk.github.io/tags/Moba/"/>
    
  </entry>
  
  <entry>
    <title>什么叫“二进制”配置方案？</title>
    <link href="https://codingcodingk.github.io/2022/02/12/Tech/Game/serialize/"/>
    <id>https://codingcodingk.github.io/2022/02/12/Tech/Game/serialize/</id>
    <published>2022-02-12T04:24:46.318Z</published>
    <updated>2022-02-13T05:03:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的很懵，刚好自己的demo有用，挖一下。</p><h1 id="先说二进制式存储"><a href="#先说二进制式存储" class="headerlink" title="先说二进制式存储"></a>先说二进制式存储</h1><p>要理解为什么二进制更优，先明白什么是二进制式存储。</p><h2 id="什么是二进制文件？"><a href="#什么是二进制文件？" class="headerlink" title="什么是二进制文件？"></a>什么是二进制文件？</h2><p>所有对计算机有所了解的人肯定都知道计算机的存储在物理上是二进制（01）形式的。所以文本文件与二进制文件的区别并不是物理上，而是逻辑上的。其本质是两者在编码层次上的差异。简单的来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据应用的具体情况自定义自己的编码。</p><p>从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。</p><h2 id="文本文件是怎么读取的？"><a href="#文本文件是怎么读取的？" class="headerlink" title="文本文件是怎么读取的？"></a>文本文件是怎么读取的？</h2><p>文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。</p><p>比如选取ASCII码形式（ASCII码的一个字符是8个比特），它就会8个比特地来解释这个文件流：”01000000 01000001 01000010 01000011”用ASCII码解析出来是“ABCD”，显示在文本编辑器上。</p><h2 id="二进制文件vs文本文件"><a href="#二进制文件vs文本文件" class="headerlink" title="二进制文件vs文本文件"></a>二进制文件vs文本文件</h2><p><strong>译码难度</strong>：一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。</p><p><strong>文件大小</strong>：关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。</p><h1 id="再聊二进制配置"><a href="#再聊二进制配置" class="headerlink" title="再聊二进制配置"></a>再聊二进制配置</h1><h2 id="二进制和json的关系"><a href="#二进制和json的关系" class="headerlink" title="二进制和json的关系"></a>二进制和json的关系</h2><p>要存储一个json文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;time&quot; = 133,</span><br><span class="line">  &quot;color&quot; = [233, 0, 0],</span><br><span class="line">  &quot;pos&quot; = [34, 22]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>json一般以utf-8格式保存成文本</strong>，utf-8是unicode编码的一种实现形式。也就是说，像程序中的数字类型133，233，22等，一个uint8就能存储下了，可是133在json中却占了3个字节，要是存个12.432312等数据要占用更多的空间。而本文所说的二进制配置，直接存133等的uint8二进制编码0x85，这样便减少了一部分文件大小。<strong>编码与解码可以商量好自己的规则</strong>，比如time，编解码都以t代替，又可以节省一部分空间，甚至可以不存储time，color，pos等key，直接顺序在配置中写value，解码时直接读value（为了说的清楚，后面的例子保留了key）这样又可以减少配置文件的大小。</p><h2 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h2><blockquote><p>  序列化是将对象or对象图(比如数组)转换成字节流的过程，反序列化是将字节流转换回对象图的过程。</p></blockquote><p>上面这段来自我clr笔记的定义，就可以明白大佬们说的“二进制来做”，做的是序列化反序列化。</p><p>不通过这种常规读取方式：</p><p>读取utf-8的.json文件 =&gt; 将utf-8读取成二进制流byte[] =&gt; 此时byte[]是json字符串，也就是json序列化后的产物，我们再通过反射(至少我常用的库是反射)反序列化 =&gt; 反序列化完成，返回一个对象。</p><p>那如果加入“二进制来做”的读取方式：</p><p>读取.bin文件 =&gt; 二进制文件更小读取很快，获取到二进制流byte[]，然后根据自己定好的的规则去读流(比如按顺序获取定长比特来读取)，反序列化 =&gt; 反序列化完成，返回一个对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大佬们说的“二进制来做”，其实想指的是一个解决方案而不是指最终存的文件是二进制式的这么简单。</p><p>你可以<strong>可以自己写规则</strong>，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Custom_MemoryStream</span> : <span class="title">MemoryStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReadInt</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">base</span>.Read(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = BitConverter.GetBytes(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">base</span>.Write(arr, <span class="number">0</span>, arr.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 类似的还有很多比如string，这里略了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entity <span class="title">MakeEntity</span>(<span class="params">MemoryStream ms</span>)</span>&#123;</span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity();</span><br><span class="line">    entity.Id = ms.ReadInt();</span><br><span class="line">    entity.Name = ms.ReadString();</span><br><span class="line">    entity.Path = ms.ReadString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用现成的解决方案比如protobuf、FlatBuffers，他们的最终文件也都是<strong>二进制式的而不是文本格式，且读取的时候读二进制流直接按长度转换成字段</strong>。</p><p>最后，接上导表工具，就算成了。</p><p>可能对于定义上还是有一点点误解，以后会来改。但是我相信，无论怎样，目的都是为了更快、更小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为本职是软开，PC以及服务器级平台根本不太在意文件的大小，更在乎可读。所以，一听有大佬和我说“商业项目本地配置读写，用二进制来做”，我真的</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="优化" scheme="https://codingcodingk.github.io/categories/Game/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Enum转换List</title>
    <link href="https://codingcodingk.github.io/2022/02/12/Tech/CSharp/experience/20220209_1/"/>
    <id>https://codingcodingk.github.io/2022/02/12/Tech/CSharp/experience/20220209_1/</id>
    <published>2022-02-12T04:24:46.313Z</published>
    <updated>2022-02-12T04:24:46.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EnumToList"><a href="#EnumToList" class="headerlink" title="EnumToList"></a>EnumToList</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">EnumToList</span>&lt;<span class="title">T</span>&gt;(<span class="params">Type enumType</span>) <span class="keyword">where</span> T : ComboBoxSourceItem, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (enumType.BaseType == <span class="keyword">typeof</span>(System.Enum))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> enumValue <span class="keyword">in</span> System.Enum.GetValues(enumType))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 値の説明を取得する</span></span><br><span class="line">                    FieldInfo fi = enumType.GetField(System.Enum.GetName(enumType, enumValue));</span><br><span class="line">                    <span class="keyword">if</span> (fi != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> description =</span><br><span class="line">                            (DescriptionAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(DescriptionAttribute));</span><br><span class="line">                        <span class="keyword">var</span> content =</span><br><span class="line">                            (DefaultValueAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(DefaultValueAttribute));</span><br><span class="line">                        <span class="keyword">var</span> code = (CodeAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(CodeAttribute));</span><br><span class="line">                        <span class="keyword">var</span> descriptionEn =</span><br><span class="line">                            (DescriptionEnAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(DescriptionEnAttribute));</span><br><span class="line">                        <span class="keyword">var</span> isKarte =</span><br><span class="line">                            (IsKarteAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(IsKarteAttribute));</span><br><span class="line">                        <span class="keyword">var</span> isIji =</span><br><span class="line">                            (IsIjiAttribute)Attribute.GetCustomAttribute(fi, <span class="keyword">typeof</span>(IsIjiAttribute));</span><br><span class="line"></span><br><span class="line">                        T obj = <span class="keyword">new</span> T();</span><br><span class="line">                        obj.Content = content?.Value.ToString() ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.Value = Convert.ToInt32(enumValue);</span><br><span class="line">                        obj.Description = description?.Description ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.DescriptionEn = descriptionEn?.DescriptionEn ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.Code = code?.Code ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">                        obj.IsKarte = isKarte?.IsKarte ?? <span class="literal">false</span>;</span><br><span class="line">                        obj.IsIji = isIji?.IsIji ?? <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                        result.Add(obj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;EnumToList&quot;&gt;&lt;a href=&quot;#EnumToList&quot; class=&quot;headerlink&quot; title=&quot;EnumToList&quot;&gt;&lt;/a&gt;EnumToList&lt;/h1&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="CSharp" scheme="https://codingcodingk.github.io/categories/CSharp/"/>
    
    <category term="一些坑" scheme="https://codingcodingk.github.io/categories/CSharp/%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：本地配置</title>
    <link href="https://codingcodingk.github.io/2022/02/08/Tech/Game/tools/luban_study/"/>
    <id>https://codingcodingk.github.io/2022/02/08/Tech/Game/tools/luban_study/</id>
    <published>2022-02-08T07:27:47.192Z</published>
    <updated>2022-03-04T14:13:03.125Z</updated>
    
    <content type="html"><![CDATA[<p>非常感谢 luban 的作者，提供了如此好用的工具，并热心的教了我很多关于实际工作流的思路，对于我来说，这些都是很宝贵的。</p><h1 id="初识luban"><a href="#初识luban" class="headerlink" title="初识luban"></a>初识luban</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>就目前我的使用来说，luban可以用于excel导出配置数据、可以用于生成proto协议（并使用Bright.Net的序列化框架）、可以用于编辑器交互、可以用于编辑器数据源与运行时真实配置数据交互。是一个各方面都非常成熟的配置文件、通信协议的解决方案。</p><p>开源地址 ： <a href="https://github.com/focus-creative-games/luban">github</a></p><p>案例开源地址：<a href="https://github.com/focus-creative-games/luban_examples">github</a></p><blockquote><p>luban高效地处理游戏开发中常见的excel、json、xml之类的数据，检查数据错误，生成c#等各种语言的代码，导出成bytes或json等多种格式。</p><ul><li>强大的数据解析和转换能力 {excel(csv,xls,xlsx), json, bson, xml, yaml, lua, unity ScriptableObject} =&gt; {binary, json, bson, xml, lua, yaml, erlang}</li><li>增强的excel格式，可以简洁地配置出像简单列表、子结构、结构列表，以及任意复杂的深层次的嵌套结构。</li><li>完备的类型系统，<strong>支持OOP类型继承</strong>，搭配excel、json、lua、xml等格式数据<strong>灵活优雅</strong>表达行为树、技能、剧情、副本之类复杂GamePlay数据</li><li>支持生成 protobuf(schema + binary + json)、flatbuffers(schema + json)、msgpack(binary)</li><li>强大的数据校验能力。ref引用检查，path资源路径检查等等</li><li>支持生成c#,java,go,c++,lua,python,javascript,typescript,erlang,rust代码</li><li>完善的本地化支持</li><li>强大灵活的自定义能力，支持代码模板和数据模板</li><li>**==通用型生成和缓存工具==**。也可以用于生成协议、数据库之类的代码，甚至可以用作对象缓存服务</li><li><strong>良好支持主流引擎、全平台、主流热更新方案、主流前后端框架</strong>。支持unity、unreal、cocos2x、微信小游戏等主流引擎。工具自身跨平台，能在Win,Linux,Mac平台良好工作。<a href="https://focus-creative-games.github.io/lubandoc/feature.html#%E6%94%AF%E6%8C%81%E4%B8%BB%E6%B5%81%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80">详见</a></li></ul></blockquote><h1 id="配置第一个Unity项目"><a href="#配置第一个Unity项目" class="headerlink" title="配置第一个Unity项目"></a>配置第一个Unity项目</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>1.下载<a href="https://dotnet.microsoft.com/en-us/download/dotnet/6.0">.net 6.0 sdk</a>。</p><p>2.下载案例luban_examples。</p><p>3.创建Unity工程，从luban_examples\Projects的Csharp_Unity_json中复制 <strong>luban_Libs</strong>目录到Unity Assets工程下。</p><p>4.在Project Settings菜单的Player里，设置开启unsafe。</p><p>5.从luban_examples\Tools复制 <strong>Luban.ClientServer工具库</strong> 和 <strong>MiniDesignerConfigsTemplate文件夹</strong> 到Unity工程（不能放到Assets！这个不是给Unity加载的所以其实放外面都行）下。</p><h2 id="6-配置bat文件"><a href="#6-配置bat文件" class="headerlink" title="6.配置bat文件"></a>6.配置bat文件</h2><p>从luban_examples\Projects的Csharp_Unity_json中复制 <strong>gen_code_json.bat 文件</strong> 到5中的同级目录。之后开始编辑bat文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> WORKSPACE=.. -- unity工程目录地址</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> GEN_CLIENT=%WORKSPACE%\Luban\Luban.ClientServer\Luban.ClientServer.exe -- 运行exe文件地址</span><br><span class="line"><span class="built_in">set</span> CONF_ROOT=%WORKSPACE%\Luban\MiniDesignerConfigsTemplate -- 自己的配置表的根目录地址</span><br><span class="line"></span><br><span class="line">%GEN_CLIENT% -j cfg --^</span><br><span class="line"> -d %CONF_ROOT%\Defines\__root__.xml ^</span><br><span class="line"> --input_data_dir %CONF_ROOT%\Datas ^ -- 配置表目录地址</span><br><span class="line"> --output_code_dir %WORKSPACE%/Assets/Gen ^ -- 配置表输出地址</span><br><span class="line"> --output_data_dir ..\GenerateDatas\json ^</span><br><span class="line"> --gen_types code_cs_unity_json,data_json ^</span><br><span class="line"> -s all </span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="7-配置表"><a href="#7-配置表" class="headerlink" title="7.配置表"></a>7.配置表</h2><p>上面CONF_ROOT的地址里就是我们的工作文件夹，这里采用案例的 MiniDesignerConfigsTemplate文件夹，在里面的Datas文件夹里有已经做好excel表格案例。</p><h2 id="8-执行bat文件并调用"><a href="#8-执行bat文件并调用" class="headerlink" title="8.执行bat文件并调用"></a>8.执行bat文件并调用</h2><p>调用后生成的就是json了，可以直接用。下面简单使用一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Tables table = <span class="keyword">new</span> Tables(Loader);</span><br><span class="line">    Item item = table.TbItem.Get(<span class="number">10010</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;<span class="subst">&#123;item.Name&#125;</span>    <span class="subst">&#123;item.Desc&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JSONNode <span class="title">Loader</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JSON.Parse(File.ReadAllText(Application.dataPath + <span class="string">&quot;/../GenerateDatas/json/&quot;</span> + fileName + <span class="string">&quot;.json&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="excel基本：自定义类型"><a href="#excel基本：自定义类型" class="headerlink" title="excel基本：自定义类型"></a>excel基本：自定义类型</h1><p>从小到大：enum &gt; bean &gt; table。</p><h2 id="enums"><a href="#enums" class="headerlink" title="enums"></a>enums</h2><p>自定义枚举enum。</p><ul><li>full_name，必选。枚举名。命名空间为当前module的完整命名空间（包含父module）。</li><li>flags，可选。是否为bit标志位类型。默认false。</li><li>unique，可选。枚举值是否唯一。默认true。</li><li>comment，可选。注释。</li><li>var.name，必选。枚举名。</li><li>var.alias，可选。别名。</li><li>var.value，可选。枚举值，不填则为上一个枚举项目值+1。</li><li>var.comment，可选。注释。</li><li>可以填枚举的 枚举项名，别名 或者 相应整数值 表达这个枚举。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210002955.png"></p><h2 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h2><p>自定义class，也就是数据表每行的结构。</p><ul><li>full_name，必选。结构（类）名，包含命名空间。</li><li>sep，可选。分割符。该结构以复合模式填写，例如MyIntVector3包含x,y,z三个int字段，通过sep=”,”，则所有读取MyIntVector3时，都会将读入的字符串用<code>,</code>拆分成三个整数。</li><li>var.name，必选。字段名。</li><li>var.type，必选。类型名。</li><li>var.group，可选。所属分组。可以多个，以<code>,</code>分割，每个值必须是root.xml中定义的group中的一个；如果不填，则该字段属于所有分组。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210003206.png"></p><h2 id="tables"><a href="#tables" class="headerlink" title="tables"></a>tables</h2><p>数据索引表，将excel们联系起来。只有记载在本表的文件，才会被输出。</p><ul><li>define_from_file，必选。false是取已有定义（也就是类型写在beans.excel里了）；true是取未有定义，也就是直接根据数据表的表头、标题等自动生成定义。</li><li>full_name，必选。资源字典全名(包含模块和名字)，一般习惯取名<code>TbXXX</code>，以后调用的时候就直接<code>table.TbXXX.Get(key);</code>来获取到资源。</li><li>value_type，必选。生成的类名，也是全名，要包含namespace。如果需要读取beans表里定义好的类型，那必须与那边的 namespace.类名 完全一致。</li><li>input，必选。文件列表，也就是数据表的地址。</li><li>index，可选。就是<code>table.TbXXX.Get(key);</code>的key，不写默认是类型第一个字段。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210003331.png"></p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>这个就是数据了，表的名字就是类名。</p><ul><li>前三行分别填写 字段名、字段类型、字段中文注释，后面的行就是数据了。</li><li>可以根据数据表直接生成对应的类结构，并不是必须要写beans表，只要table表里设置define_from_file就好。</li><li>对于枚举值，可以填枚举的 <strong>枚举项名，别名 或者 相应整数值</strong> 表达这个枚举。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220210003523.png"></p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> cfg;</span><br><span class="line"><span class="keyword">using</span> cfg.Datas; </span><br><span class="line"><span class="keyword">using</span> SimpleJSON;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Tables table = <span class="keyword">new</span> Tables(Loader);</span><br><span class="line">        Equip equip = table.Weapon.Get(<span class="number">1</span>);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;equip.Name&#125;</span>    <span class="subst">&#123;equip.Color&#125;</span>    <span class="subst">&#123;equip.Quality&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JSONNode <span class="title">Loader</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.Parse(File.ReadAllText(Application.dataPath + <span class="string">&quot;/../GenerateDatas/json/&quot;</span> + fileName + <span class="string">&quot;.json&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weapon.json</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;眼球&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;次元碎片&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">120</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;无限&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">999</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">999</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;塔拉夏的眼球&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;眼光&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;NPC赌来的法杖&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">120</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="excel进阶：List与关联外键"><a href="#excel进阶：List与关联外键" class="headerlink" title="excel进阶：List与关联外键"></a>excel进阶：List与关联外键</h1><p>光上面这样是不够的，我研究了一下手册，根据自己的项目需求整理了最合适的方案来解决List和外键的连接。不得不说，luban真的好用。</p><h2 id="List与关联外键"><a href="#List与关联外键" class="headerlink" title="List与关联外键"></a>List与关联外键</h2><h3 id="excel配置"><a href="#excel配置" class="headerlink" title="excel配置"></a>excel配置</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212193619.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212194113.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212194245.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220212194348.png"></p><h3 id="生成-json"><a href="#生成-json" class="headerlink" title="生成 json"></a>生成 json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;Color&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;Quality&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;眼球&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;SPD&quot;</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">&quot;Skill&quot;</span>: [</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"> ... <span class="comment">// 后面略了</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>和前面一样方法，json加载全表。使用的时候，有一个<code>equip.Skill_Ref</code>，这个Ref就是外键加载进来的<code>List&lt;Skills.SkillCfg&gt;</code>类型数据。</p><h2 id="分隔符sep"><a href="#分隔符sep" class="headerlink" title="分隔符sep"></a>分隔符sep</h2><p><code>list,string</code> =&gt; <code>  (list#sep=,),string</code></p><h1 id="excel进阶：使用luban生成protobuf协议并接上自己的网络库"><a href="#excel进阶：使用luban生成protobuf协议并接上自己的网络库" class="headerlink" title="excel进阶：使用luban生成protobuf协议并接上自己的网络库"></a>excel进阶：使用luban生成protobuf协议并接上自己的网络库</h1><h2 id="1-准备xml"><a href="#1-准备xml" class="headerlink" title="1.准备xml"></a>1.准备xml</h2><p><strong>luban的root配置</strong></p><p><code>__root__.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">topmodule</span> <span class="attr">name</span>=<span class="string">&quot;proto&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">name</span>=<span class="string">&quot;.&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;client&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefix</span> <span class="attr">value</span>=<span class="string">&quot;proto&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;server&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefix</span> <span class="attr">value</span>=<span class="string">&quot;proto&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>protobuf协议</strong>（不是最佳实践，CMD可以去掉，因为会生成协议号）：</p><p><code>test.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">&quot;CMD&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;None&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;Ping&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;ReqLogin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;RspLogin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">enum</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;Ping&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;isOver&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bool&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;ReqLogin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;acct&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;psd&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;RspLogin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span> <span class="attr">type</span>=<span class="string">&quot;list,LoginInfo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;LoginInfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;lv&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;exp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">proto</span> <span class="attr">name</span>=<span class="string">&quot;NetMsg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;cmd&quot;</span> <span class="attr">type</span>=<span class="string">&quot;CMD?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;ping&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Ping?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;reqLogin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ReqLogin?&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span> <span class="attr">name</span>=<span class="string">&quot;rspLogin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;RspLogin?&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proto</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-配置bat文件"><a href="#2-配置bat文件" class="headerlink" title="2.配置bat文件"></a>2.配置bat文件</h2><p>注意这么写的话，protobuf的xml 和 root.xml 需要放一块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> WORKSPACE=..</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> GEN_CLIENT=%WORKSPACE%\Luban\Luban.ClientServer\Luban.ClientServer.exe</span><br><span class="line"><span class="built_in">set</span> PROTO_ROOT=%WORKSPACE%\Luban\MiniDesignerConfigsTemplate\ProtoDefines</span><br><span class="line"></span><br><span class="line">%GEN_CLIENT% -j proto --^</span><br><span class="line"> -d %PROTO_ROOT%\__root__.xml ^</span><br><span class="line"> --output_code_dir %WORKSPACE%\Assets\Gen ^</span><br><span class="line"> --gen_type cs ^</span><br><span class="line"> --cs:use_unity_vector ^</span><br><span class="line"> -s all </span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="3-迁移unity"><a href="#3-迁移unity" class="headerlink" title="3.迁移unity"></a>3.迁移unity</h2><p>代码生成完毕后，Unity会显示缺失很多文件。把<code>luban_examples-main\ProtoProjects\Csharp_Unity\Assets</code>下的三个文件夹移到Unity目录下。</p><p>分别是：Bright.Core Bright.Net Bright.Serialization。</p><p>这是luban所依赖的protobuf序列化器。</p><h2 id="4-简单实用示例"><a href="#4-简单实用示例" class="headerlink" title="4.简单实用示例"></a>4.简单实用示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ProtoSerialize</span>&lt;<span class="title">T</span>&gt;(<span class="params">T msg</span>) <span class="keyword">where</span> T : Protocol,<span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> bf = <span class="keyword">new</span> ByteBuf();</span><br><span class="line">    msg.Serialize(bf);</span><br><span class="line">    <span class="keyword">return</span> bf.CopyData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">ProtoDeSerialize</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">byte</span>[] bytes</span>) <span class="keyword">where</span> T : Protocol, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> bf = <span class="keyword">new</span> ByteBuf(bytes);</span><br><span class="line">    T instance = <span class="keyword">new</span> T();</span><br><span class="line">    instance.Deserialize(bf);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-接上自己的网络库"><a href="#5-接上自己的网络库" class="headerlink" title="5.接上自己的网络库"></a>5.接上自己的网络库</h2><p>我自己的kcp网络库使用了这一套东西，替换了protobuf-net。开源地址：</p><p><a href="https://github.com/CodingCodingK/CodingK_Session">https://github.com/CodingCodingK/CodingK_Session</a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="bat命令"><a href="#bat命令" class="headerlink" title="bat命令"></a>bat命令</h2><p>禁止名字优化：</p><p> –naming_convention:module none  ^<br> –naming_convention:bean_member none  ^<br> –naming_convention:enum_member none  ^</p><p>二进制data+cs生成类型：</p><p> –gen_types code_cs_bin,data_bin ^</p><p>其他：<a href="https://focus-creative-games.github.io/lubandoc/command_tools.html#luban-client-%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">github手册</a></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>直接去luban_examples-main文件夹里拷贝bat吧！</p><h1 id="二进制配置文件优化"><a href="#二进制配置文件优化" class="headerlink" title="二进制配置文件优化"></a>二进制配置文件优化</h1><h2 id="原理部分"><a href="#原理部分" class="headerlink" title="原理部分"></a>原理部分</h2><p>原理部分，写在<a href="https://codingcodingk.top/2022/02/08/Tech/Game/serialize/">另外一篇</a>里了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;非常感谢 luban 的作者，提供了如此好用的工具，并热心的教了我很多关于实际工作流的思路，对于我来说，这些都是很宝贵的。&lt;/p&gt;
&lt;h1 id=&quot;初识luban&quot;&gt;&lt;a href=&quot;#初识luban&quot; class=&quot;headerlink&quot; title=&quot;初识luban&quot;&gt;</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="网络库" scheme="https://codingcodingk.github.io/tags/%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：async-await在unity中的应用</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/unity_await-async/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/unity_await-async/</id>
    <published>2022-02-01T02:52:39.179Z</published>
    <updated>2022-02-01T02:52:39.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>简而言之，Unity协同程序使用C＃对迭代器块的内置支持来实现。 您提供给StartCoroutine方法的IEnumerator迭代器对象由Unity保存，每个框架都会向前转发此迭代器对象，以获取由协调程序返回的新值。 然后，您可以通过Unity读取不同的值，以触发特殊情况行为，例如执行嵌套协同程序（返回另一个IEnumerator）时，延迟几秒钟（返回类型为WaitForSeconds的实例） 等到下一帧（返回null时）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;p&gt;简而言之，Unity协同程序使用C＃对迭代器块的内置支持来实现。 您提供给StartCoroutine方法的IEnumerator迭代器对象</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="协程" scheme="https://codingcodingk.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：定时系统</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingKTimer/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingKTimer/</id>
    <published>2022-02-01T02:52:39.176Z</published>
    <updated>2022-02-08T07:22:53.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h1><p><a href="https://github.com/CodingCodingK/CodingKTimer">CodingKTimer</a></p><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="为什么需要定时系统"><a href="#为什么需要定时系统" class="headerlink" title="为什么需要定时系统"></a>为什么需要定时系统</h2><p>Unity侧：</p><ol><li>  简化协程计时写法。</li><li>  协程基于Monobehaviour来实现，而物体激活属性变化会导致中断调用。这可由定时器解决。</li><li>  不需要依赖于unityAPI。</li></ol><p>服务端侧：</p><p>​       简化代码 =&gt; 支持多线程、指定线程。</p><h1 id="PETimer"><a href="#PETimer" class="headerlink" title="PETimer"></a>PETimer</h1><h2 id="TickTimer-高频高精度的毫秒级定时"><a href="#TickTimer-高频高精度的毫秒级定时" class="headerlink" title="TickTimer (高频高精度的毫秒级定时)"></a>TickTimer (高频高精度的毫秒级定时)</h2><ul><li>  支持多线程；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  可使用外部循环驱动计时，也可使用驱动线程（内部new的）来执行；</li><li>  定时回调默认是线程池工作线程运行，也就是在<strong>驱动线程</strong>中运行，也可<strong>外部自己驱动Handle</strong>运行；</li></ul><p>内部使用线程安全字典ConcurrentDictionary来存储Task，遍历过程中Remove无影响。</p><h3 id="调用线程"><a href="#调用线程" class="headerlink" title="调用线程"></a>调用线程</h3><p>线程可以使用新工作线程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用新线程：</span></span><br><span class="line">timerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(StartTick));</span><br><span class="line">timerThread.Start();</span><br></pre></td></tr></table></figure><p>也可以在Unity的Update中调用计时器内部 UpdateTask() 方法，确定性地使用Unity主线程。</p><p>另外还有一种方式就是自己调用<strong>Handle</strong>，也可以确定性地使用外部线程（比如Unity主线程）来执行任务：</p><ol><li><p>内部的新工作线程不再负责执行任务，而是对一个 线程安全队列 进行任务添加。</p></li><li><p>在<strong>外部 调用HandleTask()方法</strong> 来执行 内部队列 中的任务。</p></li></ol><h2 id="AsyncTimer-大量并发任务的定时"><a href="#AsyncTimer-大量并发任务的定时" class="headerlink" title="AsyncTimer (大量并发任务的定时)"></a>AsyncTimer (大量并发任务的定时)</h2><ul><li>  支持多线程；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  使用 async await异步语法计时，运行在线程池中；</li><li>  定时回调可以在驱动线程中运行，也可在外部 Handle 运行</li></ul><h3 id="时间修正"><a href="#时间修正" class="headerlink" title="时间修正"></a>时间修正</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">task.fixDelta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 限次循环任务</span></span><br><span class="line">     --task.count;</span><br><span class="line">     ++task.loopIndex;</span><br><span class="line">     <span class="comment">// ③ 修正误差</span></span><br><span class="line">     <span class="built_in">int</span> delay = (<span class="built_in">int</span>)(task.delay + task.fixDelta);</span><br><span class="line">     <span class="keyword">if</span> (delay &gt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(delay, task.ct);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// ① 计算出实际开销时间</span></span><br><span class="line">     TimeSpan ts = DateTime.UtcNow - task.startTime;</span><br><span class="line">     <span class="comment">// ② 修正实际时间值 = 理论开销时间 - 实际开销时间</span></span><br><span class="line">     task.fixDelta = (<span class="built_in">int</span>)(task.delay * task.loopIndex - ts.TotalMilliseconds);</span><br><span class="line"></span><br><span class="line">     CallBackTaskCB(task);</span><br><span class="line">&#125; <span class="keyword">while</span> (task.count &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>由于delay的累加会出现问题（主要是因为执行代码本身需要时间），导致出现 真实运行时间 与 逻辑运行时间 有偏差，所以需要修正每次delay的值从而保证真实运行时间。</p><p>比如14:00:00起了个定时任务，delay为1小时，结果15:00:00的时候开始执行任务，任务本身花掉了10s，那么就变成14:00:10的时候去+了一小时的delay。下一次执行就变成16:00:10了而不是计划中的16:00:00。用delta修正即可。</p><h2 id="FrameTimer-主要用于逻辑帧数的定时"><a href="#FrameTimer-主要用于逻辑帧数的定时" class="headerlink" title="FrameTimer (主要用于逻辑帧数的定时)"></a>FrameTimer (主要用于逻辑帧数的定时)</h2><ul><li>  只可在单线程当中运行；</li><li>  不依赖 Unity引擎环境，可在客户端服务器使用；</li><li>  只能由外部循环驱动计数；</li><li>  定时回调只可以在驱动线程中运行；</li></ul><p>内部不创建线程计时，只能外部驱动。内部没有时间概念，<strong>完全不再计时只计数</strong>。</p><p>在服务端中或和客户端中，按自己的执行帧来每次调用，调用一次算一帧。其实就相当于只有前面两种Timer的Handle方法。</p><p>delay不再是时间，而是帧数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的解决方案&quot;&gt;&lt;a href=&quot;#我的解决方案&quot; class=&quot;headerlink&quot; title=&quot;我的解决方案&quot;&gt;&lt;/a&gt;我的解决方案&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CodingCodingK/CodingKTimer</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="定时系统" scheme="https://codingcodingk.github.io/tags/%E5%AE%9A%E6%97%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：protobuf序列化</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/protobuf/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/protobuf/</id>
    <published>2022-02-01T02:52:39.172Z</published>
    <updated>2022-02-12T04:24:46.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Protobuf-初识"><a href="#Protobuf-初识" class="headerlink" title="Protobuf 初识"></a>Protobuf 初识</h1><h2 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h2><blockquote><p>  Google Protocol Buffers(简单Protobuf或PB) 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关 、可扩展的序列化结构数据格式 。目前，几乎支持所有主流编程语言 。</p></blockquote><p>他和xml、json一样，都属于数据标记语言。</p><h2 id="Protobuf优势"><a href="#Protobuf优势" class="headerlink" title="Protobuf优势"></a>Protobuf优势</h2><ol><li>  序列化与反序列化速度极快。</li><li>  与语言及平台无关，兼容性好，通过 proto文件生成多种语言文件 =&gt; 实现 服务端、客户端之间 跨语言平台的数据转换。</li><li>  数据高度压缩 =&gt; 占用空间少，节省带宽。</li></ol><h2 id="Protobuf使用"><a href="#Protobuf使用" class="headerlink" title="Protobuf使用"></a>Protobuf使用</h2><p><a href="https://github.com/protocolbuffers/protobuf">google官方全版本支持</a></p><p><a href="https://github.com/protobuf-net/protobuf-net">.net专用版本 作者Marc Gravell(本篇使用)</a></p><h2 id="Protobuf对比C-常规序列化"><a href="#Protobuf对比C-常规序列化" class="headerlink" title="Protobuf对比C#常规序列化"></a>Protobuf对比C#常规序列化</h2><p><strong>标签不同</strong>，常规只需要对类打上<code>[Serializable]</code>，而Protobuf需要对类打上<code>[ProtoContract]</code>，再对属性打上<code>[ProtoMember(1)]</code>，中间的数字是tag对应一个属性。</p><p><strong>调用不同</strong>，常规需要 Stream 配合 BinaryFormatter 来实现，protobuf的话是 Stream 配合 ProtoBuf.Serializer：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProtoBuf Serialize</span></span><br><span class="line"><span class="built_in">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    ProtoBuf.Serializer.Serialize(ms, person);</span><br><span class="line">    bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[ms.Length];</span><br><span class="line">    Buffer.BlockCopy(ms.GetBuffer(), <span class="number">0</span>, bytes, <span class="number">0</span>, (<span class="built_in">int</span>)ms.Length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoBuf DeSerialize</span></span><br><span class="line">PersonInfo newPerson = <span class="keyword">new</span> PersonInfo();</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream(bytes))</span><br><span class="line">&#123;</span><br><span class="line">    newPerson = ProtoBuf.Serializer.Deserialize&lt;PersonInfo&gt;(ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoBuf 本地存储读取</span></span><br><span class="line">PersonInfo newPerson_file = <span class="keyword">new</span> PersonInfo();</span><br><span class="line"><span class="keyword">using</span> (FileStream file = File.Create(<span class="string">&quot;person.bytes&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ProtoBuf.Serializer.Serialize(file, person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (FileStream file = File.OpenRead(<span class="string">&quot;person.bytes&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    newPerson_file = ProtoBuf.Serializer.Deserialize&lt;PersonInfo&gt;(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节量大幅优化</strong>，对2种bytes都进行输出，简单使用能直接缩10倍以上：</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220201211810.png"></p><h2 id="需求提纯"><a href="#需求提纯" class="headerlink" title="需求提纯"></a>需求提纯</h2><p>那么最后，我们要做什么？</p><ol><li>使用protobuf通信，且<strong>自动化解决</strong>最基础的打标签方式，因为那太过繁琐。</li><li>需要<strong>支持多平台</strong>，所以直接排除<code>[Serializable]</code>。</li></ol><h1 id="Protobuf-网络通信解决方案"><a href="#Protobuf-网络通信解决方案" class="headerlink" title="Protobuf 网络通信解决方案"></a>Protobuf 网络通信解决方案</h1><h2 id="1-制定协议"><a href="#1-制定协议" class="headerlink" title="1.制定协议"></a>1.制定协议</h2><h2 id="2-获取工具"><a href="#2-获取工具" class="headerlink" title="2.获取工具"></a>2.获取工具</h2><p>在 <a href="https://github.com/protobuf-net/protobuf-net">.net专用版本 作者Marc Gravell(本篇使用)</a> 中，编译源码获取 <strong>protoc.exe</strong> 和 压缩包中的 <strong>protogen.exe</strong> 两个文件。</p><h2 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3.生成代码"></a>3.生成代码</h2><h3 id="定义文件-proto"><a href="#定义文件-proto" class="headerlink" title="定义文件  .proto"></a>定义文件  .proto</h3><p><strong>相当于把之前C#实现的整个协议重写一遍。建议使用IDE VSCode来检查语法。</strong></p><p>syntax - 使用proto    package - 定义头文件名</p><p>message - 类    enum - 枚举类</p><p>required - 必须的    optional - 非必须的    repeated - 重复的，用于List</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> LogicProtocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum写法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CMD</span> </span>&#123;</span><br><span class="line">    LogicLogin = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据包写法(支持嵌套类)</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Pkg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> Head head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> Body body = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> CMD cmd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> seq = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> error = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> ReqLogicLogin reqLogicLogin = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> RspLogicLogin rspLogicLogin = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用工具-protogen-exe"><a href="#使用工具-protogen-exe" class="headerlink" title="使用工具 protogen.exe"></a>使用工具 protogen.exe</h3><p>protoc.exe也可以用于生成c#代码，但是数据更多，所以直接使用protogen.exe。</p><ol><li>cmd进入对应路径。</li><li>可以使用<code>protogen -h</code>命令来获取命令help。</li><li>输入指令<code>.\soft\protogen.exe --csharp_out=.\ .\NetProtocol.proto</code>来生成代码。</li></ol><p>指令解析：</p><ul><li>.\soft\protogen.exe 工具位置</li><li>–csharp_out=.\ 输出位置</li><li>.\NetProtocol.proto 文件位置</li></ul><h2 id="4-对比cs和proto协议区别"><a href="#4-对比cs和proto协议区别" class="headerlink" title="4.对比cs和proto协议区别"></a>4.对比cs和proto协议区别</h2><p>proto中的package转换成 <code>namespace</code>。</p><p>为每一个class和enum打上标签 <code>[global::ProtoBuf.ProtoContract()]</code>。括号里面是反射时识别的类名，不写就直接是类名。</p><p>为每一个属性打上标签 <code>[global::ProtoBuf.ProtoMember(1)]</code>。括号里是proto文件中定义的数字。</p><h1 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h1><h2 id="我的可视化GUI"><a href="#我的可视化GUI" class="headerlink" title="我的可视化GUI"></a>我的可视化GUI</h2><p>我将集成这些功能到自己做的wpf工具中（.proto生成.cs）。</p><p><a href="https://github.com/CodingCodingK/CodingKExcelParser">github地址</a></p><h2 id="我的UDP-C-S服务器通信解决方案"><a href="#我的UDP-C-S服务器通信解决方案" class="headerlink" title="我的UDP C-S服务器通信解决方案"></a>我的UDP C-S服务器通信解决方案</h2><p>基于KCP优化UDP传输可靠性的 Unity/.net Client - .net Server 通信解决方案，可以选择proto协议，内有案例。</p><p><a href="https://github.com/CodingCodingK/CodingK_Session">github地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Protobuf-初识&quot;&gt;&lt;a href=&quot;#Protobuf-初识&quot; class=&quot;headerlink&quot; title=&quot;Protobuf 初识&quot;&gt;&lt;/a&gt;Protobuf 初识&lt;/h1&gt;&lt;h2 id=&quot;什么是Protobuf&quot;&gt;&lt;a href=&quot;#什么是Pro</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="protobuf" scheme="https://codingcodingk.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>工具篇：帧同步网络库</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingK_Session/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/tools/CodingK_Session/</id>
    <published>2022-02-01T02:52:39.169Z</published>
    <updated>2022-02-12T04:24:46.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h1><p><a href="https://github.com/CodingCodingK/CodingK_Session">CodingK_Session</a></p><h1 id="聊聊网络"><a href="#聊聊网络" class="headerlink" title="聊聊网络"></a>聊聊网络</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>起源于1969年美国国防部的军用项目，最初只是一个单个的分组交换网ARPANET（并不是一个互连的网络）。1983年TCP/IP协议成为ARPANET上的标准协议，使所有使用 TCP/IP协议 的计算机都能利用互连网相互通信。因此1983年被当作因特网（Internet）诞生的时间。之后经过不断发展，形成了如今的英特网（Internet）。</p><h3 id="网络通信是指什么？"><a href="#网络通信是指什么？" class="headerlink" title="网络通信是指什么？"></a>网络通信是指什么？</h3><p>计算设备之间通过网络交换数据，更通俗地说法就是：主机A上的某个程序（进程）与主机B上的某个程序（进程）进行数据交换。</p><h3 id="网络通信如何实现？"><a href="#网络通信如何实现？" class="headerlink" title="网络通信如何实现？"></a>网络通信如何实现？</h3><p>计算设备之间通过共同遵守的 网络协议（network protocol） ，以约定好的规则来交换数据。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>五层协议的体系结构</p><p>OSI七层协议：概念清楚，理论完整，但它复杂不实用。</p><p><strong>TCP/IP四层</strong>协议：应用非常广泛。实质上，TCP/IP只有上面三层，最下层的网络接口层并没有什么具体内容。</p><p>综合前面两者，我们一般采用<strong>五层协议的体系结构</strong>来学习理解计算机网络原理。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220123211028.png"></p><h3 id="五层协议功能划分"><a href="#五层协议功能划分" class="headerlink" title="五层协议功能划分"></a>五层协议功能划分</h3><p><strong>应用层</strong>：直接为用户的应用进程提供服务。这一层的协议很多，比如HTTP协议（浏览器）、SMTP协议（邮件）、FTP协议（文件传输）等。</p><p><strong>运输层</strong>：运输应用层的数据，多个应用进程可同时使用运输层的服务，以及分发运输层的信息到应用层中相应的进程上。运输层主要使用两种协议：</p><ul><li><p>传输控制协议TCP(Transmission Control Protocol）: 面向连接 ，以报文段（segment）为传输单位，保证传输的可靠性。</p></li><li><p>用户数据报协议UDP(User Datagram Protocol）: 无连接 以用户数据报为传输单位，不保证传输的可靠性。</p></li></ul><p><strong>网络层</strong>：把运输层的报文段或用户数据报封装成 分组或包 进行传送。网络层使用IP协议，因此分组也叫作 IP数据报 ，简称数据报。此外网络层还要选择合适的路由，使运输层里的数据通过网络中的路由器找到目的主机。</p><p><strong>数据链路层</strong>：数据在网络上传输时总是在一段一段的链路上传送的（主机和路由器之间或者两个路由器之间），这时需要链接层的协议将网络层交下来的IP数据报组装成 帧（framing） ，以便在相邻的链路之间传送。数据帧里包含了必要的 传输控制信息 。</p><p><strong>物理层</strong>：在物体层上所传数据就是比特流。用不同的电压代表「0」或「1」，在硬件设备上实现数据传输。</p><p>注意：现在我们常提到的TCP/IP并不一定单指TCP和IP两个具体的协议，而是指组成因特网时所使用的整个 TCP/IP协议族 （protocol suite），还包括了其它协议，比如：DNS协议（域名转换为IP地址）、ARP协议（IP地址转换为mac地址）等等。</p><h2 id="TCP对比UDP"><a href="#TCP对比UDP" class="headerlink" title="TCP对比UDP"></a>TCP对比UDP</h2><h3 id="简易TCP通信案例"><a href="#简易TCP通信案例" class="headerlink" title="简易TCP通信案例"></a>简易TCP通信案例</h3><p>TCP所谓的建立连接并不是在物理层面建立什么连接，而是通过在通信两端建立一定的数据结构来维护双方交互的状态，用这样的<strong>数据结构</strong>来保证所谓的面向连接的特性，实现可靠传输。</p><h3 id="简易UDP通信案例"><a href="#简易UDP通信案例" class="headerlink" title="简易UDP通信案例"></a>简易UDP通信案例</h3><p>UDP在局域网基本不会丢包，很多内网的服务都是用UDP开发，简单高效易用。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在.net core使用以下2个包实现TCP/UDP通信，1个包实现指定数据流格式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br></pre></td></tr></table></figure><p>个人简易demo源码（UDP、TCP）：</p><h1 id="实现帧同步网络库"><a href="#实现帧同步网络库" class="headerlink" title="实现帧同步网络库"></a>实现帧同步网络库</h1><p>作为HOK demo的工具组之一。</p><h2 id="为什么使用UDP"><a href="#为什么使用UDP" class="headerlink" title="为什么使用UDP"></a>为什么使用UDP</h2><p>使用帧同步需要非常频繁交互。UDP更快，没有TCP那么繁琐的机制和包头额外数据。</p><h2 id="KCP入门"><a href="#KCP入门" class="headerlink" title="KCP入门"></a>KCP入门</h2><p>一套高效确认算法，可以让数据传输变得可靠有序 。</p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220124203153.png"></p><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126215129.png"></p><h3 id="KCP源码"><a href="#KCP源码" class="headerlink" title="KCP源码"></a>KCP源码</h3><p><a href="https://github.com/skywind3000/kcp">源码地址</a>，手册很细致，里面也有一些原理性质的概念。</p><p><a href="https://github.com/KumoKyaku/KCP">C#版本</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>会话ID必须由服务器统一分配，不可重复。</p><p>实现模拟连接以便识别不同客户端数据。</p><p>双端复用代码，抽象网络会话类，进行数据收发。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>在NuGet市场上就有，不用非去github下源码。</p><h2 id="基于KCP实现的可靠UDP通信"><a href="#基于KCP实现的可靠UDP通信" class="headerlink" title="基于KCP实现的可靠UDP通信"></a>基于KCP实现的可靠UDP通信</h2><h3 id="发番协定"><a href="#发番协定" class="headerlink" title="发番协定"></a>发番协定</h3><p>初次连接，传4个空字节过去。</p><p>当服务端收到后知道是新客户端，就生成全局唯一uuid并返回，返回的形式是“4个空字节+uuid”。客户端收到后设置KCPSession的sid。</p><p>kcp添加控制信息的包里，头4个字节的数字对应传入的int值，每一个字节可以转化为对应的0~255的数字。而4个字节刚好对应一个uint32，也就是传入<code>new Kcp(sid, m_handle)</code>的sid。</p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>客户端和服务端分别实现Session，两边通用一样的结构（KCPNet），但是用不一样的遍历逻辑（ClientSession、ServerSession）和管理层（ClientStart、ServerStart）。</p><p>客户端会定期发送Ping Message到服务端。</p><p>服务端有一个字典存放所有的Session，也就是ServerSession类型，超过设定时长未收到来自客户端传来的消息，就在本地字典内清除这个客户端的信息。</p><h1 id="基于KCPNet的解决方案"><a href="#基于KCPNet的解决方案" class="headerlink" title="基于KCPNet的解决方案"></a>基于KCPNet的解决方案</h1><p>本人基于KCPNet项目，集成proto协议、KCP算法的 Unity客户端 +.net core/framework服务端 解决方案。</p><p><a href="https://github.com/CodingCodingK/CodingK_Session">CodingK_Session</a></p><p>教程就不写了，我在里面写了2个使用案例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的解决方案&quot;&gt;&lt;a href=&quot;#我的解决方案&quot; class=&quot;headerlink&quot; title=&quot;我的解决方案&quot;&gt;&lt;/a&gt;我的解决方案&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CodingCodingK/CodingK_Sess</summary>
      
    
    
    
    <category term="Game" scheme="https://codingcodingk.github.io/categories/Game/"/>
    
    <category term="工具组" scheme="https://codingcodingk.github.io/categories/Game/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    
    <category term="工具组" scheme="https://codingcodingk.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BB%84/"/>
    
    <category term="网络库" scheme="https://codingcodingk.github.io/tags/%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>GameFramework框架学习：应用篇</title>
    <link href="https://codingcodingk.github.io/2022/02/01/Tech/Game/gf_demo/"/>
    <id>https://codingcodingk.github.io/2022/02/01/Tech/Game/gf_demo/</id>
    <published>2022-02-01T02:52:39.166Z</published>
    <updated>2022-02-01T02:52:39.166Z</updated>
    
    <content type="html"><![CDATA[<p>参考写在前面！！！</p><p>本文是在腾讯大佬<a href="https://www.drflower.top/">花桑</a>的GF解析文章的基础上，自己阅读源码并尝试总结、应用、拓展的<strong>个人笔记</strong>！水印以示尊敬。</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>其实半年前就知道gf，但是那时候刚入门unity没多久，看了猫仙人的simple gf来学习，很可惜只学到了皮毛也就是一些常见的设计模式比如状态机、对象池、优先队列轮询在游戏中的应用。经过半年的unity学习与项目积累，再回来看gf的源码觉得，不难且实现优雅，但是内容实在是太多了，记不下来。为了让自己学的结构能穿起来，刨析demo并自己做，很必要。</p><p>参考的也是<a href="https://www.drflower.top/posts/6e65184/#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE">花桑</a>和gf官方的demo。</p><p><font color="red">// TODO 目前只做了刨析demo的流程</font></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://blog-1300673521.cos.ap-guangzhou.myqcloud.com/images/GameFramework%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%BC%96%E5%86%99%E6%B8%B8%E6%88%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="img"></p><h1 id="启动场景全流程"><a href="#启动场景全流程" class="headerlink" title="启动场景全流程"></a>启动场景全流程</h1><h2 id="自己的GameEntry-cs"><a href="#自己的GameEntry-cs" class="headerlink" title="自己的GameEntry.cs"></a>自己的GameEntry.cs</h2><p>是自己的GameEntry类，而不是<code>UnityGameFramework.Runtime</code>中的GameEntry静态类。</p><p>作为游戏的入口，它需要继承MonoBehaviour并在Start方法中进行初始化。因为gf所有控件的初始化是在Awake内结束的，所以Start内拿到他们的时候已经可以安心使用了。</p><ol><li>  将所有默认的 GameFrameworkComponent 通过<code>UnityGameFramework.Runtime.GameEntry.GetComponent</code>获取，赋值到静态字段中，提供全局访问。<strong>这一块不同项目可以通用。</strong></li><li>  将项目中自己创建的 GameFrameworkComponent 派生类 ，与上面一样的操作进行赋值提供访问。</li></ol><h2 id="ProcedureLaunch-流程"><a href="#ProcedureLaunch-流程" class="headerlink" title="ProcedureLaunch 流程"></a>ProcedureLaunch 流程</h2><blockquote><p>  进行一些游戏启动的必要的初始化，支撑后续的启动流程，如：</p><p>  1.初始化构建信息：如版本检测和资源更新的URL信息，更新界面资源等<br>  2.语言设置：若有上次设置记录则使用上次设置记录，若没有则使用默认或系统语言<br>  3.初始化变体：根据当前语言设置，通知后续底层加载对应的资源变体<br>  4.初始本地化文本资源：根据当前语言设置选择对应的文本</p><p>  以上涉及到的资源，包括更新信息文件、更新界面资源、本地化文本等都是build-in资源，也就是发布时就在包内，不可更新的。试想我们发布的游戏是一个仅仅支撑启动的包，所有游戏资源都需要在启动后的热更流程中下载，但一些启动图片，以及热更时的界面本身也是需要资源的，需要给出基本的文本、确认框等，以提供给玩家确认是否下载、下载进度预览，还涉及到更新请求的URL。这部分资源就是我们需要放在包内的不可更新资源，主要用来支撑热更的启动，而ProcedureLaunch流程就是负责初始化这些资源和相关配置。</p></blockquote><p>顺从gf的流程，从这个流程结点开始启动项目。做的是加载在进入热更阶段之前的画面，这些画面和配置不可更新，发布在包内。</p><p><strong>流程转变</strong>发生在OnUpdate，也就是Awake、Start之后的第一帧 进入ProcedureSplash。</p><h3 id="初始化变体"><a href="#初始化变体" class="headerlink" title="初始化变体"></a>初始化变体</h3><ol><li>  根据语言选项，设置对应的 m_CurrentVariant （”en-us”、”zh-cn”、”zh-tw” 其中之一）。</li><li>  m_CurrentVariant 会显示在 LabelField 中。</li><li>  在资源加载中起到作用：ResourceManager.ResourceIniter类的 <strong>OnLoadPackageVersionListSuccess方法</strong> 中，会遍历资源的Variant是否一致。</li></ol><h2 id="ProcedureSplash-流程"><a href="#ProcedureSplash-流程" class="headerlink" title="ProcedureSplash 流程"></a>ProcedureSplash 流程</h2><blockquote><p>  闪屏流程，该流程会播放一个闪屏动画，然后根据当前的资源模式选择下一个流程，分别有</p><p>  1.编辑器模式-&gt;ProcedurePreload<br>  2.整包模式（不可更新）-&gt;ProcedureInitResources<br>  3.可更新模式-&gt;ProcedureCheckVersion</p><p>  编辑器模式下将使用EditorResourceComponent作为资源组件，里面使用的是AssetDatabase的接口直接加载Editor下资源，不涉及任何打包资源，不需要做资源列表初始化等操作。可直接进入ProcedurePreload流程。</p><p>  这个并非必要流程，若不需要闪屏，去掉此流程，把逻辑挪到上一个流程中即可。</p></blockquote><p>其实就是一个switch，决定下一个去往的流程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GameEntry.Base.EditorResourceMode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编辑器模式</span></span><br><span class="line">    ChangeState&lt;ProcedurePreload&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (GameEntry.Resource.ResourceMode == ResourceMode.Package)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 单机模式</span></span><br><span class="line">    ChangeState&lt;ProcedureInitResources&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可更新模式</span></span><br><span class="line">    ChangeState&lt;ProcedureCheckVersion&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProcedureInitResources-流程"><a href="#ProcedureInitResources-流程" class="headerlink" title="ProcedureInitResources 流程"></a>ProcedureInitResources 流程</h2><blockquote><p>  对于整包模式这个分支流程很简单，主要逻辑就是调用ResourceManager.InitResources()，加载包内资源列表，并解析到ResourceManager中，这样就初始化完毕资源的相关信息了，包括AB包、Asset、资源组、文件系统、版本号等。因为整包模式下所有资源都在包体内，只需要一步初始化即可获得所有资源信息，且后续不需要进行更新，所以初始化后便进入ProcedurePreload流程。</p></blockquote><p>单机模式，不需要资源热更的情况，只需要加载资源。</p><p>看代码层层包装，实际做的事就是：</p><ol><li><p>  将所给的地址转化成 带有<code>file://</code> 或 <code>http://</code> 前缀的远端格式。</p></li><li><p>  根据1是否成功的结果，启用携程来发送web请求，获取到返回值后执行对应的 Success 或 Failed 函数（我个人觉得这里可以换成用异步等待）</p></li><li><p><strong>Success函数</strong>：OnLoadPackageVersionListSuccess ，将请求的返回值反序列化成一个<code>PackageVersionList</code>，从中获得版本信息、Asset、Resource、FileSystem、ResourceGroup并装载。</p><p>  <strong>Failed函数</strong>：OnLoadPackageVersionListFailure，抛出GameFrameworkException。</p></li><li><p>  切换状态到 ProcedurePreload 流程。</p></li></ol><h2 id="ProcedureCheckVersion-流程"><a href="#ProcedureCheckVersion-流程" class="headerlink" title="ProcedureCheckVersion 流程"></a>ProcedureCheckVersion 流程</h2><blockquote><p>  此流程主要是调用ResourceManager.UpdateVersionList()，更新版本资源列表，其实就是更新最新的GameFrameworkVersion.dat文件，此文件记录了服务器上最新资源的信息，包括一些校验信息等，这些信息将被用来在下一个ProcedureCheckResources流程中进行资源校验。</p></blockquote><ol><li><p>  向EventPool添加成功失败情况的2个回调。</p></li><li><p>  向服务器请求版本信息。</p></li><li><p>根据版本信息来决策：</p><p>  <strong>需要版本更新</strong>：设置VersionList并切换流程到 ProcedureUpdateVersion 流程。</p><p>  <strong>不需要版本更新</strong>：切换流程到 ProcedureCheckResources 流程。</p></li></ol><h2 id="ProcedureUpdateVersion-流程"><a href="#ProcedureUpdateVersion-流程" class="headerlink" title="ProcedureUpdateVersion 流程"></a>ProcedureUpdateVersion 流程</h2><blockquote><p>  此流程主要是调用ResourceManager.UpdateVersionList()，更新版本资源列表，其实就是更新最新的GameFrameworkVersion.dat文件，此文件记录了服务器上最新资源的信息，包括一些校验信息等，这些信息将被用来在下一个ProcedureCheckResources流程中进行资源校验。</p></blockquote><p>基本上面就是全部了，唯一值得补充的是下载用的是 <strong>DownloadTask 类</strong>，然后放到 DownloadManager 的任务池里。</p><p>成功后执行回调，进入 ProcedureCheckResources 流程。</p><h2 id="ProcedureCheckResources-流程"><a href="#ProcedureCheckResources-流程" class="headerlink" title="ProcedureCheckResources 流程"></a>ProcedureCheckResources 流程</h2><blockquote><p>  资源检测流程，核心逻辑是调用ResourceManager.CheckResources()，GF内部会解析以下3个文件：</p><p>  ​    1.可读写路径下的GameFrameworkVersion.dat，文件记录着服务器上最新的资源信息<br>  ​    2.只读路径下的GameFrameworkList.dat，文件记录着只读路径（包内）下的资源信息<br>  ​    3.可读写路径下的GameFrameworkList.dat，文件记录着可读写路径下（以前通过热更下载的）的资源信息</p><p>  资源模块内部会根据本地资源信息和服务器资源信息作对比，标记出每个资源的状态，包括是否需要更新、是否可用、是否需要删除等。后续可以根据这些状态来加载或更新资源。</p><p>  检测完资源后，有哪些资源是需要更新的就已经明确了，这个时候可以根据项目具体需求选择是否进入更新流程。</p><p>  ​    a.若游戏要求所有资源都为最新时才能进入游戏，则有资源变化就必须进入更新流程更新资源<br>  ​    b.若游戏做了分包下载，进入初始场景不需要更新（初始场景资源无变化），待用到对应资源时才更新，也可以不进入更新流程，在游戏中玩家需要访问未更新资源时，再在后台更新。</p></blockquote><p>看上面就够。实际执行的代码就是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OnEnter：</span><br><span class="line"><span class="comment">// 3项加载解析</span></span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadWritePath, RemoteVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadUpdatableVersionListSuccess, OnLoadUpdatableVersionListFailure), <span class="literal">null</span>);</span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadOnlyPath, LocalVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadReadOnlyVersionListSuccess, OnLoadReadOnlyVersionListFailure), <span class="literal">null</span>);</span><br><span class="line">m_ResourceManager.m_ResourceHelper.LoadBytes(Utility.Path.GetRemotePath(Path.Combine(m_ResourceManager.m_ReadWritePath, LocalVersionListFileName)), <span class="keyword">new</span> LoadBytesCallbacks(OnLoadReadWriteVersionListSuccess, OnLoadReadWriteVersionListFailure), <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 完成后执行回调，标记出每个资源的状态，包括是否需要更新、是否可用、是否需要删除等。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCheckResourcesComplete</span>(<span class="params">...</span>)</span>;</span><br><span class="line"></span><br><span class="line">OnUpdate：</span><br><span class="line"><span class="comment">// 根据上面标记的值：是否需要更新，来确定下一个状态。</span></span><br><span class="line">需要版本更新：设置UpdateResourceCount并切换流程到 ProcedureUpdateResources 流程。</span><br><span class="line">不需要版本更新：切换流程到 ProcedurePreload 流程。</span><br></pre></td></tr></table></figure><p><strong>需要版本更新</strong>：设置UpdateResourceCount并切换流程到 ProcedureUpdateResources 流程。<br><strong>不需要版本更新</strong>：切换流程到 ProcedurePreload 流程。</p><h2 id="ProcedureUpdateResources-流程"><a href="#ProcedureUpdateResources-流程" class="headerlink" title="ProcedureUpdateResources 流程"></a>ProcedureUpdateResources 流程</h2><blockquote><p>  资源更新流程，如上文所说，在本流程可以根据项目具体需求，更新此刻需要更新的资源。例如游戏内做了资源分组，把一些活动、副本等资源单独分组了，则可以在此时只更新基础资源，待玩家访问到还没更新的活动、副本相关资源时，再在后台更新活动、副本的资源。更新的最小单位为一个资源组。</p><p>  另外这个流程还需要实现热更时的当前进度、下载速度、剩余大小等界面表现。</p><p>  更新完成后正式进入游戏业务流程。</p></blockquote><p>获取上个流程传来的 UpdateResourceCount，之后传入委托到EventPool。这4个委托的核心是维护一个<code>List&lt;UpdateLengthData&gt;</code>队列 <strong>m_UpdateLengthData</strong>（下称进度队列） 。而这个进度队列的数据结构，只有 Name、Length、TotalZipLength 三个属性。</p><p>花桑的demo里用了4个委托的情况：</p><ol><li>  OnResourceUpdateStart：为进度队列添加内容。</li><li>  OnResourceUpdateChanged：为进度队列更新进度。</li><li>  OnResourceUpdateSuccess：修改 m_UpdateSuccessCount++，并为进度队列更新进度。</li><li>  OnResourceUpdateFailure：Retry并为进度队列回退进度。如果Retry次数超过设定次数，就直接返回。</li></ol><p>设置好委托后，执行 StartUpdateResources方法。这个方法内将资源列表放到了一个 资源等待更新队列。ResourceManager的Update里会去轮询这个 资源等待更新队列，一帧一个（TODO why？）地，加入DownloadManager的TaskPool里。</p><p>等待更新任务完成后，切换到最终流程 ProcedurePreload流程。</p><h2 id="ProcedurePreload-流程"><a href="#ProcedurePreload-流程" class="headerlink" title="ProcedurePreload 流程"></a>ProcedurePreload 流程</h2><blockquote><p>   预加载流程，这一流程已经属于游戏业务层，但大部分游戏其实都需要这么一个流程，所以这里也把他规划到通用流程中，流程中主要负责设置框架的功能模块，预加载数据表，初始化游戏中的功能系统等。</p></blockquote><p>找到 Config（配置） 和 Localization（本地化组件） 的路径，传入GF进行异步加载。再对所有Data进行Preload。</p><p>完成后进入 ProcedureLoadingScene流程。</p><h2 id="ProcedureLoadingScene-流程"><a href="#ProcedureLoadingScene-流程" class="headerlink" title="ProcedureLoadingScene 流程"></a>ProcedureLoadingScene 流程</h2><p>加载Scene流程，也是通用的。先根据id获取一个SceneData类型，这个SceneData类型是装在一个字典中的，在ProcedurePreload 流程的时候会初期化。</p><p>SceneData类型附带了场景名字路径等，以及，下一个流程的名字。当Scene加载完后，根据上面取得的配置，切换到下一个流程中。</p><p>按正常顺序走，第一个场景是 Menu场景。</p><h2 id="ProcedureMenu-流程"><a href="#ProcedureMenu-流程" class="headerlink" title="ProcedureMenu 流程"></a>ProcedureMenu 流程</h2><p>对应的是游戏选关卡的界面。其实就是主城啦。</p><p>展示UI、展示关卡等等。当选择关卡后，会进入 ProcedureLoadingScene流程，一样读取SceneData切换到对应关卡并进入 ProcedureLevel流程。</p><h2 id="ProcedureLevel-流程"><a href="#ProcedureLevel-流程" class="headerlink" title="ProcedureLevel 流程"></a>ProcedureLevel 流程</h2><p>战斗流程。</p><p>根据关卡配置创建关卡 LevelControl类型，里面包含了所有战斗需要的东西，有点类似于自己常写的“BattleMgr”。</p><p>LevelControl并不继承Mono，只继承一个IReference接口。它由<strong>ProcedureLevel.OnUpdate</strong>驱动每一帧做的事，同时OnUpdate还会检测一个flag判断是否要执行切换场景了（进入 ProcedureLoadingScene流程）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考写在前面！！！&lt;/p&gt;
&lt;p&gt;本文是在腾讯大佬&lt;a href=&quot;https://www.drflower.top/&quot;&gt;花桑&lt;/a&gt;的GF解析文章的基础上，自己阅读源码并尝试总结、应用、拓展的&lt;strong&gt;个人笔记&lt;/strong&gt;！水印以示尊敬。&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="GameFramework框架" scheme="https://codingcodingk.github.io/categories/Unity/GameFramework%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="C#" scheme="https://codingcodingk.github.io/tags/C/"/>
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity渲染原理</title>
    <link href="https://codingcodingk.github.io/2022/01/22/Tech/Game/Rendering/"/>
    <id>https://codingcodingk.github.io/2022/01/22/Tech/Game/Rendering/</id>
    <published>2022-01-22T07:20:06.125Z</published>
    <updated>2022-01-22T07:20:06.126Z</updated>
    
    <content type="html"><![CDATA[<p>渲染原理学习。</p><h1 id="Rending面板"><a href="#Rending面板" class="headerlink" title="Rending面板"></a>Rending面板</h1><h2 id="Color-Space"><a href="#Color-Space" class="headerlink" title="Color Space"></a>Color Space</h2><p>以前的阴极射线管电视，需要更强烈的色彩来弥补差设备显示，但现在硬件提升已经不需要了。</p><p>这就是为什么把Rendering的Color Space从Gamma切到Linear。</p><h3 id="阴极-真空管-电视"><a href="#阴极-真空管-电视" class="headerlink" title="阴极 真空管 电视"></a>阴极 真空管 电视</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220118131229.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染原理学习。&lt;/p&gt;
&lt;h1 id=&quot;Rending面板&quot;&gt;&lt;a href=&quot;#Rending面板&quot; class=&quot;headerlink&quot; title=&quot;Rending面板&quot;&gt;&lt;/a&gt;Rending面板&lt;/h1&gt;&lt;h2 id=&quot;Color-Space&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/categories/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/categories/Unity/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="渲染" scheme="https://codingcodingk.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Unity常见UI基础问题手册</title>
    <link href="https://codingcodingk.github.io/2022/01/22/Tech/Game/Guide_UnityUI/"/>
    <id>https://codingcodingk.github.io/2022/01/22/Tech/Game/Guide_UnityUI/</id>
    <published>2022-01-22T07:20:06.124Z</published>
    <updated>2022-01-22T07:20:06.124Z</updated>
    
    <content type="html"><![CDATA[<p>仅作个人笔记用途。</p><h1 id="UI顶层显示"><a href="#UI顶层显示" class="headerlink" title="UI顶层显示"></a>UI顶层显示</h1><h2 id="方法一-做一个新的UI摄像机"><a href="#方法一-做一个新的UI摄像机" class="headerlink" title="方法一.做一个新的UI摄像机"></a>方法一.做一个新的UI摄像机</h2><p>① Canvas的Render Mode设置为<strong>Screen Space - Camera</strong></p><p>② 新建摄像机（后面称之为UI摄像机），放到原先摄像机的下面</p><p>③ 拖拽UI摄像机到Canvas的Render Camera</p><p>④ UI摄像机的 Clear Flags 设置为 <strong>Depth only</strong>，用来去掉背景；Culling Mask设置为 <strong>UI</strong>。</p><p>⑤ 确保 UI摄像机的Depth &gt; 其他摄像机的Depth （值小的会先渲染，所以值大的会在前面）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1dK4y1b7be?spm_id_from=333.999.0.0">超级细致的调试教学视频</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅作个人笔记用途。&lt;/p&gt;
&lt;h1 id=&quot;UI顶层显示&quot;&gt;&lt;a href=&quot;#UI顶层显示&quot; class=&quot;headerlink&quot; title=&quot;UI顶层显示&quot;&gt;&lt;/a&gt;UI顶层显示&lt;/h1&gt;&lt;h2 id=&quot;方法一-做一个新的UI摄像机&quot;&gt;&lt;a href=&quot;#方法一-做一</summary>
      
    
    
    
    <category term="Unity个人积累" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/categories/Unity%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/UI/"/>
    
    
    <category term="Unity" scheme="https://codingcodingk.github.io/tags/Unity/"/>
    
    <category term="UI" scheme="https://codingcodingk.github.io/tags/UI/"/>
    
  </entry>
  
</feed>
