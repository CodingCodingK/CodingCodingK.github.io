<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CLR Via C#个人笔记6 - 核心机制 | CodingCodingK Blog</title><meta name="keywords" content="C#,技术,可访问性,核心机制"><meta name="author" content="CodingCodingK"><meta name="copyright" content="CodingCodingK"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="大章20：异常和状态管理异常处理机制什么是“异常” 首先对异常有一个基本理解，对于一些预想外的情况（比如中途转换失败），需要对既有代码进行进一步的安全性保证，就需要由对异常的处理。 平时代码throw抛出就会结束后续代码的执行，终止进程，但是如果在try里throw就会被catch接住，执行catch内代码；如果catch也抛出但被更上层的catch抓住了，抛出地点的后续代码就不会执行了，但仍然会">
<meta property="og:type" content="article">
<meta property="og:title" content="CLR Via C#个人笔记6 - 核心机制">
<meta property="og:url" content="https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp6/index.html">
<meta property="og:site_name" content="CodingCodingK Blog">
<meta property="og:description" content="大章20：异常和状态管理异常处理机制什么是“异常” 首先对异常有一个基本理解，对于一些预想外的情况（比如中途转换失败），需要对既有代码进行进一步的安全性保证，就需要由对异常的处理。 平时代码throw抛出就会结束后续代码的执行，终止进程，但是如果在try里throw就会被catch接住，执行catch内代码；如果catch也抛出但被更上层的catch抓住了，抛出地点的后续代码就不会执行了，但仍然会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png">
<meta property="article:published_time" content="2021-12-26T06:13:43.705Z">
<meta property="article:modified_time" content="2022-01-14T12:18:28.901Z">
<meta property="article:author" content="CodingCodingK">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="可访问性">
<meta property="article:tag" content="核心机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png"><link rel="canonical" href="https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CLR Via C#个人笔记6 - 核心机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-14 20:18:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/mine.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="CodingCodingK Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> CodingCodingK</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CodingCodingK Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> CodingCodingK</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CLR Via C#个人笔记6 - 核心机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-26T06:13:43.705Z" title="发表于 2021-12-26 14:13:43">2021-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-14T12:18:28.901Z" title="更新于 2022-01-14 20:18:28">2022-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSharp/">CSharp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSharp/CLR-via-C/">CLR via C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSharp/CLR-via-C/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/">第四章 核心机制</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CLR Via C#个人笔记6 - 核心机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="大章20：异常和状态管理"><a href="#大章20：异常和状态管理" class="headerlink" title="大章20：异常和状态管理"></a><center>大章20：异常和状态管理</center></h1><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p><strong>什么是“异常”</strong></p>
<p>首先对异常有一个基本理解，对于一些预想外的情况（比如中途转换失败），需要对既有代码进行进一步的安全性保证，就需要由对异常的处理。</p>
<p>平时代码throw抛出就会<strong>结束后续代码的执行，终止进程</strong>，<font color="pink">但是如果在try里throw就会被catch接住，执行catch内代码；如果catch也抛出但被更上层的catch抓住了，抛出地点的后续代码就不会执行了，但仍然会执行对应finally内的代码，之后finally结束后的代码不会执行。</font></p>
<p><strong>异常处理标准流程</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do method</span></span><br><span class="line">	&#125;</span><br><span class="line">    catch (InvalidOperationException)&#123;</span><br><span class="line">        <span class="comment">// 异常预想情况1，从InvalidOperationException恢复的代码放在这</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException)&#123;</span><br><span class="line">        <span class="comment">//  异常预想情况2，从IOException恢复的代码放在这</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123;</span><br><span class="line">        <span class="comment">// 上述异常以外的其他异常恢复代码放在这</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 因为是未预想到的异常，恢复代码不可靠，所以一般抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 对try块代码的操作，进行后处理</span></span><br><span class="line">        <span class="comment">// finally总是执行，无论是否抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有在catch中抛出异常，就继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>try块</strong></p>
<p>介绍略了。</p>
<p>对于程序设计时，多少代码放到try块中是很难把控的，应该根据catch和finally的对应处理来思考这个问题：</p>
<ol>
<li>  一段代码，catch后的挽回处理如果各不相同，那就该考虑多分几块<code>try&#123;&#125;catch()&#123;&#125;</code>了</li>
<li>  一段代码，他们的finally清理代码如果都不相同，那就不应该放在一起</li>
</ol>
<p><strong>catch块⭐</strong></p>
<p>先说下<strong>捕捉类型</strong>，就是<code>catch()</code>括号里的玩意。C#要求捕捉类型必须是<code>System.Exception</code>以及它的派生类。当你括号里不指定时，就相当于捕捉<code>System.Exception</code>这个类型了，不过这样也没法在后续代码块里访问到异常信息了。</p>
<p>再说下关键，<strong>catch抓取错误的机制</strong>，也就是整个异常处理的机制。</p>
<ol>
<li>  try中代码抛出异常后，CLR将搜索捕捉类型与抛出异常相同(或是其基类)的catch块。</li>
<li>  如果catch没有任何捕捉类型与抛出的异常匹配，CLR会去回溯查找调用堆栈更高的一层的catch捕捉类型。</li>
<li>  直到找到调用堆栈的顶部，仍然没有找到匹配的catch块，就会发生未处理的异常，这个后面讨论。</li>
<li>  一旦CLR找到匹配的catch块，就会执行内层所有finally块中的代码，也就是 <font color="brown">从抛出异常的try块-到匹配到异常的catch块之间</font> 所有的finally块。顺序是：内层finally块 =&gt; 抓取到异常的catch块 =&gt; 抓取到异常的catch块的finally块 =&gt; …。</li>
</ol>
<p>然后再说下catch到后，常用的<strong>catch块末尾处理选择</strong>，提供3种：</p>
<ol>
<li>  重新抛出相同的异常，向调用栈高一层的代码通知异常的发生。</li>
<li>  抛出一个不同的异常，向调用栈高一层的代码通知异常的发生。</li>
<li>  啥也不抛，正常从线程底部退出。</li>
</ol>
<p>当选择3，线程从catch块的底部退出后，它将立即执行包含在finally块中的代码。如果没有，就执行catch块结束的后续代码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Test1(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		Test2();</span><br><span class="line">	&#125;</span><br><span class="line">	catch</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Test1 catched&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		Test3();</span><br><span class="line">	&#125;</span><br><span class="line">	catch</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Test2 catched&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentOutOfRangeException(<span class="string">&quot;test!!!&quot;</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Test3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Test2 catched</span></span><br><span class="line"><span class="comment">// Test2</span></span><br><span class="line"><span class="comment">// Test1</span></span><br></pre></td></tr></table></figure>



<p>最后，再说一下捕捉到异常时，会有一个变量将引用抛出的System.Exception对象：<code>catch (Exception e)</code>。可以用这个变量打印出<strong>堆栈调用</strong>。</p>
<p><strong>finally块</strong></p>
<p>包裹的是确保会执行的代码。</p>
<p>前面粉字里也说过，即使catch里也抛出了错误，仍然会执行finally内的代码。</p>
<p>除了Win32的TerminateThread杀死线程，或者TerminateProcess或System.Environment的FailFast方法杀死进程，finally块就不会执行。</p>
<h2 id="非CLS异常"><a href="#非CLS异常" class="headerlink" title="非CLS异常"></a>非CLS异常</h2><p><strong>RuntimeWrappedException类</strong></p>
<p>上面说的都是<strong>CLS标准的异常</strong>（也就是继承于<strong>Exception类</strong>的），但是也存在C#调用了其他编程语言写的方法，而且那个方法抛出了一个非CLS相容的异常，那么C#代码根本不能捕捉这个异常，从而造成安全隐患。</p>
<p>于是微软引入了全新的<code>System.Runtime.CompilerServices</code>的<strong>RuntimeWrappedException类</strong>，该类派生自Exception，所以他本身与CLR相容。当非CLS相容的异常被抛出时，CLR会自动构造这个类，并初始化+引用实际抛出的异常。也就是完成了 非CLS标准异常 =&gt; CLS标准异常。</p>
<h2 id="Exception-StackTrace属性"><a href="#Exception-StackTrace属性" class="headerlink" title="Exception.StackTrace属性"></a>Exception.StackTrace属性</h2><p><strong>异常抛出</strong></p>
<p>其实CLR可以让异常抛出任何类型的实例，String、Int32都行。但是为了能够简化使用，协定为统一使用System.Exception类。</p>
<p><strong>Exception.StackTrace属性</strong></p>
<p>Exception包含几个公共属性：String Message、IDictionary Data、String Source、String StackTrace、MethodBase TargetSite、String HelpLink、Exception InnerException、Int32 HResult。</p>
<p>讲一下其只读的StackTrace属性，它指出异常发生前调用了哪些方法。</p>
<p>新构造Exception类时，StackTrace是null。</p>
<p><strong>StackTrace的捕捉范围</strong></p>
<p>抛出异常时，CLR会重置异常起点，所以CLR只能记录最新的异常对象的抛出位置。</p>
<p>比如catch中又抛出了异常<code>throw e;</code>，那么StackTrace捕捉的起始点就又更新了，前面抛出的堆栈抓不到了，只能抓到最底一层的。</p>
<p>最后生成一个字符串来指出从异常抛出位置到异常捕捉位置的所有方法。</p>
<p><strong>System.Diagnostics.StackTrace类型</strong></p>
<p>该类型定义了一些属性和方法，允许开发人员程序化地处理堆栈跟踪以及构成堆栈跟踪的栈帧。</p>
<p>用这个类型来自己定制一套堆栈记录机制，实现抓取到多层抛错的堆栈记录。</p>
<h2 id="定义自己的异常类"><a href="#定义自己的异常类" class="headerlink" title="定义自己的异常类"></a>定义自己的异常类</h2><p><strong>设计原则</strong></p>
<p>创建自定义异常类应严格遵循几个原则</p>
<ol>
<li>声明可序列化（用于进行序列化写入，当然如果你不需要序列化。那么可以不声明为可序列化的）</li>
<li>添加一个默认的构造函数</li>
<li>添加包含message的构造函数</li>
<li>添加一个包含message,及内部异常类型参数的构造函数</li>
<li>添加一个序列化信息相关参数的构造函数.</li>
<li>可以把序列化重新继承ISerializable接口，重写序列化反序列化的方法</li>
</ol>
<p><strong>简单实践</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>] <span class="comment">//声明为可序列化的 因为要写入文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PayOverflowException</span> : <span class="title">Exception</span> <span class="comment">// 如有需求，可以继承ISerializable接口，重写序列化反序列化的方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"><span class="built_in">string</span> message</span>): <span class="title">base</span>(<span class="params">message</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayOverflowException</span>(<span class="params"><span class="built_in">string</span> message, Exception inner</span>): <span class="title">base</span>(<span class="params">message, inner</span>)</span> &#123; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">10000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ex = <span class="keyword">new</span> PayOverflowException(<span class="string">&quot;The employee&#x27;s max pay should be no more than 10000.&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DoSth(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (PayOverflowException ex)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">var</span> file = <span class="keyword">new</span> FileStream(<span class="string">@&quot;c:\customerexception.txt&quot;</span>, FileMode.Create);</span><br><span class="line">         <span class="comment">//以序列化方式写入</span></span><br><span class="line">         BinaryFormatter bf = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">         bf.Serialize(file, ex);</span><br><span class="line">         file.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>书中的泛型Exception示例</strong></p>
<p>比较复杂，就贴上图看一下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211217161743.png"></p>
<h2 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h2><p><strong>善用finally</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">@&quot;C:\Data.bin&quot;</span>, FileMode.Open);</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do sth to fs</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// TODO  清理代码放这，这样哪怕抛错也会把fs正确关闭</span></span><br><span class="line">		fs.Close();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C#自动实现finally</strong></p>
<p>为了方便程序员，只要使用了lock、using、foreach语句和析构器时，C#编译器就会<strong>自动生成try/finally块代码</strong>，如下：</p>
<ul>
<li>  使用lock语句时，锁在finally块中释放。</li>
<li>  使用using语句时，在finally块中调用对象的Dispose方法。</li>
<li>  使用foreach语句时，在finally块中调用IEnumerator对象的Dispose方法。</li>
<li>  定义析构器方法时，在finally块中调用基类的Finalize方法。</li>
</ul>
<p>比如下面这个方法的实现，和上面的代码编译结果一样。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法的实现和上面的代码编译结果一样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">@&quot;C:\Data.bin&quot;</span>, FileMode.Open)) &#123;</span><br><span class="line">        <span class="comment">// do sth to fs</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备份、回滚状态</strong></p>
<p>对于一些目前无法掌控到的异常，想要修复会无从下手。可以考虑一下下面的状态回滚：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> beforeDoing = num; <span class="comment">// 1.备份数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DoSth(num); <span class="comment">// 执行处理num的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    catch&#123;</span><br><span class="line">        num = beforeDoing; <span class="comment">// 2.回滚状态</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 抛出错误，让程序员知道发生了什么</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>包装抛错</strong></p>
<p>有的时候接受到了抛错，提前协定好，可以向外抛出不一样的错误类型。</p>
<p>因为直接让别人用你自己的包装类方法，如果抛错了，可能预料不到，抓不到错；如果提前协定好某些情况固定抛什么Exception，那么其他开发者就能提前预知要去抓这些错了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">PhoneBook</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> m_pathname; <span class="comment">// 地址簿文件的路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部调用的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPhoneNumber</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">string</span> phoneNum;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fs = <span class="keyword">new</span> FileStream(m_pathname, FileMode.Open);</span><br><span class="line">            ... phoneNum = ... <span class="comment">// 这里是查找代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 协定好的Exception类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e) &#123;</span><br><span class="line">            <span class="comment">// 协定好的Exception类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fs != <span class="literal">null</span>) fs.Close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="未处理的异常"><a href="#未处理的异常" class="headerlink" title="未处理的异常"></a>未处理的异常</h2><p><strong>未处理异常的处理</strong></p>
<p>异常抛出时，CLR在调用栈中向上查找与抛出的异常对象的类型匹配的catch块。如果没有任何catch块匹配抛出的异常类型，就发生一个<strong>未处理的异常</strong>，CLR一旦检测到有未处理的异常的存在，就会终止进程。</p>
<p>CLR的默认策略时将未处理的异常，写进Windows事件日志。</p>
<p><strong>Windows事件日志</strong></p>
<p>上述的未处理异常，在“事件查看器&gt;Windows日志&gt;应用程序”中可以看到，我个人推荐直接WIN+R运行<code>eventvwr.msc</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211217182146.png"></p>
<h2 id="对异常进行调试"><a href="#对异常进行调试" class="headerlink" title="对异常进行调试"></a>对异常进行调试</h2><p><strong>VS 调试&gt;异常</strong></p>
<p>讲的是VS的菜单 “调试”&gt;“异常”，能打开CLR和自己定义的所有能被识别的Exception类型，并可以选择在抛出某Exception时中断（本来的话要异常未处理才会中断）。</p>
<p>这个用到了直接百度吧，知道有这个功能就行。</p>
<h2 id="约束执行区域-CER"><a href="#约束执行区域-CER" class="headerlink" title="约束执行区域 CER"></a>约束执行区域 CER</h2><p><strong>PrepareConstrainedRegions</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In try&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        Type1.M();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Type1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这里抛出错误，M就得不到调用</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Type1&#x27;s static ctor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// In try</span></span><br><span class="line"><span class="comment">// Type1&#x27;s static ctor called</span></span><br></pre></td></tr></table></figure>

<p>像上述这样的代码执行顺序，不难看出，finally里的错误就抓不住了，而且中间出错影响finally块代码执行。</p>
<p>我们想实现<font color="brown">除非保证catch和finally块内的代码得到执行，否则就不执行try块中的代码</font>。可以使用<strong>PrepareConstrainedRegions</strong>方法，JIT编译器如果发现在一个try块之前调用了这个方法，就会提前编译与try块关联的catch和finally块中的代码。JIT编译器会加载任何程序集，创建任何类型对象，调用任何静态构造器，并对任何方法进行JIT编译。如果其中任何操作造成异常，这个异常会在线程进入try块之前发生。</p>
<p>此外，JIT编译器提前准备方法时，还会遍历整个调用图，寻找应用了<strong>ReliabilityConstractAttribute</strong>特性的方法，提前准备这些被调用的方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Demo2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    RuntimeHelpers.PrepareConstrainedRegions(); <span class="comment">// System.Runtime.CompilerServices命名空间</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In try&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        Type2.M();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Type2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Type2&#x27;s static ctor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ReliabilityConstractAttribute(Consistency.WillNotCorruptState. Cer.Success)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Type2&#x27;s static ctor called</span></span><br><span class="line"><span class="comment">// In try</span></span><br></pre></td></tr></table></figure>



<p><strong>ReliabilityConstractAttribute</strong></p>
<p>聊一下这个属性，前面提到了，这个属性要配合PrepareConstrainedRegions方法使用。这样JIT编译器提前准备方法时，会遍历整个调用图，寻找应用了<strong>ReliabilityConstractAttribute</strong>特性的方法，提前准备这些被调用的方法。</p>
<p>首先会对这个属性实例传递一个枚举成员 Consistency：</p>
<table>
<thead>
<tr>
<th>枚举成员</th>
<th>value</th>
<th>详细</th>
</tr>
</thead>
<tbody><tr>
<td>MayCorruptAppDomain</td>
<td>1</td>
<td>在遇到异常情况时，公共语言运行时 (CLR) 对当前应用程序域中的状态一致性不做任何保证。</td>
</tr>
<tr>
<td>MayCorruptInstance</td>
<td>2</td>
<td>在遇到异常情况时，此方法保证将状态损坏限制到当前实例。</td>
</tr>
<tr>
<td>MayCorruptProcess</td>
<td>0</td>
<td>在遇到异常情况时，CLR 对状态一致性不做任何保证；即这种情况可能损坏进程。</td>
</tr>
<tr>
<td>WillNotCorruptState</td>
<td>3</td>
<td>在遇到异常情况时，此方法保证不损坏状态。 （不保证此方法永远不会失效；但确实可以保证此类故障将永远不损坏状态。）</td>
</tr>
</tbody></table>
<p>以及枚举成员 Cer：</p>
<table>
<thead>
<tr>
<th>枚举成员</th>
<th>value</th>
<th>详细</th>
</tr>
</thead>
<tbody><tr>
<td>MayFail</td>
<td>1</td>
<td>在遇到异常情况时，此方法可能会失败。 在这种情况下，此方法将向调用方法报告它是否成功。 该方法的方法体周围必须有 CER 以确保它可以报告返回值。</td>
</tr>
<tr>
<td>None</td>
<td>0</td>
<td>方法、类型或程序集没有 CER 的概念。 它不利用 CER 保证。</td>
</tr>
<tr>
<td>Success</td>
<td>2</td>
<td>在遇到异常情况时，保证此方法获得成功。 应始终在调用的方法周围构造 CER，即使是在非 CER 区域内调用该方法。 如果方法完成了其任务，则该方法成功。 例如，用 ReliabilityContractAttribute(Cer.Success)意味着当它在 CER 下运行时，它始终返回 ArrayList 中的元素的数目计数，并且它永远不能将内部的字段保留为不确定状态。</td>
</tr>
</tbody></table>
<p><strong>TODO</strong></p>
<p>我说实话这节没有看懂，主要问题是不理解AppDomain的“状态”到底指的是什么，书中说22章会讲。以后在这里补吧。</p>
<h2 id="代码协定"><a href="#代码协定" class="headerlink" title="代码协定"></a>代码协定</h2><p><strong>是什么</strong></p>
<p>代码协定的核心是静态类System.Diagnostics.Contracts.Contract。</p>
<p>协定采取的形式：</p>
<ul>
<li>  前条件：一般用于对实参进行验证。</li>
<li>  后条件：方法因为一次普通的返回或抛出异常而终止时，对状态进行验证。</li>
<li>  对象不变性(Object Invariant)：在对象的整个生命期内，确保对象的字段的良好状态。</li>
</ul>
<p><strong>怎么用</strong></p>
<p>下面举个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Item</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Item</span>&gt; m_cart</span> = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line">    <span class="keyword">private</span> Decimal m_totalCost = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShoppingCart</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params">Item item</span>)</span> &#123;</span><br><span class="line">        AddItemHelper(m_cart, item, <span class="keyword">ref</span> m_totalCost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddItemHelper</span>(<span class="params">List&lt;Item&gt; m_cart, Item newItem, <span class="keyword">ref</span> Decimal totalCost</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 前条件</span></span><br><span class="line">        Contract.Requires(newItem != <span class="literal">null</span>);</span><br><span class="line">        Contract.Requires(Contract.ForAll(m_cart, s =&gt; s!= newItem));</span><br><span class="line">        <span class="comment">// 后条件</span></span><br><span class="line">        Contract.Ensures(Contract.Exists(m_cart, s=&gt; s == newItem));</span><br><span class="line">        Contract.Ensures(totalCost &gt;= Contract.OldValue(totalCost));</span><br><span class="line">        Contract.EnsureOnThrow&lt;IOException&gt;(totalCost == Contract.OldValue(totalCost));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做一些事，可能抛出IOException</span></span><br><span class="line">        m_cart.Add(newItem);</span><br><span class="line">        totalCost += <span class="number">1.00</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象不变性</span></span><br><span class="line">    [<span class="meta">ContractInvariantMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ObjectInvariant</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Contract.Invariant(m_totalCost &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<p>有空看看吧，这个技术太老了，工作中没见过。</p>
<h1 id="大章21：托管堆和垃圾回收"><a href="#大章21：托管堆和垃圾回收" class="headerlink" title="大章21：托管堆和垃圾回收"></a><center>大章21：托管堆和垃圾回收</center></h1><h2 id="托管堆⭐"><a href="#托管堆⭐" class="headerlink" title="托管堆⭐"></a>托管堆⭐</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>访问一个资源所需的步骤：</p>
<ol>
<li>  调用IL指令newobj，为代表资源的类型分配内存（C#中用new操作符完成）。</li>
<li>  初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。</li>
<li>  访问类型的成员来使用资源（有必要可以重复）。</li>
<li>  摧毁资源的状态以进行清理。</li>
<li>  释放内存。垃圾回收器独自负责这一步。</li>
</ol>
<p>C#为了简化编程，将大多数类的4这一步略去了，也就是不需要资源清理，由垃圾回收器来自动释放内存。遇到需要特殊清理不等待GC的类时，不推荐写unsafe代码，而是在类中调用额外的<strong>方法Dispose</strong>以按照自己的节奏清理资源。</p>
<h3 id="1-从托管堆分配资源"><a href="#1-从托管堆分配资源" class="headerlink" title="1.从托管堆分配资源"></a>1.从托管堆分配资源</h3><p><strong>NextObjPtr</strong></p>
<p>CLR要求所有对象从托管堆分配源。进程初始化时，CLR划出一个连续的地址空间区域作为托管堆。CLR还会维护一个指针NextObjPtr，它指向下一个对象在堆中的分配位置。</p>
<p>一个区域被非垃圾对象填满后，CLR会分配更多的区域。这个过程一直重复直至整个进程地址空间都被填满。所以，你的应用程序的内存受进程的虚拟地址空间的限制，32位进程最多能分配1.5GB，64位进程最多能分配8TB。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211221105618.png"></p>
<p><strong>new操作符执行流程</strong></p>
<p>new操作符导致CLR执行以下步骤：</p>
<ol>
<li>  计算类型（包括基类继承的字段）的<strong>字段</strong>所需的字节数。</li>
<li>  加上对象的<strong>overhead开销字段</strong>所需的字节数。每个对象都有2个开销字段：类型都西昂指针和同步块索引。对于32位应用程序，这2个字段各需32位，所以每个对象要+<strong>8字节</strong>；对于64位，各需要64位，所以每个对象要+<strong>16字节</strong>。</li>
<li>  CLR检查区域中是否有分配对象所需的字节数。如果托管堆空间足够，就在NextObjPtr指针指向的地址放入对象，为对象分配的字节会被清零。接着调用类型构造器(为this参数传递NextObjPtr)返回初始化好的对象的引用，并让NextObjPtr移动到新地址：原地址+这个类占用的内存字节数。</li>
</ol>
<p><strong>堆性能很强</strong></p>
<p>正如上述所说，对于托管堆，分配对象只需要在指针上加一个值；寻找对象时，因为同时分配的对象内存是连续的（比如FileStream）且往往有业务联系，所以因为**局部化(locality)**会获得性能提升。</p>
<h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><p><strong>垃圾回收的起因</strong></p>
<p>托管堆性能并不是无敌的，前面说的有一个大前提——内存无限，CLR总能分配新对象。如果托管堆没有大小限制，那C#的执行速度要优于c了(托管堆的结构让它有比c运行时堆更快的对象分配速度)。但是内存不可能是无限的，所以CLR有“垃圾回收”GC。</p>
<p><strong>垃圾回收的基本原理</strong></p>
<p>回收分为两个阶段： <strong>标记 –&gt; 压缩</strong></p>
<p>标记的过程，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含可达(已标记)与不可达(未标记)对象。</p>
<p>标记完成后，进入压缩阶段。在这个阶段中，垃圾回收器线性的遍历堆，以寻找不可达对象的连续内存块。并把可达对象移动到这里以压缩堆。这个过程有点类似于磁盘空间的碎片整理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211221112506.png"></p>
<p>如上图所示，绿色框表示可达对象，黄色框为不可达对象。不可达对象清除后，移动可达对象实现内存压缩(变得更紧凑)。</p>
<p>压缩之后，“指向这些对象的指针”的变量和CPU寄存器现在都会失效，垃圾回收器必须重新访问所有根，并修改它们来指向对象的新内存位置。这会造成显著的性能损失。这个损失也是托管堆的主要缺点。</p>
<p><strong>GC不是用引用计数</strong></p>
<p>引用计数是COM(Component Object Model)使用的办法，GC并不是用这个，而是用的从根遍历。了解即可。说的是堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一“部分”到达代码某个不再需要对象的地方，就递减这个计数，直到0就可以删除了。</p>
<p><strong>根（Root）</strong></p>
<p>我们将所有引用类型的变量都成为<strong>根</strong>，类中定义的任何静态字段，方法的参数，局部变量(仅限引用类型变量)等都是根，另外cpu寄存器中的对象指针也是根。根是CLR在堆之外可以找到的各种入口点。</p>
<p><strong>可达和不可达</strong></p>
<p>对象可达与不可达(Objects reachable and unreachable)：</p>
<p>如果一个根引用了堆中的一个对象，则该对象为“可达”，否则即是“不可达”。</p>
<p><strong>引用跟踪 GC算法详解</strong></p>
<p>CLR针对无法处理循环引用的情况，推出了引用跟踪算法，它只关心引用类型的变量，因为只有这种变量能引用堆上的对象。</p>
<p>GC时，</p>
<ol>
<li><p>  CLR先<strong>暂停进程中的所有线程</strong>，避免检查时对象状态被更改。</p>
</li>
<li><p>  CLR进入GC的<strong>标记阶段</strong>。这个阶段中，CLR先遍历堆中所有对象，将<font color="brown">同步块索引中的一位</font>设为0：这一位是0代表着对象未被引用要删除，是1代表对象被引用着。</p>
</li>
<li><p>  然后检查所有活动根，查看它们引用的对象，如果对象是null就跳过；否则就进行标记(就是上面说的一位改为1)。一个对象A第一次被标记后，CLR会检查这个对象A中的根(也就是这个对象A中自己的字段啥的)，查看是否也引用了其他对象BCD，有就标记。当下次有根标记这个对象A的时候，就不再检查内部字段了。这样能解决循环引用：根引用了A，A中有B导致B被标记，B中有A发现A已经被标记就不标记了。</p>
</li>
<li><p>  标记阶段结束，进入<strong>压缩</strong>阶段。这个阶段中CLR让堆中的所有幸存对象都紧挨在一起，使内存的地址空间得到释放。操作完内存后，将所有引用幸存对象的根减去所引用的对象在内存中偏移的字节数，从而保证每个根引用与以前一样的对象。</p>
</li>
</ol>
<p>结束GC后，如果GC并没有分出足够的内存给新的new操作，就会抛出OutOfMemoryException异常。</p>
<h3 id="根的作用域"><a href="#根的作用域" class="headerlink" title="根的作用域"></a>根的作用域</h3><p>根一旦离开作用域，它引用的对象就会变得“不可达”。</p>
<p>下面演示一个程序：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object o</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now);</span><br><span class="line">    <span class="comment">// 执行一次强制垃圾回收</span></span><br><span class="line">    GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行会发现，程序只输出了一次，而不是每2秒一次。</p>
<p>原因是<code>GC.Collect();</code>这句，回收开始时，会假设堆中所有都对象不可达，而CLR发现Main方法再也没有继续用过变量t，所以会回收它的内存。</p>
<p>然而神奇的是，这么写也是不对的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">    <span class="comment">// 想在Read之后引用t但是失败了，因为编译器优化了这一段</span></span><br><span class="line">    t  = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的方法应该这么写：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 每2000ms久调用一次TimerCallback方法</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(TimerCallback, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">    <span class="comment">// 在Read之后引用t（在Dispose方法返回之前，t会在GC中存活）</span></span><br><span class="line">    t.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分代-Generation-算法"><a href="#分代-Generation-算法" class="headerlink" title="分代(Generation)算法"></a>分代(Generation)算法</h2><p><strong>假设原则</strong></p>
<p>CLR的GC对代码做出了以下几点假设：</p>
<ul>
<li>  对象越新，生存期越短。</li>
<li>  对象越老，生存期越长。</li>
<li>  回收堆的一部分，速度快于回收整个堆。</li>
</ul>
<p>以此为方针，制定GC的机制。</p>
<p><strong>回收机制</strong></p>
<p>简单来说就是回收时，不可达的直接销毁，可达的压缩并放到下一代中，称作“存活对象”。</p>
<p>CLR托管堆支持3代：第0代，第1代，第2代。便于理解，可以将第0代的空间理解为256KB，第1代理解为2M，第2代理解为10M。新构造的对象会被分配到第0代。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211228093933.png"></p>
<p>如上图所示，当第0代的空间满时，垃圾回收器启动回收，不可达对象(上图C、E)会被回收，存活的对象被归为第1代。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211228093946.png"></p>
<p>当第0代空间已满，第1代也开始有很多不可达对象以至空间将满时，这时两代垃圾都将被处理：存活下来的对象(可达对象)，第0代升为第1代，第1代升为第2代。</p>
<p><strong>“预算”机制</strong></p>
<p>如果说GC时，第1代中有一些“不可达”的存在，但是第1代已用的内存开销小于<strong>预算</strong>，那么就不用担心不够用，此时去扫描一遍第1代整体进行GC处理是非常多余的。所以这个时候，CLR就会选择<strong>忽略</strong>第1代的GC，直到某一次GC发现第1代的开销到达了预算。</p>
<p>实际CLR的代回收机制更加“智能”，如果新创建的对象生存周期很短，第0代垃圾也会立刻被垃圾回收器回收(不用等空间分配满)。另外，如果回收了第0代，发现还有很多对象“可达”，并没有释放多少内存，就会增大第0代的预算至512KB，回收效果就会转变为：垃圾回收的次数将减少，但每次都会回收大量的内存。如果还没有释放多少内存，垃圾回收器将执行完全回收(3代)，如果还是不够，则会抛出“内存溢出”异常。</p>
<p>也就是说，垃圾回收器会根据回收内存的大小，动态的调整每一代的分配空间预算！达到自动优化。</p>
<p><strong>GCNotification</strong></p>
<p>该类在 第0代 or 第2代 回收时引发一个事件，可用来计算2次回收的间隔时间、分配了多少内存。</p>
<h2 id="强制垃圾回收"><a href="#强制垃圾回收" class="headerlink" title="强制垃圾回收"></a>强制垃圾回收</h2><h3 id="垃圾回收触发方式"><a href="#垃圾回收触发方式" class="headerlink" title="垃圾回收触发方式"></a>垃圾回收触发方式</h3><ul>
<li>  0代超过预算时自动触发GC</li>
<li>  代码显式调用<strong>System.GC的静态Collect</strong>方法</li>
<li>  Windows报告低内存情况</li>
<li>  CLR正在卸载AppDomain、CLR正在关闭</li>
</ul>
<h3 id="System-GC"><a href="#System-GC" class="headerlink" title="System.GC"></a>System.GC</h3><p>GC.Collect最复杂的重载签名也就这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span>(<span class="params">Int32 generation, GCCollectionMode mode, Boolean blocking</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>  generation：最多回收到x代（最高2）。</li>
<li>  blocking：阻塞（非并发）或后台（并发）回收的一个Boolean值。</li>
<li>  mode：如下表。</li>
</ul>
<table>
<thead>
<tr>
<th>符号名称</th>
<th>说明 GCCollectionMode枚举类</th>
</tr>
</thead>
<tbody><tr>
<td>Default</td>
<td>等同于不传递任何符号名称。目前还等同于传递 Forced,但CLR未来的版本可能对此进行修改</td>
</tr>
<tr>
<td>Forced</td>
<td>强制回收指定的代（以及低于它的所有代）</td>
</tr>
<tr>
<td>Optimized</td>
<td>只有在能释放大量内存或者能减少碎片化的前提下，才执行回收。如果垃圾回收没有什么效率，当前调用就没有任何效果</td>
</tr>
</tbody></table>
<h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>前面讨论的都是小对象，对于大对象（出书时是85000字节以上），CLR会区分对待：</p>
<p>内存不是在小对象的地址空间分配，而是进程地址空间的其他地方分配；总是第2代；目前不支持压缩。</p>
<h3 id="垃圾回收模式"><a href="#垃圾回收模式" class="headerlink" title="垃圾回收模式"></a>垃圾回收模式</h3><p>默认使用工作站GC模式，可以在配置文件中修改。</p>
<p><strong>工作站</strong></p>
<p>针对客户端的GC模式，假设其他应用程序不占用太多CPU资源。GC造成的延时很低，程序挂起时间很短。</p>
<p><strong>服务器</strong></p>
<p>针对服务端的GC模式，假设没有其他应用程序，所有的CPU都可用来辅助完成GC。优化了吞吐量和资源利用。每个CPU都跑一个特殊线程，它和其他线程并发回收自己的区域。</p>
<h2 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h2><h3 id="Finalize方法对GC过程的影响"><a href="#Finalize方法对GC过程的影响" class="headerlink" title="Finalize方法对GC过程的影响"></a>Finalize方法对GC过程的影响</h3><p>写代码时，理解的是GC时Finalize方法会被得到调用。实际上CLR是用了2个专门的列表来操作的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115018.png"></p>
<p>**一个是终结列表(finalization list)**，</p>
<p>对象创建(new)时，CLR检测到他们的Finalize方法被重写，就会把这些对象的指针扔进终结列表。</p>
<p>**另一个是F-reachable队列(finalization reachable Arrary)**，</p>
<p>一个无情的只顾执行对象Finalize方法然后将其移除的队列。</p>
<p>它们之间的协作：</p>
<p>终结列表中的对象在得知需要被回收后，会从终结列表转移到F-reachable队列中。此时，对象变得不在被认为是垃圾，还不能回收他的内存，被标记为垃圾但是不被认为是垃圾，叫<strong>复活</strong>了。垃圾回收器会递归该对象中所有的引用，让它们也不被内存回收，但是会被GC到更老的一代。<strong>下次GC时</strong>早已经执行完Finalize方法，会发现之前复活的对象们已经不可达，然后会回收。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115028.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230115038.png"></p>
<h3 id="有一些特殊的类，需要清理本机资源"><a href="#有一些特殊的类，需要清理本机资源" class="headerlink" title="有一些特殊的类，需要清理本机资源"></a>有一些特殊的类，需要清理本机资源</h3><p>上面说的类都是只需要内存资源就行，但是有些类比如FileStream类型需要占用本机资源(打开文件保存句柄)。</p>
<p>GC清理不了这些本机资源。</p>
<p>这里就可以使用Finalize方法来<strong>清理本机资源</strong>。</p>
<h3 id="Finalize-1"><a href="#Finalize-1" class="headerlink" title="Finalize"></a>Finalize</h3><p>GC判定对象是垃圾后，会调用其Finalize方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeType</span>&#123;</span><br><span class="line">    ~SomeType() &#123; Finalize方法体 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; C#实际生成代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeType</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="title">Finalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           Finalize方法体 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">base</span>.Finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CLR用一个特殊的高优先级的<strong>专用线程</strong>调用Finalize方法来避免死锁。Finalize方法如果阻塞(比如死循环)，会导致该线程瘫痪，致使整个程序内存不停泄露并无法捕捉到此异常。</p>
<h3 id="SafeHandle-CriticalFinalizerObject"><a href="#SafeHandle-CriticalFinalizerObject" class="headerlink" title="SafeHandle : CriticalFinalizerObject"></a>SafeHandle : CriticalFinalizerObject</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Safehandle</span> : <span class="title">CriticalFinalizerObject</span>, <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//这是本机资源的句柄</span></span><br><span class="line">	<span class="keyword">protected</span> IntPtr handle;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Safehandle</span>(<span class="params">IntPtr invalidhandlevalue, Boolean ownsHandle</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.handle = invalidhandlevalue;</span><br><span class="line">		<span class="comment">// 如果ownsHandle为true,那么这个从 Safehandle派生的对象被回收时，</span></span><br><span class="line">		<span class="comment">//本机资源会被关闭</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Sethandle</span>(<span class="params">IntPtr handle</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.handle = handle;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 这个默认实现会忽略 disposing参数</span></span><br><span class="line">		<span class="comment">// 如果资源已经释放，那么返回</span></span><br><span class="line">		<span class="comment">// 如果 ownsHandle为false,那么返回</span></span><br><span class="line">		<span class="comment">// 设置一个标志来指明该资源已经释放</span></span><br><span class="line">		<span class="comment">// 调用虚方法 ReleaseHandle</span></span><br><span class="line">		<span class="comment">// 调用GC, SuppressFinalize(this)方法来阻止调用Finalize方法</span></span><br><span class="line">		<span class="comment">// 如果 ReleaseHandle返回true,那么返回</span></span><br><span class="line">		<span class="comment">// 如果走到这一步，就激活 releaseHandleFailed托管调试助手（MDA)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认的 Finalize实现（如下所示）正是我们希望的。强烈建议不要重写这个方法</span></span><br><span class="line">	~Safehandle() &#123; Dispose(<span class="literal">false</span>);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.需要重写以实现释放资源的代码</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">ReleaseHandle</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetHandleAsInvalid</span>(<span class="params"></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 设置标志来指出这个资源已经释放</span></span><br><span class="line">		<span class="comment">// 调用GC, SuppressFinalize(this)方法来阻止调用Finalize方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span> IsClosed</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">get</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 返回指出资源是否释放的一个标志</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 2.派生类要重写这个属性</span></span><br><span class="line">	<span class="comment">// 如果句柄的值不代表资源(通常意味着句柄为0或-1),实现应返回true</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> IsInvalid</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了进一步深入了解SafeHandle类，上下都介绍一下：</p>
<p><strong>父类，CriticalFinalizerObject</strong></p>
<p>CLR特殊对待的类，它的行为：</p>
<ol>
<li>  首次构造时就进行此类Finalize方法JIT编译，保证不会出现内存满后无法编译Finalize导致无法执行的情况。</li>
<li>  在所有非CriticalFinalizerObject派生类的Finalize执行完后才开始执行它们的Finalize，这样非CriticalFinalizerObject派生类可以在Finalize中安全调用它们。</li>
<li>  AppDomain被宿主应用程序强行中断，也会调用CriticalFinalizerObject类的Finalize方法。</li>
</ol>
<p><strong>子类1，SafeFileHandle</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SafeFileHandle</span>: <span class="title">SafeHandleZeroOrMinusOneIsInvalid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeFileHandle</span>(<span class="params">Intptr preexistingHandle, Boolean ownsHandle</span>) : <span class="title">base</span>(<span class="params">ownshandle</span>)</span></span><br><span class="line">    &#123;     </span><br><span class="line">		<span class="keyword">base</span>. Sethandle(preexistinghandle);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Boolean <span class="title">Releasehandle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 告诉 Windows我们希望本机资源关闭</span></span><br><span class="line">        <span class="keyword">return</span> Win32Native.CloseHandle(<span class="keyword">base</span>.handle);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC句柄表"><a href="#GC句柄表" class="headerlink" title="GC句柄表"></a>GC句柄表</h3><p>是说CLR为每个AppDomain都提供了一个**GC句柄表(GC Handle table)<strong>，允许程序监视or手动控制对象的生存期。句柄表启动时是空白的，每个记录项都包含了</strong>对托管堆中的一个对象的引用，以及指出如何监视或控制对象的标志(flag)**。</p>
<p>使用<code>System.Runtime.InteropServices.GCHandle</code>类型在表中添加或删除记录项。在表中创建一个记录项调用该类的<code>public static GCHandle Alloc(object value, GCHandleType type);</code>，对象+标志。</p>
<p><strong>GCHandleType</strong>有下面4种枚举类：</p>
<p><strong>Weak</strong><br>该标志允许监视对象的生存期。具体地说，可检测垃圾回收器在什么时候判定该对象<br>在应用程序代码中不可达。注意，此时对象的 Finalize方法可能执行，也可能没有执<br>行，对象可能还在内存中。</p>
<p><strong>Weaktrackresurrection</strong><br>该标志允许监视对象的生存期。具体地说，可检测垃圾回收器在什么时候判定该对象<br>在应用程序的代码中不可达。注意，此时对象的 Finalize方法（如果有的话）已经执行，<br>对象的内存已经回收。</p>
<p><strong>Normal</strong><br>该标志允许控制对象的生存期。具体地说，是告诉垃圾回收器：即使应用程序中没有<br>变量（根）引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存可<br>以压缩（移动）。不向Ale方法传递任何 Gchandle Type标志，就默认使用<br>Gchandle T’ype Normal</p>
<p><strong>Pinned</strong><br>该标志允许控制对象的生存期。具体地说，是告诉垃圾回收器：即使应用程序中没有<br>变量（根）引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存不<br>能压缩（移动）。需要将内存地址交给本机代码时，这个功能很好用。本机代码知道GC<br>不会移动对象，所以能放心地向托管堆的这个内存写入。</p>
<h1 id="大章22：CLR寄宿和AppDomain"><a href="#大章22：CLR寄宿和AppDomain" class="headerlink" title="大章22：CLR寄宿和AppDomain"></a><center>大章22：CLR寄宿和AppDomain</center></h1><h2 id="CLR寄宿"><a href="#CLR寄宿" class="headerlink" title="CLR寄宿"></a>CLR寄宿</h2><p>**寄宿(hosting)**使任何应用程序都能使用CLR的功能。</p>
<p>所有托管模块和程序集文件都必须使用 Windows PE文件格式，而且要么是 Windows EXE文件，要么是DLL文件。</p>
<p><strong>开发CLR时， Microsoft实际是把它实现成包含在一个DLL中的COM服务器。</strong>很遗憾，这一句对于目前的我来说还无法深入理解，放着吧。</p>
<p>**垫片(slim)**，MSCorEE.dll。</p>
<p>CLRCreateInstance函数在MSCorEE.dll文件中实现。“垫片”的工作是决定创建哪个版本的CLR（1.0、2.0、3.0的CLR代码在MSCorWks.dll文件中；版本4则在Clr.dll文件中）。CLRCreateInstance函数可返回一个ICLRMetaHost接口。宿主应用程序可调用这个接口的GetRuntime函数，指定宿主要创建的CLR版本。然后，垫片将所需版本的CLR加载到宿主的进程中。</p>
<h2 id="初识AppDomain"><a href="#初识AppDomain" class="headerlink" title="初识AppDomain"></a>初识AppDomain</h2><p><strong>AppDomain是什么</strong></p>
<p>CLR COM服务器初始化时会创建一个AppDomain。<strong>AppDomain是一组程序集的逻辑容器，它存在的目的是为了隔离。</strong>CLR初始化时创建的第一个AppDomain称为“默认AppDomain”，这个默认的AppDomain只有在Windows进程终止时才会被销毁。</p>
<p>在 Windows中，线程总是在一个进程的上下文中创建，而且线程的整个生存期都在该进程的生存期内。<strong>但线程和Appdomain没有一对一关系。</strong>一个Windows进程可包含多个Appdomain，所以线程能执行一个Appdomain中的代码，再执行另一个AppDomain中的代码。从CLR的角度看，<strong>线程一次只能执行一个Appdomain中的代码。</strong></p>
<p><strong>AppDomain长这样</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211230160015.png"></p>
<p>AppDomain #1和AppDomain #2完全不共享信息，以至于他们都用了System.dll却不共用。虽然有些浪费内存资源，但是这就是AppDomain的本质，“隔离”。</p>
<p>另外针对这种浪费，CLR也提供了一种<strong>AppDoamin中立</strong>加载方式的程序集。CLR会为它们维护一个特殊的Loader堆，该Loader堆中的所有资源都会共享给同一个进程中的其他AppDomain。省下资源的代价是这样的程序集永远不能卸载，只能终止Windows进程让Windows回收资源。</p>
<p><strong>AppDomain特点</strong></p>
<p><strong>①一个AppDomain的代码不能直接访问另一个AppDomain的代码创建的对象。</strong><br>一个AppDomain中的代码创建了一个对象后，该对象便被该AppDomain“拥有”。换言之，它的生存期不能超过创建它的代码所有的AppDomain。一个AppDomain中的代码要访问另一个AppDomain的对象，只能使用“按引用封送”或者“按值封送”的予以。这就强制建立了清晰的分割和边界，因为一个AppDomain中的代码不能直接引用另一个AppDomain中的代码创建的对象。这种隔离使AppDomain能很容易地从进程中卸载，不会影响其他AppDomain正在运行的代码<br><strong>②AppDomain可以卸载</strong><br>CLR不支持从AppDomain中卸载特定的程序集，但可以告诉CLR卸载一个AppDomain，从而卸载该AppDomain当前包含的所有程序集<br><strong>③AppDomain可以单独保护</strong><br>AppDomain创建后会应用一个权限集，它决定了想这个AppDomain中运行的程序集授予最大权限，正是由于存在这样的权限，所以当宿主加载一些代码后，可以保证这些代码不会破坏（或读取）宿主本身使用的一些重要数据结构<br><strong>④AppDomain可以单独配置</strong><br>AppDomain创建后会关联一组配置设置。这些设置主要影响CLR在AppDomain中加载程序集的方式，设计搜索路径、版本绑定重定向、卷影复制以及加载器优化</p>
<p><strong>跨越AppDomain边界访问对象</strong></p>
<p>一个AppDomain中的代码可以和另一个AppDomain中的类型和对象通信，但只能通过良好定义的机制执行。</p>
<p>抄个网上的可运行demo，做了解吧，以后深入ILRuntime之后再补一些理解：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication7</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Marshalling();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Marshalling</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//获取AppDomain引用（“调用线程”当前正在该AppDomain中执行）</span></span><br><span class="line">			AppDomain adCallingThreadDomain = Thread.GetDomain();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//每个AppDomain都分配了友好字符串名称（以便调试）</span></span><br><span class="line">			<span class="comment">//获取这个AppDomain的友好名称并显示它</span></span><br><span class="line">			String CallingDomainName = adCallingThreadDomain.FriendlyName;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;默认AppDomain友好的名称=&#123;0&#125;&quot;</span>, adCallingThreadDomain);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//获取并显示我们的AppDomain中包含了“Main”方法的程序集</span></span><br><span class="line">			String exeAssembly = Assembly.GetEntryAssembly().FullName;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;包含“Main”方法的程序集=&#123;0&#125;&quot;</span>, exeAssembly);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义局部变量来引用一个AppDomain</span></span><br><span class="line">			AppDomain ad2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//************************************************************************************************************</span></span><br><span class="line">			<span class="comment">//************************************************************ DEMO 1：使用“按引用封送”进行跨AppDomain通信 ***</span></span><br><span class="line">			<span class="comment">//************************************************************************************************************</span></span><br><span class="line">			Console.WriteLine(<span class="string">&quot;&#123;0&#125; Demo1 按引用封送&quot;</span>, Environment.NewLine);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//新建一个AppDomain（从当前AppDomain继承安全性和配置）</span></span><br><span class="line">			ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">			MarshalByRefType mbrt = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//将我们的程序集加载到新AppDomain,构造一个对象，把它封送回我们的AppDomain（实际得到对一个代理的引用）</span></span><br><span class="line">			mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"></span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Type=&#123;0&#125;&quot;</span>, mbrt.GetType());<span class="comment">//CLR在类型上撒谎了</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//证明得到的是对一个代理对象的引用</span></span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Is proxy=&#123;0&#125;&quot;</span>, RemotingServices.IsTransparentProxy(mbrt));</span><br><span class="line"></span><br><span class="line">			<span class="comment">//看起来像是在MarshalByRefType上调用了一个方法，实则不然。</span></span><br><span class="line">			<span class="comment">//我们是在代理类型上调用了一个方法，代理是线程切换到拥有对象的那个</span></span><br><span class="line">			<span class="comment">//AppDomain,并在真实的对象上调用这个方法</span></span><br><span class="line">			mbrt.SomeMethod();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//卸载新的AppDomain</span></span><br><span class="line">			AppDomain.Unload(ad2);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//此时，mbrt引用了一个有效的代理对象；代理对象引用一个无效的AppDomain</span></span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				mbrt.SomeMethod();</span><br><span class="line">				Console.WriteLine(<span class="string">&quot;调用成功&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (AppDomainUnloadedException)</span><br><span class="line">			&#123;</span><br><span class="line">				Console.WriteLine(<span class="string">&quot;调用失败，AppDomain被卸载了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//************************************************************************************************************</span></span><br><span class="line">			<span class="comment">//************************************************************ DEMO 2：使用“按值封送”进行跨AppDomain通信 ***</span></span><br><span class="line">			<span class="comment">//************************************************************************************************************</span></span><br><span class="line">			Console.WriteLine(<span class="string">&quot;&#123;0&#125; Demo2 按值封送&quot;</span>, Environment.NewLine);</span><br><span class="line">			ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">			mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//对象的方法返回所返回对象的副本</span></span><br><span class="line">			<span class="comment">//对象按值（而非按引用）封送</span></span><br><span class="line">			MarshalByValType mbvt = mbrt.MethodWithReturn();</span><br><span class="line">			<span class="comment">//证明得到的是对一个代理对象的引用</span></span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Is proxy=&#123;0&#125;&quot;</span>, RemotingServices.IsTransparentProxy(mbvt));</span><br><span class="line">			<span class="comment">//看起来在MarshalByValType上调用一个方法，实际也是如此</span></span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Return object created &quot;</span> + mbvt.ToString());</span><br><span class="line">			<span class="comment">//卸载新的AppDomain</span></span><br><span class="line">			AppDomain.Unload(ad2);</span><br><span class="line">			<span class="comment">//此时，mbrt引用了一个有效的x代理对象；代理对象引用一个无效的AppDomain</span></span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//卸载AppDomain之后调用mbvt方法不会抛出异常</span></span><br><span class="line">				Console.WriteLine(<span class="string">&quot;Return object created &quot;</span> + mbvt.ToString());</span><br><span class="line">				Console.WriteLine(<span class="string">&quot;调用成功&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (AppDomainUnloadedException)</span><br><span class="line">			&#123;</span><br><span class="line">				Console.WriteLine(<span class="string">&quot;调用失败，AppDomain被卸载了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//************************************************************************************************************</span></span><br><span class="line">			<span class="comment">//************************************************************ DEMO 3：使用不可封送的类型进行跨AppDomain通信 ***</span></span><br><span class="line">			<span class="comment">//************************************************************************************************************</span></span><br><span class="line">			ad2 = AppDomain.CreateDomain(<span class="string">&quot;AD #2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">			mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly, <span class="string">&quot;ConsoleApplication7.MarshalByRefType&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				NonMarshalableType nmt = mbrt.MethodArgAndReturn(CallingDomainName);<span class="comment">//抛出异常:未标记为可序列化</span></span><br><span class="line">			&#125;</span><br><span class="line">			catch (SerializationException)</span><br><span class="line">			&#123;</span><br><span class="line">				Console.WriteLine(<span class="string">&quot;抛出异常:未标记为可序列化&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Console.ReadKey();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//该类型的实例可跨越AppDomain的边界“按引用封送”</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByRefType</span> : <span class="title">MarshalByRefObject</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MarshalByRefType</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;&#123;0&#125; ctor running in &#123;1&#125;&quot;</span>, GetType(), Thread.GetDomain().FriendlyName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Executing in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> MarshalByValType <span class="title">MethodWithReturn</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Execute in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">			MarshalByValType t = <span class="keyword">new</span> MarshalByValType();</span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> NonMarshalableType <span class="title">MethodArgAndReturn</span>(<span class="params"><span class="built_in">string</span> callingDomainName</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//注意：callingDomainName是可序列化的</span></span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Calling from &#x27;&#123;0&#125;&#x27; to &#x27;&#123;1&#125;&#x27;.&quot;</span>, callingDomainName, Thread.GetDomain().FriendlyName);</span><br><span class="line">			NonMarshalableType t = <span class="keyword">new</span> NonMarshalableType();</span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//该类的实例可跨越AppDomain的边界“按值封送”</span></span><br><span class="line">	[<span class="meta">Serializable</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByValType</span> : <span class="title">Object</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> DateTime m_creationTime = DateTime.Now;<span class="comment">//注意：DateTime是可序列化的</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MarshalByValType</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;&#123;0&#125; ctor running in &#123;1&#125;, Created no &#123;2:D&#125;&quot;</span>, GetType(), Thread.GetDomain().FriendlyName,</span><br><span class="line">				m_creationTime);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> m_creationTime.ToLongDateString();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该类的实例不能跨AppDomain边界进行封送</span></span><br><span class="line">	<span class="comment">//[Serializable]</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">NonMarshalableType</span> : <span class="title">Object</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">NonMarshalableType</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Execute in &quot;</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="操作AppDomain"><a href="#操作AppDomain" class="headerlink" title="操作AppDomain"></a>操作AppDomain</h2><h3 id="卸载AppDomain"><a href="#卸载AppDomain" class="headerlink" title="卸载AppDomain"></a>卸载AppDomain</h3><p>调用<strong>AppDomain的静态Unload方法</strong>可以实现卸载，CLR会按顺序执行以下操作：</p>
<ol>
<li>  挂起进程中的所有线程。</li>
<li>  检查每一个线程栈，如果线程在执行即将卸载的AppDomain中的代码，就抛出一个ThreadAbortException，并执行所有遇到的finally块。线程终止，进程可继续运行。</li>
<li>  所有线程离开目标AppDomain后，CLR遍历堆，为所有引用了目标AppDomain中的对象设置一个标志，告诉它们引用的真实对象已经不在了，再调用它们会抛出AppDomainUnloadedException异常。</li>
<li>  强制垃圾回收目标AppDomain的对象。</li>
<li>  Unload执行完毕，恢复剩余所有线程运行，此刻调用了AppDomain.Unload方法的线程才会继续运行。</li>
</ol>
<h3 id="监视AppDomain"><a href="#监视AppDomain" class="headerlink" title="监视AppDomain"></a>监视AppDomain</h3><p>// TODO 本章后续的内容等实际工作用到再看吧。</p>
<h1 id="大章23：程序集加载和反射"><a href="#大章23：程序集加载和反射" class="headerlink" title="大章23：程序集加载和反射"></a><center>大章23：程序集加载和反射</center></h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><h3 id="程序集可以用Load加载"><a href="#程序集可以用Load加载" class="headerlink" title="程序集可以用Load加载"></a>程序集可以用Load加载</h3><p>使用System.Reflection.Assembly类的静态Load方法可以在运行时加载程序集。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">publiv <span class="keyword">class</span> <span class="title">Assembly</span>&#123;</span><br><span class="line">    <span class="comment">// 2种常用重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">Load</span>(<span class="params">AssemblyName assemblyRef</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">Load</span>(<span class="params">String assemblyString</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据路径加载，内部只是找到AssemblyName作为参数传给Load方法</span></span><br><span class="line">    <span class="comment">// ex: Assembly a  = Assembly.LoadFrom(@&quot;http://Wintellect.com/SomeAssembly.dll&quot;);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">LoadFrom</span>(<span class="params">String assemblyString</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和Load不同的是，不会用版本策略，指定哪个版本就用那个版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">ReflectionOnlyLoadFrom</span>(<span class="params">String assemblyFile</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在Load内部，CLR会应用绑定重定向"><a href="#在Load内部，CLR会应用绑定重定向" class="headerlink" title="在Load内部，CLR会应用绑定重定向"></a>在Load内部，CLR会应用绑定重定向</h3><p>在GAC(全局程序集缓存）中查找程序集。如果没找到就接着去应用程序的基目录、私有路径子目录和 codebase位置查找。如果调用Load时传递的是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/w6w6/p/10592356.html">弱命名程序集</a>，Load就不会向程序集应用版本绑定重定向策略，CLR也不会去GAC査找程序集。</p>
<p>找到指定程序集后，会返回对代表已加载程序集的一个Assembly对象的引用，否则会抛出IO异常。</p>
<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><h3 id="使用反射构建动态可扩展应用程序"><a href="#使用反射构建动态可扩展应用程序" class="headerlink" title="使用反射构建动态可扩展应用程序"></a>使用反射构建动态可扩展应用程序</h3><p>通过反射的运行时序列化，使得应用程序在运行时可显式加载程序集构造类型的实例，再调用类型中定义的方法，这种绑定方法叫做<strong>晚期绑定</strong>。</p>
<h3 id="反射的性能"><a href="#反射的性能" class="headerlink" title="反射的性能"></a>反射的性能</h3><ol>
<li>  反射造成编译时无法保证类型安全性，严重依赖字符串。搜索”int”是没法找到”System.Int32”的。</li>
<li>  反射速度慢。</li>
</ol>
<p>针对第2点，提一些具体情况来理解慢在哪里：</p>
<ul>
<li>  类型及其成员的名称在编译时未知，需要用字符串名称标识每个类型以及成员。<strong>反射机制会不停的对字符串进行搜索。</strong></li>
<li>  用反射调用方法时，必须将实参打包(pack)成数组；在内部，反射必须将这些实参解包(unpack)到线程栈上。导致CLR必须检查实参的数据类型是否正确、以及访问权限。</li>
</ul>
<p>那么针对反射速度慢，有一些常见构造方案来实现类的动态行为，避免反射：</p>
<ul>
<li>  <strong>继承+重载</strong>。用父类变量接子类实例(转型)，再调用基类虚方法。</li>
<li>  <strong>接口</strong>。用接口变量接实例(转型)，再调用接口定义的方法。</li>
</ul>
<h3 id="来点反射代码"><a href="#来点反射代码" class="headerlink" title="来点反射代码"></a>来点反射代码</h3><h4 id="程序集-反射"><a href="#程序集-反射" class="headerlink" title="程序集+反射"></a>程序集+反射</h4><p>通过反射获取一个程序集定义了哪些类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        String dataAssembly =<span class="string">&quot;System, Data, veraionm4,0.0.0, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;culture-neutral, Publickeytoken=b77a5c561934e089&quot;</span>;</span><br><span class="line">        LoadAssemAndShowPublicTypes(dataAssembly);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadAssemAndShowPublicTypes</span>(<span class="params">String assemId</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 显式地将程序集加载到这个Appdomain中</span></span><br><span class="line">        Assembly a =  Assembly.Load(assemId);</span><br><span class="line">        <span class="comment">// 在一个循环中显示已加载程序集中每个公开导出Type的全名</span></span><br><span class="line">        <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> a.Exportedtypes)&#123;</span><br><span class="line">            <span class="comment">//显示类型全名</span></span><br><span class="line">            Console.Writeline(t.Fullname):</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h4><p>Type只是轻量级的对象引用，想要更多类型信息，可用TypeInfo对象。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type someType = <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line">TypeInfo info = someType.GetTypeInfo(); <span class="comment">// Extensions:System.Reflection.Introspections.GetTypeInfo </span></span><br></pre></td></tr></table></figure>

<h4 id="批量加载"><a href="#批量加载" class="headerlink" title="批量加载"></a>批量加载</h4><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106144143.png"></p>
<h3 id="反射构造类型实例"><a href="#反射构造类型实例" class="headerlink" title="反射构造类型实例"></a>反射构造类型实例</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol>
<li>  System.Activator 的 CreateInstance 方法。</li>
<li>  System.Activator 的 CreateInstanceFrom 方法。</li>
<li>  System.AppDomain 的方法。4种实例方法，可以指定在哪个AppDomain中构造对象。</li>
<li>  System.Reflection.ConstructorInfo 的 Invoke 实例方法。绑定到特定的构造器到ConstructorInfo 中。</li>
</ol>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>System.Array 的 静态CreateInstance方法。</p>
<h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>MethodInfo 的 静态CreateDelegate方法。</p>
<h4 id="开放类型"><a href="#开放类型" class="headerlink" title="开放类型"></a>开放类型</h4><p>MakeGenericType方法。</p>
<p>![image-20220106145501671](E:\My Github\hexo\blog\source_posts\Tech\CSharp\CLR-Via-CSharp\cp6.assets\image-20220106145501671.png)</p>
<h2 id="反射-程序集加载-设计支持加载项的应用程序⭐"><a href="#反射-程序集加载-设计支持加载项的应用程序⭐" class="headerlink" title="反射+程序集加载 = 设计支持加载项的应用程序⭐"></a>反射+程序集加载 = 设计支持加载项的应用程序⭐</h2><p><strong>接口是中心。</strong>假设要写一个应用程序来无缝地加载和使用别人创建的类型，</p>
<ol>
<li>  创建“宿主SDK (Host SDK)”程序集，<strong>接口的方法</strong>作为宿主应用程序与加载项之间的通信机制使用。</li>
<li>  创建单独的“宿主应用程序”程序集，引用“宿主SDK”程序集，随意开发。</li>
</ol>
<p><strong>来看一个上述的例子</strong>：</p>
<p>首先是<strong>宿主SDK</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostSDK.dll 程序集</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Wintellect.HostSDK</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAddIn</span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">DoSomething</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是引用了HostSDK.dll的<strong>AddInTypes.dll程序集</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddInTypes.dll 程序集</span></span><br><span class="line"><span class="keyword">using</span> Wintellect.HostSDK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AddIn_A</span> : <span class="title">IAddIn</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddIn_A</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddIn_A:&quot;</span> + x.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AddIn_B</span> : <span class="title">IAddIn</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddIn_B</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddIn_B:&quot;</span> + (x * <span class="number">2</span>).ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们写一个简单的Host.exe程序集的代码，也就是<strong>宿主应用程序</strong>。它必须引用HostSDK.dll程序集。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Host.exe 程序集</span></span><br><span class="line"><span class="keyword">using</span> Wintellect.HostSDK;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找宿主EXE文件所在的目标</span></span><br><span class="line">        String AddInDir = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);</span><br><span class="line">        <span class="comment">// 假定加载项程序集和宿主EXE文件在一个目录</span></span><br><span class="line">        <span class="keyword">var</span> AddInAssemblies = Directory.EnumerateFiles(AddInDir, <span class="string">&quot;*.dll&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建可由宿主使用的所有加载Type的一个集合</span></span><br><span class="line">        <span class="keyword">var</span> AddInTypes = </span><br><span class="line">            <span class="keyword">from</span> file <span class="keyword">in</span> AddInAssemblies</span><br><span class="line">            <span class="keyword">let</span> assembly = Assembly.Load(file)</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> assembly.ExportedTypes <span class="comment">// 公开导出的类型</span></span><br><span class="line">            <span class="comment">// 如果类型实现了IAddIn接口，该类型就可由宿主使用。A.IsAssignableFrom(B) 查看B是否实现or继承了A。</span></span><br><span class="line">            <span class="keyword">where</span> t.IsClass &amp;&amp; <span class="keyword">typeof</span>(IAddIn).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo())</span><br><span class="line">            <span class="keyword">select</span> t;</span><br><span class="line">        <span class="comment">// 初始化完成:宿主已发现了所有可用的加载项</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面示范宿主如何构造加载项对象并使用它们</span></span><br><span class="line">        <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> AddInTypes)&#123;</span><br><span class="line">            IAddIn ai = (IAddIn) Activator.CreateInstance(t);</span><br><span class="line">            Console.WriteLine(ai.DoSth(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用反射发现类型的成员"><a href="#使用反射发现类型的成员" class="headerlink" title="使用反射发现类型的成员"></a>使用反射发现类型的成员</h2><p>揭示WPF、ILDasm等的窗体设计器是如何利用反射实现需求的。</p>
<h3 id="反射获取类型成员"><a href="#反射获取类型成员" class="headerlink" title="反射获取类型成员"></a>反射获取类型成员</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106164233.png"></p>
<p>可以先用<code>System.Reflection.MemberInfo</code>抽象基类来接对象，然后再具体判别是什么：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();</span><br><span class="line">    <span class="keyword">foreach</span>(Assembly a <span class="keyword">in</span> assemblies) &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(Type t <span class="keyword">in</span> a.ExportedTypes) &#123;</span><br><span class="line">            <span class="keyword">foreach</span>(MemberInfo mi <span class="keyword">in</span> t.GetTypeInfo().DeclaredMembers) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> Type) &#123; 嵌套类型 &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> FieldInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> MethodInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> ConstructorInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> PropertyInfo) &#123; &#125;</span><br><span class="line">                <span class="keyword">if</span>(mi <span class="keyword">is</span> EventInfo) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聊下MemberInfo"><a href="#聊下MemberInfo" class="headerlink" title="聊下MemberInfo"></a>聊下MemberInfo</h3><p>上面看到了MemberInfo类是成员层次结构的根，它的实现意味着所有派生成员的实现。下面解析下它：</p>
<h4 id="MemberInfo属性和方法"><a href="#MemberInfo属性和方法" class="headerlink" title="MemberInfo属性和方法"></a>MemberInfo属性和方法</h4><ul>
<li>  Name。成员名称</li>
<li>  DeclaringType。成员类型。</li>
<li>  Module。</li>
<li>  CustomAttributes。返回一个<code>IEnumerable&lt;CustomAttributeData&gt;</code>，特性实例。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220106172200.png"></p>
<h4 id="MemberInfo调用"><a href="#MemberInfo调用" class="headerlink" title="MemberInfo调用"></a>MemberInfo调用</h4><p><strong>FieldInfo</strong><br>调用 Getvalue获取字段的值<br>调用 Setvalue设置字段的值</p>
<p><strong>Constructorlnfo</strong><br>调用 Invoke构造类型的实例并调用构造器</p>
<p><strong>MethodInfo</strong><br>调用 Invoke来调用类型的方法</p>
<p><strong>PropertyInfo</strong><br>调用 Getvalue来调用的属性的get访问器方法<br>调用 Setvalue来调用属性的set访问器方法</p>
<p><strong>Eventlnfo</strong><br>调用 Addeventhandler来调用事件的add访问器方法<br>调用 Removeeventhandler来调用事件的 remove访问器方法</p>
<h4 id="使用绑定句柄减少进程的内存消耗"><a href="#使用绑定句柄减少进程的内存消耗" class="headerlink" title="使用绑定句柄减少进程的内存消耗"></a>使用绑定句柄减少进程的内存消耗</h4><p>很多情况下会这么写代码：绑定了一组类型(Type)或类型成员(MemberInfo派生)，并将这些对象保存在某种形式的集合中。然后只需要搜索这个集合就可以找到特定对象，并调用(比如Invoke)它。</p>
<p>这样写很方便，但是会导致一个问题，Type和MemberInfo派生对象需要大量内存，如果只是偶尔调用会造成严重浪费。</p>
<p>可以使用**运行时句柄(runtime handle)**代替对象以减小该Assembly的内存占用。使用System下的<code>RuntimeTypeHandle</code>、<code>RuntimeFieldHandle</code>、<code>RuntimeMethodHandle</code>。三个类型都是值类型，只包含了一个IntPtr，也就是一个句柄，指向AppDomain的Loader堆中的一个类型/方法/字段。可以使用<code>Type.GetTypeFromHandle</code>和<code>Type.GetTypeHandle</code>方法实现Type和IntPtr的相互转换。</p>
<h1 id="大章24：运行时序列化"><a href="#大章24：运行时序列化" class="headerlink" title="大章24：运行时序列化"></a><center>大章24：运行时序列化</center></h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>序列化是将<strong>对象or对象图(比如数组)<strong>转换成</strong>字节流</strong>的过程，反序列化是将字节流转换回对象图的过程。</p>
<p>再举一些例子：</p>
<ul>
<li>  ASP.NET利用序列化反序列化来保存和还原会话状态。</li>
<li>  WPF的对象剪切板由序列化反序列化实现。</li>
<li>  深拷贝/备份 对象</li>
<li>  不同端末之间的交互（pc与服务器）</li>
</ul>
<h3 id="序列化反序列化API"><a href="#序列化反序列化API" class="headerlink" title="序列化反序列化API"></a>序列化反序列化API</h3><p>微软提供 BinaryFormatter 和 SoapFormatter 两个格式化器，他们都是实现了<code>System.Runtime.Serialization.IFormatter</code>这个序列化专用的接口。</p>
<p>SoapFormatter在.net3.5废了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectGraph = <span class="keyword">new</span> List&lt;String&gt; &#123; <span class="string">&quot;Jeff&quot;</span>, <span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Grant&quot;</span> &#125;;</span><br><span class="line">MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 to stream</span></span><br><span class="line">formatter.Serialize(stream, objectGraph);</span><br><span class="line"><span class="comment">// 反序列化 to obj</span></span><br><span class="line">stream.Position = <span class="number">0</span>; <span class="comment">// 流的当前位置归零!否则在末尾</span></span><br><span class="line">Object obj = formatter.Deserialize(stream);</span><br></pre></td></tr></table></figure>

<p>序列化对象之后，会将类型的全名和字段都写入流中，甚至还会将程序集的信息写入进去。</p>
<p>我们尝试一下，发现直接转字符串是不行的，也是毕竟是流，要先转Byte，再转成人能看的懂的字节：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> readBuffer = <span class="keyword">new</span> <span class="built_in">byte</span>[stream.Length];</span><br><span class="line"><span class="built_in">int</span> count = stream.CanRead ? stream.Read(readBuffer, <span class="number">0</span>, readBuffer.Length) : <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> charCount = Encoding.Default.GetCharCount(readBuffer, <span class="number">0</span>, count);</span><br><span class="line"><span class="keyword">var</span> readCharArray = <span class="keyword">new</span> <span class="built_in">char</span>[charCount];</span><br><span class="line"></span><br><span class="line">Encoding.Default.GetDecoder().GetChars(readBuffer, <span class="number">0</span>, count, readCharArray, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; readCharArray.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    test += readCharArray[i];</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(test);</span><br></pre></td></tr></table></figure>

<p>最后输出这么个东西，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test = <span class="string">&quot;\0\u0001\0\0\0\u0001\0\0\0\0\0\0\0\u0004\u0001\0\0\0\u007fSystem.Collections.Generic.List`1[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\u0003\0\0\0\u0006_items\u0005_size\b_version\u0006\0\0\b\b\t\u0002\0\0\0\u0003\0\0\0\u0003\0\0\0\u0011\u0002\0\0\0\u0004\0\0\0\u0006\u0003\0\0\0\u0004Jeff\u0006\u0004\0\0\0\u0005Aidan\u0006\u0005\0\0\0\u0005Grant\n\v&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理一下上面</span></span><br><span class="line">System.Collections.Generic.List`<span class="number">1</span>[[System.String, mscorlib, Version=<span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>, Culture=neutral, PublicKeyToken=b77a5c561934e089]]</span><br><span class="line">_items</span><br><span class="line">_siz_versio</span><br><span class="line">Jeff Aidan Grant</span><br></pre></td></tr></table></figure>

<p>转义符很多，程序集信息、字段信息确实都在里面。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>可以看到上面的那一串东西，</p>
<p>反序列化时，格式化器先获取程序集标识信息，并通过调用System.Reflection.Assembly的Load方法确保程序集已加载到正在执行的 Appdomain中。</p>
<p>然后在程序集中查找对应的类型，找不到就抛出异常。</p>
<p>找到类型就创建类型实例，并用流中的值对其字段初始化。如果字段名不完全匹配，就抛出SerializationException异常。</p>
<h2 id="使类型可序列化"><a href="#使类型可序列化" class="headerlink" title="使类型可序列化"></a>使类型可序列化</h2><h3 id="SerializebleAttribute"><a href="#SerializebleAttribute" class="headerlink" title="SerializebleAttribute"></a>SerializebleAttribute</h3><p>直接序列化一个类，会抛出SerializationException异常。因为你没有使用定制特性**[SerializebleAttribute]**。</p>
<p>该定制特性只能应用于<strong>引用类型(class)、值类型(struct)、枚举类型(enum)和委托类型(delegate)<strong>。其中，</strong>枚举类型和委托类型</strong>不必申明，他们总是可序列化的；对于<strong>类</strong>，可序列化特性不能被子类继承，但基类型如果不被申明可序列化那么子类无法可序列化，毕竟父类是子类的一部分。</p>
<h3 id="控制序列化和反序列化"><a href="#控制序列化和反序列化" class="headerlink" title="控制序列化和反序列化"></a>控制序列化和反序列化</h3><p>使用**[NonSerialized]**特性来使部分字段不参与序列化。</p>
<p>使用**[OnDeserialized]**特性来控制反序列化。它是用来修饰方法的，当实例所有字段被反序列化完后，方法才会被执行。你可以在里面给忽略的字段赋值或者标准化数据。</p>
<p>同样的还有特性**[OnDeserializing] (反序列化前)<strong>、</strong>[OnSerializing] (序列化前)<strong>、</strong>[OnSerialized]  (序列化后)**。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面4个特性时，必须获取一个StreamingContext参数并返回void：</span></span><br><span class="line">[<span class="meta">OnSerialized</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSerialized</span>(<span class="params">StreamingContext context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 举例：在序列化后，恢复任何需要恢复的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化器序列化流程"><a href="#格式化器序列化流程" class="headerlink" title="格式化器序列化流程"></a>格式化器序列化流程</h3><p>微软提供了FormatterServices类型，里面只有静态方法，下面刨析一下流程。</p>
<p>序列化：</p>
<ol>
<li>格式化器调用 Formatterservices的 GetSerializableMembers方法，<strong>反射获取类型的字段</strong>。<br>  <code>public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context)</code></li>
<li>  格式化器调用 Formatterservices的 GetObjectData方法，该方法<strong>输入一个MemberInfo[]输出一个Object[]，而输出的Object[]是MemberInfo[]对应字段的值</strong>，两者一一对应。<code>public static Object[] GetObjectData(Object obj, MemberInfo[] members)</code></li>
<li>  格式化器将程序集标识和类型的完整名称写入流中。</li>
<li>  格式化器然后遍历两个数组中的元素，将每个成员的名称和值写入流中。</li>
</ol>
<p>反序列化：</p>
<ol>
<li>  格式化器从流中读取程序集标识和完整类型名称，如果程序集没加载到AppDomain中，就会加载它。确保程序集被加载后，格式化器将程序集标识信息和类型全名传给 FormatterServices的静态方法 GetTypeFromAssembly来<strong>获取反序列化对象的Type</strong>。<code>public static Type GetTypeFromAssembly(Assembly assem, String name)</code></li>
<li>  格式化器调用 FormatterServices的静态方法 GetUninitializedObject，<strong>为对象分配内存并初始化字段</strong>为null、0，但不调用构造器。<code>public static Object GetUninitializedObject(Type type)</code></li>
<li>  格式化器调用 Formatterservices的 GetSerializableMembers方法，<strong>构造并初始化一个MemberInfo[] 数组</strong>，等待着对应的字段值。</li>
<li>  格式化器根据流中包含的数据<strong>创建并初始化一个 Object数组</strong>，是与3中一一对应的字段值。</li>
<li>将新分配对象、 MemberInfo[] 数组以及并行 Object数组（其中包含字段值）的引用传给<br>  FormatterServices的静态方法 PopulateObjectMembers：</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">PopulateObjectMembers</span>(<span class="params">Object obj, MemberInfo[] members, Object[] data</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法遍历数组，将每个字段初始化成对应的值。</p>
<h2 id="完全控制序列化-反序列化"><a href="#完全控制序列化-反序列化" class="headerlink" title="完全控制序列化/反序列化"></a>完全控制序列化/反序列化</h2><p>可以自己定义序列化和序列化的方法，来实现完全控制，具体是用<strong>ISerializable和IDeserializationCallback</strong>来实现。</p>
<h3 id="ISerializable-接口"><a href="#ISerializable-接口" class="headerlink" title="ISerializable 接口"></a>ISerializable 接口</h3><p>只有GetObjectData一个方法，但是同时需要提供一个特殊签名的构造器，反序列化的时候会调用那个构造器，一般拿来暂存 SerializationInfo。</p>
<h3 id="IDeserializationCallback接口"><a href="#IDeserializationCallback接口" class="headerlink" title="IDeserializationCallback接口"></a>IDeserializationCallback接口</h3><p>只有OnDeserialization一个方法。当然你可以不把赋值逻辑写在这里，可以直接写在构造器里，就不必实现本接口。</p>
<h3 id="看个例子"><a href="#看个例子" class="headerlink" title="看个例子"></a>看个例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ISerializable</span>,<span class="title">IDeserializationCallback</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> A;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> B;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存序列化用的字段</span></span><br><span class="line">    <span class="keyword">private</span> SerializationInfo _info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ISerializable 接口要求实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		info.AddValue(<span class="string">&quot;A&quot;</span>,A);</span><br><span class="line">		info.AddValue(<span class="string">&quot;B&quot;</span>,B);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特别签名的构造器，接口不要求实现，但是反序列化Deserialize的时候会被调用，没有会抛错，且不保存后续调不到SerializationInfo的值</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Test</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		_info = info;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDeserializationCallback 接口要求实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDeserialization</span>(<span class="params"><span class="built_in">object</span> sender</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		A = (<span class="built_in">string</span>)_info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">		B = (<span class="built_in">string</span>)_info.GetValue(<span class="string">&quot;B&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动为父类实现-ISerializable"><a href="#手动为父类实现-ISerializable" class="headerlink" title="手动为父类实现 ISerializable"></a>手动为父类实现 ISerializable</h3><p>有时候父类没实现ISerializable，子类却想实现ISerializable来完全控制序列化，那么可以手动为父类实现 ISerializable。</p>
<p>观察下面代码，关键在于<code>info.GetValue(baseType.FullName + &quot;+&quot; + fi.Name, fi.FieldType)</code>和<code>info.AddValue(baseType.FullName + &quot;+&quot; + mi[i].Name, ((FieldInfo) mi[i]).GetValue(this));</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISerializable 接口要求的特殊构造器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Test</span> (<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 手动为父类实现序列化</span></span><br><span class="line">	Type baseType = <span class="keyword">this</span>.GetType().BaseType;</span><br><span class="line">	MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;mi.Length; i++)&#123;</span><br><span class="line">        FieldInfo fi = (FieldInfo) mi[i];</span><br><span class="line">        fi.SetValue(<span class="keyword">this</span>, info.GetValue(baseType.FullName + <span class="string">&quot;+&quot;</span> + fi.Name, fi.FieldType)); <span class="comment">// 这一句很关键</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后实现本类的序列化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span>&#123;</span><br><span class="line">    Type baseType = <span class="keyword">this</span>.GetType().BaseType;</span><br><span class="line">    MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;mi.Length; i++)&#123;</span><br><span class="line">        info.AddValue(baseType.FullName + <span class="string">&quot;+&quot;</span> + mi[i].Name, ((FieldInfo) mi[i]).GetValue(<span class="keyword">this</span>)); <span class="comment">// 这一句对应上面关键的那句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看下 FormatterServices.GetSerializableMembers方法获取出来的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220110153044.png"></p>
<h3 id="为单例序列化的技巧"><a href="#为单例序列化的技巧" class="headerlink" title="为单例序列化的技巧"></a>为单例序列化的技巧</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例序列化Helper</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SingletonSerializationHelper</span>: <span class="title">IObjectReference</span>&#123;</span><br><span class="line">    <span class="comment">//这个方法在对象（它没有字段）反序列化之后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">GetRealObject</span>(<span class="params">streaming</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.GetSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例类</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> : <span class="title">ISerializable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> Instance; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)&#123;</span><br><span class="line">        info.SetType(<span class="keyword">typeof</span>(SingletonSerializationHelper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="流上下文-StreamingContext"><a href="#流上下文-StreamingContext" class="headerlink" title="流上下文 StreamingContext"></a>流上下文 StreamingContext</h2><p>前面的 ISerializable接口也好 FormatterServices.GetSerializableMembers方法也好，都用到了 StreamingContext这个类，<strong>它存储着关于程序集的上下文</strong>。</p>
<p>这个类内一共2个字段：</p>
<ul>
<li>  Context：Object类型，一个对象引用，对象中包含用户希望的任何上下文信息。</li>
<li>  State：StreamingContextStates枚举类型，一组位标志( bit flag)，指定要序列化/反序列化的对象的来源或目的地。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220110153439.png"></p>
<p>State就不多举例了，只说这个All：来源或目的地可能是上述任何一个上下文。这是默认设定。</p>
<h2 id="序列化代理"><a href="#序列化代理" class="headerlink" title="序列化代理"></a>序列化代理</h2><p>自定义一个序列化器。看了一遍，感觉XLua的Loader是参照了这里的解决方案。</p>
<h3 id="ISerializationSurrogate-接口"><a href="#ISerializationSurrogate-接口" class="headerlink" title="ISerializationSurrogate 接口"></a>ISerializationSurrogate 接口</h3><p>实现序列化代理项选择器，此选择器允许一个对象对另一个对象执行序列化和反序列化。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISerializationSurrogate</span> &#123;</span><br><span class="line">    <span class="comment">// 使用序列化对象所需的数据填充所提供的 SerializationInfo。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">Object, SerializationInfo, StreamingContext</span>)</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 SerializationInfo 中的信息填充对象。</span></span><br><span class="line">	<span class="function">Object <span class="title">SetObjectData</span>(<span class="params">Object, SerializationInfo, StreamingContext, ISurrogateSelector</span>)</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现之后怎么用？</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    IFormatter formatter = <span class="keyword">new</span> SoapFormatter();</span><br><span class="line">    SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">    <span class="comment">// 告诉代理选择器为 Datetime对象使用我们的代理MyProxy</span></span><br><span class="line">    ss.AddSurrogate(<span class="keyword">typeof</span>(DateTime), formatter.Context, <span class="keyword">new</span> MyProxy());</span><br><span class="line">    formatter.SurrogateSelector = ss;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至此，上面已经实现了一个formatter可以通过代理来 序列化/反序列化 DateTime类型。</span></span><br><span class="line">    formatter.Serialize(stream, someTime);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> test = (DateTime)formatter.Deserialize(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当格式化器准备好已登记的代理类型（如上述），调用格式化器的 Serialize方法时，会在<strong>SurrogateSelector维护的集合（一个哈希表）</strong>中查找每个对象的类型。如果发现一个匹配，就调用 ISerializationSurrogate.GetObjectData方法来获取写入流的信息。Deserialize方法同理。</p>
<p>上面提到的SurrogateSelector维护的集合是一个私有哈希表，调用AddSurrogate时，Type和StreamingContext构成了哈希表的key，对应的value就是ISerializationSurrogate对象。</p>
<h3 id="代理选择器链"><a href="#代理选择器链" class="headerlink" title="代理选择器链"></a>代理选择器链</h3><p>多个SurrogateSelector对象可链接到一起。</p>
<p>看一下 ISurrogateSelector怎么实现的，有点类似迭代器（不是真的实现了迭代器）：</p>
<p><strong>ChainSelector</strong>方法负责将参数插入到当前Selector后面。</p>
<p><strong>GetNextSelector</strong>方法返回对链表中的下一个 IsurrogateSelector对象的引用（如果当前操作的对象是链尾，就返回null）。经过测试发现，GetNextSelector并不会像迭代器的 GetEnumerator方法一样调用一次就改变一次Current，单纯只是返回值罢了。</p>
<p><strong>GetSurrogate</strong>方法返回对应Type的 ISurrogateSelector实例。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISurrogateSelector</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChainSelector</span>(<span class="params">ISurrogateSelector selector</span>)</span>;</span><br><span class="line">    <span class="function">ISurrogateSelector <span class="title">GetNextSelector</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">ISerializationSurrogate <span class="title">GetSurrogate</span>(<span class="params">Type, StreamingContext, <span class="keyword">out</span> ISurrogateSelector</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意了，格式化器在里面找对应的Type，如果到了第一个就直接调用对应方法，不会再找第二个了。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> objectGraph = <span class="keyword">new</span> Test &#123;A=<span class="string">&quot;3&quot;</span>, B=<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">		MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"></span><br><span class="line">		BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">		SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">		SurrogateSelector ss2 = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">		ss.AddSurrogate(<span class="keyword">typeof</span>(<span class="built_in">string</span>), formatter.Context, <span class="keyword">new</span> StringProxy());</span><br><span class="line">		ss2.AddSurrogate(<span class="keyword">typeof</span>(Test), formatter.Context, <span class="keyword">new</span> TestProxy());</span><br><span class="line">		ss.ChainSelector(ss2);</span><br><span class="line">		formatter.SurrogateSelector = ss;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 至此，上面已经实现了一个formatter可以通过代理来 序列化/反序列化 String和Test类型。只会调用链中第一个找到的Test类型。</span></span><br><span class="line">		formatter.Serialize(stream, objectGraph);</span><br><span class="line">		stream.Position = <span class="number">0</span>;</span><br><span class="line">		Test obj = (Test)formatter.Deserialize(stream);</span><br><span class="line"></span><br><span class="line">		Console.Read();</span><br><span class="line">        <span class="comment">// 最后，obj.isMoreThanFive 值为true;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestProxy</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">var</span> datas = (Test) obj;</span><br><span class="line">			info.AddValue(<span class="string">&quot;A&quot;</span>, datas.A);</span><br><span class="line">			info.AddValue(<span class="string">&quot;B&quot;</span>, datas.B);</span><br><span class="line">			info.AddValue(<span class="string">&quot;A_Int&quot;</span>, <span class="built_in">int</span>.Parse(datas.A));</span><br><span class="line">			info.AddValue(<span class="string">&quot;B_Int&quot;</span>, <span class="built_in">int</span>.Parse(datas.B));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">var</span> datas = <span class="keyword">new</span> Test();</span><br><span class="line">			datas.A = (<span class="built_in">string</span>)info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">			datas.B = (<span class="built_in">string</span>)info.GetValue(<span class="string">&quot;A&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line">			datas.A_Int = (<span class="built_in">int</span>)info.GetValue(<span class="string">&quot;A_Int&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">			datas.B_Int = (<span class="built_in">int</span>)info.GetValue(<span class="string">&quot;B_Int&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">			datas.isMoreThanFive = datas.A_Int + datas.B_Int &gt; <span class="number">5</span>;</span><br><span class="line">			<span class="keyword">return</span> datas;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StringProxy</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// do sth</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">// do sth</span></span><br><span class="line">			<span class="keyword">return</span> obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">Serializable</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">string</span> A;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">string</span> B;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">int</span> A_Int;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">int</span> B_Int;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">bool</span> isMoreThanFive;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与之类似的SerializationBinder：反序列化对象时重写程序集-类型"><a href="#与之类似的SerializationBinder：反序列化对象时重写程序集-类型" class="headerlink" title="与之类似的SerializationBinder：反序列化对象时重写程序集/类型"></a>与之类似的SerializationBinder：反序列化对象时重写程序集/类型</h3><p>讲的是 SerializationBinder类，<code>格式化器.Binder</code>可以指定，也就是也可以自定义。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Ver1ToVer2SerializationBinder</span> : <span class="title">SerializationBinder</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Type <span class="title">BindToType</span>(<span class="params"><span class="built_in">string</span> assemblyName, <span class="built_in">string</span> typeName</span>)</span> &#123;</span><br><span class="line">        AssemblyName assemVer1 = Assembly.GetExecutingAssembly().GetName();</span><br><span class="line">        assemVer1.Version = <span class="keyword">new</span> Version(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果是1.0.0.0版本的程序集,就返回 Ver2类</span></span><br><span class="line">        <span class="keyword">if</span>(assemblyName == assemVer1.ToString() &amp;&amp; typeName == <span class="string">&quot;Ver1&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span>(Ver2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就返回参数指定程序集的Type(默认实现)</span></span><br><span class="line">        <span class="keyword">return</span> Type.GetType(String.Format(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, typeName, assemblyName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="大章25：与-WinRT组件互操作"><a href="#大章25：与-WinRT组件互操作" class="headerlink" title="大章25：与 WinRT组件互操作"></a><center>大章25：与 WinRT组件互操作</center></h1><h2 id="WinRT-is-what？"><a href="#WinRT-is-what？" class="headerlink" title="WinRT is what？"></a>WinRT is what？</h2><p>**WinRT (Window Runtime, Windows运行时)**，是windows8带来的新类库。</p>
<p>WinRT 组件内部作为“组件对象模型”(COM)组件来实现。</p>
<p>WinRT 的特点是，他是异步的。</p>
<p>// TODO 本章只做基本了解，日后有需求补齐。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>WinRT与CLR是隐式映射的，通过各种解决方案来讲两者机制默默帮你处理成一致。</p>
<p>WinRT与.Net之间是显式映射的，写代码的时候调的是WinRT的API。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CodingCodingK</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp6/">https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://CodingCodingK.github.io" target="_blank">CodingCodingK Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#</a><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/">可访问性</a><a class="post-meta__tags" href="/tags/%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/">核心机制</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Tech/CSharp/experience/20211222_1/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C#传入方法中的是一个指针</div></div></a></div><div class="next-post pull-right"><a href="/Tech/Game/AStar/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211208131158.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">A*算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp4/" title="CLR Via C#个人笔记4 - 类型和成员基础"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">CLR Via C#个人笔记4 - 类型和成员基础</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp5/" title="CLR Via C#个人笔记5 - 基本类型"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">CLR Via C#个人笔记5 - 基本类型</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp3/" title="CLR Via C#个人笔记3 - 基元类型、引用类型和值类型"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-13</div><div class="title">CLR Via C#个人笔记3 - 基元类型、引用类型和值类型</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp1/" title="CLR Via C#个人笔记1 - CLR基础"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-29</div><div class="title">CLR Via C#个人笔记1 - CLR基础</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp2/" title="CLR Via C#个人笔记2 - 类与分配"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">CLR Via C#个人笔记2 - 类与分配</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp7/" title="CLR Via C#个人笔记7 - 线程处理"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-14</div><div class="title">CLR Via C#个人笔记7 - 线程处理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CodingCodingK</div><div class="author-info__description">一位喜欢C#的软件开发者</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CodingCodingK"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CodingCodingK" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">2022年的目标是：ET框架、烟雨开源Moba项目 + Lua程序设计 + Games101、Shader入门精要（部分）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A020%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">大章20：异常和状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">异常处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9ECLS%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.</span> <span class="toc-text">非CLS异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception-StackTrace%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">Exception.StackTrace属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">定义自己的异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">设计范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%A4%84%E7%90%86%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.</span> <span class="toc-text">未处理的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95"><span class="toc-number">1.7.</span> <span class="toc-text">对异常进行调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%9F%9F-CER"><span class="toc-number">1.8.</span> <span class="toc-text">约束执行区域 CER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8D%8F%E5%AE%9A"><span class="toc-number">1.9.</span> <span class="toc-text">代码协定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A021%EF%BC%9A%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.</span> <span class="toc-text">大章21：托管堆和垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E5%A0%86%E2%AD%90"><span class="toc-number">2.1.</span> <span class="toc-text">托管堆⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8E%E6%89%98%E7%AE%A1%E5%A0%86%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.从托管堆分配资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.1.4.</span> <span class="toc-text">根的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3-Generation-%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">分代(Generation)算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.</span> <span class="toc-text">强制垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">垃圾回收触发方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-GC"><span class="toc-number">2.3.2.</span> <span class="toc-text">System.GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.3.</span> <span class="toc-text">大对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">垃圾回收模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finalize"><span class="toc-number">2.4.</span> <span class="toc-text">Finalize</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Finalize%E6%96%B9%E6%B3%95%E5%AF%B9GC%E8%BF%87%E7%A8%8B%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">Finalize方法对GC过程的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B8%85%E7%90%86%E6%9C%AC%E6%9C%BA%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.2.</span> <span class="toc-text">有一些特殊的类，需要清理本机资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Finalize-1"><span class="toc-number">2.4.3.</span> <span class="toc-text">Finalize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SafeHandle-CriticalFinalizerObject"><span class="toc-number">2.4.4.</span> <span class="toc-text">SafeHandle : CriticalFinalizerObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-number">2.4.5.</span> <span class="toc-text">GC句柄表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A022%EF%BC%9ACLR%E5%AF%84%E5%AE%BF%E5%92%8CAppDomain"><span class="toc-number">3.</span> <span class="toc-text">大章22：CLR寄宿和AppDomain</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CLR%E5%AF%84%E5%AE%BF"><span class="toc-number">3.1.</span> <span class="toc-text">CLR寄宿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86AppDomain"><span class="toc-number">3.2.</span> <span class="toc-text">初识AppDomain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9CAppDomain"><span class="toc-number">3.3.</span> <span class="toc-text">操作AppDomain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDAppDomain"><span class="toc-number">3.3.1.</span> <span class="toc-text">卸载AppDomain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E8%A7%86AppDomain"><span class="toc-number">3.3.2.</span> <span class="toc-text">监视AppDomain</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A023%EF%BC%9A%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">4.</span> <span class="toc-text">大章23：程序集加载和反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">4.1.</span> <span class="toc-text">程序集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%8F%AF%E4%BB%A5%E7%94%A8Load%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.1.1.</span> <span class="toc-text">程序集可以用Load加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Load%E5%86%85%E9%83%A8%EF%BC%8CCLR%E4%BC%9A%E5%BA%94%E7%94%A8%E7%BB%91%E5%AE%9A%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">4.1.2.</span> <span class="toc-text">在Load内部，CLR会应用绑定重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84"><span class="toc-number">4.2.</span> <span class="toc-text">使用反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">使用反射构建动态可扩展应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">4.2.2.</span> <span class="toc-text">反射的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E7%82%B9%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">来点反射代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86-%E5%8F%8D%E5%B0%84"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">程序集+反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">类型对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">批量加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.2.4.</span> <span class="toc-text">反射构造类型实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">开放类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%8A%A0%E8%BD%BD-%E8%AE%BE%E8%AE%A1%E6%94%AF%E6%8C%81%E5%8A%A0%E8%BD%BD%E9%A1%B9%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E2%AD%90"><span class="toc-number">4.3.</span> <span class="toc-text">反射+程序集加载 &#x3D; 设计支持加载项的应用程序⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%8F%91%E7%8E%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">4.4.</span> <span class="toc-text">使用反射发现类型的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">4.4.1.</span> <span class="toc-text">反射获取类型成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E4%B8%8BMemberInfo"><span class="toc-number">4.4.2.</span> <span class="toc-text">聊下MemberInfo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MemberInfo%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">MemberInfo属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MemberInfo%E8%B0%83%E7%94%A8"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">MemberInfo调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%91%E5%AE%9A%E5%8F%A5%E6%9F%84%E5%87%8F%E5%B0%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">使用绑定句柄减少进程的内存消耗</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A024%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">大章24：运行时序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">5.1.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96API"><span class="toc-number">5.1.1.</span> <span class="toc-text">序列化反序列化API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.1.2.</span> <span class="toc-text">反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%B1%BB%E5%9E%8B%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">使类型可序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SerializebleAttribute"><span class="toc-number">5.2.1.</span> <span class="toc-text">SerializebleAttribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.2.2.</span> <span class="toc-text">控制序列化和反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.3.</span> <span class="toc-text">格式化器序列化流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E6%8E%A7%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">完全控制序列化&#x2F;反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ISerializable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.1.</span> <span class="toc-text">ISerializable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDeserializationCallback%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.2.</span> <span class="toc-text">IDeserializationCallback接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">5.3.3.</span> <span class="toc-text">看个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E4%B8%BA%E7%88%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0-ISerializable"><span class="toc-number">5.3.4.</span> <span class="toc-text">手动为父类实现 ISerializable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%8D%95%E4%BE%8B%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">5.3.5.</span> <span class="toc-text">为单例序列化的技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E4%B8%8A%E4%B8%8B%E6%96%87-StreamingContext"><span class="toc-number">5.4.</span> <span class="toc-text">流上下文 StreamingContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%90%86"><span class="toc-number">5.5.</span> <span class="toc-text">序列化代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ISerializationSurrogate-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.5.1.</span> <span class="toc-text">ISerializationSurrogate 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E9%80%89%E6%8B%A9%E5%99%A8%E9%93%BE"><span class="toc-number">5.5.2.</span> <span class="toc-text">代理选择器链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">5.5.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%B9%8B%E7%B1%BB%E4%BC%BC%E7%9A%84SerializationBinder%EF%BC%9A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%97%B6%E9%87%8D%E5%86%99%E7%A8%8B%E5%BA%8F%E9%9B%86-%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.4.</span> <span class="toc-text">与之类似的SerializationBinder：反序列化对象时重写程序集&#x2F;类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A025%EF%BC%9A%E4%B8%8E-WinRT%E7%BB%84%E4%BB%B6%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text">大章25：与 WinRT组件互操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WinRT-is-what%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">WinRT is what？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">6.2.</span> <span class="toc-text">映射</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Tech/BookNote/bookNote_howProgramRun/" title="书籍笔记 - 程序是怎样跑起来的（硬件软件交互理解）"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="书籍笔记 - 程序是怎样跑起来的（硬件软件交互理解）"/></a><div class="content"><a class="title" href="/Tech/BookNote/bookNote_howProgramRun/" title="书籍笔记 - 程序是怎样跑起来的（硬件软件交互理解）">书籍笔记 - 程序是怎样跑起来的（硬件软件交互理解）</a><time datetime="2023-06-19T16:16:58.410Z" title="发表于 2023-06-20 00:16:58">2023-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Game/tools/assetbundleInit/" title="AB包基础"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AB包基础"/></a><div class="content"><a class="title" href="/Tech/Game/tools/assetbundleInit/" title="AB包基础">AB包基础</a><time datetime="2023-04-28T09:40:50.908Z" title="发表于 2023-04-28 17:40:50">2023-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Game/UI/ugui_batch/" title="UGUI学习 - 合批规则"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UGUI学习 - 合批规则"/></a><div class="content"><a class="title" href="/Tech/Game/UI/ugui_batch/" title="UGUI学习 - 合批规则">UGUI学习 - 合批规则</a><time datetime="2023-04-27T09:32:14.928Z" title="发表于 2023-04-27 17:32:14">2023-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Project/Unity/RPG/himegami/spineInit/" title="Spine安装和简单了解、导入unity"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spine安装和简单了解、导入unity"/></a><div class="content"><a class="title" href="/Project/Unity/RPG/himegami/spineInit/" title="Spine安装和简单了解、导入unity">Spine安装和简单了解、导入unity</a><time datetime="2023-04-25T18:30:21.536Z" title="发表于 2023-04-26 02:30:21">2023-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Project/Unity/RPG/himegami/gf/" title="GameFramework个人手册"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GameFramework个人手册"/></a><div class="content"><a class="title" href="/Project/Unity/RPG/himegami/gf/" title="GameFramework个人手册">GameFramework个人手册</a><time datetime="2023-04-19T14:27:48.106Z" title="发表于 2023-04-19 22:27:48">2023-04-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> CodingCodingK</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script data-pjax defer src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io/js/chocolate.js"></script><script data-pjax defer src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io/js/cursor.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/mine.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?CodingCodingK";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="CodingCodingK";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>