<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CLR Via C#个人笔记7 - 线程处理 | CodingCodingK Blog</title><meta name="keywords" content="技术,C#,线程"><meta name="author" content="CodingCodingK"><meta name="copyright" content="CodingCodingK"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="大章26：线程基础Widnows的线程概念在没有线程概念的时候，机器都是“单线程”运行的，长时间运行的任务会阻止其他任务执行（16位windows下打印文档很容易“冻结”整个机器导致各种程序出错）。 所以微软设计新的OS内核来改进这些问题，该内核决定在进程中运行应用程序的每个实例。进程实际是应用程序的实例要使用的资源的集合，每个进程都被赋予了一个虚拟地址空间来避免被其它进程访问。 但是光这样还不够">
<meta property="og:type" content="article">
<meta property="og:title" content="CLR Via C#个人笔记7 - 线程处理">
<meta property="og:url" content="https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp7/index.html">
<meta property="og:site_name" content="CodingCodingK Blog">
<meta property="og:description" content="大章26：线程基础Widnows的线程概念在没有线程概念的时候，机器都是“单线程”运行的，长时间运行的任务会阻止其他任务执行（16位windows下打印文档很容易“冻结”整个机器导致各种程序出错）。 所以微软设计新的OS内核来改进这些问题，该内核决定在进程中运行应用程序的每个实例。进程实际是应用程序的实例要使用的资源的集合，每个进程都被赋予了一个虚拟地址空间来避免被其它进程访问。 但是光这样还不够">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png">
<meta property="article:published_time" content="2022-01-14T12:18:29.003Z">
<meta property="article:modified_time" content="2022-02-08T09:19:14.357Z">
<meta property="article:author" content="CodingCodingK">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png"><link rel="canonical" href="https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CLR Via C#个人笔记7 - 线程处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-08 17:19:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/mine.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="CodingCodingK Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> CodingCodingK</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CodingCodingK Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> CodingCodingK</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CLR Via C#个人笔记7 - 线程处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-14T12:18:29.003Z" title="发表于 2022-01-14 20:18:29">2022-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-08T09:19:14.357Z" title="更新于 2022-02-08 17:19:14">2022-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSharp/">CSharp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSharp/CLR-via-C/">CLR via C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSharp/CLR-via-C/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">第五章 线程基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CLR Via C#个人笔记7 - 线程处理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="大章26：线程基础"><a href="#大章26：线程基础" class="headerlink" title="大章26：线程基础"></a><center>大章26：线程基础</center></h1><h2 id="Widnows的线程概念"><a href="#Widnows的线程概念" class="headerlink" title="Widnows的线程概念"></a>Widnows的线程概念</h2><p>在<strong>没有线程概念</strong>的时候，机器都是“单线程”运行的，长时间运行的任务会阻止其他任务执行（16位windows下打印文档很容易“冻结”整个机器导致各种程序出错）。</p>
<p>所以微软设计新的OS内核来改进这些问题，该内核决定在进程中运行应用程序的每个实例。<strong>进程</strong>实际是应用程序的实例要使用的资源的集合，每个进程都被赋予了一个虚拟地址空间来避免被其它进程访问。</p>
<p>但是光这样还不够，如果机器只有一个CPU，应用程序死循环仍然会导致其他程序无法运行。<strong>线程</strong>就是微软交出的解决方案，它是一个Windows概念，它的职责是对CPU进行虚拟化，为每个进程都提供该进程专用的线程（功能相当于原来的一个物理CPU）。所以单物理CPU机器，一个进程死循环，不影响其他进程。</p>
<h2 id="线程开销⭐"><a href="#线程开销⭐" class="headerlink" title="线程开销⭐"></a>线程开销⭐</h2><p>和一切虚拟化机制一样，线程有空间（内存耗用）和时间（运行时的执行性能）上的开销。</p>
<p>下面对每个线程都有的开销一一介绍。</p>
<h3 id="①线程内核对象-thread-kernel-object"><a href="#①线程内核对象-thread-kernel-object" class="headerlink" title="①线程内核对象 (thread kernel object)"></a>①线程内核对象 (thread kernel object)</h3><p>这是OS为系统中创建的每个线程都分配并初始化的数据结构之一。</p>
<p>对象中包括对线程进行描述的属性、**线程上下文(thread context)**：线程上下文是包含CPU寄存器集合的内存块，x64使用约1240字节的内存。上下文是线程上一次执行完毕后，CPU寄存器的状态。</p>
<h3 id="②线程环境块-thread-environment-block-TEB"><a href="#②线程环境块-thread-environment-block-TEB" class="headerlink" title="②线程环境块 (thread environment block,TEB)"></a>②线程环境块 (thread environment block,TEB)</h3><p>TEB耗用一个内存页（x64中4KB），</p>
<p>里面有**异常处理链首(head)**：线程每进入一个try块，都会在链首(head)中插入一个节点(node)，退出try块时删除该节点。</p>
<p>此外，TEB中还有<strong>GDI(图形设备接口)和OpenGL</strong>用的一些数据。</p>
<h3 id="③用户模式栈-user-mode-stack"><a href="#③用户模式栈-user-mode-stack" class="headerlink" title="③用户模式栈 (user- mode stack)"></a>③用户模式栈 (user- mode stack)</h3><p>堆栈概念中的栈说的就是这个了，默认分配1MB内存（其实windows是保留1MB容量，等用了才调拨给你）。</p>
<p>用户模式栈存储传给方法的<strong>局部变量和实参</strong>。还包含一个<strong>返回地址</strong>：指出当前方法返回时线程该从什么地方执行。</p>
<h3 id="④内核模式栈-kernel-mode-stack"><a href="#④内核模式栈-kernel-mode-stack" class="headerlink" title="④内核模式栈 (kernel- mode stack)"></a>④内核模式栈 (kernel- mode stack)</h3><p>分配x86是12KB，x64是24KB。</p>
<p>应用程序代码向OS中的内核模式函数传递实参时，会复制 用户模式栈 传去的实参并加以验证并不允许修改。最后OS内核代码开始处理复制的值。</p>
<p><strong>应用程序代码发起内核模式函数调用 -&gt; 用户模式栈 -&gt; 内核模式栈 -&gt; 内核模式函数</strong></p>
<h3 id="⑤DLL线程连接-attach-和线程分离-detach-通知"><a href="#⑤DLL线程连接-attach-和线程分离-detach-通知" class="headerlink" title="⑤DLL线程连接 (attach)和线程分离 (detach)通知"></a>⑤DLL线程连接 (attach)和线程分离 (detach)通知</h3><p>一个Windows机制：在进程中创建线程时，都会调用进程中加载的所有非托管DLL的 DllMain方法并向该方法传递 <strong>DLL_THREAD_ATTACH</strong>标志；终止线程时，同样调用 DllMain方法并向该方法传递 <strong>DLL_THREAD_DETACH</strong>标志。</p>
<p>有的DLL需要这些通知才能为进程中 创建/销毁 的每个线程执行特殊的 初始化/资源清理 ，比如C-Runtime库DLL。</p>
<h3 id="上下文调度"><a href="#上下文调度" class="headerlink" title="上下文调度"></a>上下文调度</h3><p>首先搞清楚一点，下面讨论的都是<strong>单物理CPU（或者单核CPU）且线程数&gt;CPU数</strong>的情况！！！想看Windows的调度，去看“线程调度和优先级”节。</p>
<p>Windows任何时刻都只将一个线程分配给一个CPU(或CPU核，下面称CPU)。</p>
<p>CPU会为线程执行一个<strong>时间片 (quantum)<strong>的时长，大概30ms吧，等时间片到期了，就会进行</strong>上下文调度</strong>切换执行另一个线程。<strong>上下文</strong>是线程上一次执行完毕后，CPU寄存器的状态。</p>
<p>上下文调度具体流程：</p>
<ol>
<li>  将CPU寄存器的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。</li>
<li>从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有， Windows在<br>  开始执行任何代码或者接触任何数据之前，还必须切换CPU“看见”的虚拟地址空间。</li>
<li>  将所选上下文结构中的值加载到CPU的寄存器中。</li>
</ol>
<p>上下文调度之后线程切换完成，CPU就会执行所选的线程，直到下一个时间片过了又要切换。</p>
<p>毫无疑问，这个机制是一个非常大的开销，特别是数据不在cache中的时候访问会很慢导致还没做点啥就切换别的线程了。</p>
<p>上下文切换是<strong>净开销</strong>，也就是说它所产生的开销不会换来任何内存或性能上的收益，只是为了能够提供一个健壮的、响应灵敏的操作系统。比如，一个应用程序的线程进入死循环， Windows会定期抢占( preempt)它，将新线程分配给CPU从而使新线程有机会运行。假如新线程是任务管理器线程，就能终止包含了死循环线程的进程。</p>
<h4 id="多核情况"><a href="#多核情况" class="headerlink" title="多核情况"></a>多核情况</h4><p>理解了上面说的机制，再来理解多核心CPU的情况：</p>
<p>安装了多个CPU（或者一个多核CPU）的计算机可以真正同时运行几个线程，Windows为每个CPU内核都分配一个线程，每个内核都自己执行到其他线程的上下文切换，<strong>且Windows确保单个线程不会同时在多个内核上调度</strong>。</p>
<h2 id="停止疯狂"><a href="#停止疯狂" class="headerlink" title="停止疯狂"></a>停止疯狂</h2><p>知道了上下文调度机制，不难得出：<strong>如果只关心性能，线程数和CPU核心数一致才是最好的。</strong>如果线程数超过了CPU的数目，就会产生上下文切换和性能损失。如果每个CPU只有一个线程，就不会有上下文切换，线程将全速运行。</p>
<p>但是仍然选择这么做，是因为能让Windows整体更不容易崩溃、提高响应能力。</p>
<p>那么标题为什么要叫停止疯狂呢？</p>
<p>因为打开我的任务管理器一看，发现一台4核的cpu跑了300多个进程4000个线程，光给线程就分配掉了4GB的内存，离大谱！而大部分线程压根没被调用就是挂着，是一种极大的浪费。</p>
<h3 id="CPU发展趋势"><a href="#CPU发展趋势" class="headerlink" title="CPU发展趋势"></a>CPU发展趋势</h3><p>了解即可，讲讲硬件有个概念。</p>
<p>CPU厂商过去只知道一味地提高CPU速度。但CPU厂商没有延续这个趋势，因为高速运行的CPU会产生大量热量。</p>
<p>所以发展方向变成了实现多线程，物理上有这么些手段：</p>
<ul>
<li>  多个CPU，不适合普通用户。</li>
<li>  超线程芯片，硬件上实现多线程。通过分支预测错误和缓存未命中和等待数据的优化，来不停切换线程，实现1个线程能当2个用。WindowsOS层面并不知道硬件CPU其实是超线程的，他只知道有2个线程在并发执行。</li>
<li>  多核芯片，适合普通用户。</li>
</ul>
<h2 id="CLR线程和-Windows线程"><a href="#CLR线程和-Windows线程" class="headerlink" title="CLR线程和 Windows线程"></a>CLR线程和 Windows线程</h2><p>CLR使用 Windows的线程处理功能。</p>
<h2 id="使用专用线程"><a href="#使用专用线程" class="headerlink" title="使用专用线程"></a>使用专用线程</h2><h3 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h3><p>创建线程来执行异步的计算限制(compute- bound)操作，不过这门技术并不推荐，<strong>推荐使用线程池来执行异步</strong>。</p>
<p>但还是说回来，不用线程池而是显式创建线程来专门执行一个计算限制的操作的情况，一般是线程池方式做不到的事，比如以下几种：</p>
<ul>
<li>  线程需要以非普通线程优先级运行。（所有线程池线程都以普通优先级运行）</li>
<li>  需要线程表现为一个前台线程，防止应用程序在线程结束任务前终止。</li>
<li>  计算限制的任务需要长时间运行。（线程池为了判断是否需要创建一个额外的线程）</li>
<li>  要启动线程，并可能调用 Thread的 Abort方法来提前终止它。</li>
</ul>
<h3 id="创建专用线程，并执行异步的计算限制操作"><a href="#创建专用线程，并执行异步的计算限制操作" class="headerlink" title="创建专用线程，并执行异步的计算限制操作"></a>创建专用线程，并执行异步的计算限制操作</h3><p>为了创建专用线程，要构造 System.Threading.Thread类的实例，向构造器传递一个方法<br>名。以下是 Thread的构造器的原型：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Thread</span> : <span class="title">CriticalFinalizerObject</span>, ... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span>(<span class="params">ParameterizedThreadStart start</span>)</span>;</span><br><span class="line">    <span class="comment">// 未列出不常用的构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start参数表示<strong>专用线程要执行的方法</strong>，这个方法必须和 ParameterizedThreadStart委托的签名匹配：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">ParameterizedThreadStart</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>光创建线程还不算完，并不会真的创建一个操作系统线程。要实际创建一个操作系统线程，并让它开始执行回调方法，必须调用 <strong>Thread的Start方法</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="comment">// Main thread: starting a dedicated thread (专用线程)</span></span><br><span class="line">    Thread dedicatedThread = <span class="keyword">new</span> Thread(ComputeBoundOp);</span><br><span class="line">    dedicatedThread.Start(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>); <span class="comment">// 模拟做其他工作(10秒)</span></span><br><span class="line">    dedicatedThread.Join();<span class="comment">// 等待线程终止。Join：在此实例表示的线程终止前，阻止调用线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法的签名必须和 ParameterizedThreadStart委托匹配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ComputeBoundOp</span> (<span class="params"><span class="built_in">object</span> state</span>)</span> &#123;</span><br><span class="line">    WriteLine(state);</span><br><span class="line">    Thread. Sleep(<span class="number">1000</span>); <span class="comment">// 模拟做其他任务(1秒)</span></span><br><span class="line">    <span class="comment">// 这个方法返回后，专用线程将终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="使用线程的理由"><a href="#使用线程的理由" class="headerlink" title="使用线程的理由"></a>使用线程的理由</h3><h4 id="画面响应（通常是对于客户端GUI应用程序）"><a href="#画面响应（通常是对于客户端GUI应用程序）" class="headerlink" title="画面响应（通常是对于客户端GUI应用程序）"></a>画面响应（通常是对于客户端GUI应用程序）</h4><p>Windows为每个进程提供它自己的线程，确保发生死循环的应用程序不会妨碍其他应用程序。类似的，在客户端GUI应用程序中，可以将一些工作交给一个线程进行，使GUI线程能灵敏地响应用户输入。</p>
<h4 id="性能（对于客户端和服务器应用程序）"><a href="#性能（对于客户端和服务器应用程序）" class="headerlink" title="性能（对于客户端和服务器应用程序）"></a>性能（对于客户端和服务器应用程序）</h4><p>由于Windows每个CPU调度一个线程，而且多个（核）CPU能并发执行这些线程，所以能提升性能。</p>
<h2 id="线程调度和优先级⭐"><a href="#线程调度和优先级⭐" class="headerlink" title="线程调度和优先级⭐"></a>线程调度和优先级⭐</h2><h3 id="Windows的线程调度"><a href="#Windows的线程调度" class="headerlink" title="Windows的线程调度"></a>Windows的线程调度</h3><p>前面讲过单核CPU的上下文切换，属于是线程调度的最初级理论，下面由Windows的机制深入。</p>
<h4 id="重温一下上下文切换流程"><a href="#重温一下上下文切换流程" class="headerlink" title="重温一下上下文切换流程"></a>重温一下上下文切换流程</h4><p>**上下文(context)**结构反映了线程上一次执行完毕后CPU寄存器的状态。</p>
<p>在一个**时间片(time-slice)**之后，Windows检查现存的所有线程内核对象，在这些对象中只有那些没有正在等待什么的线程才合适调度。</p>
<h4 id="饥饿-starvation"><a href="#饥饿-starvation" class="headerlink" title="饥饿(starvation)"></a>饥饿(starvation)</h4><p>而在这些线程中，系统调度CPU执行哪一个线程，是由线程自己的<strong>优先级</strong>决定的，有0<del>31(31最高)的优先级。只要存在可调度的优先级31的线程，系统就永远不会调度CPU给0</del>30的任何线程。高优先级的线程占用CPU太久，使低优先级线程无法运行，这种情况称为**饥饿(starvation)**。</p>
<p><strong>多处理器</strong>的机器很少出现饥饿情况，因为能同时并行执行很多线程。</p>
<h4 id="抢占式操作系统"><a href="#抢占式操作系统" class="headerlink" title="抢占式操作系统"></a>抢占式操作系统</h4><p>Windows是<strong>抢占式多线程(preemptive multithreaded)操作系统</strong>，线程可在任何时间停止（被抢占）并调度另一个线程。</p>
<p>Windows是<strong>抢占式</strong>，低优先级的线程哪怕时间片没用完，也会被立刻挂起执行优先级更高的线程。</p>
<h4 id="零页线程-zero-page-thread"><a href="#零页线程-zero-page-thread" class="headerlink" title="零页线程(zero page thread)"></a>零页线程(zero page thread)</h4><p>系统启动时会创建一个特殊的<strong>零页线程</strong>，优先级为0，在没有其他线程需要“干活儿”的时候，零页线程将系统RAM的所有空闲页清零。Windows不允许其他线程的优先级为0。</p>
<h3 id="线程优先级and进程优先级"><a href="#线程优先级and进程优先级" class="headerlink" title="线程优先级and进程优先级"></a>线程优先级and进程优先级</h3><p>前面讲过了优先级是0~31，现在看一下自己写的程序可控制的优先级映射。</p>
<p>进程可通过**优先级类(priority class)**来控制优先级，一共6种；线程7种。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220112120814.png"></p>
<p>注意，表中没有值为0的线程优先级。这是因为0优先级保留给零页线程了，系统不允许其他线程的优先级为0。而且，以下优先级也不可获得：17,18,19,20,21,27,28,29或者30。以内核模式运行的设备驱动程序才能获得这些优先级。</p>
<p>我们可以通过System.Diagnostics的<strong>Process类和ProcessThread类</strong>获取进程线程的windows视图。也可以通过<strong>AppDomain和Thread类</strong>获取线程的CLR视图。</p>
<h2 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h2><p>CLR将每个线程要么视为前台线程，要么视为后台线程。一个进程的所有<strong>前台线程</strong>停止运行时，CLR强制终止仍在运行的任何<strong>后台线程</strong>。这些后台线程被直接终止；不抛出异常。</p>
<p>每个AppDomain都可运行一个单独的应用程序，而每个应用程序都有自己的前台线程。如果应用程序退出，造成它的前台线程终止，则CLR仍需保持活动并运行，使其他应用程序能继续运行。所有应用程序都退出，它们的所有前台线程都终止后，整个进程就可以被销毁了。</p>
<p>用<strong>Thread类</strong>新建线程默认是前台线程，<strong>线程池</strong>线程默认是后台线程。当然，可以通过<strong>Thread.Isbackground属性</strong>随时修改线程是前台还是后台。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>一般我们拿前台线程做画面，后台线程IO，这样用户关闭了程序界面 =&gt; 前台线程关闭 =&gt; 后台IO线程自动被关闭 =&gt; IO不执行下去（比如写入数据到Excel），是合理的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新线程（默认为前台线程）</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(Worker);</span><br><span class="line">    <span class="comment">// 使线程成为后台线程</span></span><br><span class="line">    t.IsBackground = <span class="literal">true</span>;</span><br><span class="line">    t.Start();<span class="comment">// 启动线程</span></span><br><span class="line">    <span class="comment">// ⭐如果t是前台线程，则应用程序大约10秒后才终止</span></span><br><span class="line">    <span class="comment">// ⭐如果t是后台线程，则应用程序立即终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Thread. sleep(<span class="number">10000</span>);<span class="comment">// 模拟做10秒钟的工作</span></span><br><span class="line">    <span class="comment">// 下面这行代码只有在由一个前台线程执行时才会显示</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Returning from Worker&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="大章27：计算限制的异步操作"><a href="#大章27：计算限制的异步操作" class="headerlink" title="大章27：计算限制的异步操作"></a><center>大章27：计算限制的异步操作</center></h1><h2 id="CLR线程池基础"><a href="#CLR线程池基础" class="headerlink" title="CLR线程池基础"></a>CLR线程池基础</h2><p>一个CLR拥有一个**线程池(thread pool)**。如果一个CLR下有多个AppDomain，那么它们共享一个线程池；如果一个进程中加载了多个CLR，那么每个CLR都有自己的线程池。</p>
<h3 id="向线程池请求流程⭐"><a href="#向线程池请求流程⭐" class="headerlink" title="向线程池请求流程⭐"></a>向线程池请求流程⭐</h3><p>CLR初始化时，线程池中是没有线程的。在内部，线程池维护了一个<strong>操作请求队列</strong>。应用程序执行一个异步操作时，就会对线程池进行请求，具体是将一个<strong>记录项(entry)<strong>追加到队列中。线程池会从这个队列中提取记录项，将这个记录项</strong>派发(dispatch)<strong>给一个线程池的线程；如果线程池没有线程，就创建一个新线程。当这个线程完成任务后并</strong>不销毁，而是返回线程池、进入空闲状态</strong>。但是如果一个线程在线程池里闲太久了（应用程序很久不向线程池发出请求），为了避免资源浪费，CLR才会<strong>终止</strong>它。</p>
<h2 id="使用ThreadPool"><a href="#使用ThreadPool" class="headerlink" title="使用ThreadPool"></a>使用ThreadPool</h2><p>使用ThreadPool执行简单的计算限制操作。</p>
<p>调用<code>ThreadPool.QueueUserWorkItem(WaitCallback cb);</code>或<code>ThreadPool.QueueUserWorkItem(WaitCallback cb, object state);</code>。这两个方法向线程池的队列添加一个**工作项(work item)**以及可选的状态数据，然后方法立刻返回。</p>
<p>传递的回调方法必须满足<code>delegate void WaitCallback(Object state);</code>。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面演示一下如何让一个线程池线程以异步方式调用一个方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem(DoSth, <span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread start ,id:&quot;</span> + + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread end ,id:&quot;</span> + +Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSth</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;thread from ThreadPool is doing sth ,state:&quot;</span> + state + <span class="string">&quot; thread id: &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于是异步进行的，所以有时会输出</span></span><br><span class="line"><span class="comment">//main thread start ,id:1</span></span><br><span class="line"><span class="comment">//thread from ThreadPool is doing sth ,state:5 thread id: 3</span></span><br><span class="line"><span class="comment">//main thread end ,id:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时会输出</span></span><br><span class="line"><span class="comment">//thread from ThreadPool is doing sth ,state:5 thread id: 3</span></span><br><span class="line"><span class="comment">//main thread start ,id:1</span></span><br><span class="line"><span class="comment">//main thread end ,id:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是不难看出，执行任务的线程是从线程池拿的，不再是主线程</span></span><br></pre></td></tr></table></figure>

<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>每个线程都关联了一个**执行上下文(execution context)**数据结构。它包含了安全设置(压缩栈、 Thread的 Principal属性和 Windows身份)、宿主设置、逻辑调用上下文数据。</p>
<p>每当一个**线程(初始线程)<strong>使用另一个</strong>线程(辅助线程，也就是线程使用的线程)<strong>执行任务时，为了确保两者的操作使用相同的安全设置和宿主设置，前者的上下文应</strong>流向 flow(复制到)**辅助线程。复制，这要耗费不少时间。</p>
<h3 id="阻断上下文的流向-flow"><a href="#阻断上下文的流向-flow" class="headerlink" title="阻断上下文的流向(flow)"></a>阻断上下文的流向(flow)</h3><p>可以使用<code>System.Threading.ExecutionContext</code>类来控制线程的执行上下文流到另一个线程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ExecutionContext</span> : <span class="title">IDisposable</span>, <span class="title">ISerializable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncFlowControl <span class="title">SuppressFlow</span>(<span class="params"></span>)</span>; <span class="comment">// 取消执行上下文在异步线程之间的流动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RestoreFlow</span>(<span class="params"></span>)</span>; <span class="comment">// 恢复执行上下文在异步线程之间的流动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFlowSuppressed</span>(<span class="params"></span>)</span>; <span class="comment">// 指示当前是否取消了执行上下文的流动</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个类，你可以<strong>阻止执行上下文的流动</strong>。当初始线程的上下文不流向辅助线程，辅助线程会使用上一次和它关联的任意执行上下文。所以你想要阻止流动，就需要确保<strong>辅助线程不应执行任何要依赖于执行上下文状态</strong>，比如用用户的Windows身份。</p>
<p>一般只拿来优化服务端应用程序，这样做对客户端程序优化甚微。</p>
<h4 id="阻断例子"><a href="#阻断例子" class="headerlink" title="阻断例子"></a>阻断例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将一些数据放到Main线程的逻辑调用上下文中</span></span><br><span class="line">    CallContext.LogicalSetData(<span class="string">&quot;Name&quot;</span>,<span class="string">&quot;Jeffrey&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化要由一个线程池线程做的一些工作,</span></span><br><span class="line">    <span class="comment">// 线程池线程能访问逻辑调用上下文数据</span></span><br><span class="line">    ThreadPool.QueueUserWorkItem (state =&gt; Console.WriteLine(<span class="string">&quot;Before:&quot;</span> + CallContext.LogicalGetData(<span class="string">&quot;Name&quot;</span>)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在，阻止Main线程的执行上下文的流动</span></span><br><span class="line">    ExecutionContext.SuppressFlow();</span><br><span class="line">    <span class="comment">// 然后，再做同样的事</span></span><br><span class="line">    ThreadPool.QueueUserWorkItem (state =&gt; Console.WriteLine(<span class="string">&quot;After:&quot;</span> + CallContext.LogicalGetData(<span class="string">&quot;Name&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Before:Jeffrey</span></span><br><span class="line"><span class="comment">// After:</span></span><br></pre></td></tr></table></figure>

<p>阻断后的输出After，为空。注意，无论是对于ThreadPool还是Task对象，都有效。</p>
<h2 id="线程池如何管理线程"><a href="#线程池如何管理线程" class="headerlink" title="线程池如何管理线程"></a>线程池如何管理线程</h2><h3 id="设置线程池限制"><a href="#设置线程池限制" class="headerlink" title="设置线程池限制"></a>设置线程池限制</h3><p>CLR允许开发人员设置线程池要创建的最大线程数。书中说默认大概1000。不推荐自己设置，但是可以使用ThreadPool类提供的几个静态方法：GetMaxThreads、SetMaxThreads、GetMinThreads、SetMinThreads、GetAvailableThreads 来获取或更改线程数信息。</p>
<h3 id="线程池调度机制"><a href="#线程池调度机制" class="headerlink" title="线程池调度机制"></a>线程池调度机制</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220114141818.png"></p>
<h4 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h4><p>当调用ThreadPool.QueueUserWorkItem、Timer类、Task时，任务会被添加进<strong>全局队列</strong>中，全局队列采用<strong>先进先出FIFO</strong>的方式，让工作者线程们自己去取任务。</p>
<p>全局队列使用<strong>线程同步锁</strong>，这是为了避免多个线程同时取到一个任务。</p>
<h4 id="本地队列"><a href="#本地队列" class="headerlink" title="本地队列"></a>本地队列</h4><p>在全局队列中领完的任务会放入工作者线程各自的<strong>本地队列</strong>，本地队列采用<strong>后入先出LIFO</strong>的方式来执行任务。</p>
<p>本地队列一般不锁，因为只有对应的工作者线程访问它。但是也有例外，看下面。</p>
<h4 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h4><p>下面从工作者线程的角度去理解整体调度流程。</p>
<p>如果工作者线程发现自己<strong>本地队列空</strong>了，就会尝试从另一个工作者线程的本地队列“偷”一个Task。这个Task在本地队列的队尾，并会要求获取一个线程同步锁。</p>
<p>如果<strong>所有本地队列都空</strong>了，工作者线程会使用FIFO算法从全局队列取出一个工作项并获得它的锁。</p>
<p>如果<strong>全局队列也为空</strong>，工作者线程会进入睡眠状态。</p>
<p>如果<strong>工作者线程睡眠时间很长</strong>，它会自己醒来并销毁自身，释放线程使用的资源（内核、栈等）。</p>
<h2 id="协作式取消和超时"><a href="#协作式取消和超时" class="headerlink" title="协作式取消和超时"></a>协作式取消和超时</h2><p>讲的是可以用一个辅助类，可以传递自己的一个bool字段作为参数给线程，也可以注册一些回调事件。当执行这个辅助类的<strong>Cancel方法</strong>时，会将bool字段设置成false并执行那些回调。从而实现操控线程停止事务。</p>
<p>无论是ThreadPool方法还是Task，都能使用这种方法。</p>
<h3 id="CancellationTokenSource"><a href="#CancellationTokenSource" class="headerlink" title="CancellationTokenSource"></a>CancellationTokenSource</h3><p>System.Threading.CancellationTokenSource就是上面说的辅助类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CancellationTokenSource</span>: <span class="title">IDisposable</span><span class="comment">// 一个引用类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CancellationTokenSource</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;<span class="comment">// 释放资源,比如WaitHandle</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean IsCancellationRequested &#123; <span class="keyword">get</span>; &#125;<span class="comment">// 执行Cancel后就会变成false</span></span><br><span class="line">    <span class="keyword">public</span> CancellationToken Token &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cancel</span>(<span class="params"></span>)</span>;<span class="comment">// 内部调用 Cancel并传递 false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cancel</span>(<span class="params">Boolean throwOnFirstException</span>)</span>;<span class="comment">// 如果true,回调执行一遇到抛错就立刻返回;如果false,直到全部回调执行结束才会抛出一个报错list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类通过<strong>Token</strong>方法可以获得一个或多个CancellationToken（一个值类型），可以对它<strong>注册回调</strong>，当Source.Cancel的时候会触发Token们的回调</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> CancellationToken &#123; <span class="comment">// 一个值类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CancellationToken None &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean IsCancellationRequested &#123; <span class="keyword">get</span>; &#125; <span class="comment">// 由非通过Task调用的操作调用(ThreadPool)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThrowIfCancellationRequested</span>(<span class="params"></span>)</span>; <span class="comment">// 由通过Task调用的操作调用(Task)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CancellationTokenSource， WaitHandle会收到信号</span></span><br><span class="line">    <span class="keyword">public</span> Waithandle Waithandle &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">// Gethashcode, Equals, operator==和 operator!=成员未列出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Boolean Canbecanceled &#123; <span class="keyword">get</span>; &#125;<span class="comment">// 很少使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CancellationTokenRegistration <span class="title">Register</span>(<span class="params">Action&lt;<span class="built_in">object</span>&gt; callback, Object state, Boolean useSynchronizationContext</span>)</span>;<span class="comment">// 未列出更简单的重载版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">	CancellationToken token = cts.Token;</span><br><span class="line">    <span class="comment">// 注册回调</span></span><br><span class="line">	token.Register(() =&gt; Console.WriteLine(<span class="string">&quot;Count is cancelled, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">	ThreadPool.QueueUserWorkItem(_ =&gt; Count(token, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Press &lt;Enter&gt; to cancel Thread Works&quot;</span>);</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">	cts.Cancel();</span><br><span class="line"></span><br><span class="line">	Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params">CancellationToken token, <span class="built_in">int</span> countTo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> count = <span class="number">0</span>; count &lt; countTo; count++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 当Source执行Cancel时，会变成false</span></span><br><span class="line">		<span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;break, thread &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		Console.WriteLine(count);</span><br><span class="line">		Thread.Sleep(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Press &lt;Enter&gt; to cancel Thread Works</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Count is cancelled, thread 1</span></span><br><span class="line"><span class="comment">// break, thread 3</span></span><br></pre></td></tr></table></figure>

<p>可以考虑这么用<strong>IsCancellationRequested字段</strong>以及<strong>Token回调事件</strong>。</p>
<p>注意了，输出的线程号不一样：**回调事件是调用线程做的(就是主线程thread 1)**。</p>
<h2 id="使用任务-Task"><a href="#使用任务-Task" class="headerlink" title="使用任务(Task)"></a>使用任务(Task)</h2><p>使用<strong>ThreadPool</strong>的方法，很容易就能发起一次异步的计算限制操作。但是它不透明，你无法知道什么时候完成，也无法对其添加回调函数。所以我们通过<strong>System.Threading.Tasks</strong>中的类型来使用任务。</p>
<h3 id="Task与ThreadPool等价写法"><a href="#Task与ThreadPool等价写法" class="headerlink" title="Task与ThreadPool等价写法"></a>Task与ThreadPool等价写法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(DoSth, <span class="number">5</span>);<span class="comment">// 用线程池方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Task(DoSth, <span class="number">5</span>).Start();<span class="comment">// 用Task做相等的事</span></span><br><span class="line">Task.Run(() =&gt; Dosth(<span class="number">5</span>));<span class="comment">// 与上面等价</span></span><br></pre></td></tr></table></figure>

<p>注意！<strong>无论是ThreadPool还是Task.Run，他们都是从线程池取线程</strong>。</p>
<h3 id="等待任务"><a href="#等待任务" class="headerlink" title="等待任务"></a>等待任务</h3><p>使用<code>Task.Wait();</code>可以让线程等待返回结果，返回类型在创建线程<code>Task&lt;TResult&gt;</code>的时候指定，返回值通过<code>Task.Result</code>获取。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">		&#123;</span><br><span class="line">            Thread.Sleep(<span class="number">3000</span>); <span class="comment">// 模拟做其他工作(3秒)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    task.Start(); <span class="comment">// 此时才开始执行任务</span></span><br><span class="line">    </span><br><span class="line">    task.Wait(); <span class="comment">// 进行3秒的等待</span></span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(task.Result); <span class="comment">// Result属性内部会调用Wait !!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3秒后output: 100</span></span><br></pre></td></tr></table></figure>

<p>如果在Task中抛错，异常会被吞噬并存储到一个集合中，线程会回到线程池。等到再调用Wait或Result时，会抛出<strong>System.AggregateException对象</strong>，它就是那个存储异常的集合。</p>
<p>但是如果一直不调用Wait或Result，就抛不出错。你可以通过向TaskScheduler.UnobservedTaskException事件登记回调函数来使Task被GC时抛出其异常。</p>
<h4 id="Task-WaitAny"><a href="#Task-WaitAny" class="headerlink" title="Task.WaitAny"></a>Task.WaitAny</h4><p>WaitAny静态方法 会阻塞调用线程，直到数组中的任何Task对象完成。方法返回一个int索引值，指明完成的是数组中哪个Task对象。方法返回后，线程被唤醒并继续运行，如果发生超时返回-1。</p>
<h4 id="Task-WaitAll"><a href="#Task-WaitAll" class="headerlink" title="Task.WaitAll"></a>Task.WaitAll</h4><p>WaitAll静态方法 也会阻塞调用线程，直到数组中的所有Task对象完成。方法返回一个bool值，true代表完成，false代表超时。</p>
<h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>前面使用CancellationTokenSource的IsCancellationRequested属性来取消ThreadPool事务，这边Task类似，不过用的是Source的<strong>ThrowIfCancellationRequested方法</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Dosth</span>(<span class="params">CancellationToken ct, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(; n &gt; <span class="number">0</span>; n--)&#123;</span><br><span class="line">        <span class="comment">// 调用该Source的Cancel方法后,会抛出OperationCanceledException,否则不会抛出。</span></span><br><span class="line">        ct.ThrowIfCancellationRequested();</span><br><span class="line">        </span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和正常Task抛错一样会被吞，直到你调用Wait或Result才会抛出来。</p>
<h3 id="延续任务"><a href="#延续任务" class="headerlink" title="延续任务"></a>延续任务</h3><p>任务完成时自动启动新任务，用<strong>ContinueWith方法</strong>。在任务结束后，会调用线程池的<strong>其他线程</strong>继续帮你完成任务。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; t = Task.Run(() =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;thread id &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">		Thread.Sleep(<span class="number">3000</span>); <span class="comment">// 模拟做其他工作(3秒)</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">	Task cwt = t.ContinueWith(task =&gt; Console.WriteLine(task.Result + <span class="string">&quot;,thread id &quot;</span> + Thread.CurrentThread.ManagedThreadId)); <span class="comment">// 结束后调用线程池的其他线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// thread id 3</span></span><br><span class="line"><span class="comment">// 100,thread id 4</span></span><br></pre></td></tr></table></figure>

<p>具体看thread id，执行任务 和 执行延续任务 的线程不是同一个。</p>
<p>可以传递一个<strong>TaskContinuationOptions位标志</strong>枚举类给延续任务，默认是None，有一个可能用到的TaskContinuationOptions.OnlyOnRanToCompletion枚举值，传这个代表只有在第一个任务成功执行（无抛错无取消）的情况才会执行延续任务。</p>
<h3 id="任务启动子任务"><a href="#任务启动子任务" class="headerlink" title="任务启动子任务"></a>任务启动子任务</h3><p>套娃。直到所有子任务运行结束，父任务才认为自己结束。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    Task t = Task.Run(() =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;main task,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">		<span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub1,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line">		<span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub2,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line">		<span class="keyword">new</span> Task(() =&gt;  Console.WriteLine(<span class="string">&quot;sub3,thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId)).Start();</span><br><span class="line">        <span class="comment">// 这回咱们不sleep了,就看看是不是用了回收的线程,结果确实用了!</span></span><br><span class="line">	&#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// main,thread id:1</span></span><br><span class="line"><span class="comment">// main task,thread id:3</span></span><br><span class="line"><span class="comment">// sub1,thread id:4</span></span><br><span class="line"><span class="comment">// sub3,thread id:3</span></span><br><span class="line"><span class="comment">// sub2,thread id:4</span></span><br></pre></td></tr></table></figure>

<p>看输出，顺便测试了一下子线程会不会借助已经回收到线程池的父线程来完成任务，结果是<strong>肯定</strong>的！</p>
<h3 id="任务内部揭秘"><a href="#任务内部揭秘" class="headerlink" title="任务内部揭秘"></a>任务内部揭秘</h3><p>Task比起ThreadPool多了很多可控性，但是这不是无偿的，Task方式起线程会比ThreadPool方法至少多了：</p>
<ul>
<li>  Task唯一标识id，从1开始递增分配。只有查询时才分配，一经分配不会重复发放相同数字。</li>
<li>  执行状态id。通过Task.Status属性查询。</li>
<li>  父任务引用、回调方法引用、回调方法需要参数的引用</li>
<li>  一个CancellationToken、ContinueWithTask对象集合</li>
<li>  etc.</li>
</ul>
<h4 id="Task的生命周期"><a href="#Task的生命周期" class="headerlink" title="Task的生命周期"></a>Task的生命周期</h4><p>可通过<strong>Task.Status属性</strong>查询执行状态id。只展开聊这个，透过它能理解Task的生命周期。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> TaskStatus &#123;</span><br><span class="line">    <span class="comment">// -----------这里只贴出生命周期内的状态-----------</span></span><br><span class="line">    </span><br><span class="line">    Created, <span class="comment">// 任务已显式创建：可以手动 Start()这个任务</span></span><br><span class="line">    WaitingForActivation, <span class="comment">// 任务已隐式创建：会自动开始</span></span><br><span class="line">    </span><br><span class="line">    WaitingToRun, <span class="comment">// 任务已调度，但尚末运行</span></span><br><span class="line">    Running, <span class="comment">// 任务正在运行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务正在等待它的子任务完成，子任务完成后它才完成</span></span><br><span class="line">    WaitingForChildrenToComplete,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务的最终状态是以下3个之一</span></span><br><span class="line">    RanToCompletion,</span><br><span class="line">    Canceled,</span><br><span class="line">    Faulted,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面贴出微软文档的这个类，补全一下，看的话看上面的就行。</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>值</th>
<th>详细</th>
</tr>
</thead>
<tbody><tr>
<td>Canceled</td>
<td>6</td>
<td>该任务已通过对其自身的 CancellationToken 引发 OperationCanceledException 对取消进行了确认，此时该标记处于已发送信号状态；或者在该任务开始执行之前，已向该任务的 CancellationToken 发出了信号。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/task-cancellation">任务取消</a>。</td>
</tr>
<tr>
<td>Created</td>
<td>0</td>
<td>该任务已初始化，但尚未被计划。</td>
</tr>
<tr>
<td>Faulted</td>
<td>7</td>
<td>由于未处理异常的原因而完成的任务。</td>
</tr>
<tr>
<td>RanToCompletion</td>
<td>5</td>
<td>已成功完成执行的任务。</td>
</tr>
<tr>
<td>Running</td>
<td>3</td>
<td>该任务正在运行，但尚未完成。</td>
</tr>
<tr>
<td>WaitingForActivation</td>
<td>1</td>
<td>该任务正在等待 .NET 基础结构在内部将其激活并进行计划。</td>
</tr>
<tr>
<td>WaitingForChildrenToComplete</td>
<td>4</td>
<td>该任务已完成执行，正在隐式等待附加的子任务完成。</td>
</tr>
<tr>
<td>WaitingToRun</td>
<td>2</td>
<td>该任务已被计划执行，但尚未开始执行。</td>
</tr>
</tbody></table>
<h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h3><p>就是<strong>TaskScheduler</strong>，它负责执行被调度的任务，同时向VS调试器公开任务信息。</p>
<p>官方提供2种TaskScheduler：</p>
<ul>
<li>  线程池任务调度器(thread pool task scheduler)</li>
<li>  同步上下文任务调度器(synchronization context task scheduler)</li>
</ul>
<p>默认情况，应用程序使用<strong>线程池任务调度器</strong>。它将任务调度给线程池的工作者线程。调用<code>TaskScheduler.Default</code>方法获取线程池任务调度器引用。</p>
<p>同步上下文任务调度器将借助画面线程！调用<code>TaskScheduler.FromCurrentSynchronizationContext</code>方法获取同步上下文任务调度器引用。</p>
<h4 id="同步上下文任务调度器"><a href="#同步上下文任务调度器" class="headerlink" title="同步上下文任务调度器"></a>同步上下文任务调度器</h4><p>同步上下文任务调度器适合提供了图形用户界面的应用程序，比如wpf。它将所有任务都调度给应用程序的GUI线程，使所有任务代码都能成功更新UI组件。</p>
<p><strong>该调度器不使用线程池，它调度的还是画面线程</strong>。如果用Default调度器的策略，线程池线程执行更新UI组件，会抛InvalidOperationException。</p>
<h4 id="用Task更新UI例子-♥wpf"><a href="#用Task更新UI例子-♥wpf" class="headerlink" title="用Task更新UI例子 ♥wpf"></a>用Task更新UI例子 ♥wpf</h4><p>wpf与unity一样，都是单ui线程的，其他线程没有办法调用它的api来修改ui。</p>
<p>所以下面可以看到，用上下文同步给Task从而实现更新UI，**实际上仍然是借调了主线程(ui线程)**，这个Task执行的时候你可以明显感觉到画面卡顿，因为画面线程在干活。</p>
<p>从来就没有什么魔法…</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> TaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        taskScheduler = TaskScheduler.FromCurrentSynchronizationContext();</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GUI thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t = Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;timing 1 thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.ContinueWith(o =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;timing 2 thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            myTextBox.Text = t.Result.ToString();</span><br><span class="line">        &#125;, taskScheduler); <span class="comment">// 注意!!! 如果这里不使用上下文同步的taskScheduler,会抛InvalidOperationException且更新UI失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// GUI thread id:1</span></span><br><span class="line"><span class="comment">// timing 1 thread id:3</span></span><br><span class="line"><span class="comment">// timing 2 thread id:1</span></span><br></pre></td></tr></table></figure>

<h4 id="其他自定义调度器"><a href="#其他自定义调度器" class="headerlink" title="其他自定义调度器"></a>其他自定义调度器</h4><p>![image-20220113173939283](E:\My Github\hexo\blog\source_posts\Tech\CSharp\CLR-Via-CSharp\cp7.assets\image-20220113173939283.png)</p>
<h2 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h2><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><p>静态 <strong>System.Threading.Tasks.Parallel 类</strong>，内部使用Task对象，可以用线程池的线程来<strong>并行执行</strong>操作。</p>
<p>要注意，并行执行对应<strong>顺序执行</strong>，它是无法保证顺序的。</p>
<h4 id="For、ForEach、Invoke"><a href="#For、ForEach、Invoke" class="headerlink" title="For、ForEach、Invoke"></a>For、ForEach、Invoke</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池的线程并行完成</span></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">1000</span>, i=&gt; DoSth(i));</span><br><span class="line">Parallel.ForEach(collection, item =&gt; DoSth(item)); <span class="comment">// ForEach要用迭代器遍历,比For稍慢</span></span><br><span class="line"></span><br><span class="line">Parallel.Invoke(</span><br><span class="line">    () =&gt; Method1(),</span><br><span class="line">    () =&gt; Method2(),</span><br><span class="line">    () =&gt; Method3(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>另外，Invoke有一个可控性极强的重载，指定 <strong>localInit、body、localFinally委托</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parallel.ForEach&lt;TSource,TLocal&gt; (IEnumerable&lt;TSource&gt; item, Func&lt;&gt; localInit, Func&lt;&gt; body, Func&lt;&gt; localFinally);</span><br><span class="line"></span><br><span class="line"><span class="comment">// item 是集合的每个子元素。</span></span><br><span class="line"><span class="comment">// localInit(初始化委托) 为参与工作的每个任务都调用一次该委托,在body前调用。</span></span><br><span class="line"><span class="comment">// body(主体委托) 为参与工作的每个任务都调用一次该委托。</span></span><br><span class="line"><span class="comment">// localFinally(终结委托) 为参与工作的每个任务都调用一次该委托,在body后调用。</span></span><br></pre></td></tr></table></figure>

<h4 id="返回值ParallelLoopResult"><a href="#返回值ParallelLoopResult" class="headerlink" title="返回值ParallelLoopResult"></a>返回值ParallelLoopResult</h4><p>For、ForEach都返回一个ParallelLoopResult实例。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ParallelLoopResult &#123;</span><br><span class="line">    <span class="comment">// 如果操作提前终止，以下方法返回 false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">// 保证得到处理的最低一项的索引</span></span><br><span class="line">    <span class="keyword">public</span> Int64? LowestBreakIteration &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 IsCompleted == true 说明全部运行完成，</p>
<p>如果 IsCompleted == false、LowestBreakIteration == null 说明某个线程调用了Stop，</p>
<p>如果 IsCompleted == false、LowestBreakIteration != null 说明某个线程break了。</p>
<h3 id="并行语言继承查询-PLINQ"><a href="#并行语言继承查询-PLINQ" class="headerlink" title="并行语言继承查询(PLINQ)"></a>并行语言继承查询(PLINQ)</h3><p>当只用一个线程来<strong>顺序执行</strong>调用LINQ时，我们称之为<strong>LINQ</strong>；当用<strong>并行的方式</strong>执行LINQ时，我们称之为**PLINQ(Parallel LINQ)**。</p>
<p>使用扩展方法<strong>AsParallel</strong>实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ParallelQuery</span>&lt;<span class="title">TSource</span>&gt; <span class="title">AsParallel</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParallelQuery <span class="title">Asparallel</span> (<span class="params"><span class="keyword">this</span> IEnumerable source</span>)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="执行定时计算限制操作"><a href="#执行定时计算限制操作" class="headerlink" title="执行定时计算限制操作"></a>执行定时计算限制操作</h2><h3 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h3><p>定时器，在<code>System.Threading</code>中定义的。</p>
<p>Timer的构造函数需要传入一个<strong>TimerCallback委托</strong> 回调函数，在时间到达后使用线程池线程调用这个回调函数。</p>
<h3 id="TimerCallback委托"><a href="#TimerCallback委托" class="headerlink" title="TimerCallback委托"></a>TimerCallback委托</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TimerCallback</span>(<span class="params">Object state</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Timer内部实现"><a href="#Timer内部实现" class="headerlink" title="Timer内部实现"></a>Timer内部实现</h3><p>在内部，线程池为所有Timer对象<strong>只打算使用一个线程</strong>。这个线程知道下一个Timer对象在什么时候到期（计时器还有多久触发）。下一个Timer对象到期时，线程就会唤醒，在内部调用 Threadpool的 QueueUserWorkItem,将一个工作项添加到线程池的队列中，使你的回调方法得到调用。</p>
<p>那么如果new了很多个Timer，那么有可能出现并行执行的情况，这个时候会用<strong>新的线程</strong>来帮你同时执行回调方法。</p>
<p>想避免用新线程，可以在构造Timer时传入<strong>period参数指定Timeout.Infinite</strong>，这样，计时器就只触发一次。然后，在你的回调方法中，调用 Change方法来指定一个新的<strong>dueTime</strong>，dueTime告诉CLR在首次调用回调方法之前需要等待多少毫秒，可以传递0立刻执行。</p>
<h3 id="例子、await允许线程返回"><a href="#例子、await允许线程返回" class="headerlink" title="例子、await允许线程返回"></a>例子、await允许线程返回</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Timer timer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Timer(回调, 回调参数, dueTime, period)</span></span><br><span class="line">    timer = <span class="keyword">new</span> Timer(Status, <span class="literal">null</span>, <span class="number">0</span>, Timeout.Infinite);</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Status</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Timer.Change(dueTime, period)</span></span><br><span class="line">    timer.Change(<span class="number">2000</span>, Timeout.Infinite); <span class="comment">// 返回前让Timer在2秒后再次触发</span></span><br><span class="line">    <span class="comment">// 这个方法返回后，线程回归池中，等待下一个工作项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:32 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:35 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:35:38 4</span></span><br></pre></td></tr></table></figure>

<p>然后书中用了await/async写一个等效的实现。我这里打印了线程号，可以观察出来其实两者并不同。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Status(<span class="literal">null</span>);</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; main &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Status</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now + <span class="string">&quot; &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟做2秒的事</span></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 2秒之后，某个线程池的线程会在await之后介入并继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:33 1</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:34 main 1</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:36 4</span></span><br><span class="line"><span class="comment">// 2022/01/14 11:30:39 4</span></span><br></pre></td></tr></table></figure>

<p>观察输出理解await做了什么：</p>
<p>画面线程走到await之前都是正常顺序执行的，但是遇到了await之后立刻退出了方法并继续执行了；而<strong>Status方法借由线程池线程来继续执行</strong>。</p>
<p>所以画面既没卡死，也在不断更新UI。我估计await这里的做法就是起了个Task把回调包进去，然后传递了同步上下文给它让他可以更新UI。</p>
<h1 id="大章28：I-O限制的异步操作⭐"><a href="#大章28：I-O限制的异步操作⭐" class="headerlink" title="大章28：I/O限制的异步操作⭐"></a><center>大章28：I/O限制的异步操作⭐</center></h1><p>讲述如何异步执行I/O限制的操作，允许将任务交由硬件设备处理，期间完全不占用线程和CPU资源。当然这还是离不开线程池得处理。</p>
<h2 id="Windows如何执行I-O操作"><a href="#Windows如何执行I-O操作" class="headerlink" title="Windows如何执行I/O操作"></a>Windows如何执行I/O操作</h2><h3 id="从硬件开始理解"><a href="#从硬件开始理解" class="headerlink" title="从硬件开始理解"></a>从硬件开始理解</h3><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220114151554.png"></p>
<p>图中展示的是连接了几个硬件设备的OS。</p>
<p>其实每个硬件都有自己的电路板，知道如何驱动自己的设备（寻道、读写数据、与计算机内存交换数据），所以其实不需要计算机线程来处理这些事。</p>
<h3 id="程序请求I-O流程⭐"><a href="#程序请求I-O流程⭐" class="headerlink" title="程序请求I/O流程⭐"></a>程序请求I/O流程⭐</h3><p>当你使用<code>FileStream fs = new FileStream(...); var bytes = fs.Read();</code>之后发生了这些事：</p>
<p>① 线程从托管代码转变为本机代码，Read内部<strong>调用Win32 ReadFile函数</strong>。</p>
<p>② ReadFile分配一个小数据结构，称作<strong>I/O请求包也就是IRP</strong> (I/O Request Packet)。</p>
<p>③ <strong>IRP结构初始化</strong>后包括：文件句柄，文件中的偏移量（字节读取开始位置）、一个Byte[]数组地址（用于写入读取的字节）等等。</p>
<p>④ 之后ReadFile将线程从 本机/用户模式代码=&gt;本机/内核模式代码，从而<strong>调用Windows内核并向其传递IRP数据包</strong>。Windows内核根据IRP中得设备句柄，传递给对应硬件设备的驱动程序的<strong>IRP队列</strong>。</p>
<p>⑤ 对应设备驱动软件在自己的IRP队列拿到IRP数据包，将信息传给物理硬件设备得电路板，执行I/O操作。</p>
<p>⑥ 设备执行I/O期间，发出请求的线程将无事可做，所以Windows将其变成<strong>睡眠</strong>状态。</p>
<p>⑦ 最终，硬件完成I/O操作。Windows会唤醒你的线程，并调度给一个CPU使它从内核模式返回用户模式，再<strong>返回至托管代码</strong>。</p>
<h3 id="异步请求I-O流程⭐"><a href="#异步请求I-O流程⭐" class="headerlink" title="异步请求I/O流程⭐"></a>异步请求I/O流程⭐</h3><p>上面演示了正常(同步)请求I/O流程，可以看⑥中你的线程在等待I/O期间是无所事事的。这是极大的浪费。</p>
<p>当你以异步方式发送I/O请求（用<strong>ReadAsync</strong>而不是Read） <code>FileStream fs = new FileStream(...,FileOptions.Asynchronous); Task&lt;int&gt; task = fs.ReadAsync();</code> 时发生了这些事：</p>
<p>① ReadAsync内部分配一个<code>Task&lt;int&gt;</code>对象来代表用于完成读取操作的代码。</p>
<p>② 和同步一样的方式，初始化IRP并发送到对应驱动软件IRP队列。</p>
<p>③ 驱动软件根据IRP数据包让硬件执行I/O，此刻，你的线程并<strong>不再睡眠</strong>，而是直接<strong>返回你的代码</strong>。</p>
<p>④ 从代码上看，你的线程会从ReadAsync的调用中很快返回，但是IRP可能还未处理好，所以不能在ReadAsync之后的代码中访问获取的Byte[]。</p>
<p>那么什么时候可以访问结果Byte[]呢？答案是为①中返回的<code>Task&lt;int&gt;</code>对象添加延续任务<strong>ContinueWith</strong>来执行回调方法。C#的<strong>异步函数</strong>可以简化这部分代码，从而以顺序方式写代码让你感觉像写同步I/O代码一样。</p>
<h3 id="I-O异步对比同步优势"><a href="#I-O异步对比同步优势" class="headerlink" title="I/O异步对比同步优势"></a>I/O异步对比同步优势</h3><p>资源上来说，同步阻塞线程，会导致CLR线程池不得不开辟更多线程来继续操作，<strong>增大开销</strong>；当I/O结束时线程又会回到线程池，导致<strong>过饱和</strong>，下场就是CPU同步上下文轮询花费更久。</p>
<p>效率上来说，一个线程去同步执行10个下载任务，每个5秒就得50秒；异步执行就只需要5秒。</p>
<h2 id="C-的异步函数⭐"><a href="#C-的异步函数⭐" class="headerlink" title="C#的异步函数⭐"></a>C#的异步函数⭐</h2><p>前面聊过了使用 <strong>ReadAsync + Task.ContinueWith</strong> 来实现异步，但是那么写代码比较复杂，于是微软推出了 <strong>异步函数 + Task</strong> 的方案，使开发者能够以同步顺序写代码实现异步。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; before &quot;</span> + <span class="string">&quot;tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Test(<span class="number">3</span>);</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; after &quot;</span> + <span class="string">&quot;tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    </span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">var</span> result = i * i;</span><br><span class="line">    Console.WriteLine(DateTime.Now + <span class="string">&quot; body &quot;</span> + result + <span class="string">&quot; tid:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">//  17:16:35 before tid:1</span></span><br><span class="line"><span class="comment">//  17:16:35 after tid:1</span></span><br><span class="line"><span class="comment">//  17:16:38 body 9 tid:4</span></span><br></pre></td></tr></table></figure>

<p>照这个示例来一步一步说明。</p>
<h3 id="async-gt-状态机"><a href="#async-gt-状态机" class="headerlink" title="async =&gt; 状态机"></a>async =&gt; 状态机</h3><p>我们很容易分辨Test是异步函数，因为他用async来修饰。</p>
<p>一旦方法被标记为async，编译器就会将方法的代码转换成实现了<strong>状态机</strong>的一个类型。具体下节讨论。</p>
<h3 id="await-gt-Task-ContinueWith"><a href="#await-gt-Task-ContinueWith" class="headerlink" title="await =&gt;Task.ContinueWith"></a>await =&gt;Task.ContinueWith</h3><p><code>await Task.Delay(3000);</code>这一句，Delay方法会在内部分配一个Task并实现<code>task.ContinueWith(await之后所有的代码);</code>等价的效果。</p>
<h3 id="最后，状态机恢复"><a href="#最后，状态机恢复" class="headerlink" title="最后，状态机恢复"></a>最后，状态机恢复</h3><p>当把后续代码包到Task的延续任务之后，线程不再等待Task的执行完毕，而是直接回到调用方法的地方<code>Test(3);</code>执行它之后的代码…</p>
<p>等到Task内部方法运行结束后，一个线程池线程会通知Task对象，开始激活ContinueWith回调方法（线程恢复状态机）。</p>
<h2 id="编译器如何将异步函数转换成状态机⭐"><a href="#编译器如何将异步函数转换成状态机⭐" class="headerlink" title="编译器如何将异步函数转换成状态机⭐"></a>编译器如何将异步函数转换成状态机⭐</h2><p>通过实现一个简单的异步函数使用案例，然后将IL代码反编译成C#代码来理解编译器到底做了些什么。</p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type1</span> &#123; &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Type2</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Type1&gt; <span class="title">Method1Async</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 异步执行一些操作，最后返回一个Type1对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Type2&gt; <span class="title">Method2Async</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 异步执行一些操作，最后返回一个Type2对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">MyMethodAsync</span>(<span class="params"><span class="built_in">int</span> arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> local = arg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		Type1 result1 = <span class="keyword">await</span> Method1Async();</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			Type2 result2 = <span class="keyword">await</span> Method2Async();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception e)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Catch&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span></span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>IL反编译成C#并精简后的代码：</p>
<p>要点是观察状态机的状态<strong>m_state</strong>在什么地方变化。</p>
<p>然后再观察<strong>m_x</strong>怎么实现的await循环<code>for()&#123; await ...&#125;;</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AsyncStateMachine特性指出这是一个异步方法（对使用反射的工具有用）</span></span><br><span class="line"><span class="comment">// 类型指出实现状态机的是哪个结构</span></span><br><span class="line">[<span class="meta">DebuggerStepThrough, AsyncStateMachine(typeof(StateMachine))</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">MyMethodAsync</span>(<span class="params">Int32 arg</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建状态机实例并初始化它</span></span><br><span class="line">    StateMachine stateMachine = <span class="keyword">new</span> StateMachine() &#123;</span><br><span class="line">        <span class="comment">// 创建 builder,从这个存根方法返回Task&lt;String&gt;</span></span><br><span class="line">        <span class="comment">// 状态机访问builder来设置Task完成/异常</span></span><br><span class="line">        m_builder = AsyncTaskMethodBuilder&lt;<span class="built_in">string</span>&gt;.Create(),</span><br><span class="line">        </span><br><span class="line">        m_state = <span class="number">-1</span>, <span class="comment">// 初始化状态机位置</span></span><br><span class="line">        m_arg = arg, <span class="comment">// 将实参拷贝到状态机字段</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行状态机</span></span><br><span class="line">    stateMachine.m_builder.Start(<span class="keyword">ref</span> statemachine):</span><br><span class="line">    <span class="keyword">return</span> stateMachine.m_builder.Task; <span class="comment">// 返回状态机的Task</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是状态机结构</span></span><br><span class="line">[<span class="meta">CompilerGenerated, StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> StateMachine : IAsyncStateMachine &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表状态机 builder(Task)及其位置的字段</span></span><br><span class="line">    <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="built_in">string</span>&gt; m_builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> m_state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实参和局部变量现在成了字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> m_argument, m_local, m_x;</span><br><span class="line">    <span class="keyword">public</span> Type1 m_resultType1;</span><br><span class="line">    <span class="keyword">public</span> Type2 m_resultType2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个 awaiter 类型一个字段</span></span><br><span class="line">    <span class="comment">// 任何时候这些字段只有一个是重要的，那个字段引用最近执行的、以异步方式完成的 await</span></span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter&lt;Type1&gt; m_awaiterType1;</span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter&lt;Type2&gt; m_awaiterType2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是状态机方法本身</span></span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.MoveNext() &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="literal">null</span>; <span class="comment">// Task的结果值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 编译器插入txy块来确保状态机的任务完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">bool</span> executeFinally = <span class="literal">true</span>; <span class="comment">// 先假定逻辑上离开try块</span></span><br><span class="line">            <span class="keyword">if</span>(m_state == <span class="number">-1</span>) &#123;         <span class="comment">// 如果第一次在状态机方法中，</span></span><br><span class="line">                m_ local = m_argument;  <span class="comment">// 原始方法就从头开始执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 原始代码中的try块</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                TaskAwaiter&lt;Type1&gt; awaiterType1;</span><br><span class="line">                TaskAwaiter&lt;Type2&gt; awaiterType2;</span><br><span class="line">                </span><br><span class="line">                 <span class="keyword">switch</span>(m_state) &#123;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// 开始执行源代码中try块中的代码</span></span><br><span class="line">                         <span class="comment">// 调用 Method1Async并获得它的 awaiter</span></span><br><span class="line">                         awaiterType1 = Method1Async().GetAwaiter();</span><br><span class="line">                         <span class="keyword">if</span>(!awaiterType1.IsCompleted)&#123;</span><br><span class="line">                             m_state = <span class="number">0</span>; <span class="comment">// Method1Async要以异步方式完成</span></span><br><span class="line">                             m_awaiterType1 = awaiterType1; <span class="comment">// 保存awaiter以便将来返回</span></span><br><span class="line">                </span><br><span class="line">                             <span class="comment">// 告诉awaiter在操作完成时调用MoveNext</span></span><br><span class="line">                             m_builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiterType1, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                             <span class="comment">// 上述代码调用 awaiterType1 的 OnCompleted,它会在被等待的任务上调用 ContinueWith(t=&gt; MoveNext())</span></span><br><span class="line">                             <span class="comment">// 任务完成后ContinueWith调用MoveNext</span></span><br><span class="line">                             </span><br><span class="line">                             executeFinally = <span class="literal">false</span>; <span class="comment">// 逻辑上不离开try块</span></span><br><span class="line">                             <span class="keyword">return</span>; <span class="comment">// 线程返回至调用者</span></span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// Method1Async以同步方式完成了</span></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                         </span><br><span class="line">                     <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// Method1Async 以异步方式完成了</span></span><br><span class="line">                         awaiterType1 = m_awaiterType1; <span class="comment">// 恢复最新的awaiter</span></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Method2Async 以异步方式完成了</span></span><br><span class="line">                         awaiterType2 = m_awaiterType2; <span class="comment">// 恢复最新的awaiter</span></span><br><span class="line">                         <span class="keyword">goto</span> ForLoopEpilog;</span><br><span class="line">                 &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在第一个await后，我们捕捉结果并启动for循环</span></span><br><span class="line">                m_resultType1 = awaiterType1.GetResult(); <span class="comment">// 获取awaiter的结果</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//序幕</span></span><br><span class="line">                ForLoopPrologue:</span><br><span class="line">                	m_x = <span class="number">0</span>; <span class="comment">// for循环初始化</span></span><br><span class="line">                	<span class="keyword">goto</span> ForLoopBody;</span><br><span class="line">                <span class="comment">//收场</span></span><br><span class="line">                ForLoopEpilog:</span><br><span class="line">                	m_resultType2 = awaiterType2.GetResult();</span><br><span class="line">                	m_x ++;</span><br><span class="line">                <span class="comment">// 循环主体</span></span><br><span class="line">                ForLoopBody:</span><br><span class="line">                	<span class="keyword">if</span>(m_x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="comment">// 调用 Method2Async并获取它的 awaiter</span></span><br><span class="line">                        awaiterType2 = Method2Async().GetAwaiter();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(!awaiterType2.IsCompleted)&#123;</span><br><span class="line">                            m_state = <span class="number">1</span>; <span class="comment">// Method2Async要以异步方式完成</span></span><br><span class="line">                            m_awaiterType2 = awaiterType2; <span class="comment">// 保存 awaiter以使将来返回</span></span><br><span class="line">                            </span><br><span class="line">                              <span class="comment">// 告诉 awaiter在操作完成时调用 MoveNext</span></span><br><span class="line">                        	m_builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiterType2, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                        	executeFinally = <span class="literal">false</span>; <span class="comment">// 逻辑上不离开try块</span></span><br><span class="line">                        	<span class="keyword">return</span>; <span class="comment">// 线程返回至调用者</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Method2Async以同步方式完成了</span></span><br><span class="line">                        <span class="keyword">goto</span> ForLoopEpilog; <span class="comment">// 如果走这个goto,意味着以同步方式完成就再次循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">             </span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Catch&quot;</span>); <span class="comment">// 源代码的catch块</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 本来,只要线程物理上离开try就会执行finally,</span></span><br><span class="line">                <span class="comment">// 但我们希望在线程逻辑上离开try时才执行这些代码</span></span><br><span class="line">                <span class="keyword">if</span>(executeFinally)&#123;</span><br><span class="line">                    Console.WriteLIne(<span class="string">&quot;Finally&quot;</span>); <span class="comment">// 源代码的finally块</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="string">&quot;Done&quot;</span>; <span class="comment">// 源代码最后一句</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 未处理的异常：通过设置异常来完成状态机的Task</span></span><br><span class="line">            m_builder.SetException(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常：通过返回结果来完成状态机的Task</span></span><br><span class="line">        m_builder.SetResult(result):</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="梳理一下"><a href="#梳理一下" class="headerlink" title="梳理一下"></a>梳理一下</h3><p>当编译器遇到<strong>async</strong>时，会尝试将方法编译成一个<strong>new状态机</strong>。</p>
<p>当编译器遇到<strong>await</strong>时，编译器会在它上面调用<strong>GetAwaiter</strong>方法。调用该方法所返回的对象为awaiter，正是它将被等待的对象与状态机粘合起来。</p>
<p>状态机获得awaiter后会查询其<strong>IsCompleted</strong>属性：如果操作以同步方式执行就返回true，如果以异步方式完成就返回false。如果为false，状态机调用awaiter的<strong>OnCompleted</strong>方法并传递一个委托（内含原任务和MoveNext）。此刻，状态机允许它的线程回到原地以执行其他代码。</p>
<p>将来某个时候，awaiter会在完成任务时调用委托以执行<strong>MoveNext</strong>，状态机往下运行，从而使得方法也回到当初离开的位置继续执行。之后，方法内其他的awaiter得以以同样的方式执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220117144608.png"></p>
<h2 id="异步函数扩展性"><a href="#异步函数扩展性" class="headerlink" title="异步函数扩展性"></a>异步函数扩展性</h2><p>在扩展性方面，只要是能用Task对象包装的操作，都可以用await来等待。</p>
<h3 id="TaskLogger"><a href="#TaskLogger" class="headerlink" title="TaskLogger"></a>TaskLogger</h3><p>clr作者自制的类，可用它打印尚未完成的异步操作。会影响性能，可以只在调试的时候启用。</p>
<p>// TODO</p>
<h2 id="await支持void"><a href="#await支持void" class="headerlink" title="await支持void"></a>await支持void</h2><p>异步函数的返回类型一般是<code>Task</code>或<code>Task&lt;Result&gt;</code>，它们代表函数的状态机完成。</p>
<p>但是异步函数是支持<strong>返回void</strong>的，毕竟所有事件签名几乎都是这么写的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventHandlerCallback</span>(<span class="params">Object sender, EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>C#编译器仍然会给返回void的异步函数创建状态机，但不再创建Task对象（因为创建了也没法使用）。<strong>所以你无法知道返回void的异步函数状态机在什么时候运行完毕。</strong></p>
<p>但这一般不致命，因为一般不需要知道它什么时候结束，只要可以在它执行结束完再执行后续代码就行了。</p>
<h2 id="异步函数和异常处理"><a href="#异步函数和异常处理" class="headerlink" title="异步函数和异常处理"></a>异步函数和异常处理</h2><p>如果硬件驱动收到IRP后，在进行I/O时虽然完成了但是内部出现错误，他就会向CLR的线程池post已完成的IRP。一个线程池线程会完成Task对象并设置异常，当你的状态机恢复后，await操作符会发现操作失败并引发该异常。</p>
<p>前面提过，当你用<code>Task.Start()</code>这种方式时，通常抛出一个<strong>AggregateException</strong>；但是如果你用<code>await someTask</code>的方式，编译器会优化体验，直接抛出<strong>第一个内部异常</strong>。</p>
<h2 id="线程处理模型：GUI线程⭐"><a href="#线程处理模型：GUI线程⭐" class="headerlink" title="线程处理模型：GUI线程⭐"></a>线程处理模型：GUI线程⭐</h2><p>简单聊下<strong>线程处理模型</strong>，.NET framework 支持很多种不同的应用程序模型，每种模型有自己的线程处理模型。比如说控制台应用程序没有任何线程处理模型。</p>
<h3 id="GUI线程"><a href="#GUI线程" class="headerlink" title="GUI线程"></a>GUI线程</h3><p>而GUI应用程序比如wpf引入了一个线程处理模型，<strong>这个模型中UI元素只能由创建它的线程更新</strong>，而这个线程我们叫做<strong>GUI线程</strong>。</p>
<p>如果通过线程池线程来更新UI元素，就会抛出异常。</p>
<h3 id="await优化-恢复上下文"><a href="#await优化-恢复上下文" class="headerlink" title="await优化 = 恢复上下文"></a>await优化 = 恢复上下文</h3><p><code>System.Threading.SynchronizationContext</code> 类的派生对象将应用程序模型连接到它的线程处理模型。<br>我们不和这个类打交道，只要知道它可以让你获得正确的<strong>同步上下文</strong>就行了。</p>
<p><code>await someTask;</code>的await关键字发生等待前，它会传递一个SynchronizationContext对象过去。之后，异步发生，会抽一个线程池线程来执行Task。<strong>当线程池线程完成Task后，会使用该SynchronizationContext对象</strong>，确保为应用程序模型使用正确的线程处理模型，换成人话就是<strong>会调用wpf的GUI线程来做事</strong>。</p>
<p>这就是await做的优化：<code>await someTask;</code>之后的代码如果有更新UI元素也能正常实现。但是注意，Task是由线程池线程来执行的，所以你在Task里面更新UI元素仍然会抛错。</p>
<p>来个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    Test();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GUI thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> t =  Task.Run(() =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;task thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">			Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">    <span class="keyword">await</span> t;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;after task thread id:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    myTextBox.Text = <span class="string">&quot;123&quot;</span>; <span class="comment">// 3秒后成功更新UI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// GUI thread id: 1</span></span><br><span class="line"><span class="comment">// task thread id: 3</span></span><br><span class="line"><span class="comment">// after task thread id: 1</span></span><br></pre></td></tr></table></figure>



<h2 id="I-O请求优先级"><a href="#I-O请求优先级" class="headerlink" title="I/O请求优先级"></a>I/O请求优先级</h2><p>Windows允许线程在发出I/O请求时指定优先级。但是只允许指定本进程的，不允许指定其他进程的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> (ThreadIO.BeginBackgroundProcessing())&#123;</span><br><span class="line">        <span class="comment">// 在这里执行低优先级I/O请求(例如：调用 ReadAsync/ WriteAsync)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="大章29：基元线程同步构造"><a href="#大章29：基元线程同步构造" class="headerlink" title="大章29：基元线程同步构造"></a><center>大章29：基元线程同步构造</center></h1><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁的存在是为了实现线程同步、避免多个线程同时修改一个数据源从而造成数据损坏。锁的存在意义是一次只允许一个线程访问资源。什么时候不需要锁？多个线程如果只访问不修改一个数据源，是不需要锁的。</p>
<p>锁的缺点很多，</p>
<p>即便是最快的锁，也会损害性能，需要时间开销；</p>
<p>一次只允许一个线程访问资源是锁的存在意义，但是也就意味着某个线程会被锁阻塞，导致线程池不得不创建更多的线程来处理其他问题。</p>
<h2 id="类库和线程安全"><a href="#类库和线程安全" class="headerlink" title="类库和线程安全"></a>类库和线程安全</h2><p><strong>FCL(Framework Class Library)确保其所有静态方法都是线程安全的</strong>。比如Console类就有一个静态字段，类的许多方法都要释放获取这个字段上的锁，从而保证一次只有一个线程访问控制台。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果你的代码在进程中有<strong>多个线程同时运行</strong>一段代码，如果每次执行的结果都和单线程运行时的<strong>结果一致</strong>， 那么就是线程安全的。</p>
<p>线程安全方法并不意味着一定需要线程同步锁。</p>
<p>比如System.Math的静态Max方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Max</span>(<span class="params"><span class="built_in">int</span> val1, <span class="built_in">int</span> val2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (val1 &lt; val2) ? val2 : val1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是线程安全的，它没有获取任何锁。多个线程可以同时调用Max方法，每个线程都处理的是自己的栈上数据，互不干扰。</p>
<h3 id="使所有实例方法非线程安全，使静态方法线程安全"><a href="#使所有实例方法非线程安全，使静态方法线程安全" class="headerlink" title="使所有实例方法非线程安全，使静态方法线程安全"></a>使所有实例方法非线程安全，使静态方法线程安全</h3><p>FCL并不保证实例方法是线程安全的。并不是不保证，而是没必要。正如标题，FCL是遵守这个原则的。</p>
<p>为什么说不保证实例方法线程安全？首先是<strong>没必要</strong>，线程在构造对象时，只有这个线程才拥有对象引用，其他线程都不能访问那个对象。其次是<strong>要了不好</strong>，线程同步锁会严重影响性能。</p>
<p>然而这句话也<strong>不是绝对的</strong>，如果线程随后公开了这个对象引用（比如把它放到一个静态字段中），传给了一个ThreadPool或Task的线程，那么<strong>在多个线程可能同时进行非只读访问的前提下，就需要线程同步</strong>。</p>
<h2 id="基元用户模式和内核模式构造"><a href="#基元用户模式和内核模式构造" class="headerlink" title="基元用户模式和内核模式构造"></a>基元用户模式和内核模式构造</h2><h3 id="基元-primitive"><a href="#基元-primitive" class="headerlink" title="基元 (primitive)"></a>基元 (primitive)</h3><p>基元，是指可以在代码中使用的最简单的构造。有两种基元构造：<strong>用户模式</strong>(user-mode)和<strong>内核模式</strong>( kernel-mode)。</p>
<p>用户模式的速度显著快于内核模式，但是这个速度的优势是由于<strong>协调是在硬件中发生的</strong>，这也同样意味着Windows操作系统永远检测不到一个线程在基元用户模式的构造上阻塞了。</p>
<p>而内核模式是<strong>由Windows操作系统自身提供</strong>的，所以它们在获取其他线程资源时，Windows会阻塞线程以避免它浪费CPU时间，直到资源可用才恢复线程。</p>
<p>线程在 用户模式 和 内核模式 之间转换，是一个巨大的开销。</p>
<h3 id="死锁活锁"><a href="#死锁活锁" class="headerlink" title="死锁活锁"></a>死锁活锁</h3><p>当一个线程遇到资源等待的问题时，</p>
<p>如果它是用户模式的，那么线程就会一直在一个CPU上运行，称为 <strong>活锁</strong>(livelock)；</p>
<p>如果它是内核模式的，那么线程就会一直阻塞，称为 <strong>死锁</strong>(deadlock)。</p>
<p><strong>死锁永远优于活锁</strong>，要知道，死锁只是卡死一个线程那也只是浪费了内存，而活锁线程除了内存，还一直在占用CPU的时间片。</p>
<h2 id="用户模式构造"><a href="#用户模式构造" class="headerlink" title="用户模式构造"></a>用户模式构造</h2><h3 id="原子性⭐"><a href="#原子性⭐" class="headerlink" title="原子性⭐"></a>原子性⭐</h3><p>CLR保证对以下数据类型变量的读写是原子性的：bool、char、(S)Byte、Int16、Int32、IntPtr、Single以及引用类型。这意味着<strong>变量中的所有字节都一次性读取或写入</strong>。</p>
<p>什么意思呢，比如执行以下代码时，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">x = <span class="number">0x01234567</span>;</span><br><span class="line"></span><br><span class="line">Int64 y;</span><br><span class="line">y = <span class="number">0x0123456789abcdef</span>;</span><br></pre></td></tr></table></figure>

<p>x变量会<strong>一次性（原子性）</strong>地从0x00000000变成0x01234567。另一个线程不可能看到处于中间状态的值。</p>
<p>y变量就不同了，其他线程查询到它的值可能是0x0000000000000000 到 0x0123456789abcdef的值，因为读取和写入操作不是原子性的。这称为一次 <strong>torn read</strong>（撕裂读取：一次读取被撕成两半，或者在机器级别上要2个MOV指令才能读完）。</p>
<p>有两种基元<strong>用户模式</strong>线程同步构造：易变构造和互锁构造。</p>
<p>易变构造：在特定的时间，它在包含一个简单数据类型的变量上执行原子性的<strong>读或写</strong>操作。</p>
<p>互锁构造：在特定的时间，它在包含一个简单数据类型的变量上执行原子性的<strong>读和写</strong>操作。</p>
<h3 id="易变构造-volatile-construct"><a href="#易变构造-volatile-construct" class="headerlink" title="易变构造 (volatile construct)"></a>易变构造 (volatile construct)</h3><p>说的就是由于代码是由 C#编译器转换为IL语言、再由JIT将IL语言转换成本机CPU指令，最后再执行的，所以其中包括很多的<strong>编译器优化</strong>，导致你最终生成的代码运行顺序与你书写的不同。</p>
<p>可以使用两个<code>System.Threading.Volatile</code>类（<strong>易变构造</strong>）的静态方法来确保代码顺序执行而不被优化得偏离你的意图：</p>
<p><strong>Volatile.Write</strong> 方法执行一次原子性的写入操作。强迫location中的值在调用时写入。按照编码顺序，之前的加载和存储操作必须在调用Volatile.Write之前发生。</p>
<p><strong>Volatile.Read</strong> 方法执行一次原子性的读取操作。强迫location中的值在调用时读取。按照编码顺序，之后的加载和存储操作必须在调用Volatile.Read之后发生。</p>
<h4 id="易变构造volatile-例子"><a href="#易变构造volatile-例子" class="headerlink" title="易变构造volatile 例子"></a>易变构造volatile 例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序可能被优化到偏离意图的执行案例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Before</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法由一个线程执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        val = <span class="number">5</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法由另一个线程执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意：value可能先于flag读取</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span><br><span class="line">            Console.WriteLine(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后,确保按照意图执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">After</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// flag的写入 必然在所有前面代码之前</span></span><br><span class="line">        val = <span class="number">5</span>;</span><br><span class="line">        Volatile.Write(<span class="keyword">ref</span> flag, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// flag的读取 必然在所有后续代码之前</span></span><br><span class="line">        <span class="keyword">if</span>(Volatile.Read(<span class="keyword">ref</span> flag) == <span class="number">1</span>) &#123;</span><br><span class="line">            Console.WriteLine(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互锁构造"><a href="#互锁构造" class="headerlink" title="互锁构造"></a>互锁构造</h3><p>互锁，说的是<code>System.Threading.Interlocked</code>类提供的方法，Interlocked类中的每个方法都执行一次原子读取以及写入操作。Interlocked的所有方法都建立了完整的<strong>内存栅栏</strong>(memory fence)：调用某个Interlocked方法之前的任何变量写入都在这个Interlocked方法之前执行；这个调用之后的任何变量读取都在这个调用之后读取。</p>
<h4 id="Interlocked类"><a href="#Interlocked类" class="headerlink" title="Interlocked类"></a>Interlocked类</h4><p>展示对int处理的接口，来理解他能做哪些事。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Interlocked</span> &#123;</span><br><span class="line">    <span class="comment">// return (++location)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Increment</span> (<span class="params"><span class="keyword">ref</span> Int32 location</span>)</span>;</span><br><span class="line">    <span class="comment">// return (--location)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Decrement</span> (<span class="params"><span class="keyword">ref</span> Int32 location</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Add</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Exchange</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">CompareExchange</span> (<span class="params"><span class="keyword">ref</span> Int32 location1, Int32 <span class="keyword">value</span>, Int32 comparand</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>// TODO 后面的都略了，太需要实战应用，光看不够</p>
<h1 id="大章30：混合线程同步构造"><a href="#大章30：混合线程同步构造" class="headerlink" title="大章30：混合线程同步构造"></a><center>大章30：混合线程同步构造</center></h1><h2 id="双检锁技术"><a href="#双检锁技术" class="headerlink" title="双检锁技术"></a>双检锁技术</h2><p>双检锁(Double- Check Locking)是一个非常著名的技术，开发人员用它将单实例(singleton)对象的构造推退到应用程序首次请求该对象时进行。也就是<strong>懒加载（也叫延迟初始化 lazy init）</strong>。</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// s_lock对象是实现线程安全所需要的。定义这个对象时，我们假设创建单实例对象的</span></span><br><span class="line">    <span class="comment">// 代价高于创建一个System.Object对象，并假设可能根本不需要创建单实例对象</span></span><br><span class="line">    <span class="comment">// 否则，更经济、更简单的做法是在一个类构造器中创建单实例对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> s_lock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">        </span><br><span class="line">        Monitor.Enter(s_lock); <span class="comment">// Monitor.Enter: 获取指定对象上的排他锁</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            Singleton temp = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="comment">// 将引用保存到instance中(参见正文的详细讨论)</span></span><br><span class="line">            Volatile.Write(<span class="keyword">ref</span> instance, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Monitor.Exit(s_lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存栅栏"><a href="#内存栅栏" class="headerlink" title="内存栅栏"></a>内存栅栏</h4><p>由于CLR对任何锁方法的调用都构成了一个<strong>完整的内存栅栏</strong>，在柵栏之前写入的任何变量都必须在栅栏之前完成；在栅栏之后的任何变量读取都必须在栅栏之后开始。所以第二个if中instance的值必须等待锁结束后，其他线程才能获取到，而不是什么缓存到寄存器中的东西。</p>
<p>放到JAVA就不一样了，它因为不保证完整的内存栅栏，导致第二个if可能读取到缓存到寄存器中的instance数值，从而返回true。</p>
<h4 id="发布-publishing"><a href="#发布-publishing" class="headerlink" title="发布(publishing)"></a>发布(publishing)</h4><p>而<code>Volatile.Write(ref instance, temp);</code>是解决了什么问题呢？</p>
<p>使一个值对其他线程可见称为<strong>发布</strong>。如果按照常规思路写<code>instance = new Singleton();</code>，编译器可能并不会按照你顺序写的代码来执行。它可能会先为Singleton分配内存，将引用发布到instance，然后再调用构造器，这导致了其他线程看到的instance不为null也不为正确的构造好的Singleton对象，而是一个<strong>正在构造的Singleton对象</strong>。</p>
<h3 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetSingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本与前面的效果是一样的！即使它没用“双检锁”也能保证<strong>线程安全</strong>。具体原因看下面。</p>
<p>在首次有线程访问这个Singleton的时候，CLR就会自动调用类构造器，创建并返回一个对象实例。</p>
<h4 id="线程安全⭐"><a href="#线程安全⭐" class="headerlink" title="线程安全⭐"></a>线程安全⭐</h4><p>关于线程安全需要特別说明一下，由于程序可能在多线程环境下运行，也就是可能出现同时多个线程准备执行静态构造函数的情況。<strong>CLR确保这个过程是安全的</strong>，实际上调用静态构造函数的线程需要先获得一个<strong>互斥线程同步锁</strong>，如果有多个线程试图执行类型的静态构造函数，只有一个线程能获得该锁；获得锁的线程完成初始类型初始化操作，<strong>其它线程只能等待</strong>；当初始化完成，等待的线程被唤醒，然后发现静态构造函数已经被执行过，就不会再执行，此时获得的字段也是初始化完成后的状态。</p>
<p>下面献上我自己的测试代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Task.Run(() =&gt;</span><br><span class="line">			&#123;</span><br><span class="line">				Utils.WriteLine(<span class="string">&quot; Task1 Started&quot;</span>);</span><br><span class="line">				Utils.WriteLine(<span class="string">&quot; Task1 &quot;</span> + Singleton.Instance().counter.ToString());</span><br><span class="line">				Utils.WriteLine(<span class="string">&quot; Task1 End&quot;</span>);</span><br><span class="line">			&#125;);</span><br><span class="line">			Utils.WriteLine( <span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">			Task.Run(() =&gt;</span><br><span class="line">			&#123;</span><br><span class="line">				Utils.WriteLine(<span class="string">&quot; Task2 Started&quot;</span>);</span><br><span class="line">				Utils.WriteLine(<span class="string">&quot; Task2 &quot;</span> + Singleton.Instance().counter.ToString());</span><br><span class="line">				Utils.WriteLine(<span class="string">&quot; Task2 End&quot;</span>);</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			Console.Read();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">int</span> counter;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			counter++;</span><br><span class="line">			Utils.WriteLine(<span class="string">&quot; ctor bf&quot;</span> + counter);</span><br><span class="line">			Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">			counter += <span class="number">10</span>;</span><br><span class="line">			Utils.WriteLine(<span class="string">&quot; ctor af&quot;</span> + counter);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">Instance</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Utils</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteLine</span>(<span class="params"><span class="built_in">string</span> txt</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(Thread.CurrentThread.ManagedThreadId + txt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="静态构造、实例构造、内联执行顺序"><a href="#静态构造、实例构造、内联执行顺序" class="headerlink" title="静态构造、实例构造、内联执行顺序"></a>静态构造、实例构造、内联执行顺序</h4><p>引用：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxiaotank/p/11155886.html">https://www.cnblogs.com/xiaoxiaotank/p/11155886.html</a></p>
<p>一般情况下是 <strong>静态字段内联 &gt; 静态构造 &gt; 实例字段内联 &gt; 实例构造</strong>。</p>
<p>如果加上基类就是：</p>
<p>Child静态字段内联 &gt; Child静态构造 &gt; Child实例字段内联 &gt; Base静态字段内联 &gt; Base静态构造 &gt; Base实例字段内联 &gt; Base实例构造 &gt; Child实例构造</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;---------------一般初始化顺序---------------&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> child1 = <span class="keyword">new</span> Child1();</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;\n---------------子类静态字段初始化需要使用父类静态字段时初始化顺序---------------&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> child2 = <span class="keyword">new</span> Child2();</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;\n---------------子类静态构造函数中使用父类静态字段时初始化顺序---------------&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> child3 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line">		Console.ReadKey();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child1</span> : <span class="title">Base1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 静态构造器</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line">		<span class="comment">// 静态构造器</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">Child1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line">		<span class="comment">// 实例构造器</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Child1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child2</span> : <span class="title">Base2</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">		<span class="comment"><span class="doctag">///</span> 子类静态字段初始化需要使用父类静态字段</span></span><br><span class="line">		<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>, () =&gt; BaseStatic);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">Child2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Child2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child3</span> : <span class="title">Base3</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Display ChildStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Child static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Display _childFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Child filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">		<span class="comment"><span class="doctag">///</span> 子类静态构造函数中使用父类静态字段</span></span><br><span class="line">		<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">Child3</span>(<span class="params"></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Child static ctor&quot;</span>);</span><br><span class="line">			<span class="keyword">var</span> baseStatic = BaseStatic;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Child3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Child ctor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 3个Base类相同，这里是为了演示静态成员的初始化</span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 静态字段</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line">		<span class="comment">// 实例字段</span></span><br><span class="line">		<span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line">		<span class="comment">// 静态构造器</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">Base1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line">		<span class="comment">// 实例构造器</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Base1</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base2</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">Base2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Base2</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Base3</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Display BaseStatic = <span class="keyword">new</span> Display(<span class="string">&quot;Base static filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Display _baseFiled = <span class="keyword">new</span> Display(<span class="string">&quot;Base filed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">Base3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base static ctor&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Base3</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">&quot;Base ctor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Display</span>(<span class="params"><span class="built_in">string</span> msg, Func&lt;Display&gt; displayFunc = <span class="literal">null</span></span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(msg);</span><br><span class="line">			<span class="keyword">var</span> display = displayFunc?.Invoke();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>result：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">---------------一般初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br><span class="line"></span><br><span class="line">---------------子?静?字段初始化需要使用父?静?字段?初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br><span class="line"></span><br><span class="line">---------------子?静??造函数中使用父?静?字段?初始化?序---------------</span><br><span class="line">Child <span class="keyword">static</span> filed</span><br><span class="line">Child <span class="keyword">static</span> ctor</span><br><span class="line">Base <span class="keyword">static</span> filed</span><br><span class="line">Base <span class="keyword">static</span> ctor</span><br><span class="line">Child filed</span><br><span class="line">Base filed</span><br><span class="line">Base ctor</span><br><span class="line">Child ctor</span><br></pre></td></tr></table></figure>



<h3 id="Lazy模式"><a href="#Lazy模式" class="headerlink" title="Lazy模式"></a>Lazy模式</h3><p>FCL有两个类型封装了上面描述的模式，也就是<strong>懒汉模式</strong>。</p>
<p>下面是泛型System.Lazy类(方法未列完)：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lazy</span>&lt;<span class="title">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lazy</span>(<span class="params">Func&lt;T&gt; valueFactory, LazyThreadSafetyMode mode</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> Boolean IsValueCreated &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> T Value &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line">LazyThreadSafetyMode &#123;</span><br><span class="line">    None, <span class="comment">// 完全没有线程安全支持(适合GUI应用程序)</span></span><br><span class="line">    ExecutionAndPublication, <span class="comment">// 使用双检锁技术</span></span><br><span class="line">    PublicationOnly, <span class="comment">// 使用Interlocked.CompareExchange技术</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个“延迟初始化”包装器，它将Datetime的获取包装起来</span></span><br><span class="line">    Lazy&lt;<span class="built_in">string</span>&gt; s = <span class="keyword">new</span> Lazy&lt;<span class="built_in">string</span>&gt;(() =&gt; DateTime.Now.ToLongTimeString(), <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(s.IsValueCreated); <span class="comment">// 还没查询Value，返回false</span></span><br><span class="line">    Console.WriteLine(s.Value); <span class="comment">// 开始调用委托</span></span><br><span class="line">    Console.WriteLine(s.IsValueCreated); <span class="comment">// 已经查询了Value，返回true</span></span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">    Console.WriteLine(s.Value); <span class="comment">// 委托没有被重复调用，显示相同结果是正常的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo output:</span></span><br><span class="line"><span class="comment">// False</span></span><br><span class="line"><span class="comment">// 2:40:42 PM</span></span><br><span class="line"><span class="comment">// True</span></span><br><span class="line"><span class="comment">// 2:40:42 PM</span></span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CodingCodingK</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp7/">https://codingcodingk.github.io/Tech/CSharp/CLR-Via-CSharp/cp7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://CodingCodingK.github.io" target="_blank">CodingCodingK Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/C/">C#</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Tech/CSharp/Essence/structAndObject/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C#精要 - 值类篇</div></div></a></div><div class="next-post pull-right"><a href="/Tech/Game/01knapsack/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20211208131158.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">背包问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp1/" title="CLR Via C#个人笔记1 - CLR基础"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-29</div><div class="title">CLR Via C#个人笔记1 - CLR基础</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp3/" title="CLR Via C#个人笔记3 - 基元类型、引用类型和值类型"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-13</div><div class="title">CLR Via C#个人笔记3 - 基元类型、引用类型和值类型</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp2/" title="CLR Via C#个人笔记2 - 类与分配"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">CLR Via C#个人笔记2 - 类与分配</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp4/" title="CLR Via C#个人笔记4 - 类型和成员基础"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">CLR Via C#个人笔记4 - 类型和成员基础</div></div></a></div><div><a href="/Tech/CSharp/CLR-Via-CSharp/cp5/" title="CLR Via C#个人笔记5 - 基本类型"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/clr-via-csharp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">CLR Via C#个人笔记5 - 基本类型</div></div></a></div><div><a href="/Tech/CSharp/Essence/async/" title="C#精要 - 异步篇"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">C#精要 - 异步篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CodingCodingK</div><div class="author-info__description">一个正在成为游戏开发者的人</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CodingCodingK"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CodingCodingK" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">2022年的目标是：ET框架 + 烟雨Moba | Lua程序设计 + C++Primer</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A026%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">大章26：线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Widnows%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">Widnows的线程概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%80%E9%94%80%E2%AD%90"><span class="toc-number">1.2.</span> <span class="toc-text">线程开销⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E7%BA%BF%E7%A8%8B%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1-thread-kernel-object"><span class="toc-number">1.2.1.</span> <span class="toc-text">①线程内核对象 (thread kernel object)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97-thread-environment-block-TEB"><span class="toc-number">1.2.2.</span> <span class="toc-text">②线程环境块 (thread environment block,TEB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E6%A0%88-user-mode-stack"><span class="toc-number">1.2.3.</span> <span class="toc-text">③用户模式栈 (user- mode stack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E6%A0%88-kernel-mode-stack"><span class="toc-number">1.2.4.</span> <span class="toc-text">④内核模式栈 (kernel- mode stack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4DLL%E7%BA%BF%E7%A8%8B%E8%BF%9E%E6%8E%A5-attach-%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB-detach-%E9%80%9A%E7%9F%A5"><span class="toc-number">1.2.5.</span> <span class="toc-text">⑤DLL线程连接 (attach)和线程分离 (detach)通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.6.</span> <span class="toc-text">上下文调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E6%83%85%E5%86%B5"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">多核情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%96%AF%E7%8B%82"><span class="toc-number">1.3.</span> <span class="toc-text">停止疯狂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF"><span class="toc-number">1.3.1.</span> <span class="toc-text">CPU发展趋势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CLR%E7%BA%BF%E7%A8%8B%E5%92%8C-Windows%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">CLR线程和 Windows线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%93%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">使用专用线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么时候用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%93%E7%94%A8%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E8%AE%A1%E7%AE%97%E9%99%90%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.</span> <span class="toc-text">创建专用线程，并执行异步的计算限制操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-number">1.5.3.</span> <span class="toc-text">使用线程的理由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%BB%E9%9D%A2%E5%93%8D%E5%BA%94%EF%BC%88%E9%80%9A%E5%B8%B8%E6%98%AF%E5%AF%B9%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%AB%AFGUI%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%89"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">画面响应（通常是对于客户端GUI应用程序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%EF%BC%88%E5%AF%B9%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%89"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">性能（对于客户端和服务器应用程序）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E2%AD%90"><span class="toc-number">1.6.</span> <span class="toc-text">线程调度和优先级⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">Windows的线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%B8%A9%E4%B8%80%E4%B8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">重温一下上下文切换流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF-starvation"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">饥饿(starvation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">抢占式操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E9%A1%B5%E7%BA%BF%E7%A8%8B-zero-page-thread"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">零页线程(zero page thread)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7and%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">线程优先级and进程优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">前台线程和后台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A027%EF%BC%9A%E8%AE%A1%E7%AE%97%E9%99%90%E5%88%B6%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">大章27：计算限制的异步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CLR%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">CLR线程池基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E2%AD%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">向线程池请求流程⭐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ThreadPool"><span class="toc-number">2.2.</span> <span class="toc-text">使用ThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.3.</span> <span class="toc-text">执行上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E6%B5%81%E5%90%91-flow"><span class="toc-number">2.3.1.</span> <span class="toc-text">阻断上下文的流向(flow)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E6%96%AD%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">阻断例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">线程池如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%99%90%E5%88%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">设置线程池限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">线程池调度机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%98%9F%E5%88%97"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">全局队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">本地队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">调度机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%8F%96%E6%B6%88%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-number">2.5.</span> <span class="toc-text">协作式取消和超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CancellationTokenSource"><span class="toc-number">2.5.1.</span> <span class="toc-text">CancellationTokenSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1-Task"><span class="toc-number">2.6.</span> <span class="toc-text">使用任务(Task)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Task%E4%B8%8EThreadPool%E7%AD%89%E4%BB%B7%E5%86%99%E6%B3%95"><span class="toc-number">2.6.1.</span> <span class="toc-text">Task与ThreadPool等价写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.6.2.</span> <span class="toc-text">等待任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-WaitAny"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">Task.WaitAny</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-WaitAll"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">Task.WaitAll</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.6.3.</span> <span class="toc-text">取消任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E7%BB%AD%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.6.4.</span> <span class="toc-text">延续任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%AD%90%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.6.5.</span> <span class="toc-text">任务启动子任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%86%85%E9%83%A8%E6%8F%AD%E7%A7%98"><span class="toc-number">2.6.6.</span> <span class="toc-text">任务内部揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.6.6.1.</span> <span class="toc-text">Task的生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.6.7.</span> <span class="toc-text">任务调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.6.7.1.</span> <span class="toc-text">同步上下文任务调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8Task%E6%9B%B4%E6%96%B0UI%E4%BE%8B%E5%AD%90-%E2%99%A5wpf"><span class="toc-number">2.6.7.2.</span> <span class="toc-text">用Task更新UI例子 ♥wpf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.6.7.3.</span> <span class="toc-text">其他自定义调度器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">2.7.</span> <span class="toc-text">并行执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel"><span class="toc-number">2.7.1.</span> <span class="toc-text">Parallel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#For%E3%80%81ForEach%E3%80%81Invoke"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">For、ForEach、Invoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BCParallelLoopResult"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">返回值ParallelLoopResult</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E8%AF%AD%E8%A8%80%E7%BB%A7%E6%89%BF%E6%9F%A5%E8%AF%A2-PLINQ"><span class="toc-number">2.7.2.</span> <span class="toc-text">并行语言继承查询(PLINQ)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97%E9%99%90%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.</span> <span class="toc-text">执行定时计算限制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer%E7%B1%BB"><span class="toc-number">2.8.1.</span> <span class="toc-text">Timer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TimerCallback%E5%A7%94%E6%89%98"><span class="toc-number">2.8.2.</span> <span class="toc-text">TimerCallback委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.8.3.</span> <span class="toc-text">Timer内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E3%80%81await%E5%85%81%E8%AE%B8%E7%BA%BF%E7%A8%8B%E8%BF%94%E5%9B%9E"><span class="toc-number">2.8.4.</span> <span class="toc-text">例子、await允许线程返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A028%EF%BC%9AI-O%E9%99%90%E5%88%B6%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E2%AD%90"><span class="toc-number">3.</span> <span class="toc-text">大章28：I&#x2F;O限制的异步操作⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8CI-O%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">Windows如何执行I&#x2F;O操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3"><span class="toc-number">3.1.1.</span> <span class="toc-text">从硬件开始理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AF%B7%E6%B1%82I-O%E6%B5%81%E7%A8%8B%E2%AD%90"><span class="toc-number">3.1.2.</span> <span class="toc-text">程序请求I&#x2F;O流程⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82I-O%E6%B5%81%E7%A8%8B%E2%AD%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">异步请求I&#x2F;O流程⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%BC%82%E6%AD%A5%E5%AF%B9%E6%AF%94%E5%90%8C%E6%AD%A5%E4%BC%98%E5%8A%BF"><span class="toc-number">3.1.4.</span> <span class="toc-text">I&#x2F;O异步对比同步优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E2%AD%90"><span class="toc-number">3.2.</span> <span class="toc-text">C#的异步函数⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async-gt-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.2.1.</span> <span class="toc-text">async &#x3D;&gt; 状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await-gt-Task-ContinueWith"><span class="toc-number">3.2.2.</span> <span class="toc-text">await &#x3D;&gt;Task.ContinueWith</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%EF%BC%8C%E7%8A%B6%E6%80%81%E6%9C%BA%E6%81%A2%E5%A4%8D"><span class="toc-number">3.2.3.</span> <span class="toc-text">最后，状态机恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%B0%86%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%88%90%E7%8A%B6%E6%80%81%E6%9C%BA%E2%AD%90"><span class="toc-number">3.3.</span> <span class="toc-text">编译器如何将异步函数转换成状态机⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">反编译代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A2%B3%E7%90%86%E4%B8%80%E4%B8%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">梳理一下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">异步函数扩展性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TaskLogger"><span class="toc-number">3.4.1.</span> <span class="toc-text">TaskLogger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#await%E6%94%AF%E6%8C%81void"><span class="toc-number">3.5.</span> <span class="toc-text">await支持void</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">异步函数和异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%EF%BC%9AGUI%E7%BA%BF%E7%A8%8B%E2%AD%90"><span class="toc-number">3.7.</span> <span class="toc-text">线程处理模型：GUI线程⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GUI%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.7.1.</span> <span class="toc-text">GUI线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await%E4%BC%98%E5%8C%96-%E6%81%A2%E5%A4%8D%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.7.2.</span> <span class="toc-text">await优化 &#x3D; 恢复上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E8%AF%B7%E6%B1%82%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.8.</span> <span class="toc-text">I&#x2F;O请求优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A029%EF%BC%9A%E5%9F%BA%E5%85%83%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0"><span class="toc-number">4.</span> <span class="toc-text">大章29：基元线程同步构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.1.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%BA%93%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.2.</span> <span class="toc-text">类库和线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E4%BD%BF%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">使所有实例方法非线程安全，使静态方法线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E5%85%83%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0"><span class="toc-number">4.3.</span> <span class="toc-text">基元用户模式和内核模式构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%85%83-primitive"><span class="toc-number">4.3.1.</span> <span class="toc-text">基元 (primitive)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%B4%BB%E9%94%81"><span class="toc-number">4.3.2.</span> <span class="toc-text">死锁活锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0"><span class="toc-number">4.4.</span> <span class="toc-text">用户模式构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E2%AD%90"><span class="toc-number">4.4.1.</span> <span class="toc-text">原子性⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E5%8F%98%E6%9E%84%E9%80%A0-volatile-construct"><span class="toc-number">4.4.2.</span> <span class="toc-text">易变构造 (volatile construct)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%93%E5%8F%98%E6%9E%84%E9%80%A0volatile-%E4%BE%8B%E5%AD%90"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">易变构造volatile 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E9%94%81%E6%9E%84%E9%80%A0"><span class="toc-number">4.4.3.</span> <span class="toc-text">互锁构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Interlocked%E7%B1%BB"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">Interlocked类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%AB%A030%EF%BC%9A%E6%B7%B7%E5%90%88%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0"><span class="toc-number">5.</span> <span class="toc-text">大章30：混合线程同步构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%A3%80%E9%94%81%E6%8A%80%E6%9C%AF"><span class="toc-number">5.1.</span> <span class="toc-text">双检锁技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">单例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A0%85%E6%A0%8F"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">内存栅栏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-publishing"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">发布(publishing)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-number">5.1.2.</span> <span class="toc-text">简化版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%AD%90"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">线程安全⭐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E3%80%81%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E3%80%81%E5%86%85%E8%81%94%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">静态构造、实例构造、内联执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lazy%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">Lazy模式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-6/" title="Games101 - 着色"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 着色"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-6/" title="Games101 - 着色">Games101 - 着色</a><time datetime="2022-06-22T14:32:28.598Z" title="发表于 2022-06-22 22:32:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-5/" title="Games101 - 遮挡与深度"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 遮挡与深度"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-5/" title="Games101 - 遮挡与深度">Games101 - 遮挡与深度</a><time datetime="2022-06-22T14:32:28.594Z" title="发表于 2022-06-22 22:32:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-4/" title="Games101 - 光栅化"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 光栅化"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-4/" title="Games101 - 光栅化">Games101 - 光栅化</a><time datetime="2022-06-22T14:32:28.591Z" title="发表于 2022-06-22 22:32:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-3/" title="Games101 - MVP变换"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - MVP变换"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-3/" title="Games101 - MVP变换">Games101 - MVP变换</a><time datetime="2022-06-17T01:51:05.738Z" title="发表于 2022-06-17 09:51:05">2022-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-2/" title="Games101 - 矩阵变换入门"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 矩阵变换入门"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-2/" title="Games101 - 矩阵变换入门">Games101 - 矩阵变换入门</a><time datetime="2022-06-17T01:51:05.735Z" title="发表于 2022-06-17 09:51:05">2022-06-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> CodingCodingK</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script data-pjax defer src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io/js/chocolate.js"></script><script data-pjax defer src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io/js/cursor.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/mine.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?CodingCodingK";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="CodingCodingK";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>