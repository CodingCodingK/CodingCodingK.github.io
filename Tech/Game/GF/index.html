<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>GameFramework框架学习：原理篇 | CodingCodingK Blog</title><meta name="keywords" content="Unity,C#"><meta name="author" content="CodingCodingK"><meta name="copyright" content="CodingCodingK"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考写在前面！！！ 本文是在腾讯大佬花桑和大佬猫刀刀的GF解析文章的基础上，阅读源码并尝试总结、应用、拓展的个人笔记！无其他用途，水印以示尊敬。 运行流程启动基于MonoBehaviour来实现。 12345678910111213141516171819202122232425public abstract class GameFrameworkComponent : MonoBehaviour">
<meta property="og:type" content="article">
<meta property="og:title" content="GameFramework框架学习：原理篇">
<meta property="og:url" content="https://codingcodingk.github.io/Tech/Game/GF/index.html">
<meta property="og:site_name" content="CodingCodingK Blog">
<meta property="og:description" content="参考写在前面！！！ 本文是在腾讯大佬花桑和大佬猫刀刀的GF解析文章的基础上，阅读源码并尝试总结、应用、拓展的个人笔记！无其他用途，水印以示尊敬。 运行流程启动基于MonoBehaviour来实现。 12345678910111213141516171819202122232425public abstract class GameFrameworkComponent : MonoBehaviour">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg">
<meta property="article:published_time" content="2022-01-22T07:20:06.123Z">
<meta property="article:modified_time" content="2022-02-01T02:52:39.165Z">
<meta property="article:author" content="CodingCodingK">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png"><link rel="canonical" href="https://codingcodingk.github.io/Tech/Game/GF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GameFramework框架学习：原理篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-01 10:52:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/mine.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="CodingCodingK Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> CodingCodingK</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CodingCodingK Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> CodingCodingK</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GameFramework框架学习：原理篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-22T07:20:06.123Z" title="发表于 2022-01-22 15:20:06">2022-01-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-01T02:52:39.165Z" title="更新于 2022-02-01 10:52:39">2022-02-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/GameFramework%E6%A1%86%E6%9E%B6/">GameFramework框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GameFramework框架学习：原理篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>参考写在前面！！！</p>
<p>本文是在腾讯大佬<a target="_blank" rel="noopener" href="https://www.drflower.top/">花桑</a>和大佬<a target="_blank" rel="noopener" href="http://www.maodaodao.top/">猫刀刀</a>的GF解析文章的基础上，阅读源码并尝试总结、应用、拓展的<strong>个人笔记</strong>！无其他用途，水印以示尊敬。</p>
<h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>基于MonoBehaviour来实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GameFrameworkComponent</span> : <span class="title">MonoBehaviour</span> &#123; </span><br><span class="line">    <span class="comment">// 游戏框架组件初始化。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameEntry.RegisterComponent(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GameEntry</span> &#123;</span><br><span class="line">    <span class="comment">// 提供api方便外部访问这个链队，从而获取组件</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">readonly</span> <span class="title">GameFrameworkLinkedList</span>&lt;<span class="title">GameFrameworkComponent</span>&gt; s_GameFrameworkComponents</span> = <span class="keyword">new</span> GameFrameworkLinkedList&lt;GameFrameworkComponent&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterComponent</span>(<span class="params">GameFrameworkComponent gameFrameworkComponent</span>)</span>&#123;</span><br><span class="line">        Type type = gameFrameworkComponent.GetType();</span><br><span class="line">        ... <span class="comment">// 确保链队未添加过同type元素</span></span><br><span class="line">        s_GameFrameworkComponents.AddLast(gameFrameworkComponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------执行完上述base.Awake()后，回到各自的Awake()逻辑。下面用ProcedureComponent举例。------------------</span></span><br><span class="line">ProcedureComponent.<span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.Awake(); <span class="comment">// 上面做的事</span></span><br><span class="line">    m_ProcedureManager = GameFrameworkEntry.GetModule&lt;IProcedureManager&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="GameFrameworkModule"><a href="#GameFrameworkModule" class="headerlink" title="GameFrameworkModule"></a>GameFrameworkModule</h3><p>GameFrameworkModule（GF层中各个模块的基类）采用懒加载。在Awake中GetModule的时候时，GameFrameworkEntry会先检测内部有没有这个模块对象，没有时再调用内部的CreateModule来实例化该模块。</p>
<p>CreateModule是通过传入的接口去掉第一个字符I，然后反射调用构造器的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------GameFrameworkEntry.GetModule&lt;T&gt;() where T : class-----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的 type 是接口 (比如 IProcedureManager)</span></span><br><span class="line"><span class="built_in">string</span> typeName = Utility.Text.Format&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;&#123;0&#125;.&#123;1&#125;&quot;</span>, type.Namespace, type.Name.Substring(<span class="number">1</span>));</span><br><span class="line">...</span><br><span class="line">GameFrameworkModule instance = (GameFrameworkModule) Activator.CreateInstance(Type.GetType(typeName));</span><br><span class="line">... <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br></pre></td></tr></table></figure>

<p>最后这个类（比如 ProcedureManager），就在GF框架里而不是UGF框架了。这个是一个很好的解耦。</p>
<p>然后我们讲讲CreateModule方法里省略的代码，①里做的事：</p>
<p>根据<code>instance.Priority</code>优先级，插入到<code>GameFrameworkEntry。s_GameFrameworkModules</code>全局队列中合适的节点位置。这么做是为了保证链队始终保持优先级从大到小排序，等后面Update的时候就直接foreach遍历就完事了！</p>
<h2 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220120143413.png"></p>
<p>Tick部分逻辑比较轻：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GameFrameworkComponent</span> : <span class="title">MonoBehaviour</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BaseComponent</span> : <span class="title">GameFrameworkComponent</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameFrameworkEntry.Update(Time.deltaTime, Time.unscaledDeltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GameFrameworkEntry</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接foreach就可以！初始化① 的时候保证了链队是按优先级顺序排的</span></span><br><span class="line">        <span class="keyword">foreach</span> (GameFrameworkModule gameFrameworkModule <span class="keyword">in</span> GameFrameworkEntry.s_GameFrameworkModules)</span><br><span class="line">            gameFrameworkModule.Update(elapseSeconds, realElapseSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ShutDown"><a href="#ShutDown" class="headerlink" title="ShutDown"></a>ShutDown</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220120150856.png"></p>
<p>卸载。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ShutdownType : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仅关闭游戏框架。</span></span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭游戏框架并重启游戏。</span></span><br><span class="line">    Restart,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭游戏框架并退出游戏。</span></span><br><span class="line">    Quit,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameEntry.Shutdown(ShutdownType shutdownType)&#123;</span><br><span class="line">    baseComponent.Shutdown();</span><br><span class="line">    s_GameFrameworkComponents.Clear();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.None) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.Restart)</span><br><span class="line">    &#123;</span><br><span class="line">        SceneManager.LoadScene(GameFrameworkSceneId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shutdownType == ShutdownType.Quit)</span><br><span class="line">    &#123;</span><br><span class="line">        Application.Quit();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------下面只讨论None：仅关闭游戏框架。-----------------------</span></span><br><span class="line"></span><br><span class="line">BaseComponent.Shutdown()</span><br><span class="line">&#123;</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseComponent.OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">    GameFrameworkEntry.Shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameFrameworkEntry.Shutdown()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>() &#123; ... &#125; <span class="comment">// 从后往前遍历 s_GameFrameworkModules 所有成员执行 Shutdown(); </span></span><br><span class="line">    </span><br><span class="line">    GameFrameworkEntry.s_GameFrameworkModules.Clear();</span><br><span class="line">    ReferencePool.ClearAll();</span><br><span class="line">    Utility.Marshal.FreeCachedHGlobal();</span><br><span class="line">    GameFrameworkLog.SetLogHelper((GameFrameworkLog.ILogHelper) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GF书写习惯"><a href="#GF书写习惯" class="headerlink" title="GF书写习惯"></a>GF书写习惯</h1><p>GF整体代码的书写习惯是利用 接口 + Dictionary + List 来实现对外的api调用。</p>
<p>而<strong>接口的实际对象</strong>正如前面所说，绝大部分都是Awake的时候反射构造 <strong>同名实现类</strong> 实现的。</p>
<p>这一点对于扩展来说非常开闭，就是提高了熵。</p>
<p>知道了这一点后，下面的探究就不再对GF的接口进行关注了，而是只看他们的实现类了。</p>
<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;Player&gt; fsm; <span class="comment">//一个状态机</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;FsmState&lt;Player&gt;&gt; stateList; <span class="comment">//状态结点List</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建状态列表</span></span><br><span class="line">        stateList = <span class="keyword">new</span> List&lt;FsmState&lt;Player&gt;&gt;() &#123; <span class="keyword">new</span> IdleState(), <span class="keyword">new</span> MoveState() &#125;;</span><br><span class="line">        <span class="comment">//创建状态机，注意，对于所有持有者为Player类型的状态机的名字参数&quot;name&quot;不能重复</span></span><br><span class="line">        fsm = GameEntry.fsmComponent.fsmManager.CreateFsm&lt;Player&gt;(<span class="string">&quot;name&quot;</span>, <span class="keyword">this</span>, stateList);</span><br><span class="line">        <span class="comment">//以IdleState为初始状态，启动状态机</span></span><br><span class="line">        fsm.Start&lt;IdleState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FsmManager"><a href="#FsmManager" class="headerlink" title="FsmManager"></a>FsmManager</h2><p>FsmManager 和 IFsmManager。状态机最外层的存在，有Update会被循环，外部直接调用它的<code>CreateFsm</code>方法。</p>
<p>值得注意的是（下面）用了2次foreach完成1次轮询，为什么要这么做？</p>
<p><strong>因为如果在第一次foreach的时候就直接调用fsm.Update很可能导致m_Fsms的更改，从而导致迭代器的损坏。</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级60</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FsmManager</span> : <span class="title">GameFrameworkModule</span>, <span class="title">IFsmManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> Dictionary&lt;TypeNamePair, FsmBase&gt; m_Fsms;</span><br><span class="line">    <span class="keyword">readonly</span> List&lt;FsmBase&gt; m_TempFsms;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        m_TempFsms.Clear();</span><br><span class="line">        <span class="keyword">foreach</span>(m_Fsms) &#123; ... &#125; <span class="comment">// 将m_Fsms全部放入干净的m_TempFsms中。</span></span><br><span class="line">        <span class="keyword">foreach</span>(m_TempFsms) &#123; fsm.Update(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fsm-lt-T-gt"><a href="#Fsm-lt-T-gt" class="headerlink" title="Fsm&lt; T &gt;"></a>Fsm&lt; T &gt;</h2><p>一个状态机。继承自FsmBase，也就是上面字典的申明类型。<strong>FsmBase抽象类</strong> 就不介绍了，是一些状态机的通用属性比如Name、IsDestory之类的属性。</p>
<p>T传进去的是你的数据类型，和结点<code>FsmState&lt;T&gt;</code>传的T一致。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Fsm</span>&lt;<span class="title">T</span>&gt; : <span class="title">FsmBase</span>, <span class="title">IReference</span>, <span class="title">IFsm</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> Dictionary&lt;Type, FsmState&lt;T&gt;&gt; m_States;</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, Variable&gt; m_Datas;</span><br><span class="line">    <span class="keyword">private</span> FsmState&lt;T&gt; m_CurrentState;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>&lt;<span class="title">TState</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        FsmState&lt;T&gt; state = GetState&lt;TState&gt;();</span><br><span class="line">        m_CurrentState = state;</span><br><span class="line">        m_CurrentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_CurrentState.OnUpdate(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个是对FsmState结点提供的方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">ChangeState</span>&lt;<span class="title">TState</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type stateType = <span class="keyword">typeof</span>(TState);</span><br><span class="line">        FsmState&lt;T&gt; state = GetState(stateType); <span class="comment">// GetState 就是从m_States里查找</span></span><br><span class="line">        m_CurrentState.OnLeave(<span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">        m_CurrentState = state;</span><br><span class="line">        m_CurrentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FsmState-lt-T-gt"><a href="#FsmState-lt-T-gt" class="headerlink" title="FsmState&lt; T &gt;"></a>FsmState&lt; T &gt;</h2><p>一个状态结点。一个状态机对应多个状态结点，想象一下状态机的图就行了。</p>
<p><strong>一般来说，我们需要自己实现的就只有这个类。</strong></p>
<p>对上面调用过的方法进行展示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FsmState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 生命周期（全是虚方法，具体行为要自己实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params">IFsm&lt;T&gt; fsm, <span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnLeave</span>(<span class="params">IFsm&lt;T&gt; fsm, <span class="built_in">bool</span> isShutdown</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params">IFsm&lt;T&gt; fsm</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不对外提供的方法，在自己实现的状态结点代码内互相切换状态。当然你可以在子类里选择公开它。</span></span><br><span class="line">    <span class="comment">// 一般在OnUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ChangeState</span>&lt;<span class="title">TState</span>&gt;(<span class="params">IFsm&lt;T&gt; fsm</span>) <span class="keyword">where</span> TState : FsmState&lt;T&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        Fsm&lt;T&gt; fsmImplement = (Fsm&lt;T&gt;)fsm;</span><br><span class="line">        fsmImplement.ChangeState&lt;TState&gt;(); <span class="comment">// 调用上面的 Fsm.ChangeState方法 来实现切换状态。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己实现这个抽象类的时候，ChangeState调用的时机一般写在 <strong>OnUpdate</strong> 方法里。比如每帧都判断一个flag，flag为true就切换到其他状态。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实可以更深层次的拓展出<strong>状态栈</strong>：如果状态被某个状态打断，可以恢复到之前的状态。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>在ProcedureComponent组件（下面）中提到，是通过m_AvailableProcedureTypeNames来创建实例，并以m_EntranceProcedure为起始状态，启动流程状态机，那么这两个变量是怎么来的呢。</p>
<p>如图所示，我们直接通过流程组件的Inspector来配置，<strong>GF会通过反射获取所有继承ProcedureBase的子类，并展示在此面板</strong>，我们只需要勾选需要流程即可把它加入到m_AvailableProcedureTypeNames中，而面板上的Entrance Procedure则代表了m_EntranceProcedure，这里我们选择了StarForce.ProcedureLaunch作为起始状态，那么ProcedureLaunch类中的OnEnter方法中的逻辑，就是我们游戏启动后最先执行的游戏业务逻辑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/GameFramework_Procedure_Config.png"></p>
<p>代码上看，是对有限状态机的封装。功能上看，如果把游戏整体看作一部电影的话，那玩家游玩时刻总是在整个游戏的某个流程结点罢了。</p>
<p>常见的二次元游戏流程线：打开游戏app &gt; 热更 &gt; 登陆 &gt; 主城： 各种丰富的业务（任务系统、商城系统、养成系统、etc） ，选择了副本系统 &gt; 战斗，战斗结束回到主城</p>
<p>我个人认为这么划分基本就涵盖了所有的业务。在花卷的博客里写了：</p>
<blockquote>
<p>  一般地说，一个游戏拥有的流程数量是非常有限的，如果规划出数十个流程出来，很可能是对流程的理解有所偏差。例如一个塔防游戏有数十个关卡，每个关卡的内容都不一样，但关卡中的地图，炮塔，敌人生成等，其实都是数据驱动的，而他们的逻辑其实是一样的，只是数据不同造成表现不同，所以无论是哪个关卡，他们都应该属于同一个流程。</p>
</blockquote>
<p>所以我觉得 主城系统里的各种养成系统，都是一个流程结点；战斗系统里各种副本，也属于一个流程结点。</p>
<h2 id="ProcedureBase"><a href="#ProcedureBase" class="headerlink" title="ProcedureBase"></a>ProcedureBase</h2><p>非常简单，就是继承了一下 FsmState 并指定类型 IProcedureManager 罢了。本质就是个状态结点。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ProcedureBase</span> : <span class="title">FsmState</span>&lt;<span class="title">IProcedureManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ProcedureManager"><a href="#ProcedureManager" class="headerlink" title="ProcedureManager"></a>ProcedureManager</h2><p>内部包裹了<strong>一个 FsmManager 和 一个Type为ProcedureManager的状态机</strong>，也就是状态机的最外层。</p>
<ol>
<li>  字段m_FsmManager为有限状态机管理器，会在Initialize方法初始化时作为参数传入，m_ProcedureFsm为管理流程用的有限状态机。</li>
<li>  方法Initialize会取得FsmManager实例和包括所有流程（继承ProcedureBase的对象）的列表，并用FsmManager创建出一个状态机实例储存于m_ProcedureFsm中。</li>
<li>  与Fsm模块类似，流程模块提供HasProcedure、GetProcedure接口来查询和获取指定流程对象，CurrentProcedure获得当前处于的流程，CurrentProcedureTime获取当前流程持续时间。</li>
<li>  <strong>StartProcedure</strong>方法，令状态机从指定流程启动，这里是游戏框架正式启动游戏的关键入口。该方法其实就是调用了内部状态机的Start。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级-10</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ProcedureManager</span> : <span class="title">GameFrameworkModule</span>, <span class="title">IProcedureManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsmManager m_FsmManager;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;IProcedureManager&gt; m_ProcedureFsm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">IFsmManager fsmManager, <span class="keyword">params</span> ProcedureBase[] procedures</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_FsmManager = fsmManager;</span><br><span class="line">        m_ProcedureFsm = m_FsmManager.CreateFsm(<span class="keyword">this</span>, procedures); <span class="comment">// procedures就是所有流程！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ProcedureComponent"><a href="#ProcedureComponent" class="headerlink" title="ProcedureComponent"></a>ProcedureComponent</h2><p>ProcedureManager的<strong>Initialize</strong>方法会取得FsmManager实例和包括所有流程（继承ProcedureBase的对象）的列表，并用FsmManager创建出一个状态机实例储存于m_ProcedureFsm中。这些是在ProcedureComponent里完成的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ProcedureComponent</span> : <span class="title">GameFrameworkComponent</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所有流程的列表</span></span><br><span class="line">        ProcedureBase[] procedures = <span class="keyword">new</span> ProcedureBase[m_AvailableProcedureTypeNames.Length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_AvailableProcedureTypeNames.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Type procedureType = Utility.Assembly.GetType(m_AvailableProcedureTypeNames[i]);</span><br><span class="line">            procedures[i] = (ProcedureBase)Activator.CreateInstance(procedureType);</span><br><span class="line">            <span class="keyword">if</span> (m_EntranceProcedureTypeName == m_AvailableProcedureTypeNames[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据名字，寻找初始流程</span></span><br><span class="line">                m_EntranceProcedure = procedures[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Initialize，把 所有流程的列表procedures 传进去了</span></span><br><span class="line">        m_ProcedureManager.Initialize(GameFrameworkEntry.GetModule&lt;IFsmManager&gt;(), procedures);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始流程，游戏运行！</span></span><br><span class="line">        m_ProcedureManager.StartProcedure(m_EntranceProcedure.GetType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcedureComponent继承了Mono类，上面的Start方法会被Unity内部主动调用，调用后会根据<strong>m_AvailableProcedureTypeNames通过反射来创建流程对象</strong>，进行一系列初始化，再以<strong>m_EntranceProcedure为起始状态</strong>，启动流程状态机。</p>
<h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>其实 流程模块 完全是状态机实例完成，那么功能上没必要单独做成一个模块，但是GF却单独提取成一个模块。很大的原因是因为状态机的状态内部对外是不希望透明的，而流程内部的流程结点是希望对外透明、可访问的。</p>
<h2 id="完整的启动流程"><a href="#完整的启动流程" class="headerlink" title="完整的启动流程"></a>完整的启动流程</h2><p><a href="">GameFramework框架学习：应用篇</a></p>
<p><a target="_blank" rel="noopener" href="https://www.drflower.top/posts/6e65184/#ProcedureLaunch">花桑启动流程博文</a></p>
<h1 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h1><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126163846.png"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a target="_blank" rel="noopener" href="https://www.drflower.top/posts/16213a73/#UIFormInfo">花卷博客UI篇</a>很细，这里只简述。</p>
<h3 id="UIManager"><a href="#UIManager" class="headerlink" title="UIManager"></a>UIManager</h3><p>UIManager是外部访问框架UI模块的入口。</p>
<p><strong>UIManager</strong> 持有 Dictionary&lt;string, **UIGroup**&gt;。</p>
<blockquote>
<p>  UIManager内部会用GF的对象池模块创建一个对象池，用于缓存UIForm对象的GameObject实例，外部调用OpenUIForm来打开UI时，会先尝试从对象池获取该界面，若对象池中有同类型的空闲实例，则直接取出使用，若没有则从资源模块加载，加载成功后，会注册到对象池中，再交给UIManager使用。而调用CloseUIForm来关闭UI时，UIForm会被加到Queue类型的字段m_RecycleQueue中，在下一次Update时，会把队列所有元素取出，回收到对象池中。</p>
<p>  内部维护了一个私有字段m_Serial，每次调用OpenUIForm的时候，m_Serial都会自增1，他表示了每个UIForm在其生命周期内的唯一标识符，即使是同一个UIForm实例，被关闭后放回对象池，再被取出来使用，其m_Serial也会发生变化。</p>
</blockquote>
<h3 id="UIGroup"><a href="#UIGroup" class="headerlink" title="UIGroup"></a>UIGroup</h3><p>UIGroup是一系列窗口集合，内部用链队存储了一个 LinkedListNode&lt; **UIFormInfo** &gt;，用链表来模栈式结构（链头在最上层）。有Depth的概念。</p>
<blockquote>
<p>  Refresh：UIGroup的核心逻辑，根据链表顺序以及UIForm的属性，去调用UIForm的OnDepthChanged、OnCover、OnReveal、OnPause、OnResume这些方法。</p>
</blockquote>
<h3 id="UIFormInfo"><a href="#UIFormInfo" class="headerlink" title="UIFormInfo"></a>UIFormInfo</h3><p>UIFormInfo持有<strong>UIForm</strong>的引用。</p>
<p>既然UIForm是窗口，那为什么要对它再包一层Info呢？它只多了Paused和Covered两个状态，用来表示状态，提供给UIGroup或外界。</p>
<h3 id="UIForm"><a href="#UIForm" class="headerlink" title="UIForm"></a>UIForm</h3><p>UIForm是UI窗口类，被UIGroup直接管理，每个UI窗口都会有一个UIForm实例，同时也拥有一个<strong>UIFormLogic</strong>实例（一般是它的派生类）。有唯一标识符字段m_SerialId。</p>
<h3 id="UIFormLogic"><a href="#UIFormLogic" class="headerlink" title="UIFormLogic"></a>UIFormLogic</h3><p>UIFormLogic为UI界面的具体逻辑类，类内有UIForm的所有生命周期方法。</p>
<p>游戏业务层不对UIForm做扩展，而是<strong>对UIFormLogic继承进行扩展</strong>，也就是自己的脚本继承UIFormLogic，正常写。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126175427.png"></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126181213.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220126181431.png"></p>
<h1 id="引用池"><a href="#引用池" class="headerlink" title="引用池"></a>引用池</h1><p>就是对象池结构。</p>
<p>关于对象池我的一些个人理解：对象池本身的存在理由是，因为频繁创建-销毁对象，会让堆产生大量的内存碎片，导致gc的压缩更频繁。这不好，所以直接申请一大块内存，保持在游戏运行时不释放它。 </p>
<p>但在GF中并不要求开发者在创建的时候就传入引用池capacity，默认会是0，然后动态扩容。我个人认为，可能是因为分配大量内存而不用的危害远比频繁压缩大，所以<strong>gf中对象池的核心作用只是复用对象，也就是减少mono对象和类对象的创建</strong>。</p>
<p>每个对象的内存大小是固定的，未使用的对象会保留在内存中。</p>
<blockquote>
<p>  GF中池子有两种，一种叫引用池，一种叫对象池，两者原理一样，但具体实现和针对的对象不同，引用池一般用来储存普通的C#类型对象，而对象池则一般用于储存UnityEngine下的对象（如Unity中的GameObject对象）。</p>
</blockquote>
<h2 id="ReferencePool"><a href="#ReferencePool" class="headerlink" title="ReferencePool"></a>ReferencePool</h2><p>ReferencePool 静态类，是外部访问引用池模块的入口。</p>
<p>内部维护了一个Dictionary&lt;Type, **ReferenceCollection**&gt;，这个字典就是所有的引用池，Typa对应引用池类型。</p>
<p>采用惰性初始化：当内部有需要获取某引用池实例（比如外界调用API获取引用，内部就先需要get到这个池子），如果在这个字典里Type的池子并不存在，则构造一个加入字典再返回。</p>
<h2 id="ReferenceCollection"><a href="#ReferenceCollection" class="headerlink" title="ReferenceCollection"></a>ReferenceCollection</h2><p>引用池。每一个引用池都有自己对应的Type，不同类型的对象储存在各自类型的池子中。</p>
<p>① 需要对构造器传入一个Type，在初期化时会保存好Type。</p>
<p>② <strong>Queue存储引用</strong>：内部维护了一个Queue&lt; **IReference** &gt;，来储存池子中的对象。</p>
<p>③ <strong>池容量动态扩容</strong>：创建时不需要指定池的capacity，设置为0。容量的扩大，完全靠动态扩容（具体思考看本节开头）。</p>
<h2 id="IReference"><a href="#IReference" class="headerlink" title="IReference"></a>IReference</h2><blockquote>
<p>   IReference接口只包含一个Clear方法，此方法会在对象回收池被调用，每一个需要被引用池储存的类型都需要实现此接口，以能清空当前状态，恢复到初始状态，供下次使用。</p>
</blockquote>
<p>引用池-&gt;对象复用 的根本。</p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>引用池一般用来储存普通的C#类型对象。</p>
<p>比如可以实现复用状态机的状态：</p>
<ol>
<li>  状态内实现Create方法，去引用池Acquire（取）一个空闲的相同状态。</li>
<li>  状态内实现Clear方法（IReference接口），清空所有字段变回初始值。</li>
</ol>
<p>之后调用，只需要在new状态机的时候Create，Destory时Clear就可以了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 花桑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFsm&lt;Player&gt; fsm;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建状态列表(不用引用池)</span></span><br><span class="line">        <span class="comment">//List&lt;FsmState&lt;Player&gt;&gt; stateList = new List&lt;FsmState&lt;Player&gt;&gt;() &#123; new IdleState(), new MoveState() &#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建状态列表(使用引用池)</span></span><br><span class="line">        List&lt;FsmState&lt;Player&gt;&gt; stateList = <span class="keyword">new</span> List&lt;FsmState&lt;Player&gt;&gt;() &#123; IdleState.Create(), MoveState.Create() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --------------------------下面和原来一样--------------------------</span></span><br><span class="line">        <span class="comment">//创建状态机，注意，对于所有持有者为Player类型的状态机的名字参数不能重复，这里用自增ID避免重复</span></span><br><span class="line">        fsm = GameEntry.Fsm.CreateFsm&lt;Player&gt;((SERIAL_ID++).ToString(), <span class="keyword">this</span>, stateList);</span><br><span class="line">        <span class="comment">//以IdleState为初始状态，启动状态机</span></span><br><span class="line">        fsm.Start&lt;IdleState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出状态机所有状态</span></span><br><span class="line">        FsmState&lt;Player&gt;[] states = fsm.GetAllStates();</span><br><span class="line">        <span class="comment">//销毁状态机</span></span><br><span class="line">        GameEntry.Fsm.DestroyFsm(fsm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把状态实例归还引用池</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> states)</span><br><span class="line">        &#123;</span><br><span class="line">            ReferencePool.Release((IReference)item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inspector面板监视"><a href="#Inspector面板监视" class="headerlink" title="Inspector面板监视"></a>Inspector面板监视</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220127141559.png"></p>
<p><strong>Enable Strick Check</strong>：开启类型检测。对象池内部操作时，一方面检测Type是不是非抽象Class且实现了IReference接口的Class；另一方面是释放对象（也就是把对象放回对象池时），需要检查这个对象是不是已经空闲着了。如果 类型不满足、空闲还要求释放 ，就抛错。不过这个检测开启会影响性能，所以只建议测试时开。</p>
<p><strong>面板用途</strong>：可以通过此面板方便地检查业务逻辑中有没有正确使用引用池，例如某个对象只会在某个流程中会使用，我们可以检测在流程循环中，这个对象的Acquire和Release是否相等，而流程结束时，Using是否为0，Unused是否与Add相等。</p>
<h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>GF中对象池与引用池作用类似，一般用于储存UnityEngine下的对象（如Unity中的GameObject对象）。</p>
<p>对象池的实现我们可以把他分成3部分，上图中从上到下每一行就是一部分，分别是</p>
<ol>
<li>  <strong>物体部分</strong>（抽象类ObjectBase，Object&lt; T &gt;，结构体ObjectInfo），</li>
<li>  <strong>对象池部分</strong>（抽象类ObjectPoolBase，ObjectPool&lt; T &gt;，委托ReleaseObjectFilterCallback），</li>
<li>  <strong>对象池管理器部分</strong>（接口IObjectPoolManager，类ObjectPoolManager）。</li>
</ol>
<p>其中Object和ObjectPool是ObjectPoolManager的内部私有类。</p>
<h2 id="整体关系⭐"><a href="#整体关系⭐" class="headerlink" title="整体关系⭐"></a>整体关系⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220127173856.png"></p>
<p>对象池：ObjectPool&lt; T &gt;类。它继承 ObjectPoolBase抽象类，且内部持有一个**Object&lt; T &gt;**一对多GF字典。</p>
<p>对象：Object&lt; T &gt; 类。它内部持有一个T对象的引用，且要求T必须继承自 <strong>ObjectBase抽象</strong>类。它实现 IReference接口，所以Create的时候是从引用池分配的。</p>
<p>对象抽象：ObjectBase 类，也就是上面2个类中限定的T 。内部持有一个<strong>object字段（m_Target）</strong>，这才是真正的 System.Object对象。</p>
<h2 id="物体部分"><a href="#物体部分" class="headerlink" title="物体部分"></a>物体部分</h2><h3 id="ObjectBase"><a href="#ObjectBase" class="headerlink" title="ObjectBase"></a>ObjectBase</h3><p>通过Initialize方法可把目标对象传递给m_Target字段，这才是object。通过重写OnSpawn、OnUnspawn方法实现对象获取、回收时执行的逻辑。</p>
<h3 id="Object-lt-T-gt"><a href="#Object-lt-T-gt" class="headerlink" title="Object&lt; T &gt;"></a>Object&lt; T &gt;</h3><p>它实现 IReference接口，Create的时候是从引用池分配的，Release。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object&lt;T&gt; <span class="title">Create</span>(<span class="params">T obj, <span class="built_in">bool</span> spawned</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    internalObject = ReferencePool.Acquire&lt;Object&lt;T&gt;&gt;();</span><br><span class="line">    internalObject.m_Object = obj; <span class="comment">// m_Object就是持有的ObjectBase对象引用</span></span><br><span class="line">    internalObject.m_SpawnCount = spawned ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> internalObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"><span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Object.Release(isShutdown);</span><br><span class="line">    ReferencePool.Release(m_Object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象池-1"><a href="#对象池-1" class="headerlink" title="对象池"></a>对象池</h2><h3 id="ObjectPool-lt-T-gt"><a href="#ObjectPool-lt-T-gt" class="headerlink" title="ObjectPool&lt; T &gt;"></a>ObjectPool&lt; T &gt;</h3><p>对象池，继承自 ObjectPoolBase抽象类 和 IObjectPool接口。两者其实很相似，但是却要做成2个是因为IObjectPool是泛型接口，而ObjectPoolBase不是泛型，后者在使用起来的时候可以不需要明确ObjectBase类型。</p>
<p>内部持有：一个<code>&lt;string, Object&lt;T&gt;&gt;</code>类型类型的一对多GF字典，一个<code>&lt;object, Object&lt;T&gt;&gt;</code>类型的普通字典。</p>
<p>Spawn方法：获取对象。字典中，有空闲的就返回，没有就返回null。也就是说，<strong>并不会新建对象</strong>。</p>
<p>Register方法：创建对象。</p>
<p>AutoReleaseInterval 属性：执行Release的频率。</p>
<p>Release方法：自动释放，频率由AutoReleaseInterval 决定，每个池可不同。Release过程会先获取可释放对象序列，然后通过委托ReleaseObjectFilterCallback对可释放物体序列进行筛选后，最后仅对筛选后的对象调用ReleaseObject进行释放。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">T obj, <span class="built_in">bool</span> spawned</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object&lt;T&gt; internalObject = Object&lt;T&gt;.Create(obj, spawned); <span class="comment">// Create方法在上面一小节有展示</span></span><br><span class="line">    m_Objects.Add(obj.Name, internalObject);</span><br><span class="line">    m_ObjectMap.Add(obj.Target, internalObject);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_ObjectMap.Count &gt; m_Capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        Release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    toReleaseCount = Count - m_Capacity; <span class="comment">// 当前对象池中对象的数量 - 池容量</span></span><br><span class="line">    expireTime = DateTime.UtcNow.AddSeconds(-m_ExpireTime); <span class="comment">// 计算出过期时间点</span></span><br><span class="line">    ...</span><br><span class="line">    GetCanReleaseObjects(m_CachedCanReleaseObjects);</span><br><span class="line">    List&lt;T&gt; toReleaseObjects = releaseObjectFilterCallback(m_CachedCanReleaseObjects, toReleaseCount, expireTime);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">foreach</span> (T toReleaseObject <span class="keyword">in</span> toReleaseObjects)</span><br><span class="line">    &#123;</span><br><span class="line">        ReleaseObject(toReleaseObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① <code>GetCanReleaseObjects(m_CachedCanReleaseObjects);</code> 方法：遍历m_ObjectMap的Value值，非使用中状态、非锁定状态、以及自定义释放标记为True时被认为是可释放对象。将所有可释放对象传入m_CachedCanReleaseObjects。</p>
<p>② <code>releaseObjectFilterCallback(m_CachedCanReleaseObjects, toReleaseCount, expireTime)</code> 委托方法：这个方法负责从可释放对象序列中进一步选出符合要求的对象，之后再进行释放。默认有DefaultReleaseObjectFilterCallback方法，也可以自己传入委托。</p>
<p>③ ReleaseObject 方法：会把从对应的<code>Object&lt;T&gt;</code>对象从m_Objects和m_ObjectMap中移除。</p>
<h2 id="对象池管理"><a href="#对象池管理" class="headerlink" title="对象池管理"></a>对象池管理</h2><h3 id="ObjectPoolManager"><a href="#ObjectPoolManager" class="headerlink" title="ObjectPoolManager"></a>ObjectPoolManager</h3><p>在内部使用字典保存所有对象池 ObjectPool&lt; T &gt;。</p>
<p>CreateSingleSpawnObjectPool方法 和 CreateMultiSpawnObjectPool方法 创建对象池，分别对应一个对象同时只能被获取一次的对象，以及一个对象能被同时获取多次两种类型的对象池。正常对象是必须用Single模式的，只有一些资源部分可以用Multi。</p>
<p>这一层在</p>
<h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>需要一个逻辑物体<strong>ObjectBase</strong>，以及继承Mono的表现物体<strong>GameFrameworkComponent</strong>。</p>
<p>官方Demo的示例：</p>
<p><strong>HPBarItemObject</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HPBarItemObject</span> : <span class="title">ObjectBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HPBarItemObject <span class="title">Create</span>(<span class="params"><span class="built_in">object</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HPBarItemObject hpBarItemObject = ReferencePool.Acquire&lt;HPBarItemObject&gt;();</span><br><span class="line">        hpBarItemObject.Initialize(target);</span><br><span class="line">        <span class="keyword">return</span> hpBarItemObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params"><span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 销毁血条的GameObject</span></span><br><span class="line">        HPBarItem hpBarItem = (HPBarItem)Target;</span><br><span class="line">        Object.Destroy(hpBarItem.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HPBarComponent</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HPBarComponent</span> : <span class="title">GameFrameworkComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> HPBarItem m_HPBarItemTemplate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Transform m_HPBarInstanceRoot = <span class="literal">null</span>; <span class="comment">// 设置生成物体的Root</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_InstancePoolCapacity = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IObjectPool&lt;HPBarItemObject&gt; m_HPBarItemObjectPool = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HPBarItem&gt; m_ActiveHPBarItems = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Canvas m_CachedCanvas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_HPBarInstanceRoot == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Error(<span class="string">&quot;You must set HP bar instance root first.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_CachedCanvas = m_HPBarInstanceRoot.GetComponent&lt;Canvas&gt;();</span><br><span class="line">        <span class="comment">// 传入对象池名字、对象池容量作为参数，并持有这个对象池的接口引用</span></span><br><span class="line">        m_HPBarItemObjectPool = GameEntry.ObjectPool.CreateSingleSpawnObjectPool&lt;HPBarItemObject&gt;(<span class="string">&quot;HPBarItem&quot;</span>, m_InstancePoolCapacity);</span><br><span class="line">        m_ActiveHPBarItems = <span class="keyword">new</span> List&lt;HPBarItem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HideHPBar</span>(<span class="params">HPBarItem hpBarItem</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不再需要该对象时</span></span><br><span class="line">        hpBarItem.Reset();</span><br><span class="line">        m_ActiveHPBarItems.Remove(hpBarItem);</span><br><span class="line">        m_HPBarItemObjectPool.Unspawn(hpBarItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HPBarItem <span class="title">CreateHPBarItem</span>(<span class="params">Entity entity</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HPBarItem hpBarItem = <span class="literal">null</span>;</span><br><span class="line">        HPBarItemObject hpBarItemObject = m_HPBarItemObjectPool.Spawn();</span><br><span class="line">        <span class="keyword">if</span> (hpBarItemObject != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果对象池里有空闲对象,就直接返回</span></span><br><span class="line">            hpBarItem = (HPBarItem)hpBarItemObject.Target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果对象池里无空闲对象,就自己在外部建好物体,然后由此创建为ObjectBase,最后丢到池里注册</span></span><br><span class="line">            hpBarItem = Instantiate(m_HPBarItemTemplate);</span><br><span class="line">            Transform transform = hpBarItem.GetComponent&lt;Transform&gt;();</span><br><span class="line">            transform.SetParent(m_HPBarInstanceRoot);</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">            m_HPBarItemObjectPool.Register(HPBarItemObject.Create(hpBarItem), <span class="literal">true</span>); <span class="comment">// true:注册时就立马使用; false:注册时不立马使用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hpBarItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inspector面板监视-1"><a href="#Inspector面板监视-1" class="headerlink" title="Inspector面板监视"></a>Inspector面板监视</h2><p><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/20220128142351.png"></p>
<h2 id="引用池与对象池的区别"><a href="#引用池与对象池的区别" class="headerlink" title="引用池与对象池的区别"></a>引用池与对象池的区别</h2><ol>
<li>  引用池从池子内部通过默认构造方法创建对象，只适合普通的C#对象。对象池是在外部自行创建对象后再注册进去，能用于必须通过Unity API才能实例化的对象。</li>
<li>  引用池仅提供Clear接口来清除对象状态，在移除对象时没有任何额外处理，仅仅是去掉引用，适用于受GC管理的类型。而对象池提供OnSpawn，OnUnspawn两个操作，且在移除对象时，提供Release接口，对于Unity中的GameObject需要在Release写上Destroy(gameObject)的逻辑才能销毁。</li>
<li>  对象池提供自行释放的机制，可指定每个池子自动释放周期、物体过期时长、池子容量，并在可一定程度上自定义每个池子的释放策略。引用池没有以上机制，仅可通过Remove接口主动移除对象。</li>
<li>  对象池提供锁定物体、自定义释放标记功能，可进一步定制释放策略。</li>
</ol>
<h2 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h2><p><strong>同一个对象池中，为什么还要以Name区分对象集合？</strong></p>
<p>在同一个prefab上挂上相同的脚本，最后以他们的资源路径名字作为Name，则可在一个对象池中对不同外形的陨石进行区分，以实现向一个对象池取不同外型的陨石的需求。</p>
<blockquote>
<p>  官方Demo StarForce中的陨石对象池，虽然他们都是同一个类型，具有相同的逻辑，但他们可能有不一样的外型。我们把外型不同的陨石做成单独prefab，并在这些prefab上挂上相同的脚本，最后以他们的资源路径名字作为Name，则可在一个对象池中对不同外形的陨石进行区分，以实现向一个对象池取不同外型的陨石的需求。</p>
</blockquote>
<p><strong>在同一个对象池中以Name区分对象，与用多个对象池储存不同Name的对象有什么区别？</strong></p>
<p>让开发者能更好地规划释放策略。</p>
<blockquote>
<p>  主要区别就在于一个对象池执行同一个释放逻辑，而多个对象池是各自执行各自的释放逻辑。继续以上面的陨石为例子，我们一共有3种陨石，我希望储存陨石的对象池总容量是60，我们随机去生成不同种类的陨石，如果随机结果不均匀，最终池子里可能有种类一40个，种类二15个，种类三5个，在我们把他们放在同一对象池下管理情况下，这没有什么问题，无论怎样它都很好地以总数量为60个的策略去管理。但如果我们把不同外形的陨石分到不同的对象池去管理，我们很难去动态调整3个池子的容量平衡，以达到总数量为60的策略。</p>
</blockquote>
<p><strong>为什么既有引用池又有对象池，全部用对象池不是就可以满足需求了吗？</strong></p>
<p>对象池太繁琐，引用池使用更轻便。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CodingCodingK</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://codingcodingk.github.io/Tech/Game/GF/">https://codingcodingk.github.io/Tech/Game/GF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://CodingCodingK.github.io" target="_blank">CodingCodingK Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Tech/Game/gf_demo/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GameFramework框架学习：应用篇</div></div></a></div><div class="next-post pull-right"><a href="/Tech/CSharp/Essence/tips/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C#精要 - 小概念篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Tech/Game/gf_demo/" title="GameFramework框架学习：应用篇"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-01</div><div class="title">GameFramework框架学习：应用篇</div></div></a></div><div><a href="/Intro/display/" title="王者荣耀复刻项目 展示"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/hok.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-25</div><div class="title">王者荣耀复刻项目 展示</div></div></a></div><div><a href="/Tech/Game/tools/aoi/" title="AOI视野管理"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-13</div><div class="title">AOI视野管理</div></div></a></div><div><a href="/Tech/Game/tools/serialize/" title="什么叫“二进制”配置方案？"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">什么叫“二进制”配置方案？</div></div></a></div><div><a href="/Tech/Game/UI/Guide_UnityUI/" title="Unity常见UI基础问题手册"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">Unity常见UI基础问题手册</div></div></a></div><div><a href="/Tech/Game/UI/ugui_1/" title="UGUI学习 - Base篇"><img class="cover" src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">UGUI学习 - Base篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/Seed_profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CodingCodingK</div><div class="author-info__description">一个正在成为游戏开发者的人</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CodingCodingK"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CodingCodingK" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">2022年的目标是：ET框架、烟雨开源Moba项目 + Lua程序设计 + Games101、Shader入门精要（部分）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">运行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GameFrameworkModule"><span class="toc-number">1.2.1.</span> <span class="toc-text">GameFrameworkModule</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tick"><span class="toc-number">1.3.</span> <span class="toc-text">Tick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShutDown"><span class="toc-number">1.4.</span> <span class="toc-text">ShutDown</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GF%E4%B9%A6%E5%86%99%E4%B9%A0%E6%83%AF"><span class="toc-number">2.</span> <span class="toc-text">GF书写习惯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.</span> <span class="toc-text">有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FsmManager"><span class="toc-number">3.2.</span> <span class="toc-text">FsmManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fsm-lt-T-gt"><span class="toc-number">3.3.</span> <span class="toc-text">Fsm&lt; T &gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FsmState-lt-T-gt"><span class="toc-number">3.4.</span> <span class="toc-text">FsmState&lt; T &gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">3.5.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">4.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProcedureBase"><span class="toc-number">4.2.</span> <span class="toc-text">ProcedureBase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProcedureManager"><span class="toc-number">4.3.</span> <span class="toc-text">ProcedureManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProcedureComponent"><span class="toc-number">4.4.</span> <span class="toc-text">ProcedureComponent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-1"><span class="toc-number">4.5.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">完整的启动流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UI%E6%A8%A1%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">UI模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UIManager"><span class="toc-number">5.1.1.</span> <span class="toc-text">UIManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIGroup"><span class="toc-number">5.1.2.</span> <span class="toc-text">UIGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIFormInfo"><span class="toc-number">5.1.3.</span> <span class="toc-text">UIFormInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIForm"><span class="toc-number">5.1.4.</span> <span class="toc-text">UIForm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIFormLogic"><span class="toc-number">5.1.5.</span> <span class="toc-text">UIFormLogic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.</span> <span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">引用池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReferencePool"><span class="toc-number">6.1.</span> <span class="toc-text">ReferencePool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReferenceCollection"><span class="toc-number">6.2.</span> <span class="toc-text">ReferenceCollection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IReference"><span class="toc-number">6.3.</span> <span class="toc-text">IReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-number">6.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspector%E9%9D%A2%E6%9D%BF%E7%9B%91%E8%A7%86"><span class="toc-number">6.5.</span> <span class="toc-text">Inspector面板监视</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">7.</span> <span class="toc-text">对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%85%B3%E7%B3%BB%E2%AD%90"><span class="toc-number">7.1.</span> <span class="toc-text">整体关系⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E9%83%A8%E5%88%86"><span class="toc-number">7.2.</span> <span class="toc-text">物体部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectBase"><span class="toc-number">7.2.1.</span> <span class="toc-text">ObjectBase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-lt-T-gt"><span class="toc-number">7.2.2.</span> <span class="toc-text">Object&lt; T &gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0-1"><span class="toc-number">7.3.</span> <span class="toc-text">对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectPool-lt-T-gt"><span class="toc-number">7.3.1.</span> <span class="toc-text">ObjectPool&lt; T &gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%AE%A1%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">对象池管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectPoolManager"><span class="toc-number">7.4.1.</span> <span class="toc-text">ObjectPoolManager</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="toc-number">7.5.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspector%E9%9D%A2%E6%9D%BF%E7%9B%91%E8%A7%86-1"><span class="toc-number">7.6.</span> <span class="toc-text">Inspector面板监视</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%B1%A0%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.7.</span> <span class="toc-text">引用池与对象池的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-2"><span class="toc-number">7.8.</span> <span class="toc-text">思考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-7/" title="Games101 - 渲染管线、Shader、Texture"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 渲染管线、Shader、Texture"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-7/" title="Games101 - 渲染管线、Shader、Texture">Games101 - 渲染管线、Shader、Texture</a><time datetime="2022-06-25T05:13:48.938Z" title="发表于 2022-06-25 13:13:48">2022-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-6/" title="Games101 - 着色"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 着色"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-6/" title="Games101 - 着色">Games101 - 着色</a><time datetime="2022-06-22T14:32:28.598Z" title="发表于 2022-06-22 22:32:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-5/" title="Games101 - 遮挡与深度"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 遮挡与深度"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-5/" title="Games101 - 遮挡与深度">Games101 - 遮挡与深度</a><time datetime="2022-06-22T14:32:28.594Z" title="发表于 2022-06-22 22:32:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-4/" title="Games101 - 光栅化"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - 光栅化"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-4/" title="Games101 - 光栅化">Games101 - 光栅化</a><time datetime="2022-06-22T14:32:28.591Z" title="发表于 2022-06-22 22:32:28">2022-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Tech/Graphics/games101-3/" title="Games101 - MVP变换"><img src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io.ImageHost/img/bg5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Games101 - MVP变换"/></a><div class="content"><a class="title" href="/Tech/Graphics/games101-3/" title="Games101 - MVP变换">Games101 - MVP变换</a><time datetime="2022-06-17T01:51:05.738Z" title="发表于 2022-06-17 09:51:05">2022-06-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> CodingCodingK</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script data-pjax defer src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io/js/chocolate.js"></script><script data-pjax defer src="https://cdn.jsdelivr.net/gh/CodingCodingK/CodingCodingK.github.io/js/cursor.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/mine.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?CodingCodingK";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="CodingCodingK";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>